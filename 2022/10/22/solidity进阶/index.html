<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Solididy进阶 | Banana69</title><meta name="keywords" content="智能合约"><meta name="author" content="Banana69"><meta name="copyright" content="Banana69"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="0x01 函数重载函数名相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，solidity不允许修饰器（modifier）重载。 重载函数在经过编译后，由于不同的参数类型，其函数选择器也不相同。 再调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配，如果出现多个匹配的重载函数则会报错。 function f(uint8 _in) public pure returns">
<meta property="og:type" content="article">
<meta property="og:title" content="Solididy进阶">
<meta property="og:url" content="https://banana69.site/2022/10/22/solidity%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="Banana69">
<meta property="og:description" content="0x01 函数重载函数名相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，solidity不允许修饰器（modifier）重载。 重载函数在经过编译后，由于不同的参数类型，其函数选择器也不相同。 再调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配，如果出现多个匹配的重载函数则会报错。 function f(uint8 _in) public pure returns">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2022-10-22T01:24:02.000Z">
<meta property="article:modified_time" content="2022-11-10T11:29:08.220Z">
<meta property="article:author" content="Banana69">
<meta property="article:tag" content="智能合约">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://banana69.site/2022/10/22/solidity%E8%BF%9B%E9%98%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Solididy进阶',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-10 19:29:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Banana69" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Banana69</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Solididy进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-10-22T01:24:02.000Z" title="发表于 2022-10-22 09:24:02">2022-10-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Solididy进阶"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h3 id="0x01-函数重载"><a href="#0x01-函数重载" class="headerlink" title="0x01 函数重载"></a>0x01 函数重载</h3><p>函数名相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，<code>solidity</code>不允许修饰器（<code>modifier</code>）重载。</p>
<p>重载函数在经过编译后，由于不同的参数类型，其函数选择器也不相同。</p>
<p>再调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配，如果出现多个匹配的重载函数则会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f(uint8 _in) public pure returns (uint8 out) &#123;</span><br><span class="line">	out = _in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f(uint256 _in) public pure returns (uint256 out) &#123;</span><br><span class="line">	out = _in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>f(50)</code>会报错，因为 50 既可以被转换为 uint8 ，也可以被转换为uint256。</p>
<h3 id="0x02-库合约"><a href="#0x02-库合约" class="headerlink" title="0x02 库合约"></a>0x02 库合约</h3><p>库函数是一种特殊的合约，为了提升<code>solidity</code>代码的复用性和减少<code>gas</code>而存在。库合约一般都是一些好用的函数合集（<code>库函数</code>）。</p>
<p>库合约与普通合约有以下几点不同：</p>
<ol>
<li>不能存在状态变量</li>
<li>不能够继承或被继承</li>
<li>不能接受以太币</li>
<li>不可以被销毁</li>
</ol>
<p><strong>使用库合约：</strong></p>
<ol>
<li><p><strong>using for</strong></p>
<p> <code>using for</code>指令可将库函数附加到任何类型，添加指令后，库 A 中的函数会自动添加为 B 类型变量的成员，并且可以直接调用，<strong>在调用时，这个变量会被当作第一个参数传递给函数。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 利用using for指令</span><br><span class="line">using Strings for uint256;</span><br><span class="line">function getString1(uint256 _number) public pure returns(string memory)&#123;</span><br><span class="line">    // 库函数会自动添加为uint256型变量的成员</span><br><span class="line">    return _number.toHexString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>通过库合约名称调用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 直接通过库合约名调用</span><br><span class="line">function getString2(uint256 _number) public pure returns(string memory)&#123;</span><br><span class="line">    return Strings.toHexString(_number);</span><br><span class="line">&#125;`</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>String</code>库合约是将uint256类型转换为相应的<code>string</code>类型的代码库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">library Strings &#123;</span><br><span class="line">    bytes16 private constant _HEX_SYMBOLS = &quot;0123456789abcdef&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` decimal representation.</span><br><span class="line">     */</span><br><span class="line">    function toString(uint256 value) public pure returns (string memory) &#123;</span><br><span class="line">        // Inspired by OraclizeAPI&#x27;s implementation - MIT licence</span><br><span class="line">        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol</span><br><span class="line"></span><br><span class="line">        if (value == 0) &#123;</span><br><span class="line">            return &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 temp = value;</span><br><span class="line">        uint256 digits;</span><br><span class="line">        while (temp != 0) &#123;</span><br><span class="line">            digits++;</span><br><span class="line">            temp /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes memory buffer = new bytes(digits);</span><br><span class="line">        while (value != 0) &#123;</span><br><span class="line">            digits -= 1;</span><br><span class="line">            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));</span><br><span class="line">            value /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.</span><br><span class="line">     */</span><br><span class="line">    function toHexString(uint256 value) public pure returns (string memory) &#123;</span><br><span class="line">        if (value == 0) &#123;</span><br><span class="line">            return &quot;0x00&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 temp = value;</span><br><span class="line">        uint256 length = 0;</span><br><span class="line">        while (temp != 0) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            temp &gt;&gt;= 8;</span><br><span class="line">        &#125;</span><br><span class="line">        return toHexString(value, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.</span><br><span class="line">     */</span><br><span class="line">    function toHexString(uint256 value, uint256 length) public pure returns (string memory) &#123;</span><br><span class="line">        bytes memory buffer = new bytes(2 * length + 2);</span><br><span class="line">        buffer[0] = &quot;0&quot;;</span><br><span class="line">        buffer[1] = &quot;x&quot;;</span><br><span class="line">        for (uint256 i = 2 * length + 1; i &gt; 1; --i) &#123;</span><br><span class="line">            buffer[i] = _HEX_SYMBOLS[value &amp; 0xf];</span><br><span class="line">            value &gt;&gt;= 4;</span><br><span class="line">        &#125;</span><br><span class="line">        require(value == 0, &quot;Strings: hex length insufficient&quot;);</span><br><span class="line">        return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="接收与发送ETH"><a href="#接收与发送ETH" class="headerlink" title="接收与发送ETH"></a>接收与发送ETH</h3><h5 id="接收ETH"><a href="#接收ETH" class="headerlink" title="接收ETH"></a>接收ETH</h5><p><code>Solidity</code>支持两种特殊的回调函数，<code>receive()</code>和<code>fallback()</code>，他们主要在两种情况下被使用：</p>
<ol>
<li>接收ETH</li>
<li>处理合约中不存在的函数调用</li>
</ol>
<ul>
<li><p><strong>receive()</strong></p>
<p><code>receive()</code>合约用来接收ETH，一个合约最多有一个 <code>receive()</code>函数，声明该函数时必须包含<code>external</code>和<code>payable</code>关键字，当合约接收到ETH时，<code>receive()</code>会被触发。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义事件</span><br><span class="line">event Received(address Sender, uint Value);</span><br><span class="line">// 接收ETH时释放Received事件</span><br><span class="line">receive() external payable &#123;</span><br><span class="line">    emit Received(msg.sender, msg.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>fallback()</strong></p>
<p><code>fallback()</code>函数会在调用合约不存在的函数时被触发，在声明时也必须包含<code>external</code>关键字，一般会用<code>payable</code>修饰。</p>
<pre><code>// fallback
fallback() external payable&#123;
    emit fallbackCalled(msg.sender, msg.value, msg.data);
&#125;
</code></pre>
</li>
</ul>
<p><code>receive()</code>和<code>fallback()</code>的区别在于合约接收<code>ETH</code>时，<code>msg.data</code>为空且存在<code>receive()</code>时，会触发<code>receive()</code>；<code>msg.data</code>不为空或不存在<code>receive()</code>时，会触发<code>fallback()</code>，此时<code>fallback()</code>必须为<code>payable</code>，<code>receive()</code>和<code>payable fallback()</code>均不存在的时候，向合约发送<code>ETH</code>将会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           接收ETH</span><br><span class="line">              |</span><br><span class="line">         msg.data是空？</span><br><span class="line">            /  \</span><br><span class="line">          是    否</span><br><span class="line">          /      \</span><br><span class="line">receive()存在?   fallback()</span><br><span class="line">        / \</span><br><span class="line">       是  否</span><br><span class="line">      /     \</span><br><span class="line">receive()   fallback()</span><br></pre></td></tr></table></figure>

<h5 id="发送ETH"><a href="#发送ETH" class="headerlink" title="发送ETH"></a>发送ETH</h5><p>在部署可以发送ETH的合约时需要在合约中实现<code>payable</code>的构造函数和<code>receive()</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract SendETH &#123;</span><br><span class="line">    // 构造函数，payable使得部署的时候可以转eth进去</span><br><span class="line">    constructor() payable&#123;&#125;</span><br><span class="line">    // receive方法，接收eth时被触发</span><br><span class="line">    receive() external payable&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Solidity</code>有三种方法向其他合约发送<code>ETH</code>，他们是：<code>transfer()</code>，<code>send()</code>和<code>call()</code>。</p>
<h6 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h6><p>用法：<code>address(receiver).transfer(amount)</code></p>
<p><code>transfer()</code>的 gas 限制是 2300，可以足够用于转账，但如果接收合约中的<code>fallback()</code>或<code>receive（）</code>函数不能实现太复杂的逻辑，否则会导致错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transferETH(address payable _to, uint256 amount) external payable &#123;</span><br><span class="line">	_to.transfer(amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="send"><a href="#send" class="headerlink" title="send"></a>send</h6><p>用法：<code>address(receiver).send(amount)</code></p>
<p><code>send()</code>函数的的gas与<code>transfer()</code>相同也是2300gas，但也要求接收合约中的<code>fallback()</code>或<code>receive（）</code>函数不能实现太复杂的逻辑。</p>
<p>如果转账失败不会<code>revert</code>，而是会返回<code>false</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sendETH(address payable _to, uint256 amount) external payable &#123;</span><br><span class="line">	bool success = _to.send(amount);</span><br><span class="line">	if(!success)&#123;</span><br><span class="line">		revert SendFailed();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="send-1"><a href="#send-1" class="headerlink" title="send"></a>send</h6><p>用法：<code>address(receiver).call&#123;value: amount(&quot;&quot;)&#125;</code></p>
<p><code>call()</code>没有gas限制，在可以支持接受合约的<code>fallback()</code>或者<code>receive()</code>实现复杂的逻辑，当<code>call()</code>转账失败也不会revert，<code>call()</code>的返回值是<code>(bool, data)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callSendETH(address payable _to, unint256 amount) external payable&#123;</span><br><span class="line">	(bool success, )= _to.call&#123;value:amount&#125;(&quot;&quot;)</span><br><span class="line">	if(!success)&#123;</span><br><span class="line">		revert CallFailed();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="调用合约"><a href="#调用合约" class="headerlink" title="调用合约"></a>调用合约</h3><p>调用<code>OtherContract</code>合约</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract OtherContract &#123;</span><br><span class="line">    uint256 private _x = 0; // 状态变量_x</span><br><span class="line">    // 收到eth的事件，记录amount和gas</span><br><span class="line">    event Log(uint amount, uint gas);</span><br><span class="line">    </span><br><span class="line">    // 返回合约ETH余额</span><br><span class="line">    function getBalance() view public returns(uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)</span><br><span class="line">    function setX(uint256 x) external payable&#123;</span><br><span class="line">        _x = x;</span><br><span class="line">        // 如果转入ETH，则释放Log事件</span><br><span class="line">        if(msg.value &gt; 0)&#123;</span><br><span class="line">            emit Log(msg.value, gasleft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 读取_x</span><br><span class="line">    function getX() external view returns(uint x)&#123;</span><br><span class="line">        x = _x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="传入合约地址"><a href="#传入合约地址" class="headerlink" title="传入合约地址"></a>传入合约地址</h5><p>可以利用合约的地址和合约代码（接口）来创建合约的引用：<code>_name(_Address)</code>，其中<code>_Name</code>是合约名，<code>_Address</code>是合约地址。然后用合约的引用来调用合约中的函数。如：<code>_Name(_Address).func()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callSetX(address _Address, uint256 x) external &#123;</span><br><span class="line">	OtherContract(_Address).setX(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="传入合约变量"><a href="#传入合约变量" class="headerlink" title="传入合约变量"></a>传入合约变量</h5><p>可以直接在函数里传入合约的引用，只需要把上面参数的<code>address</code>类型更改目标合约名，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callgetX(OtherContract _Address) external view returns(uint x)&#123;</span><br><span class="line">	x = _Address.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建合约变量"><a href="#创建合约变量" class="headerlink" title="创建合约变量"></a>创建合约变量</h5><p>可以通过创建合约变量，然后通过合约变量来调用目标函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callGetX(address _Address) external view returns(uin x)&#123;</span><br><span class="line">	OtherContract oc = OtherContract(_Address);</span><br><span class="line">	x = oc.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="调用合约并发送ETH"><a href="#调用合约并发送ETH" class="headerlink" title="调用合约并发送ETH"></a>调用合约并发送ETH</h5><p>如果目标合约的函数是<code>payable</code>的，那么我们可以通过调用它给合约进行转账：<code>_Name(_Address).func&#123;value:_Value&#125;()</code></p>
<blockquote>
<p>在小于0.6.2的版本为：Name(ContractAddress).value(Value).gas(Gas)()</p>
</blockquote>
<h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><p><code>call</code> 是<code>address</code>类型的低级成员函数，它用来与其他合约交互。它的返回值为<code>(bool, data)</code>，分别对应<code>call</code>是否成功以及目标函数的返回值。</p>
<ul>
<li><code>call</code>是<code>solidity</code>官方推荐的通过触发<code>fallback</code>或<code>receive</code>函数发送<code>ETH</code>的方法。</li>
<li>不推荐用<code>call</code>来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数。</li>
<li>当我们不知道对方合约的源代码或<code>ABI</code>，就没法生成合约变量；这时，我们仍可以通过<code>call</code>调用对方合约的函数。</li>
</ul>
<p>规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contractAddress.call(二进制编码)</span><br></pre></td></tr></table></figure>

<p>二进制编码可以利用<code>abi.encodeWithSignature</code>获得</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;函数签名&quot;，具体参数)</span><br></pre></td></tr></table></figure>

<p><code>call</code>在调用合约时也可以指定交易发送的<code>value</code>和<code>gas</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contractAddress.call&#123;value:amount, gas:gasAmount&#125;(abi.encodeWithSignature(&quot;funcSig&quot;,params))</span><br></pre></td></tr></table></figure>

<p>利用<code>call</code>调用<code>OtherContrat</code>合约</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callSetX(address payable _addr, uint256 x) public payable &#123;</span><br><span class="line">	(bool success, bytes memory data) = _addr.call&#123;value:sg.value&#125;(</span><br><span class="line">		abi.encodeWithSignature(&quot;setX(uint256)&quot;,x)</span><br><span class="line">		);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果利用<code>call</code>调用合约中不存在的函数，那么目标合约中的<code>fallback</code>函数会被触发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callNonExist(address _addr) external&#123;</span><br><span class="line">    // call getX()</span><br><span class="line">    (bool success, bytes memory data) = _addr.call(</span><br><span class="line">        abi.encodeWithSignature(&quot;foo(uint256)&quot;)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时<code>call</code>还是会调用成功，并返回<code>success</code>，但是其实调用的是目标合约中的<code>fallback</code>函数</p>
<h3 id="Delegetecall"><a href="#Delegetecall" class="headerlink" title="Delegetecall"></a>Delegetecall</h3><p><code>delegatecall</code>也是 solidity 中 <code>address</code> 类型的低级成员函数。</p>
<p>当用户<code>A</code>通过合约<code>B</code>来<code>call</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，<code>语境</code>(<code>Context</code>，可以理解为包含变量和状态的环境)也是合约<code>C</code>的：<code>msg.sender</code>是<code>B</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>C</code>的变量上。</p>
<p><img src="/image/solidity%E8%BF%9B%E9%98%B6.assets/image-20221103211841263.png" alt="image-20221103211841263"></p>
<p>而当用户<code>A</code>通过合约<code>B</code>来<code>delegatecall</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，但是<code>语境</code>仍是合约<code>B</code>的：<code>msg.sender</code>是<code>A</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>B</code>的变量上。</p>
<p><img src="/image/solidity%E8%BF%9B%E9%98%B6.assets/image-20221103212047007.png" alt="image-20221103212047007"></p>
<p>相当于把合约C的代码拉过来在B的环境下执行。</p>
<p>规则也与<code>call</code>类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contractAddress.delegatecall(二进制编码)</span><br></pre></td></tr></table></figure>

<p>与<code>call</code>不同的是，<code>delegatecall</code>在调用合约时可以指定交易发送的<code>gas</code>，但不能指定发送的<code>ETH</code>数额。</p>
<p>**<font color=red>注意</font>**：<code>delegatecall</code>有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。</p>
<p>使用<code>delegatecall</code>的应用场景：</p>
<ol>
<li>代理合约（<code>Proxy Contract</code>）：将智能合约的存储合约和逻辑合约分开：代理合约（<code>Proxy Contract</code>）存储所有相关的变量，并且保存逻辑合约的地址；所有函数存在逻辑合约（<code>Logic Contract</code>）里，通过<code>delegatecall</code>执行。当升级时，只需要将代理合约指向新的逻辑合约即可。</li>
<li>EIP-2535 Diamonds（钻石）：钻石是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合同的代理合同。 更多信息请查看：<a target="_blank" rel="noopener" href="https://eip2535diamonds.substack.com/p/introduction-to-the-diamond-standard">钻石标准简介</a>。</li>
</ol>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 被调用的合约C</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public num;</span><br><span class="line">    address public sender;</span><br><span class="line"></span><br><span class="line">    function setVars(uint _num) public payable &#123;</span><br><span class="line">        num = _num;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发起调用的合约：</p>
<p>首先，合约<code>B</code>必须和目标合约<code>C</code>的变量存储布局必须相同，两个变量，并且顺序为<code>num</code>和<code>sender</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract B &#123;</span><br><span class="line">    uint public num;</span><br><span class="line">    address public sender;</span><br></pre></td></tr></table></figure>

<p><code>callSetVars</code>函数通过<code>call</code>来调用<code>setVars</code>。它有两个参数<code>_addr</code>和<code>_num</code>，分别对应合约<code>C</code>的地址和<code>setVars</code>的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过call来调用C的setVars()函数，将改变合约C里的状态变量</span><br><span class="line">   function callSetVars(address _addr, uint _num) external payable&#123;</span><br><span class="line">       // call setVars()</span><br><span class="line">       (bool success, bytes memory data) = _addr.call(</span><br><span class="line">           abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>delegatecallSetVars</code>函数通过<code>delegatecall</code>来调用<code>setVars</code>。与上面的<code>callSetVars</code>函数相同，有两个参数<code>_addr</code>和<code>_num</code>，分别对应合约<code>C</code>的地址和<code>setVars</code>的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    // 通过delegatecall来调用C的setVars()函数，将改变合约B里的状态变量</span><br><span class="line">    function delegatecallSetVars(address _addr, uint _num) external payable&#123;</span><br><span class="line">        // delegatecall setVars()</span><br><span class="line">        (bool success, bytes memory data) = _addr.delegatecall(</span><br><span class="line">            abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="在合约中创建新合约"><a href="#在合约中创建新合约" class="headerlink" title="在合约中创建新合约"></a><font color=purple>在合约中创建新合约</font></h3><p>在以太坊链上，用户（外部账户，<code>EOA</code>）可以创建智能合约，智能合约同样也可以创建新的智能合约。去中心化交易所<code>uniswap</code>就是利用工厂合约（<code>Factory</code>）创建了无数个币对合约（<code>Pair</code>）。</p>
<p>有俩种方法可以创建智能合约</p>
<h5 id="Create"><a href="#Create" class="headerlink" title="Create:"></a><font color=red><strong>Create:</strong></font></h5><p>new 一个合约，并传入新合约构造函数所需的参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Contract x = new Contract&#123;value: _value&#125;(params)</span><br></pre></td></tr></table></figure>

<p>其中<code>Contract</code>是要创建的合约名，<code>x</code>是合约对象（地址），如果构造函数是<code>payable</code>，可以创建时转入<code>_value</code>数量的<code>ETH</code>，<code>params</code>是新合约构造函数的参数。</p>
<p><code>Uniswap V2</code><a target="_blank" rel="noopener" href="https://github.com/Uniswap/v2-core/tree/master/contracts">核心合约</a>中包含两个合约：</p>
<ol>
<li>UniswapV2Pair: 币对合约，用于管理币对地址、流动性、买卖。</li>
<li>UniswapV2Factory: 工厂合约，用于创建新的币对，并管理币对地址。</li>
</ol>
<p>下面我们用<code>create</code>方法实现一个极简版的<code>Uniswap</code>：<code>Pair</code>币对合约负责管理币对地址，<code>PairFactory</code>工厂合约用于创建新的币对，并管理币对地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Pair &#123;</span><br><span class="line">	address public factory;   //工厂合约地址</span><br><span class="line">	address public token0;		//代币1</span><br><span class="line">	address public token1;		//代币2	</span><br><span class="line">	</span><br><span class="line">	constructor() payable &#123;</span><br><span class="line">		factory = msg.sender;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 在部署时由工厂调用一次</span><br><span class="line">	function initialize(address _token0, address _token1) external &#123;</span><br><span class="line">		require(msg.sender ==factory, &quot;Uniswapv2;FORBIDDEN&quot;);</span><br><span class="line">		token0 = _token0;</span><br><span class="line">		token1 = _token1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Pair</code>合约很简单，包含3个状态变量：<code>factory</code>，<code>token0</code>和<code>token1</code>。</p>
<p>构造函数<code>constructor</code>在部署时将<code>factory</code>赋值为工厂合约地址。<code>initialize</code>函数会在<code>Pair</code>合约创建的时候被工厂合约调用一次，将<code>token0</code>和<code>token1</code>更新为币对中两种代币的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract PairFactory &#123;</span><br><span class="line">	//通过俩个代币地址查Pair地址</span><br><span class="line">	mapping(address =&gt; mapping(address =&gt; address)) public getPair;</span><br><span class="line">	address[] public allPairs;	//保存所有Pair地址</span><br><span class="line">	</span><br><span class="line">	function createPair(address tokenA, address tokenB) external returns(address pairAddr) &#123;</span><br><span class="line">		//创建新合约</span><br><span class="line">		Pair pair = new Pair();</span><br><span class="line">		//调用新合约的initialize方法</span><br><span class="line">		pair.initialize(tokenA, tokenB);</span><br><span class="line">		//更新地址map</span><br><span class="line">		pairAddr = address(pair);</span><br><span class="line">		allPairs.push(pairAddr);</span><br><span class="line">		getPair[tokenA][tokenB] = pairAddr;</span><br><span class="line">		getPair[tokenB][tokenA] = pairAddr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂合约（<code>PairFactory</code>）有两个状态变量<code>getPair</code>是两个代币地址到币对地址的<code>map</code>，方便根据代币找到币对地址；<code>allPairs</code>是币对地址的数组，存储了所有代币地址。</p>
<p><code>PairFactory</code>合约只有一个<code>createPair</code>函数，根据输入的两个代币地址<code>tokenA</code>和<code>tokenB</code>来创建新的<code>Pair</code>合约。其中</p>
<p><code>Pair pair = new Pair();</code></p>
<h5 id="Create2"><a href="#Create2" class="headerlink" title="Create2:"></a><font color=red><strong>Create2:</strong></font></h5><p>CREATE2 操作码使我们在智能合约部署在以太坊网络之前就能预测合约的地址。Uniswap创建Pair合约用的就是CREATE2而不是CREATE.</p>
<h6 id="create-地址计算"><a href="#create-地址计算" class="headerlink" title="create 地址计算"></a>create 地址计算</h6><p>智能合约可以由其他合约和普通账户利用<code>CREATE</code>操作码创建。 在这两种情况下，新合约的地址都以相同的方式计算：创建者的地址(通常为部署的钱包地址或者合约地址)和<code>nonce</code>(该地址发送交易的总数,对于合约账户是创建的合约总数,每创建一个合约nonce+1))的哈希。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新合约_Address = hash(创建着地址，nonce)</span><br></pre></td></tr></table></figure>

<p>创建者地址不会变，但<code>nonce</code>可能会随时间而改变，因此用<code>CREATE</code>创建的合约地址不好预测。</p>
<h6 id="create2地址计算"><a href="#create2地址计算" class="headerlink" title="create2地址计算"></a>create2地址计算</h6><p><code>CREATE2</code>的目的是为了让合约地址独立于未来的事件。不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上。用<code>CREATE2</code>创建的合约地址由4个部分决定：</p>
<ul>
<li><code>0xFF</code>：一个常数，避免和<code>CREATE</code>冲突</li>
<li>创建者地址</li>
<li><code>salt</code>（盐）：一个创建者给定的数值</li>
<li>待部署合约的字节码（<code>bytecode</code>）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newAddress = hash(&quot;0xFF&quot;,创建者地址, salt, bytecode)</span><br></pre></td></tr></table></figure>

<p><code>CREATE2</code> 确保，如果创建者使用 <code>CREATE2</code> 和提供的 <code>salt</code> 部署给定的合约<code>bytecode</code>，它将存储在新地址中。</p>
<p><strong>create2用法：</strong></p>
<p>与<strong>create</strong>类似，但是需要多传入一个 <code>salt</code>参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Contract x = new Contract&#123;salt: _salt, value: _value&#125;(params)</span><br></pre></td></tr></table></figure>



<p>使用 <code>create2</code>实现Uniswap</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Pair&#123;</span><br><span class="line">    address public factory; // 工厂合约地址</span><br><span class="line">    address public token0; // 代币1</span><br><span class="line">    address public token1; // 代币2</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        factory = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // called once by the factory at time of deployment</span><br><span class="line">    function initialize(address _token0, address _token1) external &#123;</span><br><span class="line">        require(msg.sender == factory, &#x27;UniswapV2: FORBIDDEN&#x27;); // sufficient check</span><br><span class="line">        token0 = _token0;</span><br><span class="line">        token1 = _token1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数<code>constructor</code>在部署时将<code>factory</code>赋值为工厂合约地址。<code>initialize</code>函数会在<code>Pair</code>合约创建的时候被工厂合约调用一次，将<code>token0</code>和<code>token1</code>更新为币对中两种代币的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract PairFactory2&#123;</span><br><span class="line">        mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址</span><br><span class="line">        address[] public allPairs; // 保存所有Pair地址</span><br><span class="line"></span><br><span class="line">        function createPair2(address tokenA, address tokenB) external returns (address pairAddr) &#123;</span><br><span class="line">            require(tokenA != tokenB, &#x27;IDENTICAL_ADDRESSES&#x27;); //避免tokenA和tokenB相同产生的冲突</span><br><span class="line">            // 计算用tokenA和tokenB地址计算salt</span><br><span class="line">            //将tokenA和tokenB按大小排序</span><br><span class="line">            (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); </span><br><span class="line">            bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">            // 用create2部署新合约</span><br><span class="line">            Pair pair = new Pair&#123;salt: salt&#125;(); </span><br><span class="line">            // 调用新合约的initialize方法</span><br><span class="line">            pair.initialize(tokenA, tokenB);</span><br><span class="line">            // 更新地址map</span><br><span class="line">            pairAddr = address(pair);</span><br><span class="line">            allPairs.push(pairAddr);</span><br><span class="line">            getPair[tokenA][tokenB] = pairAddr;</span><br><span class="line">            getPair[tokenB][tokenA] = pairAddr;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>工厂合约（<code>PairFactory2</code>）有两个状态变量<code>getPair</code>是两个代币地址到币对地址的<code>map</code>，方便根据代币找到币对地址；<code>allPairs</code>是币对地址的数组，存储了所有币对地址。</p>
<p><code>PairFactory2</code>合约只有一个<code>createPair2</code>函数，使用<code>CREATE2</code>根据输入的两个代币地址<code>tokenA</code>和<code>tokenB</code>来创建新的<code>Pair</code>合约。其中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pair pair = new Pair&#123;salt: salt&#125;(); </span><br></pre></td></tr></table></figure>

<p>就是利用<code>CREATE2</code>创建合约的代码，非常简单，而<code>salt</code>为<code>token1</code>和<code>token2</code>的<code>hash</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br></pre></td></tr></table></figure>



<p><strong>事先计算Pair的地址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 提前计算pair合约地址</span><br><span class="line">function calculateAddr(address tokenA, address tokenB) public view returns(address predictedAddress)&#123;</span><br><span class="line">  require(tokenA != tokenB, &#x27;IDENTICAL_ADDRESSES&#x27;); //避免tokenA和tokenB相同产生的冲突</span><br><span class="line">  // 计算用tokenA和tokenB地址计算salt</span><br><span class="line">  //将tokenA和tokenB按大小排序</span><br><span class="line">  (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); </span><br><span class="line">  bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">  // 计算合约地址方法 hash()</span><br><span class="line">  predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(</span><br><span class="line">  bytes1(0xff),</span><br><span class="line">  address(this),</span><br><span class="line">  salt,</span><br><span class="line">  keccak256(type(Pair).creationCode)</span><br><span class="line">  )))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ABI编码"><a href="#ABI编码" class="headerlink" title="ABI编码"></a>ABI编码</h3><p><code>ABI</code> (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。</p>
<p><code>Solidity</code>中，<code>ABI编码</code>有4个函数：<code>abi.encode</code>, <code>abi.encodePacked</code>, <code>abi.encodeWithSignature</code>, <code>abi.encodeWithSelector</code>。而<code>ABI解码</code>有1个函数：<code>abi.decode</code>，用于解码<code>abi.encode</code>的数据。</p>
<h5 id="abi-encode"><a href="#abi-encode" class="headerlink" title="abi.encode"></a>abi.encode</h5><p><code>ABI</code>被设计出来跟智能合约交互，他将每个参数填充为32字节的数据，并拼接在一起。如果你要和合约交互，你要用的就是<code>abi.encode</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint x = 1;</span><br><span class="line">address addr = msg.sender;</span><br><span class="line">function encode() public view returns(bytes memory result) &#123;</span><br><span class="line">        result = abi.encode(x,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000004b20993bc481177ec7e8f571cecae8a9e22c02db</span><br></pre></td></tr></table></figure>

<p><strong>abi.encode</strong> 会将每个数据都填充为 32 字节</p>
<h5 id="abi-encodePacked"><a href="#abi-encodePacked" class="headerlink" title="abi.encodePacked"></a>abi.encodePacked</h5><p>将给定参数根据其所需最低空间编码。它类似 <code>abi.encode</code>，但是会把其中填充的很多<code>0</code>省略。比如，只用1字节来编码<code>uint</code>类型。当你想省空间，并且不与合约交互的时候，可以使用<code>abi.encodePacked</code>，例如算一些数据的<code>hash</code>时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint x = 1;</span><br><span class="line">address addr = msg.sender;</span><br><span class="line">function encode() public view returns(bytes memory result) &#123;</span><br><span class="line">        result = abi.encodePacked(x,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0x00000000000000000000000000000000000000000000000000000000000000014b20993bc481177ec7e8f571cecae8a9e22c02db</span><br></pre></td></tr></table></figure>

<h5 id="abi-encodeWithSignature"><a href="#abi-encodeWithSignature" class="headerlink" title="abi.encodeWithSignature"></a>abi.encodeWithSignature</h5><p>与<code>abi.encode</code>功能类似，只不过第一个参数为<code>函数签名</code>，比如<code>&quot;foo(uint256,address)&quot;</code>。当调用其他合约的时候可以使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint x = 1;</span><br><span class="line">address addr = msg.sender;</span><br><span class="line">function encodeWithSignature() public view returns(bytes memory result) &#123;</span><br><span class="line">   result = abi.encodeWithSignature(&quot;foo(uint256,address,string,uint256[2])&quot;, x, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0xe87082f100000000000000000000000000000000000000000000000000000000000000010000000000000000000000004b20993bc481177ec7e8f571cecae8a9e22c02db</span><br></pre></td></tr></table></figure>

<p><code>abi.encode</code>编码结果前加上了4字节的函数选择器。 函数选择器就是通过函数名和参数进行签名处理(Keccak–Sha3)来标识函数，可以用于不同合约之间的函数调用</p>
<h5 id="abi-encodeWithSelector"><a href="#abi-encodeWithSelector" class="headerlink" title="abi.encodeWithSelector"></a>abi.encodeWithSelector</h5><p>与<code>abi.encodeWithSignature</code>功能类似，只不过第一个参数为<code>函数选择器</code>，为<code>函数签名</code>Keccak哈希的前4个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint x = 1;</span><br><span class="line">address addr = msg.sender;</span><br><span class="line">function encodeWithSelector() public view returns(bytes memory result) &#123;</span><br><span class="line">	result = abi.encodeWithSelector(bytes4(keccak256(&quot;foo(uint256,address,string,uint256[2])&quot;)), x, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0xe87082f100000000000000000000000000000000000000000000000000000000000000010000000000000000000000004b20993bc481177ec7e8f571cecae8a9e22c02db</span><br></pre></td></tr></table></figure>



<h5 id="abi-decode-解码"><a href="#abi-decode-解码" class="headerlink" title="abi.decode(解码)"></a>abi.decode(解码)</h5><p><code>abi.decode</code>用于解码<code>abi.encode</code>生成的二进制编码，将它还原成原本的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function decode(bytes memory data) public pure returns(uint dx, address daddr) &#123;</span><br><span class="line">      (dx, daddr) = abi.decode(data, (uint, address));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/image/solidity%E8%BF%9B%E9%98%B6.assets/image-20221108214419590.png" alt="image-20221108214419590"></p>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ol>
<li><p>在合约开发中，ABI常配合call来实现对合约的底层调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes4 selector = contract.getValue.selector;</span><br><span class="line">   </span><br><span class="line">bytes memory data = abi.encodeWithSelector(selector, _x);</span><br><span class="line">(bool success, bytes memory returnedData) = address(contract).staticcall(data);</span><br><span class="line">require(success);</span><br><span class="line">   </span><br><span class="line">return abi.decode(returnedData, (uint256));</span><br></pre></td></tr></table></figure></li>
<li><p>ethers.js中常用ABI实现合约的导入和函数调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wavePortalContract = <span class="keyword">new</span> ethers.Contract(contractAddress, contractABI, signer);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Call the getAllWaves method from your Smart Contract</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> waves = <span class="keyword">await</span> wavePortalContract.getAllWaves();</span><br></pre></td></tr></table></figure></li>
<li><p>对不开源合约进行反编译后，某些函数无法查到函数签名，可通过ABI进行调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes memory data = abi.encodeWithSelector(bytes4(0x533ba33a));</span><br><span class="line">(bool success, bytes memory returnedData) = address(contract).staticcall(data);</span><br><span class="line">require(success);</span><br><span class="line">return abi.decode(returnedData, (uint256));</span><br></pre></td></tr></table></figure></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Banana69</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://banana69.site/2022/10/22/solidity%E8%BF%9B%E9%98%B6/">https://banana69.site/2022/10/22/solidity%E8%BF%9B%E9%98%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Banana69.site" target="_blank">Banana69</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/">智能合约</a></div><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Banana69</div><div class="author-info__description">菜鸡的博客</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Banannna69"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Banannna69" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:junminn@126.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-text">0x01 函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-%E5%BA%93%E5%90%88%E7%BA%A6"><span class="toc-text">0x02 库合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E4%B8%8E%E5%8F%91%E9%80%81ETH"><span class="toc-text">接收与发送ETH</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6ETH"><span class="toc-text">接收ETH</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81ETH"><span class="toc-text">发送ETH</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#transfer"><span class="toc-text">transfer</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#send"><span class="toc-text">send</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#send-1"><span class="toc-text">send</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%90%88%E7%BA%A6"><span class="toc-text">调用合约</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E5%85%A5%E5%90%88%E7%BA%A6%E5%9C%B0%E5%9D%80"><span class="toc-text">传入合约地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E5%85%A5%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F"><span class="toc-text">传入合约变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F"><span class="toc-text">创建合约变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%90%88%E7%BA%A6%E5%B9%B6%E5%8F%91%E9%80%81ETH"><span class="toc-text">调用合约并发送ETH</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Call"><span class="toc-text">Call</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Delegetecall"><span class="toc-text">Delegetecall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%90%88%E7%BA%A6%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%B0%E5%90%88%E7%BA%A6"><span class="toc-text">在合约中创建新合约</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Create"><span class="toc-text">Create:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Create2"><span class="toc-text">Create2:</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#create-%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97"><span class="toc-text">create 地址计算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#create2%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97"><span class="toc-text">create2地址计算</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ABI%E7%BC%96%E7%A0%81"><span class="toc-text">ABI编码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#abi-encode"><span class="toc-text">abi.encode</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#abi-encodePacked"><span class="toc-text">abi.encodePacked</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#abi-encodeWithSignature"><span class="toc-text">abi.encodeWithSignature</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#abi-encodeWithSelector"><span class="toc-text">abi.encodeWithSelector</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#abi-decode-%E8%A7%A3%E7%A0%81"><span class="toc-text">abi.decode(解码)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/22/solidity%E8%BF%9B%E9%98%B6/" title="Solididy进阶">Solididy进阶</a><time datetime="2022-10-22T01:24:02.000Z" title="发表于 2022-10-22 09:24:02">2022-10-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/08/23/solidity%E7%BC%96%E5%86%99%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/" title="solidity编写内联汇编">solidity编写内联汇编</a><time datetime="2022-08-23T08:51:44.000Z" title="发表于 2022-08-23 16:51:44">2022-08-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/08/19/Chain-Flag%E8%AE%B0%E5%BD%95/" title="Chain Flag记录">Chain Flag记录</a><time datetime="2022-08-19T09:38:23.000Z" title="发表于 2022-08-19 17:38:23">2022-08-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/07/29/RaceToEmpty%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/" title="The Dao 事件分析">The Dao 事件分析</a><time datetime="2022-07-29T08:55:14.000Z" title="发表于 2022-07-29 16:55:14">2022-07-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/07/28/evm-puzzles/" title="Evm-puzzles题解">Evm-puzzles题解</a><time datetime="2022-07-27T16:00:00.000Z" title="发表于 2022-07-28 00:00:00">2022-07-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Banana69</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>