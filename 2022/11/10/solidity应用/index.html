<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>solidity应用学习笔记 | Banana69</title><meta name="keywords" content="区块链"><meta name="author" content="Banana69"><meta name="copyright" content="Banana69"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ERC20ERC20是以太坊上的代币标准，来自2015年11月V神参与的EIP20。它实现了代币转账的基本逻辑：  IERC20 totalSupply: 获取该合约内总的 ERC20 Token 总量 balanceOf: 获取特定账户的 ERC20 Token 总量 transfer: 向目标账户转移特定数量的 ERC20 Token allowance: 获取目标账户能够使用的源账户的 ER">
<meta property="og:type" content="article">
<meta property="og:title" content="solidity应用学习笔记">
<meta property="og:url" content="https://banana69.site/2022/11/10/solidity%E5%BA%94%E7%94%A8/index.html">
<meta property="og:site_name" content="Banana69">
<meta property="og:description" content="ERC20ERC20是以太坊上的代币标准，来自2015年11月V神参与的EIP20。它实现了代币转账的基本逻辑：  IERC20 totalSupply: 获取该合约内总的 ERC20 Token 总量 balanceOf: 获取特定账户的 ERC20 Token 总量 transfer: 向目标账户转移特定数量的 ERC20 Token allowance: 获取目标账户能够使用的源账户的 ER">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2022-11-10T11:31:09.000Z">
<meta property="article:modified_time" content="2023-01-12T15:35:33.903Z">
<meta property="article:author" content="Banana69">
<meta property="article:tag" content="区块链">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://banana69.site/2022/11/10/solidity%E5%BA%94%E7%94%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'solidity应用学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-12 23:35:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Banana69" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Banana69</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">solidity应用学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-11-10T11:31:09.000Z" title="发表于 2022-11-10 19:31:09">2022-11-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="solidity应用学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h2><p><code>ERC20</code>是以太坊上的代币标准，来自2015年11月V神参与的<a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-20"><code>EIP20</code></a>。它实现了代币转账的基本逻辑：</p>
<ul>
<li>IERC20 totalSupply: 获取该合约内总的 ERC20 Token 总量</li>
<li>balanceOf: 获取特定账户的 ERC20 Token 总量</li>
<li>transfer: 向目标账户转移特定数量的 ERC20 Token</li>
<li>allowance: 获取目标账户能够使用的源账户的 ERC20 Token 数量</li>
<li>approve: 向目标账户授权, 可以转移指定额度的 ERC20 Token 数量</li>
<li>transferFrom: ( 第三方调用 ) 从源账户向目标账户转移制定数量的 ERC20 Token</li>
</ul>
<h3 id="IERC20"><a href="#IERC20" class="headerlink" title="IERC20"></a>IERC20</h3><p><code>IERC20</code>是<code>ERC20</code>代币标准的接口合约，规定了<code>ERC20</code>代币需要实现的函数和事件。 之所以需要定义接口，是因为有了规范后，就存在所有的<code>ERC20</code>代币都通用的函数名称，输入参数，输出参数。 在接口函数中，只需要定义函数名称，输入参数，输出参数，并不关心函数内部如何实现。 由此，函数就分为内部和外部两个内容，一个重点是实现，另一个是对外接口，约定共同数据。 这就是为什么需要<code>ERC20.sol</code>和<code>IERC20.sol</code>两个文件实现一个合约。</p>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p><code>IERC20</code>定义了<code>2</code>个事件：<code>Transfer</code>事件和<code>Approval</code>事件，分别在转账和授权时被释放</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 释放条件：当 `value` 单位的货币从账户 (`from`) 转账到另一账户 (`to`)时.</span><br><span class="line"> */</span><br><span class="line">event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev 释放条件：当 `value` 单位的货币从账户 (`owner`) 授权给另一账户 (`spender`)时.</span><br><span class="line"> */</span><br><span class="line">event Approval(address indexed owner, address indexed spender, uint256 value);</span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><code>IERC20</code>一共定义了 6 个函数，提供了转移代币的基本功能，并允许代币获得批准，以便其他链上第三方使用。</p>
<ul>
<li><p>**totalSupply()**返回代币总量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 返回代币总供给.</span><br><span class="line"> */</span><br><span class="line">function totalSupply() external view returns (uint256);</span><br></pre></td></tr></table></figure></li>
<li><p>**balanceof()**返回账户余额</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 返回账户`account`所持有的代币数.</span><br><span class="line"> */</span><br><span class="line">function balanceOf(address account) external view returns (uint256);</span><br></pre></td></tr></table></figure></li>
<li><p>**transfer()**转账操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 转账 `amount` 单位代币，从调用者账户到另一账户 `to`.</span><br><span class="line"> *</span><br><span class="line"> * 如果成功，返回 `true`.</span><br><span class="line"> *</span><br><span class="line"> * 释放 &#123;Transfer&#125; 事件.</span><br><span class="line"> */</span><br><span class="line">function transfer(address to, uint256 amount) external returns (bool);</span><br></pre></td></tr></table></figure></li>
<li><p>**allowance()**返回授权额度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 返回`owner`账户授权给`spender`账户的额度，默认为0。</span><br><span class="line"> *</span><br><span class="line"> * 当&#123;approve&#125; 或 &#123;transferFrom&#125; 被调用时，`allowance`会改变.</span><br><span class="line"> */</span><br><span class="line">function allowance(address owner, address spender) external view returns (uint256);</span><br></pre></td></tr></table></figure></li>
<li><p>**approve()**授权</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 调用者账户给`spender`账户授权 `amount`数量代币。</span><br><span class="line"> *</span><br><span class="line"> * 如果成功，返回 `true`.</span><br><span class="line"> *</span><br><span class="line"> * 释放 &#123;Approval&#125; 事件.</span><br><span class="line"> */</span><br><span class="line">function approve(address spender, uint256 amount) external returns (bool);</span><br></pre></td></tr></table></figure></li>
<li><p>**transferFrom()**授权转账</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 通过授权机制，从`from`账户向`to`账户转账`amount`数量代币。转账的部分会从调用者的`allowance`中扣除。</span><br><span class="line"> *</span><br><span class="line"> * 如果成功，返回 `true`.</span><br><span class="line"> *</span><br><span class="line"> * 释放 &#123;Transfer&#125; 事件.</span><br><span class="line"> */</span><br><span class="line">function transferFrom(</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint256 amount</span><br><span class="line">) external returns (bool);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="实现ERC20"><a href="#实现ERC20" class="headerlink" title="实现ERC20"></a>实现ERC20</h3><p>我们需要状态变量来记录账户余额，授权额度和代币信息。其中<code>balanceOf</code>, <code>allowance</code>和<code>totalSupply</code>为<code>public</code>类型，会自动生成一个同名<code>getter</code>函数，实现<code>IERC20</code>规定的<code>balanceOf()</code>, <code>allowance()</code>和<code>totalSupply()</code>。而<code>name</code>, <code>symbol</code>, <code>decimals</code>则对应代币的名称，代号和小数位数。</p>
<p><font color=red>用<code>override</code>修饰<code>public</code>变量，会重写继承自父合约的与变量同名的<code>getter</code>函数，比如<code>IERC20</code>中的<code>balanceOf()</code>函数。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(address =&gt; uint256) public override balanceOf;</span><br><span class="line"></span><br><span class="line">mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance;</span><br><span class="line"></span><br><span class="line">uint256 public override totalSupply;   // 代币总供给</span><br><span class="line"></span><br><span class="line">string public name;   // 名称</span><br><span class="line">string public symbol;  // 代号</span><br><span class="line"></span><br><span class="line">uint8 public decimals = 18; // 小数位数</span><br></pre></td></tr></table></figure>

<p>下面是实现的合约：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ERC20.sol</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;=0.6.0 &lt;0.9.0;</span><br><span class="line">import &quot;./IERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ERC20 is IERC20 &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public override balanceOf;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance;</span><br><span class="line"></span><br><span class="line">    uint256 public override totalSupply; // 代币总供给</span><br><span class="line"></span><br><span class="line">    string public name; // 名称</span><br><span class="line">    string public symbol; // 代号</span><br><span class="line"></span><br><span class="line">    uint8 public decimals = 18; // 小数位数</span><br><span class="line"></span><br><span class="line">    constructor(string memory _name, string memory _symbol) &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">        symbol = _symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * transfer()</span><br><span class="line">     * 实现IERC20中的transfer函数，代币转账逻辑。</span><br><span class="line">     * 调用方扣除amount数量代币，接收方增加相应代币。</span><br><span class="line">     */</span><br><span class="line">    function transfer(address recipient, uint amount)</span><br><span class="line">        external</span><br><span class="line">        override</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(msg.sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * approve()</span><br><span class="line">     * 实现IERC20中的approve函数，代币授权逻辑。被授权方spender可以支配授权方(调用者)的amount数量的代币。</span><br><span class="line">     * spender可以是EOA账户，也可以是合约账户：当你用uniswap交易代币时，你需要将代币授权给uniswap合约。</span><br><span class="line">     */</span><br><span class="line">    function approve(address spender, uint amount)</span><br><span class="line">        external</span><br><span class="line">        override</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        allowance[msg.sender][spender] = amount;</span><br><span class="line">        emit Approval(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * transferFrom()</span><br><span class="line">     * 实现IERC20中的授权转账逻辑，被授权方sender的amount数量的代币给接收方recipient(使用的是授权者账户中的代币)</span><br><span class="line">     */</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint amount</span><br><span class="line">    ) external override returns (bool) &#123;</span><br><span class="line">        allowance[sender][msg.sender] -= amount;</span><br><span class="line">        balanceOf[sender] -= amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * mint()函数：铸造代币函数，不在IERC20标准中。</span><br><span class="line">     * 这里为了教程方便，任何人可以铸造任意数量的代币，实际应用中会加权限管理，只有owner可以铸造代币：</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    function mint(uint amount) external &#123;</span><br><span class="line">        balanceOf[msg.sender] += amount;</span><br><span class="line">        totalSupply += amount;</span><br><span class="line">        emit Transfer(address(0), msg.sender, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * burn()销毁代币函数，不在IERC20标准中。</span><br><span class="line">     */</span><br><span class="line">    function burn(uint amount) external &#123;</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        totalSupply -= amsount;</span><br><span class="line">        emit Transfer(msg.sender, address(0), amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//IERC20.sol</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// WTF Solidity by 0xAA</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=0.6.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev ERC20 接口合约.</span><br><span class="line"> */</span><br><span class="line">interface IERC20 &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @dev 释放条件：当 `value` 单位的货币从账户 (`from`) 转账到另一账户 (`to`)时.</span><br><span class="line">     */</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 释放条件：当 `value` 单位的货币从账户 (`owner`) 授权给另一账户 (`spender`)时.</span><br><span class="line">     */</span><br><span class="line">    event Approval(</span><br><span class="line">        address indexed owner,</span><br><span class="line">        address indexed spender,</span><br><span class="line">        uint256 value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 返回代币总供给.</span><br><span class="line">     */</span><br><span class="line">    function totalSupply() external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 返回账户`account`所持有的代币数.</span><br><span class="line">     */</span><br><span class="line">    function balanceOf(address account) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 转账 `amount` 单位代币，从调用者账户到另一账户 `to`.</span><br><span class="line">     *</span><br><span class="line">     * 如果成功，返回 `true`.</span><br><span class="line">     *</span><br><span class="line">     * 释放 &#123;Transfer&#125; 事件.</span><br><span class="line">     */</span><br><span class="line">    function transfer(address to, uint256 amount) external returns (bool);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 返回`owner`账户授权给`spender`账户的额度，默认为0。</span><br><span class="line">     *</span><br><span class="line">     * 当&#123;approve&#125; 或 &#123;transferFrom&#125; 被调用时，`allowance`会改变.</span><br><span class="line">     */</span><br><span class="line">    function allowance(address owner, address spender)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 调用者账户给`spender`账户授权 `amount`数量代币。</span><br><span class="line">     *</span><br><span class="line">     * 如果成功，返回 `true`.</span><br><span class="line">     *</span><br><span class="line">     * 释放 &#123;Approval&#125; 事件.</span><br><span class="line">     */</span><br><span class="line">    function approve(address spender, uint256 amount) external returns (bool);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 通过授权机制，从`from`账户向`to`账户转账`amount`数量代币。转账的部分会从调用者的`allowance`中扣除。</span><br><span class="line">     *</span><br><span class="line">     * 如果成功，返回 `true`.</span><br><span class="line">     *</span><br><span class="line">     * 释放 &#123;Transfer&#125; 事件.</span><br><span class="line">     */</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用-web3js-调用ERC20"><a href="#使用-web3js-调用ERC20" class="headerlink" title="使用 web3js 调用ERC20"></a>使用 web3js 调用ERC20</h3><p>在这里使用Ganache搭建的虚拟环境</p>
<p><img src="solidity%E5%BA%94%E7%94%A8.assets/image-20221110215538178.png" alt="image-20221110215538178"></p>
<p><code>compile.js</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let Web3 = require(&#x27;web3&#x27;)</span><br><span class="line">let solc = require(&#x27;solc&#x27;)</span><br><span class="line">let fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">async function deployContract () &#123;</span><br><span class="line">    //首先读取文件</span><br><span class="line">    const source = fs.readFileSync(&#x27;ERC20.sol&#x27;, &#x27;utf8&#x27;)</span><br><span class="line"></span><br><span class="line">    // Get Path and Load Contract</span><br><span class="line">    function findImports (path) &#123;</span><br><span class="line">        if (fs.existsSync(path)) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                contents: fs.readFileSync(path, &#x27;utf8&#x27;),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (fs.existsSync(&#x27;./node_modules/&#x27; + path)) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                contents: fs.readFileSync(&#x27;./node_modules/&#x27; + path, &#x27;utf8&#x27;),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &#123; error: &#x27;File not found&#x27; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const input = &#123;</span><br><span class="line">        language: &#x27;Solidity&#x27;,</span><br><span class="line">        sources: &#123;</span><br><span class="line">            &#x27;ERC20.sol&#x27;: &#123;</span><br><span class="line">                content: source,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        settings: &#123;</span><br><span class="line">            outputSelection: &#123;</span><br><span class="line">                &#x27;*&#x27;: &#123;</span><br><span class="line">                    &#x27;*&#x27;: [&#x27;*&#x27;],</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    const tempFile = JSON.parse(</span><br><span class="line">        solc.compile(JSON.stringify(input), &#123; import: findImports &#125;)</span><br><span class="line">    )</span><br><span class="line">    const contractFile = tempFile.contracts[&#x27;ERC20.sol&#x27;][&#x27;ERC20&#x27;]</span><br><span class="line"></span><br><span class="line">    // Export Contract Data</span><br><span class="line">    module.exports = contractFile</span><br><span class="line">    console.log(&quot;Compile Success!&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">deployContract().catch((error) =&gt; &#123;</span><br><span class="line">    console.error(error)</span><br><span class="line">    process.exitCode = 1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>index.js</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Web3 = require(&#x27;web3&#x27;)</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">const contractFile = require(&#x27;./compile&#x27;)</span><br><span class="line"></span><br><span class="line">require(&#x27;dotenv&#x27;).config()</span><br><span class="line">const privateKey = process.env.PRIVATE_KEY</span><br><span class="line"></span><br><span class="line">//设置收款账户</span><br><span class="line">const receiver = &#x27;0x48a5B46E63aACd0EC6cDa708507C52e8C9bee33a&#x27;</span><br><span class="line"></span><br><span class="line">//构造web3对象</span><br><span class="line">const web3 = new Web3(new Web3.providers.HttpProvider(&quot;http://127.0.0.1:7545&quot;))</span><br><span class="line">// const providerRPC = &#123;</span><br><span class="line">//     development: &quot;http://127.0.0.1:8545&quot;</span><br><span class="line">// &#125;</span><br><span class="line">// const web3 = new Web3(providerRPC.development)</span><br><span class="line"></span><br><span class="line">//获取账户地址</span><br><span class="line">const account = web3.eth.accounts.privateKeyToAccount(privateKey)</span><br><span class="line">const account_from = &#123;</span><br><span class="line">    privateKey: account.privateKey,</span><br><span class="line">    accountAddress: account.address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(account_from)</span><br><span class="line"></span><br><span class="line">//获取abi和bytecode</span><br><span class="line">const bytecode = contractFile.evm.bytecode.object</span><br><span class="line">const abi = contractFile.abi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const Trans = async () =&gt; &#123;</span><br><span class="line">    //部署合约</span><br><span class="line">    console.log()</span><br><span class="line">    console.log(&#x27;============================ 0. Deploy Contract&#x27;)</span><br><span class="line">    console.log(</span><br><span class="line">        `Attempting to deploy from account $&#123;account_from.accountAddress&#125;`</span><br><span class="line">    )</span><br><span class="line">    web3.eth.getBlockNumber(function (error, result) &#123;</span><br><span class="line">        console.log(result)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //使用对应的 abi 构造相应的合约实例</span><br><span class="line">    const deployContract = new web3.eth.Contract(abi)</span><br><span class="line"></span><br><span class="line">    //创建部署合约的交易</span><br><span class="line">    const deployTx = deployContract.deploy(&#123;</span><br><span class="line">        data: bytecode,</span><br><span class="line">        arguments: [&#x27;DAPPLEARNING&#x27;, &#x27;DAPP&#x27;],</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //交易签名</span><br><span class="line">    const deployTransaction = await web3.eth.accounts.signTransaction(</span><br><span class="line">        &#123;</span><br><span class="line">            data: deployTx.encodeABI(),</span><br><span class="line">            gas: 6700000</span><br><span class="line">        &#125;,</span><br><span class="line">        account_from.privateKey</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //发送交易并获取交易回执</span><br><span class="line">    const deployReceipt = await web3.eth.sendSignedTransaction(deployTransaction.rawTransaction)</span><br><span class="line">    contractAddr = deployReceipt.contractAddress</span><br><span class="line">    console.log(`Contract deployed at address: $&#123;deployReceipt.contractAddress&#125;`)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //----------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">    const web3Socket = new Web3(</span><br><span class="line">        new Web3.providers.WebsocketProvider(</span><br><span class="line">            &#x27;http://127.0.0.1:7545&#x27;</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    erc20 = new web3Socket.eth.Contract(abi, deployReceipt.contractAddress)</span><br><span class="line"></span><br><span class="line">    erc20.events.Transfer(function (error, event) &#123;</span><br><span class="line">        console.log(&#x27;Mint Success&#x27;)</span><br><span class="line">        console.log(event.returnValues)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    erc20.events.Approval(function (error, event) &#123;</span><br><span class="line">        console.log(&#x27;Approval Success&#x27;)</span><br><span class="line">        console.log(event.returnValues)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //----------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //创建合约实例</span><br><span class="line">    const erc20Contract = new web3.eth.Contract(</span><br><span class="line">        abi,</span><br><span class="line">        deployReceipt.contractAddress</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    //创建交易 mint铸造token</span><br><span class="line">    console.log()</span><br><span class="line">    console.log(&#x27;============================ 1. Mint&#x27;)</span><br><span class="line"></span><br><span class="line">    const mintTx = erc20Contract.methods</span><br><span class="line">        .mint(100000)</span><br><span class="line">        .encodeABI()</span><br><span class="line"></span><br><span class="line">    const mintTransaction = await web3.eth.accounts.signTransaction(</span><br><span class="line">        &#123;</span><br><span class="line">            to: deployReceipt.contractAddress,</span><br><span class="line">            data: mintTx,</span><br><span class="line">            gas: 6700000,</span><br><span class="line">        &#125;,</span><br><span class="line">        account_from.privateKey</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    await web3.eth.sendSignedTransaction(</span><br><span class="line">        mintTransaction.rawTransaction</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    await erc20Contract.methods</span><br><span class="line">        .balanceOf(account.address)</span><br><span class="line">        .call()</span><br><span class="line">        .then((result) =&gt; &#123;</span><br><span class="line">            console.log(`The balance of account is $&#123;result&#125;`)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //授权</span><br><span class="line">    console.log()</span><br><span class="line">    console.log(&#x27;============================ 2. Approval&#x27;)</span><br><span class="line">    const approvalTx = erc20Contract.methods.approve(receiver, 666).encodeABI()</span><br><span class="line"></span><br><span class="line">    const approvalTransaction = await web3.eth.accounts.signTransaction(</span><br><span class="line">        &#123;</span><br><span class="line">            to: contractAddr,</span><br><span class="line">            data: approvalTx,</span><br><span class="line">            gas: 6700000</span><br><span class="line">        &#125;,</span><br><span class="line">        account_from.privateKey</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    await web3.eth.sendSignedTransaction(approvalTransaction.rawTransaction)         //发送交易</span><br><span class="line"></span><br><span class="line">    let allowance = await erc20Contract.methods.allowance(account.address, receiver).call()</span><br><span class="line">    console.log(`allowance[$&#123;account.address&#125;][$&#123;receiver&#125;]:$&#123;allowance&#125;`)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //使用授权转账</span><br><span class="line">    console.log()</span><br><span class="line">    console.log(&#x27;============================ 3. TransferFrom&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    await web3.eth.sendSignedTransaction(transferFromTransaction.rawTransaction)     //发送交易</span><br><span class="line"></span><br><span class="line">    balance = await erc20Contract.methods.balanceOf(account.address).call()</span><br><span class="line">    console.log(`balanceOf[$&#123;account.address&#125;]:$&#123;balance&#125;`)</span><br><span class="line"></span><br><span class="line">    balance = await erc20Contract.methods.balanceOf(receiver2).call()</span><br><span class="line">    console.log(`balanceOf[$&#123;receiver2&#125;]:$&#123;balance&#125;`)</span><br><span class="line"></span><br><span class="line">    balance = await erc20Contract.methods.balanceOf(receiver).call()</span><br><span class="line">    console.log(`balanceOf[$&#123;receiver&#125;]:$&#123;balance&#125;`)</span><br><span class="line"></span><br><span class="line">    allowance = await erc20Contract.methods.allowance(account.address, receiver).call()</span><br><span class="line">    console.log(`allowance[$&#123;account.address&#125;][$&#123;receiver&#125;]:$&#123;allowance&#125;`)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Trans().then(() =&gt; process.exit(0)).catch((error) =&gt; &#123;</span><br><span class="line">    console.error(error)</span><br><span class="line">    process.exit(1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="ERC72"><a href="#ERC72" class="headerlink" title="ERC72"></a>ERC72</h2><p><code>BTC</code>和<code>ETH</code>这类代币都属于同质化代币，矿工挖出的第<code>1</code>枚<code>BTC</code>与第<code>10000</code>枚<code>BTC</code>并没有不同，是等价的。但世界中很多物品是不同质的，其中包括房产、古董、虚拟艺术品等等，这类物品无法用同质化代币抽象。因此，<a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-721">以太坊EIP721</a>提出了<code>ERC721</code>标准，来抽象非同质化的物品。这一讲，我们将介绍<code>ERC721</code>标准，并基于它发行一款<code>NFT</code>。</p>
<h4 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h4><p><code>EIP</code>全称 <code>Ethereum Imporvement Proposals</code>(以太坊改进建议), 是以太坊开发者社区提出的改进建议, 是一系列以编号排定的文件, 类似互联网上IETF的RFC。</p>
<p><code>EIP</code>可以是 <code>Ethereum</code> 生态中任意领域的改进, 比如新特性、ERC、协议改进、编程工具等等。</p>
<p><code>ERC</code>全称 Ethereum Request For Comment (以太坊意见征求稿), 用以记录以太坊上应用级的各种开发标准和协议。如典型的Token标准(<code>ERC20</code>, <code>ERC721</code>)、名字注册(<code>ERC26</code>, <code>ERC13</code>), URI范式(<code>ERC67</code>), Library/Package格式(<code>EIP82</code>), 钱包格式(<code>EIP75</code>,<code>EIP85</code>)。</p>
<p>ERC协议标准是影响以太坊发展的重要因素, 像<code>ERC20</code>, <code>ERC223</code>, <code>ERC721</code>, <code>ERC777</code>等, 都是对以太坊生态产生了很大影响。</p>
<p>所以最终结论：<code>EIP</code>包含<code>ERC</code>。</p>
<h4 id="ERC165"><a href="#ERC165" class="headerlink" title="ERC165"></a>ERC165</h4><p>通过<a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-165">ERC165标准</a>，智能合约可以声明它支持的接口，供其他合约检查。简单的说，ERC165就是检查一个智能合约是不是支持了<code>ERC721</code>，<code>ERC1155</code>的接口。</p>
<p><code>IERC165</code>接口合约只声明了一个<code>supportsInterface</code>函数，输入要查询的<code>interfaceId</code>接口id，若合约实现了该接口id，则返回<code>true</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface IERC165 &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@dev </span>如果合约实现了查询的`interfaceId`，则返回true</span></span><br><span class="line"><span class="comment">     * 规则详见：https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">supportsInterface</span>(<span class="params">bytes4 interfaceId</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看下<code>ERC721</code>是如何实现<code>supportsInterface()</code>函数的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">supportsInterface</span>(<span class="params">bytes4 interfaceId</span>) <span class="title">external</span> <span class="title">pure</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">           interfaceId == type(IERC721).interfaceId ||</span><br><span class="line">           interfaceId == type(IERC165).interfaceId;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>当查询的是<code>IERC721</code>或<code>IERC165</code>的接口id时，返回<code>true</code>；反之返回<code>false</code>。</p>
<h4 id="IERC721"><a href="#IERC721" class="headerlink" title="IERC721"></a>IERC721</h4><p><code>IERC721</code>是<code>ERC721</code>标准的接口合约，规定了<code>ERC721</code>要实现的基本函数。它利用<code>tokenId</code>来表示特定的非同质化代币，授权或转账都要明确<code>tokenId</code>；而<code>ERC20</code>只需要明确转账的数额即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev ERC721标准接口.</span><br><span class="line"> */</span><br><span class="line">interface IERC721 is IERC165 &#123;</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);</span><br><span class="line">    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);</span><br><span class="line">    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);</span><br><span class="line"></span><br><span class="line">    function balanceOf(address owner) external view returns (uint256 balance);</span><br><span class="line"></span><br><span class="line">    function ownerOf(uint256 tokenId) external view returns (address owner);</span><br><span class="line"></span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 tokenId,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 tokenId</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    function transferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 tokenId</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    function approve(address to, uint256 tokenId) external;</span><br><span class="line"></span><br><span class="line">    function setApprovalForAll(address operator, bool _approved) external;</span><br><span class="line"></span><br><span class="line">    function getApproved(uint256 tokenId) external view returns (address operator);</span><br><span class="line"></span><br><span class="line">    function isApprovedForAll(address owner, address operator) external view returns (bool);</span><br></pre></td></tr></table></figure>

<h5 id="IERC721事件"><a href="#IERC721事件" class="headerlink" title="IERC721事件"></a>IERC721事件</h5><p><code>IERC721</code>包含3个事件，其中<code>Transfer</code>和<code>Approval</code>事件在<code>ERC20</code>中也有。</p>
<ul>
<li><code>Transfer</code>事件：在转账时被释放，记录代币的发出地址<code>from</code>，接收地址<code>to</code>和<code>tokenid</code>。</li>
<li><code>Approval</code>事件：在授权时释放，记录授权地址<code>owner</code>，被授权地址<code>approved</code>和<code>tokenid</code>。</li>
<li><code>ApprovalForAll</code>事件：在批量授权时释放，记录批量授权的发出地址<code>owner</code>，被授权地址<code>operator</code>和授权与否的<code>approved</code>。</li>
</ul>
<h5 id="IERC721函数"><a href="#IERC721函数" class="headerlink" title="IERC721函数"></a>IERC721函数</h5><ul>
<li><code>balanceOf</code>：返回某地址的NFT持有量<code>balance</code>。</li>
<li><code>ownerOf</code>：返回某<code>tokenId</code>的主人<code>owner</code>。</li>
<li><code>transferFrom</code>：普通转账，参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li>
<li><code>safeTransferFrom</code>：安全转账（如果接收方是合约地址，会要求实现<code>ERC721Receiver</code>接口）。参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li>
<li><code>approve</code>：授权另一个地址使用你的NFT。参数为被授权地址<code>approve</code>和<code>tokenId</code>。</li>
<li><code>getApproved</code>：查询<code>tokenId</code>被批准给了哪个地址。</li>
<li><code>setApprovalForAll</code>：将自己持有的该系列NFT批量授权给某个地址<code>operator</code>。</li>
<li><code>isApprovedForAll</code>：查询某地址的NFT是否批量授权给了另一个<code>operator</code>地址。</li>
<li><code>safeTransferFrom</code>：安全转账的重载函数，参数里面包含了<code>data</code>。</li>
</ul>
<h4 id="IERC721Receiver"><a href="#IERC721Receiver" class="headerlink" title="IERC721Receiver"></a>IERC721Receiver</h4><p>如果一个合约没有实现<code>ERC721</code>的相关函数，转入的<code>NFT</code>就进了黑洞，永远转不出来了。为了防止误转账，<code>ERC721</code>实现了<code>safeTransferFrom()</code>安全转账函数，目标合约必须实现了<code>IERC721Receiver</code>接口才能接收<code>ERC721</code>代币，不然会<code>revert</code>。<code>IERC721Receiver</code>接口只包含一个<code>onERC721Received()</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ERC721接收者接口：合约必须实现这个接口来通过安全转账接收ERC721</span><br><span class="line">interface IERC721Receiver &#123;</span><br><span class="line">    function onERC721Received(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external returns (bytes4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看下<code>ERC721</code>利用<code>_checkOnERC721Received</code>来确保目标合约实现了<code>onERC721Received()</code>函数（返回<code>onERC721Received</code>的<code>selector</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _checkOnERC721Received(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes memory _data</span><br><span class="line">    ) private returns (bool) &#123;</span><br><span class="line">        if (to.isContract()) &#123;</span><br><span class="line">            return</span><br><span class="line">                IERC721Receiver(to).onERC721Received(</span><br><span class="line">                    msg.sender,</span><br><span class="line">                    from,</span><br><span class="line">                    tokenId,</span><br><span class="line">                    _data</span><br><span class="line">                ) == IERC721Receiver.onERC721Received.selector;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="IERC721Metadata"><a href="#IERC721Metadata" class="headerlink" title="IERC721Metadata"></a>IERC721Metadata</h4><p><code>IERC721Metadata</code>是<code>ERC721</code>的拓展接口，实现了3个查询<code>metadata</code>元数据的常用函数：</p>
<ul>
<li><code>name()</code>：返回代币名称。</li>
<li><code>symbol()</code>：返回代币代号。</li>
<li><code>tokenURI()</code>：通过<code>tokenId</code>查询<code>metadata</code>的链接<code>url</code>，<code>ERC721</code>特有的函数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface IERC721Metadata is IERC721 &#123;</span><br><span class="line">    function name() external view returns (string memory);</span><br><span class="line"></span><br><span class="line">    function symbol() external view returns (string memory);</span><br><span class="line"></span><br><span class="line">    function tokenURI(uint256 tokenId) external view returns (string memory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ERC721主合约"><a href="#ERC721主合约" class="headerlink" title="ERC721主合约"></a>ERC721主合约</h4><p><code>ERC721</code>主合约实现了<code>IERC721</code>，<code>IERC165</code>和<code>IERC721Metadata</code>定义的所有功能，包含<code>4</code>个状态变量和<code>17</code>个函数。实现都比较简单，每个函数的功能见代码注释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// by 0xAA</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">import &quot;./IERC165.sol&quot;;</span><br><span class="line">import &quot;./IERC721.sol&quot;;</span><br><span class="line">import &quot;./IERC721Receiver.sol&quot;;</span><br><span class="line">import &quot;./IERC721Metadata.sol&quot;;</span><br><span class="line">import &quot;./Address.sol&quot;;</span><br><span class="line">import &quot;./String.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ERC721 is IERC721, IERC721Metadata&#123;</span><br><span class="line">    using Address for address; // 使用Address库，用isContract来判断地址是否为合约</span><br><span class="line">    using Strings for uint256; // 使用String库，</span><br><span class="line"></span><br><span class="line">    // Token名称</span><br><span class="line">    string public override name;</span><br><span class="line">    // Token代号</span><br><span class="line">    string public override symbol;</span><br><span class="line">    // tokenId 到 owner address 的持有人映射</span><br><span class="line">    mapping(uint =&gt; address) private _owners;</span><br><span class="line">    // address 到 持仓数量 的持仓量映射</span><br><span class="line">    mapping(address =&gt; uint) private _balances;</span><br><span class="line">    // tokenID 到 授权地址 的授权映射</span><br><span class="line">    mapping(uint =&gt; address) private _tokenApprovals;</span><br><span class="line">    //  owner地址。到operator地址 的批量授权映射</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造函数，初始化`name` 和`symbol` .</span><br><span class="line">     */</span><br><span class="line">    constructor(string memory name_, string memory symbol_) &#123;</span><br><span class="line">        name = name_;</span><br><span class="line">        symbol = symbol_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC165接口supportsInterface</span><br><span class="line">    function supportsInterface(bytes4 interfaceId)</span><br><span class="line">        external</span><br><span class="line">        pure</span><br><span class="line">        override</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        return</span><br><span class="line">            interfaceId == type(IERC721).interfaceId ||</span><br><span class="line">            interfaceId == type(IERC165).interfaceId ||</span><br><span class="line">            interfaceId == type(IERC721Metadata).interfaceId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的balanceOf，利用_balances变量查询owner地址的balance。</span><br><span class="line">    function balanceOf(address owner) external view override returns (uint) &#123;</span><br><span class="line">        require(owner != address(0), &quot;owner = zero address&quot;);</span><br><span class="line">        return _balances[owner];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的ownerOf，利用_owners变量查询tokenId的owner。</span><br><span class="line">    function ownerOf(uint tokenId) public view override returns (address owner) &#123;</span><br><span class="line">        owner = _owners[tokenId];</span><br><span class="line">        require(owner != address(0), &quot;token doesn&#x27;t exist&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的isApprovedForAll，利用_operatorApprovals变量查询owner地址是否将所持NFT批量授权给了operator地址。</span><br><span class="line">    function isApprovedForAll(address owner, address operator)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        override</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        return _operatorApprovals[owner][operator];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的setApprovalForAll，将持有代币全部授权给operator地址。调用_setApprovalForAll函数。</span><br><span class="line">    function setApprovalForAll(address operator, bool approved) external override &#123;</span><br><span class="line">        _operatorApprovals[msg.sender][operator] = approved;</span><br><span class="line">        emit ApprovalForAll(msg.sender, operator, approved);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的getApproved，利用_tokenApprovals变量查询tokenId的授权地址。</span><br><span class="line">    function getApproved(uint tokenId) external view override returns (address) &#123;</span><br><span class="line">        require(_owners[tokenId] != address(0), &quot;token doesn&#x27;t exist&quot;);</span><br><span class="line">        return _tokenApprovals[tokenId];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    // 授权函数。通过调整_tokenApprovals来，授权 to 地址操作 tokenId，同时释放Approval事件。</span><br><span class="line">    function _approve(</span><br><span class="line">        address owner,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) private &#123;</span><br><span class="line">        _tokenApprovals[tokenId] = to;</span><br><span class="line">        emit Approval(owner, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的approve，将tokenId授权给 to 地址。条件：to不是owner，且msg.sender是owner或授权地址。调用_approve函数。</span><br><span class="line">    function approve(address to, uint tokenId) external override &#123;</span><br><span class="line">        address owner = _owners[tokenId];</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == owner || _operatorApprovals[owner][msg.sender],</span><br><span class="line">            &quot;not owner nor approved for all&quot;</span><br><span class="line">        );</span><br><span class="line">        _approve(owner, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查询 spender地址是否可以使用tokenId（他是owner或被授权地址）。</span><br><span class="line">    function _isApprovedOrOwner(</span><br><span class="line">        address owner,</span><br><span class="line">        address spender,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) private view returns (bool) &#123;</span><br><span class="line">        return (spender == owner ||</span><br><span class="line">            _tokenApprovals[tokenId] == spender ||</span><br><span class="line">            _operatorApprovals[owner][spender]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 转账函数。通过调整_balances和_owner变量将 tokenId 从 from 转账给 to，同时释放Transfer事件。</span><br><span class="line">     * 条件:</span><br><span class="line">     * 1. tokenId 被 from 拥有</span><br><span class="line">     * 2. to 不是0地址</span><br><span class="line">     */</span><br><span class="line">    function _transfer(</span><br><span class="line">        address owner,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) private &#123;</span><br><span class="line">        require(from == owner, &quot;not owner&quot;);</span><br><span class="line">        require(to != address(0), &quot;transfer to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">        _approve(owner, address(0), tokenId);</span><br><span class="line"></span><br><span class="line">        _balances[from] -= 1;</span><br><span class="line">        _balances[to] += 1;</span><br><span class="line">        _owners[tokenId] = to;</span><br><span class="line"></span><br><span class="line">        emit Transfer(from, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 实现IERC721的transferFrom，非安全转账，不建议使用。调用_transfer函数</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) external override &#123;</span><br><span class="line">        address owner = ownerOf(tokenId);</span><br><span class="line">        require(</span><br><span class="line">            _isApprovedOrOwner(owner, msg.sender, tokenId),</span><br><span class="line">            &quot;not owner nor approved&quot;</span><br><span class="line">        );</span><br><span class="line">        _transfer(owner, from, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 安全转账，安全地将 tokenId 代币从 from 转移到 to，会检查合约接收者是否了解 ERC721 协议，以防止代币被永久锁定。调用了_transfer函数和_checkOnERC721Received函数。条件：</span><br><span class="line">     * from 不能是0地址.</span><br><span class="line">     * to 不能是0地址.</span><br><span class="line">     * tokenId 代币必须存在，并且被 from拥有.</span><br><span class="line">     * 如果 to 是智能合约, 他必须支持 IERC721Receiver-onERC721Received.</span><br><span class="line">     */</span><br><span class="line">    function _safeTransfer(</span><br><span class="line">        address owner,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes memory _data</span><br><span class="line">    ) private &#123;</span><br><span class="line">        _transfer(owner, from, to, tokenId);</span><br><span class="line">        require(_checkOnERC721Received(from, to, tokenId, _data), &quot;not ERC721Receiver&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实现IERC721的safeTransferFrom，安全转账，调用了_safeTransfer函数。</span><br><span class="line">     */</span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes memory _data</span><br><span class="line">    ) public override &#123;</span><br><span class="line">        address owner = ownerOf(tokenId);</span><br><span class="line">        require(</span><br><span class="line">            _isApprovedOrOwner(owner, msg.sender, tokenId),</span><br><span class="line">            &quot;not owner nor approved&quot;</span><br><span class="line">        );</span><br><span class="line">        _safeTransfer(owner, from, to, tokenId, _data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // safeTransferFrom重载函数</span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) external override &#123;</span><br><span class="line">        safeTransferFrom(from, to, tokenId, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     * 铸造函数。通过调整_balances和_owners变量来铸造tokenId并转账给 to，同时释放Transfer事件。铸造函数。通过调整_balances和_owners变量来铸造tokenId并转账给 to，同时释放Transfer事件。</span><br><span class="line">     * 这个mint函数所有人都能调用，实际使用需要开发人员重写，加上一些条件。</span><br><span class="line">     * 条件:</span><br><span class="line">     * 1. tokenId尚不存在。</span><br><span class="line">     * 2. to不是0地址.</span><br><span class="line">     */</span><br><span class="line">    function _mint(address to, uint tokenId) internal virtual &#123;</span><br><span class="line">        require(to != address(0), &quot;mint to zero address&quot;);</span><br><span class="line">        require(_owners[tokenId] == address(0), &quot;token already minted&quot;);</span><br><span class="line"></span><br><span class="line">        _balances[to] += 1;</span><br><span class="line">        _owners[tokenId] = to;</span><br><span class="line"></span><br><span class="line">        emit Transfer(address(0), to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 销毁函数，通过调整_balances和_owners变量来销毁tokenId，同时释放Transfer事件。条件：tokenId存在。</span><br><span class="line">    function _burn(uint tokenId) internal virtual &#123;</span><br><span class="line">        address owner = ownerOf(tokenId);</span><br><span class="line">        require(msg.sender == owner, &quot;not owner of token&quot;);</span><br><span class="line"></span><br><span class="line">        _approve(owner, address(0), tokenId);</span><br><span class="line"></span><br><span class="line">        _balances[owner] -= 1;</span><br><span class="line">        delete _owners[tokenId];</span><br><span class="line"></span><br><span class="line">        emit Transfer(owner, address(0), tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // _checkOnERC721Received：函数，用于在 to 为合约的时候调用IERC721Receiver-onERC721Received, 以防 tokenId 被不小心转入黑洞。</span><br><span class="line">    function _checkOnERC721Received(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes memory _data</span><br><span class="line">    ) private returns (bool) &#123;</span><br><span class="line">        if (to.isContract()) &#123;</span><br><span class="line">            return</span><br><span class="line">                IERC721Receiver(to).onERC721Received(</span><br><span class="line">                    msg.sender,</span><br><span class="line">                    from,</span><br><span class="line">                    tokenId,</span><br><span class="line">                    _data</span><br><span class="line">                ) == IERC721Receiver.onERC721Received.selector;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实现IERC721Metadata的tokenURI函数，查询metadata。</span><br><span class="line">     */</span><br><span class="line">    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) &#123;</span><br><span class="line">        require(_owners[tokenId] != address(0), &quot;Token Not Exist&quot;);</span><br><span class="line"></span><br><span class="line">        string memory baseURI = _baseURI();</span><br><span class="line">        return bytes(baseURI).length &gt; 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计算&#123;tokenURI&#125;的BaseURI，tokenURI就是把baseURI和tokenId拼接在一起，需要开发重写。</span><br><span class="line">     * BAYC的baseURI为ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/ </span><br><span class="line">     */</span><br><span class="line">    function _baseURI() internal view virtual returns (string memory) &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h2 id="荷兰拍卖"><a href="#荷兰拍卖" class="headerlink" title="荷兰拍卖"></a>荷兰拍卖</h2><p>荷兰拍卖（<code>Dutch Auction</code>）是一种特殊的拍卖形式。 亦称“减价拍卖”，它是指拍卖标的的竞价由高到低依次递减直到第一个竞买人应价（达到或超过底价）时击槌成交的一种拍卖。</p>
<p>卖家有100朵鲜花，必须在一天内卖完，否则花就谢了。首先，卖家设定最高价为每朵100元，每两个小时降价10元。拍卖开始后没有人竞价。过了两个小时，降到每朵90元时，有个竞买人竞价。如果他买100朵，则拍卖到此结束，此竞买人成为买受人，100朵鲜花以每朵90元成交。如果他只买70朵，那么剩下的30朵继续拍卖。如果一天过去了，不再有人竞价，那么拍卖的结果是唯一的竞买人成为买受人，以每朵90元的成交价买走70朵花。但是，如果过了两小时又有人来竞买剩下的30朵花，而价格为每朵80元。这时结束拍卖，第一个人以每朵90元的价格买了70朵，第二个人以每朵80元的价格买了30朵。</p>
<p>在币圈，很多<code>NFT</code>通过荷兰拍卖发售，其中包括<code>Azuki</code>和<code>World of Women</code>，其中<code>Azuki</code>通过荷兰拍卖筹集了超过<code>8000</code>枚<code>ETH</code>。</p>
<p>项目方非常喜欢这种拍卖形式，主要有两个原因</p>
<ol>
<li>荷兰拍卖的价格由最高慢慢下降，能让项目方获得最大的收入。</li>
<li>拍卖持续较长时间（通常6小时以上），可以避免<code>gas war</code>。</li>
</ol>
<p><strong>荷兰拍卖合约</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Banana69</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://banana69.site/2022/11/10/solidity%E5%BA%94%E7%94%A8/">https://banana69.site/2022/11/10/solidity%E5%BA%94%E7%94%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Banana69.site" target="_blank">Banana69</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></div><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Banana69</div><div class="author-info__description">菜鸡的博客</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Banannna69"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Banannna69" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:junminn@126.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ERC20"><span class="toc-text">ERC20</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IERC20"><span class="toc-text">IERC20</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-text">事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0ERC20"><span class="toc-text">实现ERC20</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-web3js-%E8%B0%83%E7%94%A8ERC20"><span class="toc-text">使用 web3js 调用ERC20</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ERC72"><span class="toc-text">ERC72</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EIP"><span class="toc-text">EIP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ERC165"><span class="toc-text">ERC165</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IERC721"><span class="toc-text">IERC721</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IERC721%E4%BA%8B%E4%BB%B6"><span class="toc-text">IERC721事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IERC721%E5%87%BD%E6%95%B0"><span class="toc-text">IERC721函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IERC721Receiver"><span class="toc-text">IERC721Receiver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IERC721Metadata"><span class="toc-text">IERC721Metadata</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ERC721%E4%B8%BB%E5%90%88%E7%BA%A6"><span class="toc-text">ERC721主合约</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8D%B7%E5%85%B0%E6%8B%8D%E5%8D%96"><span class="toc-text">荷兰拍卖</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/04/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/" title="Java 登录认证">Java 登录认证</a><time datetime="2023-02-04T09:36:53.000Z" title="发表于 2023-02-04 17:36:53">2023-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/17/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93/" title="抢先交易 Front-running">抢先交易 Front-running</a><time datetime="2023-01-17T14:12:01.000Z" title="发表于 2023-01-17 22:12:01">2023-01-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/11/10/solidity%E5%BA%94%E7%94%A8/" title="solidity应用学习笔记">solidity应用学习笔记</a><time datetime="2022-11-10T11:31:09.000Z" title="发表于 2022-11-10 19:31:09">2022-11-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/22/solidity%E8%BF%9B%E9%98%B6/" title="Solididy进阶">Solididy进阶</a><time datetime="2022-10-22T01:24:02.000Z" title="发表于 2022-10-22 09:24:02">2022-10-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/08/23/solidity%E7%BC%96%E5%86%99%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/" title="solidity编写内联汇编">solidity编写内联汇编</a><time datetime="2022-08-23T08:51:44.000Z" title="发表于 2022-08-23 16:51:44">2022-08-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Banana69</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>