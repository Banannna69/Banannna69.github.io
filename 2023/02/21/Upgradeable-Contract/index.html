<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Upgradeable Contract 可升级合约 | Banana69</title><meta name="author" content="Banana69"><meta name="copyright" content="Banana69"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="0x01 前言区块链的不可更改性与传统的软件开发过程有根本性的冲突，在传统的软件开发过程中，代码被不断地更新以修复错误和增加新的功能。在智能合约可以通过一些技术在不改变代码的条件下增加新的功能。主要是通过deldegatecall和回退函数fallback实现。 0x02 代码和存储 我们将智能合约在执行过程中的EVM状态分为持久性和易失性状态。持久性状态在不同的交易中都会被记住，而易失性状态在交">
<meta property="og:type" content="article">
<meta property="og:title" content="Upgradeable Contract 可升级合约">
<meta property="og:url" content="https://banana69.site/2023/02/21/Upgradeable-Contract/index.html">
<meta property="og:site_name" content="Banana69">
<meta property="og:description" content="0x01 前言区块链的不可更改性与传统的软件开发过程有根本性的冲突，在传统的软件开发过程中，代码被不断地更新以修复错误和增加新的功能。在智能合约可以通过一些技术在不改变代码的条件下增加新的功能。主要是通过deldegatecall和回退函数fallback实现。 0x02 代码和存储 我们将智能合约在执行过程中的EVM状态分为持久性和易失性状态。持久性状态在不同的交易中都会被记住，而易失性状态在交">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2023-02-21T11:09:45.000Z">
<meta property="article:modified_time" content="2023-02-27T07:54:53.811Z">
<meta property="article:author" content="Banana69">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://banana69.site/2023/02/21/Upgradeable-Contract/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Upgradeable Contract 可升级合约',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-27 15:54:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Banana69" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Banana69</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Upgradeable Contract 可升级合约</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-02-21T11:09:45.000Z" title="发表于 2023-02-21 19:09:45">2023-02-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Upgradeable Contract 可升级合约"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>区块链的不可更改性与传统的软件开发过程有根本性的冲突，在传统的软件开发过程中，代码被不断地更新以修复错误和增加新的功能。在智能合约可以通过一些技术在不改变代码的条件下增加新的功能。主要是通过<code>deldegatecall</code>和回退函数<code>fallback</code>实现。</p>
<h3 id="0x02-代码和存储"><a href="#0x02-代码和存储" class="headerlink" title="0x02 代码和存储"></a>0x02 代码和存储</h3><p><img src="/image/Upgradeable-Contract.assets/20230106095207.png" alt="Foundry test on command"></p>
<p>我们将智能合约在执行过程中的EVM状态分为持久性和易失性状态。持久性状态在不同的交易中都会被记住，而易失性状态在交易执行后会立即被遗忘。EVM代码和存储都是持久性的，而堆栈、内存、程序计数器和剩余gas的值都是易失性的。在这里，我们将关注点放在代码和存储部分，他们对理解可升级合约来说很重要。</p>
<p>虽然代码和存储都是持久的，但两者之间有一个根本的区别。存储是可变的，可以被修改，而代码一旦部署就不可改变。为此，代码与存储在内存的只读部分分开保存。这种分离使得<code>delegatecall</code>指令成为可能，它使用一个合约的代码和另一个合约的存储</p>
<p>区分存储和内存是很重要的。存储器是持久的，它将32个字节的地址映射到32个字节的值，这些值被称为slot。另一方面，内存是不稳定的，它将32字节的地址映射为1字节1字节的值。换句话说，存储是按字处理（一个字是32字节），而内存是按字节处理的。</p>
<p>在 Solidity 中，任何在合约层声明的变量都被映射到一个或多个slot。例如，考虑下面的合约：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Token &#123;</span><br><span class="line">  address immutable owner; //immutable 表示不可变，不占用 slot</span><br><span class="line">  uint256 public totalSupply;</span><br><span class="line">  mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function mint(address user, uint256 amount) external &#123;</span><br><span class="line">    require(msg.sender == owner, &quot;Only owner is allowed to mint&quot;);</span><br><span class="line">    balanceOf[user] += amount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个变量被映射到slot 0，第二个被映射到slot 1 [注1]，下图为这个合约的存储结构：</p>
<blockquote>
<p>注1：若占用少于32字节的变量可以存储在同一个slot中。例如，一个slot可以包含两个类型为<code>uint128</code>的变量。</p>
</blockquote>
<img src="/image/Upgradeable-Contract.assets/40.png" alt="Foundry方案" style="zoom:73%;" />

<p>像 <code>address </code>和 <code>uint256 </code>这样的简单类型的值最多需要32个字节，因此可以放入一个存储槽，但对于形如 <code>mapping(address =&gt; uint) a;</code> 的映射类型变量，就无法简单仿照值类型按顺序储存了。对于映射，其会根据上节提到的规则占据位置 <code>p</code> 处的一个插槽，但该插槽不会被真正使用。映射中的键 <code>k</code> 所对应的值会位于 <code>keccak256(k . p)</code>， 其中 <code>.</code> 是连接符。如果该值同时是一个非基本类型，则将 <code>keccak256(k . p)</code> 作为偏移量来找到具体的位置。</p>
<p>如果我们想访问<code>balanceOf[addr]</code>，相应的槽被计算出来，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keccak(</span><br><span class="line">  leftPadTo32Bytes(addr) ++ leftPadTo32Bytes(1)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们把key（这里是：<code>addr</code>）和映射的槽号（这里是：1），把它们都零扩展到32字节，把它们连接起来（用++表示），最后计算结果的keccak哈希值。下面的 Foundry 测试展示了如何用 Solidity 来表达:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract StorageTest is Test &#123;</span><br><span class="line">    address Alice = makeAddr(&quot;Alice&quot;);</span><br><span class="line"></span><br><span class="line">    function testLoadBalance() public &#123;</span><br><span class="line">        Token t = new Token(&quot;Hi&quot;);</span><br><span class="line">        t.mint(Alice, 5 ether);</span><br><span class="line"></span><br><span class="line">        // Compute the slot at which Alice&#x27;s balance is stored in the Token contract</span><br><span class="line">        bytes32 aliceBalanceSlot = keccak256(</span><br><span class="line">            abi.encodePacked(uint256(uint160(Alice)), uint256(1))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // Now load Alice&#x27;s balance</span><br><span class="line">        uint256 aliceBalance = uint256(vm.load(address(t), aliceBalanceSlot));</span><br><span class="line"></span><br><span class="line">        // Make sure that the loaded balance matches Alice&#x27;s real balance</span><br><span class="line">        assertEq(aliceBalance, t.balanceOf(Alice));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/image/Upgradeable-Contract.assets/image-20230221194303023.png" alt="image-20230221194303023"></p>
<p>在这个例子中，我们想检索<code>t.balanceOf(Alice)</code>的值，但我们没有直接这样做，而是手动计算Alice的余额所在的槽。为此，<code>aliceBalanceSlot</code>是按照上面的描述计算的。然后我们使用 Foundry 提供的 <a target="_blank" rel="noopener" href="https://book.getfoundry.sh/cheatcodes/load">vm.load()</a> 来加载合约 <code>Token</code>中存储在slot上的值。最后，我们使用 <code>assertEq()</code> 来确保我们实际上已经加载了正确的值</p>
<p>对于像Token这样的简单合约，我们可以很容易地手动计算出合约变量的slot。然而对于使用继承的更复杂的合约，或者有多个变量被存储在同一个slot中的合约，要计算合约变量的位置就变的很困难。Foundry 提供了一个命令来可视化合约的存储布局。例如，要显示 Token 合约的存储布局，你可以使用以下命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forge inspect Token storage-layout</span><br></pre></td></tr></table></figure>

<p><img src="/image/Upgradeable-Contract.assets/image-20230221194830454.png" alt="image-20230221194830454"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/naddison36/sol2uml">sol2uml</a> 可以用于分析已经部署的合约。</p>
<h3 id="0x03-delegatecall-委托调用"><a href="#0x03-delegatecall-委托调用" class="headerlink" title="0x03 delegatecall 委托调用"></a>0x03 delegatecall 委托调用</h3><p>这主要是由于<code>delegatecall</code>指令[注2]，它使用一个合约的代码，并使用另一个合约的存储来执行它，因此可以通过该指令升级智能合约并改变其行为。这可以通过一个简单的例子来说明。</p>
<blockquote>
<p>注2: 如果我们一般性地谈论改变合约的行为，那么这已经可以用<code>selfdestruct</code>来实现了，因为它<em>删除了所有</em>代码。虽然这是一种非常有限的（而且不是非常有用的）改变合约行为的形式，但当与<a target="_blank" rel="noopener" href="https://medium.com/consensys-diligence/smart-contract-security-newsletter-16-create2-faq-b641405044bf">create2</a>结合时，就有了更多的可能性。然而，<code>delegatecall</code>仍然是实现可升级合约的主要方式。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Counter &#123;</span><br><span class="line">  uint256 number;</span><br><span class="line"></span><br><span class="line">  function get() external view returns(uint256) &#123;</span><br><span class="line">    return number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function add(uint256 n) external &#123;</span><br><span class="line">    require(n &lt;= 5, &quot;Max increment is 5&quot;);</span><br><span class="line">    number += n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DelegateCounter &#123;</span><br><span class="line">  uint256 number;</span><br><span class="line"></span><br><span class="line">  function get() external view returns(uint256) &#123;</span><br><span class="line">    return number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function delegateAdd(Counter c, uint256 n) external &#123;</span><br><span class="line">    bytes memory callData = abi.encodeWithSignature(&quot;add(uint256)&quot;, n);</span><br><span class="line">    (bool ok,) = address(c).delegatecall(callData);</span><br><span class="line"></span><br><span class="line">    if(!ok) revert(&quot;Delegate call failed&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Counter合约代表了一个每次最多只能增加5的计数器，其定义了<code>add()</code>函数来执行这个操作，还定义了<code>get()</code>函数来获取当前计数器的值，除了函数<code>delegateAdd()</code>外，<code>DelegateCounter</code>合约与<code>Counter</code>基本相同。为了解释<code>delegateAdd()</code>是如何工作的，下面给出这两个合约的结构：</p>
<img src="/image/Upgradeable-Contract.assets/20230106095227.png" alt="Foundry test on command" style="zoom:33%;" />

<p><code>delegateAdd()</code>使用<code>delegatecall</code>来执行来自合约<code>Counter</code>的函数<code>add()</code>，使用<code>DelegateCounter</code>的上下文来存储。两个合约应该有兼容的存储布局，也就是说，它们应该将相同的变量分配到相同的slot中。</p>
<p><code>delegatecall</code>是Solidity中的一个低级原语，使用起来不如普通函数调用方便。一般来说，每当我们想在一个合约上调用一个函数时，我们需要同时指定我们想调用的函数和我们想传递的论据。这些信息需要以一种众所周知的格式进行编码，以便目标合约知道如何解释它。这种格式也被称为应用二进制接口（ABI），并在 <code>合约ABI规范 </code>中描述。对于正常的函数调用，Solidity为我们做了这个编码，但是当使用<code>delegatecall</code>时，需要自己获取编码。这是在<code>delegateAdd()</code>的第一行完成的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes memory callData = abi.encodeWithSignature(&quot;add(uint256)&quot;, n);</span><br></pre></td></tr></table></figure>

<p><code>encodeWithSignature()</code>的第一个参数表示我们要调用的函数的签名，其余参数表示我们要传递给该函数的值。在上面的例子中，我们对一个名为add的函数的调用进行了编码，该函数需要一个<code>uint256</code>类型的参数，其值应该是<code>n</code>。如果我们假设<code>n</code>是，例如，4，那么<code>callData</code>将看起来如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x1003e2d20000000000000000000000000000000000000000000000000000000000000004</span><br></pre></td></tr></table></figure>

<p>前四个字节代表 “函数选择器”，它是通过获取函数签名的 keccak 哈希值中最重要的前四个字节计算出来的。这个函数签名是 “add(uint256)”，我们可以使用 Foundry 自带的 cast 命令行工具来计算其 keccak 哈希值。</p>
<p><img src="/image/Upgradeable-Contract.assets/image-20230222114710713.png" alt="image-20230222114710713"></p>
<p>然后把它传递给<code>deldegatacall</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(bool ok,) = address(c).delegatecall(callData);</span><br></pre></td></tr></table></figure>

<p>这一行在当前合约的上下文中执行函数<code>Counter.add()</code>。任何由<code>Counter.add()</code>执行的存储访问都将使用调用合约的存储，在此案例中，它是<code>DelegateCounter</code>类型。因此，当<code>Counter.add()</code>函数写到slot 0以更新存储变量<code>number</code>时，它更新的是<code>DelegateCounter</code>的存储，而不是<code>Counter</code>的存储。</p>
<p><code>delegatecall</code>返回两个值。一个表示调用是否成功的布尔值，和一个包含任何返回数据的字节数组。由于<code>Counter.add()</code>不返回任何东西，<code>delegateAdd()</code>忽略返回数据，只检查调用是否成功。这里用一个固定的消息来作为revert 消息，而不是返回原始错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(!ok) revert(&quot;Delegate call failed&quot;);</span><br></pre></td></tr></table></figure>

<p>在forge中进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract DelegateCallTest is Test &#123;</span><br><span class="line">    function testDelegate() public &#123;</span><br><span class="line">        Counter c = new Counter();</span><br><span class="line">        DelegateCounter d = new DelegateCounter();</span><br><span class="line"></span><br><span class="line">        // Sanity check: both counters should start at zero</span><br><span class="line">        assertEq(c.get(), 0);</span><br><span class="line">        assertEq(d.get(), 0);</span><br><span class="line"></span><br><span class="line">        d.delegateAdd(c, 4);</span><br><span class="line"></span><br><span class="line">        // Check that `d` has been updated</span><br><span class="line">        assertEq(c.get(), 0);</span><br><span class="line">        assertEq(d.get(), 4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/image/Upgradeable-Contract.assets/image-20230222115303905.png" alt="image-20230222115303905"></p>
<p>首先创建了 <code>Counter </code>和 <code>DelegateCounter </code>合约的新实例，他们的计数器的初始值都为 0，调用<code>d.delegateAdd(c, 4)</code>。如上所述，<code>delegateAdd()</code>本质上是调用<code>c.add(4)</code>，其方式是所有存储访问都指向<code>d</code>而不是<code>c</code>。下面两个断言验证了这一点，它们检查了<code>c</code>仍然为零，而<code>d</code>已经被更新。</p>
<p>我们可以将任何合约传递给<code>delegateAdd()</code>，它实现了一个签名为<code>add(uint256)</code>的函数。因此，即使 <code>DelegateCounter </code>保持不变，我们也可以通过向 <code>delegateAdd() </code>传递一些其他合约来改变其行为。然而，为了完全实现可升级的合约，我们还需要关注会退函数。在这之前，如何处理<code>delegatecall</code>的第二个返回值，即包含从被调用函数返回的数据的字节数组也是很有用的。</p>
<h3 id="0x04-处理-delegatecall-返回值"><a href="#0x04-处理-delegatecall-返回值" class="headerlink" title="0x04 处理 delegatecall 返回值"></a>0x04 处理 delegatecall 返回值</h3><p>使用<code>delegatecall</code>比正常的函数调用复杂，因为我们必须根据ABI对调用进行手动编码。从调用中返回的数据也是如此。我们只是得到一个原始的字节数组，我们需要根据被调用的函数的返回类型自己解码。为了说明如何做到这一点，我们现在为<code>DelegateCounter</code>实现一个<code>delegateGet()</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract DelegateCounter &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  function delegateGet(Counter c) external returns(uint256) &#123;</span><br><span class="line">    bytes memory callData = abi.encodeWithSignature(&quot;get()&quot;);</span><br><span class="line">    (bool ok, bytes memory retVal) = address(c).delegatecall(callData);</span><br><span class="line"></span><br><span class="line">    if(!ok) revert(&quot;Delegate call failed&quot;);</span><br><span class="line"></span><br><span class="line">    return abi.decode(retVal, (uint256));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现与<code>delegateAdd()</code>非常相似。我们首先对我们想要执行的调用进行ABI编码，然后使用<code>delegatecall</code>来进行调用。然而，这一次我们也处理了由调用返回的数据，我们将其存储在<code>retVal</code>中。因为<code>get()</code>返回一个<strong>uint256</strong>，ABI规定像<strong>uint256</strong>这样的固定宽度类型的值是通过简单的取其<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Endianness">big-endian</a>表示并将结果填充到32字节来编码的，返回的数据可以通过简单的将retVal 类型转换为<strong>uint256</strong>来解码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return uint256(bytes32(retVal));</span><br></pre></td></tr></table></figure>

<p>对于复杂的类型，解码变得更加复杂。Solidity提供了函数<code>abi.decode()</code>，可以为我们执行解码。使用这个函数，我们可以将返回语句重写如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return abi.decode(retVal, (uint256));</span><br></pre></td></tr></table></figure>

<p>函数<code>abi.decode()</code>需要两个参数。一个包含一些ABI编码值的字节数组，以及一个包含编码值类型的元组。</p>
<h3 id="0x05-泛化"><a href="#0x05-泛化" class="headerlink" title="0x05 泛化"></a>0x05 泛化</h3><p>我们可以对<code>delegateGet()</code>做最后的修改，以便对处理返回数据的方式进行概括。注意，当我们用<code>abi.decode(retVal, (uint256))</code>对返回数据进行解码时，我们对返回类型进行了硬编码。如果我们想在任意函数中使用<code>delegatecall</code>，那么我们也需要能够处理任意的返回数据。这在纯 Solidity 中是不可能的，所以我们需要转向汇编。特别是，我们需要替换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return abi.decode(retVal, (uint256));</span><br></pre></td></tr></table></figure>

<p>将其替换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123;</span><br><span class="line">  let data := add(retVal, 32)</span><br><span class="line">  let size := mload(retVal)</span><br><span class="line">  return(data, size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/Upgradeable-Contract.assets/20230106095235.png" alt="协议方案" style="zoom:35%;" />

<p><code>return(data,size)</code>指令结束当前函数的执行，并返回由<code>data</code>和<code>size</code>给出的内存范围内的数据，其中data表示起始地址，<code>size</code>表示数据的字节大小（详见<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/en/latest/yul.html#specification-of-yul">Yul规范</a>）。在上面的例子中，<code>data</code>和<code>size</code>的计算方式可能不是很明显。要理解这一点，重要的是要知道数组是如何在内存中布局的。首先，请注意，当我们从汇编块中引用像<code>retVal</code>这样的内存变量时，我们实际上是指它的地址。因此，当我们在上面的汇编块中使用<code>retVal</code>时，我们指的是<code>retVal</code>所表示的字节数组在内存中的起始地址。其次，Solidity在内存中排列数组的方式如下 [注4]。首先是数组的长度, 存储为一个32字节的无符号数字, 然后是所有的数组元素. 因此，<code>retVal</code>的数组长度直接存储在<code>retVal</code>的地址（我们通过<code>mload</code>加载），为了得到数组元素的地址，我们需要给<code>retVal</code>增加一个32字节的偏移量。</p>
<blockquote>
<p>注4: 这与数组在存储中的布局不同，<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html">存储中状态变量的布局</a>和<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/en/latest/internals/layout_in_memory.html">内存中的布局</a>。</p>
</blockquote>
<p>有了上述汇编，我们可以简单地转发任何来自<code>delegatecall</code>的返回数据，而不需要知道编码后的值的类型。这使得我们可以调用任意的函数而不需要事先知道它们的返回类型。</p>
<p>最后的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function delegateGetBetter(Counter c) external returns(uint256) &#123;</span><br><span class="line">        bytes memory callData = abi.encodeWithSignature(&quot;get()&quot;);</span><br><span class="line">        (bool ok, bytes memory retVal) = address(c).delegatecall(callData);</span><br><span class="line"></span><br><span class="line">        if(!ok) revert(&quot;Delegate call failed&quot;);</span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            let data := add(retVal, 32)</span><br><span class="line">            let size := mload(retVal)</span><br><span class="line"></span><br><span class="line">            // The `return` instruction expects two arguments that describe the region in memory</span><br><span class="line">            // that contains the return data:</span><br><span class="line">            // - The address in memory that stores the beginning of the return data.</span><br><span class="line">            // - The size of the return data in bytes.</span><br><span class="line">            //</span><br><span class="line">            // `retVal` refers to a byte array in memory. The first slot (32 bytes) contains the</span><br><span class="line">            // number of elements, and the following slots contain the elements themselves.</span><br><span class="line">            return(data, size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="0x06-回退函数"><a href="#0x06-回退函数" class="headerlink" title="0x06 回退函数"></a>0x06 回退函数</h3><p><a target="_blank" rel="noopener" href="https://docs.soliditylang.org/en/latest/contracts.html#fallback-function">回退函数</a>是实现可升级合约时另一个有用的功能。它们允许开发者指定当一个不存在的函数被调用时应该发生什么。默认的行为是回退，但这可以被改变。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ifc &#123;</span><br><span class="line">  function hello() external;</span><br><span class="line">  function bye() external;</span><br><span class="line">&#125;</span><br><span class="line">contract C &#123;</span><br><span class="line">  event Log(string msg);</span><br><span class="line"></span><br><span class="line">  function hello() external &#123;</span><br><span class="line">    emit Log(&quot;hello&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    emit Log(&quot;fallback&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面我们定义了一个带有函数<code>hello()</code>和<code>bye()</code>的简单接口。此外，我们定义了一个合约<code>C</code>，它包含一个函数<code>hello()</code>和一个<em>fallback</em>函数。现在考虑下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ifc ifc = Ifc(address(new C()));</span><br><span class="line">ifc.hello(); // Emits Log(&quot;hello&quot;)</span><br><span class="line">ifc.bye();   // Emits Log(&quot;fallback&quot;)</span><br></pre></td></tr></table></figure>

<p>我们创建了一个新的合约<code>C</code>的实例，并将其转换为 <code>Ifc</code> 类型，这使得我们可以同时调用<code>hello()</code>和<code>bye()</code>。当我们调用<code>Bye()</code>时，由于<code>C</code>没有定义，所以会执行回退函数。</p>
<p>一个有用的事实是，我们可以使用<code>msg.data</code>来访问触发回退函数的原始调用数据。例如，如果在<code>C</code>的回退函数中加入<code>console.logBytes(msg.data)</code>，那么在调用<code>ifc.bye()</code>时就会产生如下日志信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xe71b8b93</span><br></pre></td></tr></table></figure>

<p>这是<code>bye()</code>的函数选择器，这意味着通过检查<code>msg.data</code>我们可以确定用户最初打算调用哪个函数。</p>
<h3 id="0x07-创建可升级合约"><a href="#0x07-创建可升级合约" class="headerlink" title="0x07 创建可升级合约"></a>0x07 创建可升级合约</h3><p>使用<code>delegatecall</code>和回退函数，我们可以实现一个基于<strong>代理</strong>的可升级合约的一般解决方案。其核心思想如下。对于每一个我们希望其代码可以升级的合约，我们实际上部署了<em>两个</em>合约。一个<em>代理合约</em>和一个<em>逻辑合约</em>。代理合约是存储所有数据的合约，而逻辑合约则包含对这些数据进行操作的功能。用户将只与代理合约进行交互。当用户在代理上调用一个函数时，代理会使用一个委托调用将调用转发给逻辑合约。因为代理使用委托调用，执行逻辑合约的函数会影响代理的存储。因此，当使用可升级合约时，代理持有状态，而逻辑合约持有代码。从用户的角度来看，代理的行为与逻辑合约的行为是一样的。升级合约只是意味着代理使用了一个新的逻辑合约。</p>
<h4 id="7-1-实现代理合约I"><a href="#7-1-实现代理合约I" class="headerlink" title="7.1 实现代理合约I"></a>7.1 实现代理合约I</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract FaultyProxy &#123;</span><br><span class="line">  address public implementation;</span><br><span class="line"></span><br><span class="line">  function upgradeTo(address newImpl) external &#123;</span><br><span class="line">    implementation = newImpl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external payable &#123;</span><br><span class="line">    (bool ok, bytes memory returnData) = implementation.delegatecall(msg.data);</span><br><span class="line"></span><br><span class="line">    if(!ok)</span><br><span class="line">      revert(&quot;Calling logic contract failed&quot;);</span><br><span class="line"></span><br><span class="line">    // Forward the return value</span><br><span class="line">    assembly &#123;</span><br><span class="line">      let data := add(returnData, 32)</span><br><span class="line">      let size := mload(returnData)</span><br><span class="line">      return(data, size)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代理合约在一般情况下是不起作用的，代理有一个全局变量<code>implementation</code>，它存储了逻辑合约的地址。通过调用<code>upgradeTo()</code>可以改变逻辑合约，使逻辑（代码）可以升级。（目前所有人都可以调用<code>upgradeTo()</code>。这里还需要使用的回退函数，它的目的是转发任何对使用<code>delegatecall</code>的逻辑合约的调用。(除了对<code>upgradeTo()</code>和<code>implementation()</code>的调用，这些调用是由代理本身处理的。) 但我们怎么知道用户想调用哪个函数呢？幸运的是，触发回退函数的原始calldata可以通过<code>msg.data</code>访问 [注 5]。由于 calldata 包含函数签名和参数值，我们可以将 <code>msg.data</code>传递给<code>delegatecall</code>，之后再检查是否调用成功，如果不成功就 revert，否则就转发返回数据。</p>
<blockquote>
<p>注 5： 回退函数也可以使用不同的签名，其中calldata被直接作为参数传递。更多信息请参见 Solidity 文档 关于 <a target="_blank" rel="noopener" href="https://learnblockchain.cn/docs/solidity/contracts.html#fallback">fallback 函数</a> 的说明。</p>
</blockquote>
<p>下面给出一个使用如何使用代理合约的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建逻辑合约</span><br><span class="line">Counter logic = new Counter();</span><br><span class="line"></span><br><span class="line">// 创建代理并告诉他应该使用的逻辑合约</span><br><span class="line">FaultyProxy proxy = new FaultyProxy();</span><br><span class="line">proxy.upgradeTo(address(logic));</span><br><span class="line"></span><br><span class="line">// 为了从逻辑合约中调用函数，将代理转为正确的类型</span><br><span class="line">Counter proxied = Counter(address(proxy));</span><br><span class="line"></span><br><span class="line">// 将代理合约看作是逻辑合约</span><br><span class="line">proxied.add(2);</span><br><span class="line"></span><br><span class="line">// 检查是否生效</span><br><span class="line">console.log(&quot;counter = &quot;,proxied.get());</span><br></pre></td></tr></table></figure>

<p>前两步分别创建了逻辑和代理合约。第二步还调用了<code>upgradeTo()</code>，这样代理就知道要使用哪个逻辑合约。第三步需要告诉Solidity编译器，我们现在计划使用代理，就像它是逻辑合约一样。第四步是它变得有趣的地方。我们在代理上调用<code>add()</code>函数。由于代理没有定义任何该名称的函数，其回调函数被执行。在回调函数中，<code>msg.data</code>包含以下调用数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x1003e2d20000000000000000000000000000000000000000000000000000000000000002</span><br></pre></td></tr></table></figure>

<p>这代表了对一个签名为 “add(uint256)”、参数为2的函数的调用 。然后，回退函数用上述调用数据执行一个 “delegatecall”，使用代理的存储空间执行 “Counter “合约中的 “add() “函数。</p>
<p>最后，在第五步中，我们试图从代理中获取当前的计数器值。然而，执行<code>proxied.get()</code>实际上是回退了! 这个错误的原因可以通过可视化代理和逻辑合约来轻松解释。</p>
<p>下面是<code>FaultyProxy</code>和<code>Counter</code>合约的存储结构</p>
<img src="/image/Upgradeable-Contract.assets/foundry_scheme_4.png" alt="Foundry Scheme" style="zoom:33%;" />

<p>当比较两个合约的存储布局时，我们可以注意到它们在slot 0中存储了不同的变量。这产生了一个严重的后果。当<code>Counter.add()</code>使用<code>FaultyProxy</code>的存储空间执行时，它覆盖了slot 0，以便更新<code>number</code>。然而，在合约<code>FaultyProxy</code>中，slot 0包含<code>implementation</code>的值。因此，当我们在步骤(4)中调用<code>proxied.add(2)</code>时，我们实际上将存储在<code>implementation</code>中的地址增加了2，使得地址无效。更确切地说，现在产生的地址指向一个账户，而这个账户很可能没有被部署过合约。当对一个空账户进行委托时，调用将成功，但没有数据被返回。然而，由于我们确实希望返回一个<code>uint256</code>类型的值，所以测试被revert。</p>
<h4 id="7-2-实现代理合约II"><a href="#7-2-实现代理合约II" class="headerlink" title="7.2 实现代理合约II"></a>7.2 实现代理合约II</h4><p>解决代理和逻辑合约之间的存储插槽碰撞问题，一个简单的方法是在<code>Counter</code>合约中的<code>number</code>前添加一个虚拟存储变量。然后，<code>number</code>将被存储在slot 1中，它将不再与<code>FaultyProxy</code>的<code>implementation</code>发生冲突。然而，这并不是一个好的解决方案，虚拟存储变量容易被遗忘，而且如果逻辑合约继承了其他合约，可能很难执行。</p>
<p>还有一个办法是遵循<a target="_blank" rel="noopener" href="https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies#unstructured-storage-proxies">非结构化存储模式</a>，它被广泛使用（例如OpenZeppelin，也见<a target="_blank" rel="noopener" href="https://blog.openzeppelin.com/upgradeability-using-unstructured-storage/">使用非结构化存储的可升级性</a>），它为这个问题提供了一个不需要对逻辑合约进行任何修改的解决方案。其主要的思想是让代理合约将逻辑合约地址存储在一个地址很大的存储插槽中，这样一来，插槽碰撞的几率就可以忽略不计了。</p>
<p>实现一个新的代理合约：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Proxy &#123;</span><br><span class="line">	bytes32 constant IMPLEMENTATION_SLOT = bytes32(uint256(keccak256(&#x27;eip1967.proxy.implementation&#x27;)) - 1);</span><br><span class="line">	</span><br><span class="line">	function upgradeTo(address newImpl) external &#123;</span><br><span class="line">		bytes32 slot = IMPLEMENTATION_SLOT;</span><br><span class="line">		assembly &#123;</span><br><span class="line">			sstore(slot,newImpl)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	function implementation() public view returns(address impl)&#123;</span><br><span class="line">		bytes slot = IMPLEMENTATION_SLOT;</span><br><span class="line">		assembly &#123;</span><br><span class="line">			impl := sload(slot)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fallback() external payable &#123;</span><br><span class="line">		(bool ok, bytes memory returnData) = implementation().delegatecall(msg.data);</span><br><span class="line">		if(!ok)&#123;</span><br><span class="line">			revert(&quot;Calling logic contract failed&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		assembly &#123;</span><br><span class="line">			let data := add(returnData, 32)</span><br><span class="line">			let size := mload(returnData)</span><br><span class="line">			return(data, size)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Proxy</code>和<code>FaultyProxy</code>之间的关键区别是，<code>Proxy</code>没有声明任何存储变量。相反，逻辑合约的地址被存储在槽<code>IMPLEMENTATION_SLOT</code>中，它被计算为 <code>eip1967.proxy.implementation </code>字符串的keccak散列值减去 1[注6] 。这个插槽号在<a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-1967">EIP-1967</a>中被标准化。有了一个定义明确的槽来存储逻辑合约，像Etherscan这样的服务可以自动检测合约是否具有代理功能，在此案例中，可以显示代理和逻辑合约的信息。例如，如果你在Etherscan上查看<a target="_blank" rel="noopener" href="https://etherscan.io/address/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48#code">USDC</a>的代码，除了正常的 <code>读/写合约 </code>标签外，还有 <code>作为代理读/写 </code>的选项，它提供了一个指向当前逻辑合约的链接。</p>
<blockquote>
<p>注6: 为什么我们要从keccak的哈希值中减去一个？纯粹从功能的角度来看，这没有什么区别。使用不加-1的keccak哈希值也一样可以工作。然而，正如在<a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-1967">EIP-1967</a>中提到的，增加-1的偏移量是为了使预像攻击更加困难（见: <a target="_blank" rel="noopener" href="https://github.com/ethereum/EIPs/pull/1967#issuecomment-489276813%EF%BC%89">https://github.com/ethereum/EIPs/pull/1967#issuecomment-489276813）</a></p>
</blockquote>
<p>测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract ProxyTest is Test &#123;</span><br><span class="line">    function testProxy() public &#123;</span><br><span class="line">        // (1) Create logic contract</span><br><span class="line">        Counter logic = new Counter();</span><br><span class="line"></span><br><span class="line">        // (2) Create proxy and tell it which logic contract to use</span><br><span class="line">        Proxy proxy = new Proxy();</span><br><span class="line">        proxy.upgradeTo(address(logic));</span><br><span class="line"></span><br><span class="line">        // (3) To be able to call functions from the logic contract, we need to</span><br><span class="line">        //     cast the proxy to the right type</span><br><span class="line">        Counter proxied = Counter(address(proxy));</span><br><span class="line">        proxied.initialize(23);</span><br><span class="line"></span><br><span class="line">        assertEq(proxied.get(), 23);</span><br><span class="line"></span><br><span class="line">        // (4) Now we treat the proxy as if it were the logic contract</span><br><span class="line">        proxied.add(2); // Works as expected</span><br><span class="line">        assertEq(proxied.get(), 25);</span><br><span class="line"></span><br><span class="line">        vm.expectRevert(&quot;Calling logic contract failed&quot;);</span><br><span class="line">        proxied.add(7); // Fails as expected</span><br><span class="line"></span><br><span class="line">        // (5) Upgrade to a new logic contract</span><br><span class="line">        proxy.upgradeTo(address(new CounterV2()));</span><br><span class="line"></span><br><span class="line">        // (6) Now adding a value larger than 5 actually works!</span><br><span class="line">        proxied.add(7);</span><br><span class="line">        assertEq(proxied.get(), 32);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了升级合约，<code>upgradeTo()</code>函数需要修改<code>IMPLEMENTATION_SLOT</code>给出的槽位上的地址，这可以使用<code>sstore</code>指令。注意，我们需要将<code>IMPLEMENTATION_SLOT</code>复制到一个局部变量中，因为不可能直接从汇编中读取常数。函数<code>implementation()</code>以类似的方式实现，读取存储在槽<code>IMPLEMENTATION_SLOT</code>的地址。最后，回退函数保持不变，只是我们现在使用<code>implementation()</code>函数而不是存储变量来获取逻辑合约地址。</p>
<p>我们使用<code>sstore</code>/<code>sload</code>来访问逻辑合约，而不是使用合约变量，这使得这个代理<em>非结构化</em>，这也解释了<em>非结构化存储模式</em>的名字。我们可以从合约存储结构中直观地看到代理和逻辑合约。</p>
<img src="/image/Upgradeable-Contract.assets/foundry_scheme_5.png" alt="逻辑方案" style="zoom:33%;" />

<p>当使用<code>delegatecall</code>时，必须确保调用者合约和被调用者合约都有兼容的存储布局，对于<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1jcgOWSRhSe6sDG4CO5r4eNrDkCGinLcOeJ1xXtDCeiY/edit#heading=h.5lko0ulckh7r">delegatecall</a>部分的<code>Counter</code>和<code>DelegateCounter</code>合约，这很容易验证，因为这两个合约定义的存储变量完全相同。另一方面，<code>Proxy</code>与<code>Counter</code>的存储布局不相同，但由于两个合约使用完全不同的存储插槽，因此也不会存在变量覆盖的问题。（事实上，<code>Proxy</code>是完全独立于所使用的具体逻辑合约，因此这意味着人们只需要写一个可以被所有人使用的代理。)</p>
<p>当然，这只有在<code>IMPLEMENTATION_SLOT</code>表示的槽不会意外地与逻辑合约中的任何存储变量冲突时才安全，<code>IMPLEMENTATION_SLOT</code>表示一个相当大的值。由于像 <code>uint256 </code>这样有固定大小的存储变量被分配到从零开始的槽号，现实中我们可以假设它们的插槽号比<code>IMPLEMENTATION_SLOT</code>小得多。而且在任何情况下，由于这些插槽是在编译时分配的，因此编译器可以检测到与<code>IMPLEMENTATION_SLOT</code>的碰撞并报告错误。</p>
<p>但是，对于动态大小的类型，如映射和动态数组，情况有点不同，其元素的存储槽是使用keccak hashes计算的（见Solidity文档中的<a target="_blank" rel="noopener" href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html#id2">映射和动态数组</a>）。这样计算的槽实际上可能与<code>IMPLEMENTATION_SLOT</code>相冲突。(但是这种情况发生的概率很小)</p>
<p>虽然上面的代理实现是可行的，但它仍然存在一些缺陷，因此不应该被用于生产环境，这些缺陷是</p>
<ol>
<li>该代理容易受到函数选择器冲突的影响，这可能导致意外的行为（见”设计选择“ 一节）。</li>
<li><code>upgradeTo()</code>是无权限的，这意味着任何人都可以升级合约。由于升级合约可以极大地改变其行为，这是一个明显的安全问题，任何代理实现都必须解决。我们将在后续的文章中讨论与此直接相关的Audius攻击。</li>
</ol>
<h3 id="0x08-初始化合约"><a href="#0x08-初始化合约" class="headerlink" title="0x08 初始化合约"></a>0x08 初始化合约</h3><p>截至到目前，我们只使用了<code>Counter</code>合约作为逻辑合约，它非常简单，甚至没有一个用户定义的构造函数。这让我们成功地忽略了使用代理时产生的一个重要限制。不能使用构造函数。原因是构造函数实际上不是函数，因此不能被delegatecall调用。解决的办法是使用一个单独的初始化函数。让我们修改<code>Counter</code>，这样我们可以用计数器的初始值来初始化它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">contract Counter &#123;</span><br><span class="line">  bool isInitialized;</span><br><span class="line">  uint256 number;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function">function <span class="title">initialize</span><span class="params">(uint256 start)</span> external </span>&#123;</span><br><span class="line">    require(!isInitialized, “Already initialized”);</span><br><span class="line">    number = start;</span><br><span class="line">    isInitialized = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">function <span class="title">get</span><span class="params">()</span> external view <span class="title">returns</span><span class="params">(uint256)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function">function <span class="title">add</span><span class="params">(uint256 n)</span> external </span>&#123;</span><br><span class="line">    require(n &lt;= <span class="number">5</span>, <span class="string">&quot;Max increment is 5&quot;</span>);</span><br><span class="line">    number += n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里添加了<code>isInitialized</code>存储变量和<code>initialize()</code>函数。与构造函数相比，<code>initialize()</code>函数只是一个普通的函数，可以被调用任意次数。由于安全敏感的参数经常在初始化过程中被设置，所以防止重新初始化是很重要的，我们在这里借助<code>isInitialized</code>来做到这一点。虽然这在这个简单的例子中是可行的，但对于生产来说，建议使用像OpenZeppelin的<a target="_blank" rel="noopener" href="https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers">Initializable</a>这样的东西，它可以正确处理继承，并支持在升级后重新初始化。</p>
<h3 id="0x09-可成功升级的合约"><a href="#0x09-可成功升级的合约" class="headerlink" title="0x09 可成功升级的合约"></a>0x09 可成功升级的合约</h3><p>让我们创建一个 “CounterV2”合约，它与 “Counter” 类似，但将增量限制从5增加到10。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract CounterV2 &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  function add(uint256 n) external &#123;</span><br><span class="line">    require(n &lt;= 10, &quot;Max increment is 10&quot;); // Increase max increment to 10</span><br><span class="line">    number += n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署以及合约升级的整个过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// (1) Create logic contract</span><br><span class="line">Counter logic = new Counter();</span><br><span class="line"></span><br><span class="line">// (2) Create proxy and tell it which logic contract to use</span><br><span class="line">Proxy proxy = new Proxy();</span><br><span class="line">proxy.upgradeTo(address(logic));</span><br><span class="line"></span><br><span class="line">// (3) To be able to call functions from the logic contract, we need to</span><br><span class="line">//     cast the proxy to the right type</span><br><span class="line">Counter proxied = Counter(address(proxy));</span><br><span class="line">proxied.initialize(23);</span><br><span class="line"></span><br><span class="line">// (4) Now we treat the proxy as if it were the logic contract</span><br><span class="line">proxied.add(2); // Works as expected</span><br><span class="line">// proxied.add(7); Would fail (as expected)</span><br><span class="line"></span><br><span class="line">// (5) Upgrade to a new logic contract</span><br><span class="line">CounterV2 logicV2 = new CounterV2();</span><br><span class="line">proxy.upgradeTo(address(logicV2));</span><br><span class="line"></span><br><span class="line">// (6) Now adding a value larger than 5 actually works!</span><br><span class="line">proxied.add(7); // Works as expected</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在步骤（2）中，我们创建一个新的代理并分配逻辑合约，在步骤（3）中我们调用初始化函数。相比之下，OpenZeppelin的实现可以在一个步骤中完成所有这些工作（见<a target="_blank" rel="noopener" href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#ERC1967Proxy-constructor-address-bytes-">ERC1967Proxy.constructor()</a>），这可以防止前面的攻击，而且更节省Gas。</p>
<p>代理的存储结构如下</p>
<img src="/image/Upgradeable-Contract.assets/foundry_scheme.png" alt="进度计划" style="zoom:40%;" />

<p>测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract ProxyTest is Test &#123;</span><br><span class="line">    function testProxy() public &#123;</span><br><span class="line">        // (1) Create logic contract</span><br><span class="line">        Counter logic = new Counter();</span><br><span class="line"></span><br><span class="line">        // (2) Create proxy and tell it which logic contract to use</span><br><span class="line">        Proxy proxy = new Proxy();</span><br><span class="line">        proxy.upgradeTo(address(logic));</span><br><span class="line"></span><br><span class="line">        // (3) To be able to call functions from the logic contract, we need to</span><br><span class="line">        //     cast the proxy to the right type</span><br><span class="line">        Counter proxied = Counter(address(proxy));</span><br><span class="line">        proxied.initialize(23);</span><br><span class="line"></span><br><span class="line">        assertEq(proxied.get(), 23);</span><br><span class="line"></span><br><span class="line">        // (4) Now we treat the proxy as if it were the logic contract</span><br><span class="line">        proxied.add(2); // Works as expected</span><br><span class="line">        assertEq(proxied.get(), 25);</span><br><span class="line"></span><br><span class="line">        vm.expectRevert(&quot;Calling logic contract failed&quot;);</span><br><span class="line">        proxied.add(7); // Fails as expected</span><br><span class="line"></span><br><span class="line">        // (5) Upgrade to a new logic contract</span><br><span class="line">        proxy.upgradeTo(address(new CounterV2()));</span><br><span class="line"></span><br><span class="line">        // (6) Now adding a value larger than 5 actually works!</span><br><span class="line">        proxied.add(7);</span><br><span class="line">        assertEq(proxied.get(), 32);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/Upgradeable-Contract.assets/image-20230227154350154.png" alt="image-20230227154350154" style="zoom:50%;" />



<h3 id="0x0A-代理合约的选择"><a href="#0x0A-代理合约的选择" class="headerlink" title="0x0A 代理合约的选择"></a>0x0A 代理合约的选择</h3><h4 id="10-1-如何防止代理和逻辑合约之间的存储槽碰撞？"><a href="#10-1-如何防止代理和逻辑合约之间的存储槽碰撞？" class="headerlink" title="10.1 如何防止代理和逻辑合约之间的存储槽碰撞？"></a>10.1 如何防止代理和逻辑合约之间的存储槽碰撞？</h4><p>在这篇文章中使用非结构化存储模式来解决这个问题，也可以使用Inherited 存储或 Eternal存储。</p>
<h4 id="10-2-如何处理代理和逻辑合约之间的函数选择器冲突？"><a href="#10-2-如何处理代理和逻辑合约之间的函数选择器冲突？" class="headerlink" title="10.2 如何处理代理和逻辑合约之间的函数选择器冲突？"></a>10.2 如何处理代理和逻辑合约之间的函数选择器冲突？</h4><p>函数在内部是由函数选择器来识别的，这些选择器有四个字节长，来自函数签名的keccak散列。这使得不同签名的函数有可能映射到同一个函数选择器上，从而导致选择器冲突。</p>
<p>例如，签名<code>proxyOwner()</code>和<code>clash550254402()</code>的函数选择器是一样的</p>
<img src="/image/Upgradeable-Contract.assets/image-20230227154818754.png" alt="image-20230227154818754" style="zoom:50%;" />

<p>如果函数选择器冲突发生在单个合约的两个函数之间，那么 Solidity 编译器会以错误中止。然而，如果这样的冲突发生在<em>不同</em>合约的两个函数之间，那么就不会报告错误，因为这通常并不重要。但是，使用代理时除外。代理的回退函数会将任何它自己没有定义的函数转发给逻辑合约。现在，如果代理和逻辑合约定义了一个具有相同选择器的函数，那么代理将永远不会把对该函数的调用转发给逻辑合约，而是自己处理调用。更多信息请参见<a target="_blank" rel="noopener" href="https://medium.com/nomic-foundation-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357">以太坊代理中的恶意后门</a>。</p>
<p>这个问题至少有两种流行的解决方案：透明代理模式和通用可升级代理标准(UUPS)。透明代理模式的工作原理是，根据信息发送者的情况，将<em>所有</em>功能调用转发到逻辑合约，或者完全不转发。如果消息发送者是一个指定的代理管理员，那么我们假设他们只想调用代理本身的功能，而不是逻辑合约。对他们来说，调用是不会被转发的。另一方面，对于任何其他用户，我们假设他们只想调用逻辑合约中的功能，因此他们的调用总是被转发。这就避免了任何源于函数选择器冲突的问题，因为发送者决定了应该使用哪个合约。更多信息，请参阅<a target="_blank" rel="noopener" href="https://blog.openzeppelin.com/the-transparent-proxy-pattern/">透明代理模式</a>。</p>
<p>UUPS模式描述于<a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-1822">EIP-1822</a>。在这里，函数选择器冲突的问题是通过在代理中不定义<em>任何</em>公共函数来避免的。相反，所有管理代理的功能(包括<code>upgradeTo()</code>)都在逻辑合约中实现。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Banana69</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://banana69.site/2023/02/21/Upgradeable-Contract/">https://banana69.site/2023/02/21/Upgradeable-Contract/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Banana69.site" target="_blank">Banana69</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Banana69</div><div class="author-info__description">菜鸡的博客</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Banannna69"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Banannna69" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:junminn@126.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-%E5%89%8D%E8%A8%80"><span class="toc-text">0x01 前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-%E4%BB%A3%E7%A0%81%E5%92%8C%E5%AD%98%E5%82%A8"><span class="toc-text">0x02 代码和存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-delegatecall-%E5%A7%94%E6%89%98%E8%B0%83%E7%94%A8"><span class="toc-text">0x03 delegatecall 委托调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-%E5%A4%84%E7%90%86-delegatecall-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">0x04 处理 delegatecall 返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x05-%E6%B3%9B%E5%8C%96"><span class="toc-text">0x05 泛化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x06-%E5%9B%9E%E9%80%80%E5%87%BD%E6%95%B0"><span class="toc-text">0x06 回退函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x07-%E5%88%9B%E5%BB%BA%E5%8F%AF%E5%8D%87%E7%BA%A7%E5%90%88%E7%BA%A6"><span class="toc-text">0x07 创建可升级合约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E5%90%88%E7%BA%A6I"><span class="toc-text">7.1 实现代理合约I</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E5%90%88%E7%BA%A6II"><span class="toc-text">7.2 实现代理合约II</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x08-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%88%E7%BA%A6"><span class="toc-text">0x08 初始化合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x09-%E5%8F%AF%E6%88%90%E5%8A%9F%E5%8D%87%E7%BA%A7%E7%9A%84%E5%90%88%E7%BA%A6"><span class="toc-text">0x09 可成功升级的合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x0A-%E4%BB%A3%E7%90%86%E5%90%88%E7%BA%A6%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">0x0A 代理合约的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E4%BB%A3%E7%90%86%E5%92%8C%E9%80%BB%E8%BE%91%E5%90%88%E7%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AD%98%E5%82%A8%E6%A7%BD%E7%A2%B0%E6%92%9E%EF%BC%9F"><span class="toc-text">10.1 如何防止代理和逻辑合约之间的存储槽碰撞？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%A3%E7%90%86%E5%92%8C%E9%80%BB%E8%BE%91%E5%90%88%E7%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%87%BD%E6%95%B0%E9%80%89%E6%8B%A9%E5%99%A8%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="toc-text">10.2 如何处理代理和逻辑合约之间的函数选择器冲突？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/03/Hot100/" title="LeetCode 热题 HOT 100 - 简单">LeetCode 热题 HOT 100 - 简单</a><time datetime="2023-03-02T16:00:00.000Z" title="发表于 2023-03-03 00:00:00">2023-03-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/23/Ethernaut/" title="Ethernaut 题解">Ethernaut 题解</a><time datetime="2023-02-22T16:00:00.000Z" title="发表于 2023-02-23 00:00:00">2023-02-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/21/Upgradeable-Contract/" title="Upgradeable Contract 可升级合约">Upgradeable Contract 可升级合约</a><time datetime="2023-02-21T11:09:45.000Z" title="发表于 2023-02-21 19:09:45">2023-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/05/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/" title="OrionProtocol攻击分析">OrionProtocol攻击分析</a><time datetime="2023-02-05T15:37:00.000Z" title="发表于 2023-02-05 23:37:00">2023-02-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/04/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/" title="Java 登录认证">Java 登录认证</a><time datetime="2023-02-04T09:36:53.000Z" title="发表于 2023-02-04 17:36:53">2023-02-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Banana69</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>