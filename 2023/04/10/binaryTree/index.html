<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>二叉树算法 | Banana69</title><meta name="author" content="Banana69"><meta name="copyright" content="Banana69"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="二叉树的遍历二叉树是一个包含 节点，以及它的 左右孩子 的一种数据结构。   如果按照 根节点 -&gt; 左孩子 -&gt; 右孩子 的方式遍历，即「先序遍历」，每次先遍历根节点，遍历结果为 1 2 4 5 3 6 7； 同理，如果按照 左孩子 -&gt; 根节点 -&gt; 右孩子 的方式遍历，即「中序序遍历」，遍历结果为 4 2 5 1 6 3 7； 如果按照 左孩子 -&gt; 右孩子 -">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树算法">
<meta property="og:url" content="https://banana69.site/2023/04/10/binaryTree/index.html">
<meta property="og:site_name" content="Banana69">
<meta property="og:description" content="二叉树的遍历二叉树是一个包含 节点，以及它的 左右孩子 的一种数据结构。   如果按照 根节点 -&gt; 左孩子 -&gt; 右孩子 的方式遍历，即「先序遍历」，每次先遍历根节点，遍历结果为 1 2 4 5 3 6 7； 同理，如果按照 左孩子 -&gt; 根节点 -&gt; 右孩子 的方式遍历，即「中序序遍历」，遍历结果为 4 2 5 1 6 3 7； 如果按照 左孩子 -&gt; 右孩子 -">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2023-04-09T16:00:00.000Z">
<meta property="article:modified_time" content="2023-04-12T04:34:21.669Z">
<meta property="article:author" content="Banana69">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://banana69.site/2023/04/10/binaryTree/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '二叉树算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-12 12:34:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Banana69" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Banana69</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">二叉树算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-04-09T16:00:00.000Z" title="发表于 2023-04-10 00:00:00">2023-04-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="二叉树算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树是一个包含 <strong>节点</strong>，以及它的 <strong>左右孩子</strong> 的一种数据结构。</p>
<img src="/image/binaryTree.assets/ff26c3f4485c043a17923c3dcab65891f0d32c45e1400c36364e5084462bf2e4.png" alt="img" style="zoom:50%;" />

<p>如果按照 根节点 -&gt; 左孩子 -&gt; 右孩子 的方式遍历，即「先序遍历」，每次先遍历根节点，遍历结果为 1 2 4 5 3 6 7；</p>
<p>同理，如果按照 左孩子 -&gt; 根节点 -&gt; 右孩子 的方式遍历，即「中序序遍历」，遍历结果为 4 2 5 1 6 3 7；</p>
<p>如果按照 左孩子 -&gt; 右孩子 -&gt; 根节点 的方式遍历，即「后序序遍历」，遍历结果为 4 5 2 6 7 3 1；</p>
<p>最后，层次遍历就是按照每一层从左向右的方式进行遍历，遍历结果为 1 2 3 4 5 6 7。</p>
<h2 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h2><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>
<img src="/image/binaryTree.assets/1679378425598-80e93918-33b3-4101-8883-8f3b6d2958fc.png" alt="img" style="zoom:47%;" />

<p>输出顺序为：中，左，右，使用递归来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        preOrder(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        preOrder(root.left, res);</span><br><span class="line">        preOrder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归实现：</p>
<p><img src="/image/binaryTree.assets/1600934720-bMXWmu-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt="二叉树前序遍历（迭代法）.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       stack.push(root);</span><br><span class="line">       <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">           TreeNode tmp = stack.peek();</span><br><span class="line">           stack.pop();</span><br><span class="line">           res.add(tmp.val);</span><br><span class="line">           <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.push(tmp.right);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.push(tmp.left);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><p>按照 左孩子 -&gt; 根节点 -&gt; 右孩子 的方式遍历</p>
<p><img src="/image/binaryTree.assets/image-20230321212759879.png" alt="image-20230321212759879"></p>
<p>使用递归实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        inOrder(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left,res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inOrder(root.right,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于栈的非递归实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">      <span class="keyword">if</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(cur);</span><br><span class="line">        cur = cur.left;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        list.add(cur.val);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h2><p><img src="/image/binaryTree.assets/64547759EAC75079FDBF501CAA589890.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;1,#,2,3&#125;</span><br><span class="line">返回值：[3,2,1]</span><br></pre></td></tr></table></figure>

<p>按照 左孩子 -&gt; 右孩子 -&gt; 根节点 的方式遍历</p>
<p>递归的实现方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        postOrder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder(root.left,res);</span><br><span class="line">        postOrder(root.right,res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先序遍历是中左右，后序遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图</p>
<p><img src="/image/binaryTree.assets/4f49ee1ccbd7b2d641a740d63a68f69146dc0bcb6dd5c0471e4289730d902352-image.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">      List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">      stack.push(root);</span><br><span class="line">      <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">          TreeNode node = stack.pop();</span><br><span class="line">          res.add(node.val);</span><br><span class="line">          <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">              stack.push(node.left);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">              stack.push(node.right);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Collections.reverse(res);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树层次遍历"><a href="#二叉树层次遍历" class="headerlink" title="二叉树层次遍历"></a>二叉树层次遍历</h2><img src="/image/binaryTree.assets/image-20230321221655375.png" alt="image-20230321221655375" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">while</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 102.二叉树的层序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//checkFun01(root,0);</span></span><br><span class="line">        checkFun02(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DFS--递归方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFun01</span><span class="params">(TreeNode node, Integer deep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resList.size() &lt; deep) &#123;</span><br><span class="line">            <span class="comment">//当层级增加时，list的Item也增加，利用list的索引值进行层级界定</span></span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            resList.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        resList.get(deep - <span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun01(node.left, deep);</span><br><span class="line">        checkFun01(node.right, deep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS--迭代方式--借助队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFun02</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.offer(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; itemList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> len = que.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode tmpNode = que.poll();</span><br><span class="line">                itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tmpNode.left != <span class="keyword">null</span>) que.offer(tmpNode.left);</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.right != <span class="keyword">null</span>) que.offer(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resList.add(itemList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h2><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>使用队列，每次出队的时候判断左右孩子是否存在，若存在则入队，根据res容量判断是否是奇数层，若是奇数层，则对tmp做反转后再存入res</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">                TreeNode node  = queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                Collections.reverse(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BM29-二叉树中和为某一值的路径-一"><a href="#BM29-二叉树中和为某一值的路径-一" class="headerlink" title="BM29 二叉树中和为某一值的路径(一)"></a><strong>BM29</strong> <strong>二叉树中和为某一值的路径(一)</strong></h2><p>给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。</p>
<p>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点</p>
<p>2.叶子节点是指没有子节点的节点</p>
<p>3.路径只能从父节点到子节点，不能从子节点到父节点</p>
<p>4.总节点数目为n</p>
<p>例如：<br>给出如下的二叉树，  <em>sum</em>=22</p>
<p><img src="/image/binaryTree.assets/999991351_1596786493913_8BFB3E9513755565DC67D86744BB6159.png" alt="img"></p>
<p>返回true，因为存在一条路径 5→4→11→25→4→11→2的节点值之和为 22</p>
<p>思路：</p>
<p>使用递归的方法，从根节点遍历到叶子，我们可以在根节点每次往下一层的时候，将sum减去节点值，最后检查是否完整等于0. 而遍历的方法我们可以选取二叉树常用的递归前序遍历，因为每次进入一个子节点，更新sum值以后，相当于对子树查找有没有等于新目标值的路径，因此这就是子问题，递归的三段式为：</p>
<ul>
<li><strong>终止条件：</strong> 每当遇到节点为空，意味着过了叶子节点，返回。每当检查到某个节点没有子节点，它就是叶子节点，此时sum减去叶子节点值刚好为0，说明找到了路径。</li>
<li><strong>返回值：</strong> 将子问题中是否有符合新目标值的路径层层往上返回。</li>
<li><strong>本级任务：</strong> 每一级需要检查是否到了叶子节点，如果没有则递归地进入子节点，同时更新sum值减掉本层的节点值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span> <span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum - root.val == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>非递归，使用深度优先搜索(dfs)，即从初始点开始，一直沿着同一个分支遍历，直到该分支结束，然后回溯到上一级继续沿着一个分支走到底，如此往复，直到所有的节点都有被访问到。</p>
<ul>
<li>step 1：首先检查空节点，空树没有路径。</li>
<li>step 2：使用两个栈同步遍历，一个栈记录节点，辅助深度优先搜索，另一个栈跟随记录到该节点为止的路径和（C++中可以在一个栈中嵌套pair实现）。根节点及根节点值先进栈。</li>
<li>step 3：遍历的时候每次弹出两个栈中的内容，判断是否是叶子节点且路径和是否等于目标值。</li>
<li>step 4：没有到叶子节点就将左右子节点（如果有）加入栈中，并跟随加入路径和。</li>
<li>step 5：如果遍历结束也没有找到路径和，则该二叉树中没有。</li>
</ul>
<img src="/image/binaryTree.assets/D33422A0A2A416179193EAF5EBD60154.gif" alt="alt" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span> <span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        s1.push(root);</span><br><span class="line">        s2.push(root.val);</span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">            TreeNode tmp = s1.pop();</span><br><span class="line">            <span class="keyword">int</span> cur_sum = s2.pop();</span><br><span class="line">            <span class="keyword">if</span>(tmp.left == <span class="keyword">null</span> &amp;&amp; tmp.right == <span class="keyword">null</span> &amp;&amp; cur_sum == sum)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                s1.push(tmp.left);</span><br><span class="line">                s2.push((cur_sum + tmp.left.val));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                s1.push(tmp.right);</span><br><span class="line">                s2.push(cur_sum + tmp.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BM30-二叉搜索树与双向链表"><a href="#BM30-二叉搜索树与双向链表" class="headerlink" title="BM30 二叉搜索树与双向链表"></a><strong>BM30</strong> <strong>二叉搜索树与双向链表</strong></h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示</p>
<p><img src="/image/binaryTree.assets/image-20230328120306477.png" alt="image-20230328120306477"></p>
<p>注意:</p>
<p>1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继<br>2.返回链表中的第一个节点的指针<br>3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构</p>
<p>4.你不用输出双向链表，程序会根据你的返回值自动打印输出</p>
<p>思路：</p>
<p>使用二叉树的中序遍历进行递归：</p>
<ul>
<li>step 1：创建两个指针，一个指向题目中要求的链表头（head），一个指向当前遍历的前一节点（pre)。</li>
<li>step 2：首先递归到最左，初始化head与pre。</li>
<li>step 3：然后处理中间根节点，依次连接pre与当前节点，连接后更新pre为当前节点。</li>
<li>step 4：最后递归进入右子树，继续处理。</li>
<li>step 5：递归出口即是节点为空则返回。</li>
</ul>
<p><img src="/image/binaryTree.assets/8F315406A801B462272F54DD34866AFD.gif" alt="图片说明"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归到最小值</span></span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = pRootOfTree;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//与上一节点建立连接</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = pre;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用栈进行非递归</strong></p>
<ul>
<li>step 1：创建两个指针，一个指向题目中要求的链表头（head），一个指向当前遍历的前一节点（pre)，创建一个布尔型变量，标记是否是第一次到最左，因为第一次到最左就是链表头。</li>
<li>step 2：判断空树不能连接。</li>
<li>step 3：初始化一个栈辅助中序遍历。</li>
<li>step 4：依次将父节点加入栈中，直接进入二叉树最左端。</li>
<li>step 5：第一次进入最左，初始化head与pre，然后进入它的根节点开始连接。</li>
<li>step 6：最后将右子树加入栈中，栈中依次就弹出“左中右”的节点顺序，直到栈为空。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isFirst = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pRootOfTree != <span class="keyword">null</span> || !s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(pRootOfTree != <span class="keyword">null</span>)&#123;</span><br><span class="line">                s.push(pRootOfTree);</span><br><span class="line">                pRootOfTree = pRootOfTree.left;</span><br><span class="line">            &#125;</span><br><span class="line">            pRootOfTree = s.pop();</span><br><span class="line">            <span class="comment">//最左的元素就是表头</span></span><br><span class="line">            <span class="keyword">if</span>(isFirst)&#123;</span><br><span class="line">                head = pRootOfTree;</span><br><span class="line">                pre = head;</span><br><span class="line">                isFirst = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre.right = pRootOfTree;</span><br><span class="line">                pRootOfTree.left = pre;</span><br><span class="line">                pre = pRootOfTree;</span><br><span class="line">            &#125;</span><br><span class="line">            pRootOfTree = pRootOfTree.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BM31-对称的二叉树"><a href="#BM31-对称的二叉树" class="headerlink" title="BM31 对称的二叉树"></a><strong>BM31</strong> <strong>对称的二叉树</strong></h2><p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）<br>例如：下面这棵二叉树是对称的</p>
<p><img src="/image/binaryTree.assets/A22A794C036C06431E632F9D5E2E298F.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">&#123;1,2,2,3,4,4,3&#125;</span><br><span class="line">返回值：</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>思路：使用dfs进行递归，前序遍历的时候我们采用的是“根左右”的遍历次序，如果这棵二叉树是对称的，即相应的左右节点交换位置完全没有问题，那我们是不是可以尝试“根右左”遍历，按照轴对称图像的性质，这两种次序的遍历结果应该是一样的。</p>
<ul>
<li><strong>终止条件：</strong> 当进入子问题的两个节点都为空，说明都到了叶子节点，且是同步的，因此结束本次子问题，返回true；当进入子问题的两个节点只有一个为空，或是元素值不相等，说明这里的对称不匹配，同样结束本次子问题，返回false。</li>
<li><strong>返回值：</strong> 每一级将子问题是否匹配的结果往上传递。</li>
<li><strong>本级任务：</strong> 每个子问题，需要按照上述思路，“根左右”走左边的时候“根右左”走右边，“根左右”走右边的时候“根右左”走左边，一起进入子问题，需要两边都是匹配才能对称。</li>
</ul>
<p>算法步骤：</p>
<ul>
<li>step 1：两种方向的前序遍历，同步过程中的当前两个节点，同为空，属于对称的范畴。</li>
<li>step 2：当前两个节点只有一个为空或者节点值不相等，已经不是对称的二叉树了。</li>
<li>step 3：第一个节点的左子树与第二个节点的右子树同步递归对比，第一个节点的右子树与第二个节点的左子树同步递归比较。</li>
</ul>
<h2 id="BM32-合并二叉树"><a href="#BM32-合并二叉树" class="headerlink" title="BM32 合并二叉树"></a><strong>BM32</strong> <strong>合并二叉树</strong></h2><p>已知两颗二叉树，将它们合并成一颗二叉树。合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。例如：<br>两颗二叉树是:</p>
<p><img src="/image/binaryTree.assets/9E290CFD3730B9B08A5CEFF25799608F.png" alt="img"></p>
<p><img src="/image/binaryTree.assets/DD0A63560E770A8510049C5182E6E622.png" alt="img"></p>
<p><img src="/image/binaryTree.assets/9CB750F8909D5985C0D01D8B71AD58BA.png" alt="img"></p>
<p>思路：</p>
<p><strong>二叉树的前序遍历：</strong></p>
<ul>
<li>step 1：首先判断t1与t2是否为空，若为则用另一个代替，若都为空，返回的值也是空。</li>
<li>step 2：然后依据前序遍历的特点，优先访问根节点，将两个根点的值相加创建到新树中。</li>
<li>step 3：两棵树再依次同步进入左子树和右子树。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t1 TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t2 TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span> <span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前序遍历</span></span><br><span class="line">        TreeNode head = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">        head.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        head.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>非递归层次遍历</strong></p>
<p>使用队列的数据结构，让两颗树丛根节点开始同步走，使用队列辅助两个二叉树同时进行层次遍历</p>
<ul>
<li>step 1：首先判断t1与t2是否为空，若为则用另一个代替，若都为空，返回的值也是空。</li>
<li>step 2：使用三个辅助队列，第一个队列q用于暂存合并后的二叉树的层次遍历节点，第二个队列q1用于暂存t1的层次遍历节点，第三个队列q2用于暂存t2的层次遍历节点。 </li>
<li>step 3：两棵树同步层次遍历，先将根节点加入队列中，同时根节点优先合并。</li>
<li>step 4：每次从队列分别弹出一个元素，判断分别二者的左右子节点是否存在，若是都存在，则相加合并，若是只存在一个则连接该存在的节点，若是都不存在则连接null。</li>
</ul>
<p><img src="/image/binaryTree.assets/25859DB6141E0AD8570558D9A0369C18.gif" alt="图片说明"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//合并根节点</span></span><br><span class="line">        TreeNode head = <span class="keyword">new</span> TreeNode(root1.val + root2.val);</span><br><span class="line">        <span class="comment">//连接后的树的层次遍历节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">//分别存两棵树的层次遍历节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q1 = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q2 = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        q.offer(head);</span><br><span class="line">        q1.offer(root1); </span><br><span class="line">        q2.offer(root2);</span><br><span class="line">        <span class="keyword">while</span> (!q1.isEmpty() &amp;&amp; !q2.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = q.poll();</span><br><span class="line">            TreeNode node1 = q1.poll();</span><br><span class="line">            TreeNode node2 = q2.poll();</span><br><span class="line"></span><br><span class="line">            TreeNode left1 = node1.left;</span><br><span class="line">            TreeNode left2 = node2.left;</span><br><span class="line">            </span><br><span class="line">            TreeNode right1 = node1.right;</span><br><span class="line">            TreeNode right2 = node2.right;</span><br><span class="line">            <span class="keyword">if</span>(left1 != <span class="keyword">null</span> || left2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//两个左节点都存在</span></span><br><span class="line">                <span class="keyword">if</span>(left1 != <span class="keyword">null</span> &amp;&amp; left2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    TreeNode left = <span class="keyword">new</span> TreeNode(left1.val + left2.val);</span><br><span class="line">                    node.left = left;</span><br><span class="line">                    <span class="comment">//新节点入队列</span></span><br><span class="line">                    q.offer(left); </span><br><span class="line">                    q1.offer(left1);</span><br><span class="line">                    q2.offer(left2);</span><br><span class="line">                <span class="comment">//只连接一个节点</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left1 != <span class="keyword">null</span>)</span><br><span class="line">                    node.left = left1;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    node.left = left2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right1 != <span class="keyword">null</span> || right2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//两个右节点都存在</span></span><br><span class="line">                <span class="keyword">if</span>(right1 != <span class="keyword">null</span> &amp;&amp; right2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    TreeNode right = <span class="keyword">new</span> TreeNode(right1.val + right2.val);</span><br><span class="line">                    node.right = right;</span><br><span class="line">                    <span class="comment">//新节点入队列</span></span><br><span class="line">                    q.offer(right);</span><br><span class="line">                    q1.offer(right1);</span><br><span class="line">                    q2.offer(right2);</span><br><span class="line">                <span class="comment">//只连接一个节点</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right1 != <span class="keyword">null</span>) </span><br><span class="line">                    node.right = right1;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    node.right = right2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="BM33-二叉树的镜像"><a href="#BM33-二叉树的镜像" class="headerlink" title="BM33 二叉树的镜像"></a><strong>BM33</strong> <strong>二叉树的镜像</strong></h2><p>操作给定的二叉树，将其变换为源二叉树的镜像</p>
<img src="/image/binaryTree.assets/image-20230330111009702.png" alt="image-20230330111009702" style="zoom:50%;" />

<p>思路：</p>
<p>使用前序遍历进行递归，先进行交换左右孩子节点，然后反转左子树，反转右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Mirror</span> <span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(pRoot);</span><br><span class="line">        Mirror(pRoot.left);</span><br><span class="line">        Mirror(pRoot.right);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BM34-判断是不是二叉搜索树"><a href="#BM34-判断是不是二叉搜索树" class="headerlink" title="BM34 判断是不是二叉搜索树"></a><strong>BM34</strong> <strong>判断是不是二叉搜索树</strong></h2><p>给定一个二叉树根节点，请你判断这棵树是不是二叉搜索树。</p>
<p>二叉搜索树满足每个节点的左子树上的所有节点均小于当前节点且右子树上的所有节点均大于当前节点</p>
<img src="/image/binaryTree.assets/image-20230330113807490.png" alt="image-20230330113807490" style="zoom:50%;" />

<p>思路：在中序遍历下输出的二叉搜索树为有序序列，有了这个特性，<strong>验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       inOrder(root, res);</span><br><span class="line">       <span class="keyword">int</span> pre = res.get(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.size(); i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> cur = res.get(i);</span><br><span class="line">           <span class="keyword">if</span>( cur &lt;= pre)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           pre = cur;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left, list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inOrder(root.right, list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="BM35-判断是不是完全二叉树"><a href="#BM35-判断是不是完全二叉树" class="headerlink" title="BM35 判断是不是完全二叉树"></a><strong>BM35</strong> <strong>判断是不是完全二叉树</strong></h2><p>给定一个二叉树，确定他是否是一个完全二叉树。</p>
<p>完全二叉树的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）</p>
<p>思路：</p>
<p>对完全二叉树最重要的定义就是叶子节点只能出现在最下层和次下层，所以我们想到可以使用队列辅助进行层次遍历——从上到下遍历所有层，每层从左到右，只有次下层和最下层才有叶子节点，其他层出现叶子节点就意味着不是完全二叉树。</p>
<ul>
<li>step 1：先判断空树一定是完全二叉树。</li>
<li>step 2：初始化一个队列辅助层次遍历，将根节点加入。</li>
<li>step 3：逐渐从队列中弹出元素访问节点，如果遇到某个节点为空，进行标记，代表到了完全二叉树的最下层，若是后续还有访问，则说明提前出现了叶子节点，不符合完全二叉树的性质。</li>
<li>step 4：否则，继续加入左右子节点进入队列排队，等待访问。</li>
</ul>
<p>也可以理解为使用层次遍历对二叉树，如果遍历到当前层时如果遇到空节点，如果该空节点右侧还有节点，说明该树一定不是完全二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleteTree</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        TreeNode cur;</span><br><span class="line">        <span class="comment">// 首次出现的标记位</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            cur = queue.poll();</span><br><span class="line">            <span class="comment">// 遇到空节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="keyword">null</span>)&#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 后续遇到空节点，则说明经过叶子结点</span></span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(cur.left);</span><br><span class="line">            queue.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路二：</strong></p>
<p>本题是需要判断完全二叉树，而完全二叉树有下面公式，如果某个节点索引是i，那么他的左右子节点为（索引从1开始）</p>
<p>$left = 2 * i$</p>
<p>$right = 2 * i + 1$</p>
<p>两个计数操作</p>
<ul>
<li>计数当前遍历访问的节点是第几个节点</li>
<li>计数在完全二叉树中，当前访问的节点在完全二叉树中的编号</li>
</ul>
<p>如果最终得到的两个值相同，说明该树是一棵完全二叉树</p>
<p>如果最终得到的两个值不同，说明该树不是一棵完全二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleteTree</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">1</span>) == ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, idx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(root.left, idx * <span class="number">2</span>) + dfs(root.right, idx * <span class="number">2</span>+ <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BM36-判断是不是平衡二叉树"><a href="#BM36-判断是不是平衡二叉树" class="headerlink" title="BM36 判断是不是平衡二叉树"></a><strong>BM36</strong> <strong>判断是不是平衡二叉树</strong></h2><p>输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。</p>
<p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</p>
<p><strong>平衡二叉树</strong>（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<img src="/image/binaryTree.assets/image-20230403101323019.png" alt="image-20230403101323019" style="zoom:50%;" />

<p>思路：</p>
<p>使用递归进行判断，如果左右子树都是平衡的，且左右节点的深度差不超过1，则就可以确定这个节点是一颗平衡二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> IsBalanced_Solution(root.left) </span><br><span class="line">            &amp;&amp; IsBalanced_Solution(root.right) </span><br><span class="line">            &amp;&amp; Math.abs(deep(root.left) - deep(root.right)) &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">deep</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(deep(root.left),deep(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路二：</p>
<p>使用回溯算法，对于父节点，需要确定两个子节点深度之差小于一。对于子节点，需要向上一节点传递自己的深度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep(root) == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deep</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = deep(node.left);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = deep(node.right);</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;left: &quot;</span> + left.val + <span class="string">&quot;,right: &quot;</span> + right.val);</span><br><span class="line">        <span class="keyword">if</span> ((left - right) &gt; <span class="number">1</span> || (right - left) &gt;<span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父节点向自己的父节点返回自己的高度</span></span><br><span class="line">        <span class="keyword">return</span> (left &gt; right ? left : right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BM37-二叉搜索树的最近公共祖先"><a href="#BM37-二叉搜索树的最近公共祖先" class="headerlink" title="BM37 二叉搜索树的最近公共祖先"></a><strong>BM37</strong> <strong>二叉搜索树的最近公共祖先</strong></h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>1.对于该题的最近的公共祖先定义:对于有根树T的两个节点p、q，最近公共祖先LCA(T,p,q)表示一个节点x，满足x是p和q的祖先且x的深度尽可能大。在这里，一个节点也可以是它自己的祖先.</p>
<p>2.二叉搜索树是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值</p>
<p>3.所有节点的值都是唯一的。</p>
<p>4.p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
<img src="/image/binaryTree.assets/image-20230403105257012.png" alt="image-20230403105257012" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;7,1,12,0,4,11,14,#,#,3,5&#125;,1,12</span><br><span class="line">输出：7</span><br><span class="line">说明：节点1 和 节点12 的最近公共祖先是7   </span><br></pre></td></tr></table></figure>

<p>思路：利用二叉搜索树，分别从跟节点往下利用二叉搜索树较大的数在右子树，较小的数在左子树，找到p，q的位置。</p>
<ul>
<li>step 1：根据二叉搜索树的性质，从根节点开始查找目标节点，当前节点比目标小则进入右子树，当前节点比目标大则进入左子树，直到找到目标节点。这个过程成用数组记录遇到的元素。</li>
<li>step 2：分别在搜索二叉树中找到p和q两个点，并记录各自的路径为数组。</li>
<li>step 3：同时遍历两个数组，比较元素值，最后一个相等的元素就是最近的公共祖先。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  ArrayList&lt;Integer&gt; <span class="title">getPath</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node.val != target)&#123;</span><br><span class="line">            path.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(target &lt; node.val)&#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(node.val);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt;  path_p = getPath(root,p);</span><br><span class="line">        ArrayList&lt;Integer&gt;  path_q = getPath(root,q);</span><br><span class="line">        System.out.println(path_p);</span><br><span class="line">        System.out.println(path_q);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 比较两个点，找到第一个不同的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path_p.size() &amp;&amp; i &lt; path_q.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = path_p.get(i);</span><br><span class="line">            <span class="keyword">int</span> y = path_q.get(i);</span><br><span class="line">            <span class="keyword">if</span>(x == y)&#123;</span><br><span class="line">                res = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BM38-在二叉树中找到两个节点的最近公共祖先"><a href="#BM38-在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="BM38 在二叉树中找到两个节点的最近公共祖先"></a><strong>BM38</strong> <strong>在二叉树中找到两个节点的最近公共祖先</strong></h2><p>给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。</p>
<img src="/image/binaryTree.assets/image-20230403112708934.png" alt="image-20230403112708934" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;3,5,1,6,2,0,8,#,#,7,4&#125;,5,1</span><br><span class="line">返回值：3</span><br></pre></td></tr></table></figure>

<p>思路：使用递归的方法：</p>
<ul>
<li>step 1：如果o1和o2中的任一个和root匹配，那么root就是最近公共祖先。</li>
<li>step 2：如果都不匹配，则分别递归左、右子树。</li>
<li>step 3：如果有一个节点出现在左子树，并且另一个节点出现在右子树，则root就是最近公共祖先.</li>
<li>step 4：如果两个节点都出现在左子树，则说明最低公共祖先在左子树中，否则在右子树。</li>
<li>step 5：继续递归左、右子树，直到遇到step1或者step3的情况。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == o1 || root.val == o2)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左子树寻找公共祖先</span></span><br><span class="line">        <span class="keyword">int</span> left = lowestCommonAncestor(root.left, o1, o2);</span><br><span class="line">        <span class="comment">// 右子树寻找公共祖先</span></span><br><span class="line">        <span class="keyword">int</span> right = lowestCommonAncestor(root.right, o1, o2);</span><br><span class="line">        <span class="comment">// 左子树没找到则在右子树中</span></span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BM39-序列化二叉树"><a href="#BM39-序列化二叉树" class="headerlink" title="BM39 序列化二叉树"></a><strong>BM39</strong> <strong>序列化二叉树</strong></h2><p>请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。</p>
<p>二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）</p>
<p>二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<img src="/image/binaryTree.assets/image-20230403122123263.png" alt="image-20230403122123263" style="zoom:50%;" />

<p>层序序列化(即用函数Serialize转化)如上的二叉树转为”{1,2,3,#,#,6,7}”，再能够调用反序列化(Deserialize)将”{1,2,3,#,#,6,7}”构造成如上的二叉树。</p>
<p>当然你也可以根据满二叉树结点位置的标号规律来序列化，还可以根据先序遍历和中序遍历的结果来序列化。不对序列化之后的字符串进行约束，所以欢迎各种奇思妙想。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;1,2,3,#,#,6,7&#125;</span><br><span class="line">输出：&#123;1,2,3,#,#,6,7&#125;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p><strong>序列化：</strong></p>
<p>借助队列对二叉树做层序遍历，并将叶子结点的 <code>null</code>打印出来</p>
<p>设 <em>m</em> 为列表区间 [0,<em>n</em>] 中的 <code>null</code> 节点个数，则可总结出根节点、左子节点、右子节点的列表索引的递推公式：</p>
<img src="/image/binaryTree.assets/image-20230403122358764.png" alt="image-20230403122358764" style="zoom:50%;" />

<img src="/image/binaryTree.assets/image-20230403122408581.png" alt="image-20230403122408581" style="zoom:50%;" />

<p><strong>反序列化：</strong></p>
<p>基于本文开始推出的 node , node.left , node.right 在序列化列表中的位置关系，可实现反序列化。</p>
<p>利用队列按层构建二叉树，借助一个指针 i 指向节点 node 的左、右子节点，每构建一个 node 的左、右子节点，指针 i 就向右移动<br>1 位。</p>
<img src="/image/binaryTree.assets/image-20230403123211712.png" alt="image-20230403123211712" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;() &#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                res.append(node.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.deleteCharAt(res.length() - <span class="number">1</span>);</span><br><span class="line">        res.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(str.equals(<span class="string">&quot;[]&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       String[] vals = str.substring(<span class="number">1</span>, str.length() - <span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">       TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[<span class="number">0</span>]));</span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;() &#123;&#123;add(root);&#125;&#125;;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[i]));</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">            node.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[i]));</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(Arrays.asList(vals));</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BM40-重建二叉树"><a href="#BM40-重建二叉树" class="headerlink" title="BM40 重建二叉树"></a><strong>BM40</strong> <strong>重建二叉树</strong></h2><p>给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。</p>
<p>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。</p>
<p><img src="/image/binaryTree.assets/776B0E5E0FAD11A6F15004B29DA5E628.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,2,4,7,3,5,6,8],[4,7,2,1,5,3,8,6]</span><br><span class="line">输出：&#123;1,2,3,4,#,5,6,#,7,#,#,8&#125;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>对于二叉树的前序遍历，我们知道序列的第一个元素必定是根节点的值，因为序列没有重复的元素，因此中序遍历中可以找到相同的这个元素，而我们又知道中序遍历中根节点将二叉树分成了左右子树两个部分，如下图所示</p>
<img src="/image/binaryTree.assets/image-20230404111221225.png" alt="image-20230404111221225" style="zoom:50%;" />

<p>数字1是根节点，并将二叉树分成了(247)和(3568)两棵子树，而子树的的根也是相应前序序列的首位，比如左子树的根是数字2，右子树的根是数字3，这样我们就可以利用前序遍历序列找子树的根节点，利用中序遍历序列区分每个子树的节点数。</p>
<p>算法步骤：</p>
<ul>
<li>step 1：先根据前序遍历第一个点建立根节点。</li>
<li>step 2：然后遍历中序遍历找到根节点在数组中的位置。</li>
<li>step 3：再按照子树的节点数将两个遍历的序列分割成子数组，将子数组送入函数建立子树。</li>
<li>step 4：直到子树的序列长度为0，结束递归。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = pre.length;</span><br><span class="line">        <span class="keyword">int</span> m = vin.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建根结点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vin.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 找到前序遍历的第一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(pre[<span class="number">0</span>] == vin[i])&#123;</span><br><span class="line">                root.left = reConstructBinaryTree(</span><br><span class="line">                    Arrays.copyOfRange(pre, <span class="number">1</span>, i + <span class="number">1</span>), </span><br><span class="line">                    Arrays.copyOfRange(vin, <span class="number">0</span>, i));</span><br><span class="line">            </span><br><span class="line">            root.right = reConstructBinaryTree(</span><br><span class="line">                Arrays.copyOfRange(pre, i + <span class="number">1</span>, pre.length), </span><br><span class="line">                Arrays.copyOfRange(vin, i + <span class="number">1</span>, vin.length));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>思路2：</strong>使用栈辅助，使用非递归前序遍历，然后依次建立结点</p>
<ul>
<li>step 1：首先前序遍历第一个数字依然是根节点，并建立栈辅助遍历。</li>
<li>step 2：然后我们就开始判断，在前序遍历中相邻的两个数字必定是只有两种情况：要么前序后一个是前一个的左节点；要么前序后一个是前一个的右节点或者其祖先的右节点。</li>
<li>step 3：我们可以同时顺序遍历pre和vin两个序列，判断是否是左节点，如果是左节点则不断向左深入，用栈记录祖先，如果不是需要弹出栈回到相应的祖先，然后进入右子树，整个过程类似非递归前序遍历。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = pre.length;</span><br><span class="line">        <span class="keyword">int</span> m = vin.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 前序的第一个即根结点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val != vin[j])&#123;</span><br><span class="line">                cur.left = <span class="keyword">new</span> TreeNode(pre[i]);</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="comment">// 弹出到符合的祖先</span></span><br><span class="line">                <span class="keyword">while</span>(!s.isEmpty() &amp;&amp; s.peek().val == vin[j])&#123;</span><br><span class="line">                    cur = s.pop();</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.right = <span class="keyword">new</span> TreeNode(pre[i]);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Banana69</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://banana69.site/2023/04/10/binaryTree/">https://banana69.site/2023/04/10/binaryTree/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Banana69.site" target="_blank">Banana69</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Banana69</div><div class="author-info__description">菜鸡的博客</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Banannna69"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Banannna69" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:junminn@126.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的前序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的中序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的后序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树层次遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-32-III-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-III"><span class="toc-text">剑指 Offer 32 - III. 从上到下打印二叉树 III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BM29-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84-%E4%B8%80"><span class="toc-text">BM29 二叉树中和为某一值的路径(一)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BM30-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">BM30 二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BM31-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">BM31 对称的二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BM32-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">BM32 合并二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BM33-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-text">BM33 二叉树的镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BM34-%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">BM34 判断是不是二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BM35-%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">BM35 判断是不是完全二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BM36-%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">BM36 判断是不是平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BM37-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">BM37 二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BM38-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">BM38 在二叉树中找到两个节点的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BM39-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">BM39 序列化二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BM40-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">BM40 重建二叉树</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/10/binaryTree/" title="二叉树算法">二叉树算法</a><time datetime="2023-04-09T16:00:00.000Z" title="发表于 2023-04-10 00:00:00">2023-04-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/01/HashMap-%E5%AD%A6%E4%B9%A0/" title="HashMap 学习">HashMap 学习</a><time datetime="2023-04-01T11:00:17.000Z" title="发表于 2023-04-01 19:00:17">2023-04-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/03/Hot100/" title="LeetCode 热题 HOT 100 - 简单">LeetCode 热题 HOT 100 - 简单</a><time datetime="2023-03-02T16:00:00.000Z" title="发表于 2023-03-03 00:00:00">2023-03-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/23/Ethernaut/" title="Ethernaut 题解">Ethernaut 题解</a><time datetime="2023-02-22T16:00:00.000Z" title="发表于 2023-02-23 00:00:00">2023-02-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/21/Upgradeable-Contract/" title="Upgradeable Contract 可升级合约">Upgradeable Contract 可升级合约</a><time datetime="2023-02-21T11:09:45.000Z" title="发表于 2023-02-21 19:09:45">2023-02-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Banana69</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>